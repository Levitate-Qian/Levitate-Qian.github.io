[{"title":"LaTeX札记（八）：Beamer演示文稿","url":"/2025/05/08/latex-note-08/","content":"\n\n\n# $ \\LaTeX{}$札记（八）——Beamer演示文稿\n\n又是一年毕业季～ 这次把做了这么久beamer的一些心得分享一下。\n\n首先，推荐阅读一下[beamer的手册](https://tug.ctan.org/macros/latex/contrib/beamer/doc/beameruserguide.pdf)（*The beamer class User Guide for version 3.72.*，通过命令行`texdoc beamer`即可获得），也有[中文翻译版](https://static.latexstudio.net/wp-content/uploads/2017/02/BeamerUserGuide_V3.24_zh-cn.pdf)（但是年份比较早，针对的还是3.24版）。在手册中其实已经很详尽的说明了如何创建一个beamer演示文稿，这里我就粗略的说明一下吧～\n\nBeamer的上手还是很简单的，有个模版往里面填论文的内容就可以啦～ 我[学位论文答辩的beamer模版](https://github.com/Levitate-Qian/SEU_radio_beamer_template)也已经放在Github里，如果想要改为自己学校的样式，换换logo、配色方案、主图就可以叻，都还是挺简单的～\n\n---\n\n鉴于我也学艺不精，本篇札记主要分为以下几部分：\n\n+ 入门\n  + 是什么\n  + 基本结构\n+ 进阶\n  + 与常见的article相比，beamer独特的用法\n    + 突出强调（structure & alert）\n    + 块（block）\n    + 列表（enumerate & itemize & description）\n  + 使Beamer更“演示”的一些方式\n    + 帧、叠层、动画\n    + 多列并排\n    + 公式的优雅注释\n    + 页面脚注\n  + “演讲者备注”的实现——笔记页\n+ 其他应用\n  + poster制作（先咕咕咕～）\n  \n\n如果还有什么想到了在加～\n\n---\n\n## Beamer入门\n\n### 引子\n\n#### 引子（一）\n\n在小红书上之前有这样一个问题“PPT上面的这个是怎么做的”（图自小红书用户ID:10987385808）\n\n![图片](/640)\n\n而我关注很久的“旁门左道PPT”在[PPT最上面这个是啥？咋做的呀？](https://mp.weixin.qq.com/s/H_8SMeaF9wdpFj9OlHpCIA)中回复ppt的导航栏就可以完成这样的操作。真的是这样的吗？\n\n注意到上面的小圆点是会跟随页面的递进而变化的，同时圆圈的透明度代表当前页面属于哪一小节。这样的操作真的能通过ppt简单的实现吗？其实是很困难的，如果只是实现简单的章节导航栏，ppt还是可以实现的，但是对于这种每页都不同的，对于ppt来说就是难上加难了，尤其当你要加减页面时，那就更加痛苦了。\n\n很显然，这个演示文档并不是使用powerpoint制作的，而是采用beamer制作的，文字风格和主题也是非常默认的风格～而顶部这个导航栏则是通过选用相应的beamer主题自动实现的，它会根据你的章节分配自动实现这样的小圆点。\n\n![image-20250509151402512](/image-20250509151402512.png)\n\n例如上图这样，该页所属的节（section）的标题会重点突出，其他节会轻微透明；当前页面的圆圈会显示为实心，当前页面所属小节的圆圈会显示为更深的颜色。\n\n\n\n#### 引子（二）&是什么？\n\n我最开始接触到beamer是在数模美赛培训期间，想要将论文用类似ppt的手段展示出来，但是把latex写的内容转化成ppt也很麻烦，于是就搜到了beamer这个东西。\n\n>  当然latex公式要想在ppt中完美显示也有很多手段，我首推IguanaTex（*A Free LaTeX Add-In for PowerPoint on Windows and Mac*）。\n>\n> 如果你本地安装了texlive/mactex，那么这个工具属于是即插即用，直接把论文的公式复制过来就可以了。生成的公式是矢量格式，对每个元素都可以更换颜色等等，很方便。虽然界面是丑了点～\n>\n> 写着写着就歪了～\n\n言归正传，beamer可以直接把你的论文转化为一个适合演示的pdf，放在大屏上展示你的成果～\n\n> beamer 是LATEX 的一个文档类（class）， 它可用于创建用投影机（projector） 放映的演示稿（presentations），也可用于制作幻灯片（slides）。\n\n### Beamer的基本结构\n\nBeamer和一般创建的latex文件类似，都有导言区和正文组成。\n\n#### 导言区\n\n在beamer的导言区中通常包括以下部分：\n\n+ **文件分类**，即`beamer`或者`ctexbeamer`（引入中文的相关环境）。在`documentclass`中我们还可以加上对应的选项来采用需要的页面比例（*aspectratio*）、字体大小（如*10pt*）、输出版本（如*handout*会取消所有叠层，输出可供分发的版本）。例如在我提供的模版中，\n\n  ```tex\n  \\documentclass[aspectratio=169,xcolor=table,10pt]{ctexbeamer}\n  ```\n\n  其中`xcolor=table`是为表格颜色提供的选项。\n\n+ <u>**主题**</u> 🆕：beamer包含五类主题，这五个主题相互影响，与先后放置排列顺序甚至也有影响。这里不加赘述，具体每种主题能够带来什么样的效果可以参考beamer手册第III部分。在提供的模版中，我新定义了一种SEU颜色主题，其中定义了SEUcolor（东大绿）, SEUyellow, SEUdarkyellow, SEUred, SEUblue五种颜色，在模版中主要采用东大绿、东大黄作为主色调，其余颜色大家可以按需选用。\n\n  + 演示主题`\\usetheme`\n  + 颜色主题`\\usecolortheme`\n  + 字体主题`\\usefonttheme`\n  + 内部主题`\\useinnertheme`\n  + 外部主题`\\useoutertheme`\n\n+ **标题、作者、单位、日期**——这一部分基本与article一致。我们可以采用`[]`, `{}` 设置简略、完整版本的文本，用于封面和页脚。\n\n+ 相关的**字体设置、宏包**应用\n\n  + 字体相关设置可以参考“[LaTeX札记（四）：字体](https://levitate-qian.github.io/2022/04/14/latex-note-04/)”的相关设置。在模版中，中文主字体为采用“更纱黑体”、斜体采用“霞鹜文楷”；西文主字体采用computer modern的非衬线体与cmbright的组合，以满足公式中字体同样统一；并且定义了`\\XWWK`直接调用“霞鹜文楷”，方便霞鹜文楷与直立英文文本并排。\n  + 其余相关图片、表格、画图等宏包\n\n+ 其余常用**command定义**\n\n+ <u>**标题页面**</u> 🆕：封面页面定义、节标题页面定义、小节标题页面定义——其中，节标题、小节标题的实现方式其实就是在每个出现节、小节的开头位置，新增一个页面，显示相应的内容，大家可以按需调整。\n\n  + 封面标题——加入了校标、院徽，四牌楼校区的楼\n    ```tex\n    \\titlegraphic { \n    \\begin{tikzpicture}[overlay,remember picture]\n    \\node[above left] at (current page.332){\n        \\includegraphics[width=.6\\textwidth]{seu_building.png}\n    };\n    \\node[above=0.5cm] at (current page.220){\n        % \\includegraphics[width=.25\\textwidth]{logo_color_green.pdf}\n        \\includegraphics[width=.13\\textwidth]{SEUlogo.pdf}\n        \\includegraphics[width=.13\\textwidth]{RADIOlogo.pdf}\n    };\n    \\end{tikzpicture}\n    }\n    ```\n\n  + 节标题——修改了编号样式（改为“Part I”的样式，虽然这不是真的part），增加了该节出现的小节标题。注意这里小节标题的放置比较丑陋，展示没有想到更好的居中对齐方式。\n    ```tex\n    \\AtBeginSection[]{\n        %  \\let\\insertsectionnumber\\relax\n         \\let\\sectionname\\relax\n         \\frame{\\sectionpage}\n    }\n    \\renewcommand{\\thesection}{\\Roman{section}}\n    \\setbeamertemplate{section page}\n    {\n        \\begin{centering}\n            {\\usebeamerfont{section title} \\textsc{Part} \\thesection}\n    \n            \\vspace{10pt}\n        \\begin{beamercolorbox}[sep=12pt,center,colsep=-4bp,rounded=true,shadow=true]{part title}\n        \\usebeamerfont{section title}\\bfseries\\insertsection\\par\n        \\end{beamercolorbox}\n    \n        \\vspace{20pt}\\begin{minipage}\n            {.35\\linewidth}\n            \\tableofcontents[sectionstyle=hide,subsectionstyle=show/shaded/hide]\n        \\end{minipage}\n        \n        \\end{centering}\n    }\n    ```\n\n  + 小节标题（暂未启用）——表示该小节在整体结构中的位置\n    ```tex\n    \\AtBeginSubsection[]\n    {\n    \\begin{frame}[shrink]\n    \n        \\centering\n            \\tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]\n    \n    \\end{frame}\n    }\n    ```\n\n    \n\n#### 正文\n\n正文部分可以采用`\\part`, `\\section`, `\\subsection`来进行划分章节，同时也存在对应的`*`版本用于不编号，在目录中不进行显示。\n\n+ 注意到论文答辩一般是一个比较简短的演示文稿，所以一般不会用到`\\part`来区分。对于不同的part会一般分别采用新的tableofcontent目录，包括顶部或侧边的导航栏，即导航栏和目录中只显示当前part的节。\n\n+ `\\section`（节）的标题一般会显示在导航栏中，其样式根据主题区分。\n\n+ `\\subsection`（小节）的标题根据不同的主题可能会显示/不显示在导航栏或页面顶端。对于论文答辩一般也不会区分到小节，所以可用可不用～\n\n+ 此外，类似于latex论文中，我们可以采用`[]`, `{}` 设置长短标题，用于目录等不同用途，在beamer中同样有这样的操作。例如：\n  ```tex\n  \\section[SIP上行 -- 迭代接收机设计]{上行链路叠加导频系统的迭代接收机设计}\n  ```\n\n  那么，在导航栏中会显示`[]`中的短标题，减少字数，更突出重点；而在使用tableofcontent（目录）、节标题页中会显示`{}`的长标题。\n\n而对于每一个页面我们可以采用`frame`环境进行包裹，作为一个页面。例如：\n```tex\n\\begin{frame}\n\t\t\\frametitle{该页面标题}\n\t\t页面正文内容\n\\end{frame}\n```\n\n或者更简单的写作\n\n```tex\n\\begin{frame}{该页面标题}\n\t\t页面正文内容\n\\end{frame}\n```\n\n如果我们把“页面标题”留空，则可以得到一个不带标题的页面。注意如果我们如果需要在页面中包含代码等环境，可能需要采用脆弱环境，即加上`[fragile]` 选项。\n\n为了在标题栏放置校标、院徽，并将标题文字加粗，我在模版中定义了`\\frametitleb`命令，只要将上述的`\\frametitle{该页面标题}`修改为`\\frametitleb{该页面标题}`就能够获得下面的标题文本效果。\n```tex\n\\newcommand{\\frametitleb}[1]{\\frametitle{\\makebox[\\framewidth]{\\bfseries #1 \\hfill\\raisebox{-1.5ex}{\\includegraphics[height=1.1\\baselineskip]{logo.pdf}}}}}\n```\n\n![image-20250509172712132](/image-20250509172712132.png)\n\n\n\n---\n\n## Beamer进阶\n\n在第一部分中，我们主要介绍了beamer的结构，但是总体看来除了frame，其余貌似和article/book类型没什么区别啊🤨～ 下面就介绍一些beamer更独有的用法，让beamer更加“演示”！\n\n### Beamer独特的用法\n\n#### 列表有了“新外观”（有序列表`enumerate`、无序列表`itemize`、描述`description`）\n\n我们再将上面出现的图搬下来，可以看到无序列表、有序列表的圆点、序号变成了一种更加立体的风格，这个主要是*Warsaw*主题提供的特性。我们也可以采用别的主题获得不同的效果，例如*Berlin*主题提供平面方块点的风格，*Hannover*主题提供平面圆点的风格…… 更本质其实是内部主题（inner theme）起了作用，上面三个主题分别对应于*rounded*、*rectangles*、*circles*三种内部主题。\n\n而描述环境则是将前面悬挂部分的问题设置为了结构色。\n\n![image-20250509151402512](/image-20250509151402512.png)\n\n\n\n#### 通过“颜色”进行突出强调（结构色`structure`、警告色`alert`）\n\n在slides中，我们通常利用颜色进行突出强调。于是在beamer中我们有一些通过颜色来表示内容轻重缓急的方式。\n\n+ 结构色`\\structure`：在手册中表述为“*给定的文本被标记为（marked as）结构（structure）的一部分，也就是说，它有助于观众了解演示稿的结构。*” 在给出模版的效果就是把显示的文字颜色变化为东大绿（即结构色），其余常见模版中一般是默认的蓝色。使用方法：`\\structure{text}`\n+ 警告色`\\alert`：在手册中表述为“*给定的文本高亮显示，典型地显示为红色。*” 使用方法：`\\alert{text}`\n+ 半透明`shade`：这并不是一个能够在全文使用的颜色效果，而是当采用叠层等设置时候，会将当前不在视觉重点的内容采用半透明的方式显示。一般在目录设置中会使用。此外，利用`\\setbeamercovered{transparent}`，列表项会以一定的透明度被隐藏。\n\n此外，我们可以通过重定义`\\emph`更加突出重点。例如，我定义了两种强调的方式：\n\n```tex\n\\renewcommand{\\emph}[1]{{\\XWWK \\structure{#1}}}\n\\newcommand{\\emphbf}[1]{\\structure{\\bfseries#1}}\n```\n\n于是，`\\emph`利用结构色的霞鹜文楷突出强调，而非原本的正文色斜体；`\\emphbf`则进一步利用结构色的粗非衬线体突出强调。\n\n\n\n#### “包裹起来”的块环境`block`\n\nbeamer中定义了用于排版文本的三种块环境，块环境包含标题（可省略）、正文。\n\n+ 常规块：`\\begin{block}{标题}\t正文\t\\end{block}`——采用结构色配色\n+ 举例块：`\\begin{exampleblock}{标题}\t正文\t\\end{exampleblock}` ——一般是黄色\n+ 警告块：`\\begin{alertblock}{标题}\t正文\t\\end{alertblock}`——一般是红色\n\n![image-20250509171557907](/image-20250509171557907.png)\n\n当我们对标题的`{}`留空即可得到只包含正文的块，这可能帮我们生成一个具有整行宽度的框，放置一些需要突出的内容，例如在模版中图名即放置在不带标题的举例块中，并配合一个小图标。\n\n![image-20250509171750746](/image-20250509171750746.png)\n\n但是，我并不推荐在全文中滥用块环境，每段文本都用块包裹，这会显得非常割裂。\n\n此外，在beamer中定理、定义、证明等其实也都是采用的块环境，只是进行了一定的预先定义。\n\n\n\n### 使Beamer更“演示”的一些方式\n\n#### 帧、叠层、动画\n\n在beamer中页面被按照帧（frame）进行放映，而在一帧中可以创建多个叠层（overlay）分段展示，实现类似于powerpoint中一页内容中分部分显示的效果。（*ps：我觉得帧这个概念有点奇怪，甚至觉得后面那个叠层才是实际帧的意思*😂）\n\n由于论文答辩也不需要非常多的动画，这里只介绍三个主要的叠层相关操作：\n\n+ **只是“暂停”**：pause 提供了一个最简单的分段显示帧的方法。如果在帧的某处放置`\\pause`，其后的内容会在下一slide才出现。这个`\\pause`能够在一个帧中多处使用。此外，该命令还可以跟着一个选项表示在该帧第几个slide后才显示，即`\\pause[数字]`。\n\n+ **列表中**\n\n  + 如果你想让列表的每一项按顺序出现可以在`\\begin{itemize}`后面加上选项`[<+->]`，具体含义参见手册吧。即：\n    ```tex\n    \\begin{itemize}[<+->]\n        \\item 从第1个slide开始显示直到这一帧结束。\n        \\item 从第2个slide开始显示直到这一帧结束。\n        \\item 从第3个slide开始显示直到这一帧结束。\n    \\end{itemize}\n    ```\n\n  + 如果你想让不同项目在不同slide上面显示。可以看下下面的案例：\n    ```tex\n    \\begin{itemize}\n        \\item<1> 只在第1个slide显示。\n        \\item<2-> 从第2个slide开始显示直到这一帧结束。\n        \\item<2-4> 在第2到4个slide上显示，其余不显示。\n        \\item<3,5> 在第3和第5个slide上显示，其余不显示。\n    \\end{itemize}\n    ```\n\n  + 还有一些类似于高亮等的用法，请参考手册\n\n+ **大段文字图片**——这种情况主要出现在如下情况：“一个帧顶部的内容始终是一致的（例如一个图），下半部分对这个图的不同模块进行说明（每次的文本说明都会占足整个下半部分）”，但是如果我采用不同的帧表现顶部图像位置可能会动来动去，同时会占用三个页码。此时，采用`overprint`环境就是非常好的选择。\n  ![image-20250509175325388](/image-20250509175325388.png)\n\n  + 采用overprint环境，对每个叠层的内容放置一个onslide。\n    ```tex\n    \\begin{frame}{heading}\n        {不变的图片或者文字内容}\n        \\begin{overprint}\n            \\onslide<1>\n            Some text for the first slide.\\\\\n            Possibly several lines long.\n            \\onslide<2>\n            Replacement on the second slide. \n        \\end{overprint}\n    \\end{frame}\n    ```\n  + 该方案有两个已知的弊端：①使用handout模式时候不好处理，毕竟只有一个页面但要放置三段文本是不可行的，只能有所取舍；②此时overprint生成的区间的高度是偏高的，采用内容左右分布时候，minipage不能采用m选项，否则对齐可能有问题。\n\n对于动画这个问题，已经在该系列的第一辑“[LaTeX札记（一）：插入动画](https://levitate-qian.github.io/2020/06/13/latex-note-01/)”中分享过啦～但是值得注意的是，动画对于PDF阅读器的要求很高，需要使用Adobe Acrobat获得较好的放映体验！\n\n\n\n#### 图文、多列并排`minipage`\n\n为了能够有效利用横向空间，beamer中一般需要多列并排。我通常选用minipage环境这样能够更方便的对齐基线、调整列宽。\n\n```tex\n\\begin{minipage}[m]{.47\\linewidth}\n     \\centering\\includegraphics[width=\\linewidth]{figure.pdf}\n\\end{minipage}\\hfill\n\\begin{minipage}[m]{.47\\linewidth}\n    \\begin{exampleblock}{}\n    \t\t\\raisebox{-1pt}{\\structure{\\faArrowCircleLeft}}\\parbox{.95\\textwidth}{\\centering 图片说明}\n    \\end{exampleblock} \n    文本说明\n    \\begin{itemize}\n        \\item A\n        \\item B\n    \\end{itemize}\n\\end{minipage}\n```\n\n![image-20250509180621890](/image-20250509180621890.png)在上面的例子中给出了一个左图右文的图文并排案例，两个块垂直居中对齐，可以获得类似上图的效果。大家可以自行调整minipage的宽度、对齐选项等实现符合需求的效果。\n\n#### 公式注释\n\n在beamer中为了更清晰、简要地说明公式，我们可以使用`annotate-equations`宏包为公式添加漂亮的注释。具体地使用说明请参考“[Github上的使用说明](https://github.com/st--/annotate-equations)”。同样给一个例子~\n\n```tex\n\\begin{equation*}\n        [\\hat{\\mathbf{d}}]_u = \\tikzmarknode{nodeSum}{\\sum_{a\\in\\mathcal{Q}}} \\eqnmarkbox[SEUdarkyellow]{nodeA}{a} \\cdot \\eqnmarkbox[SEUcolor]{nodeProb}{\\mathbb{P}\\left[[\\mathbf{d}]_u = a \\,|\\, \\mathsf{L}_\\text{map}^A \\right]}\n\\end{equation*}\n\\annotate[yshift=.7em,xshift=1em]{below,right}{nodeSum}{\\scriptsize \\textit{加权求和}}\n\\annotate[yshift=.5em]{above}{nodeA}{\\scriptsize \\textit{星座点对应的复值符号}}\n\\annotate{below}{nodeProb}{\\scriptsize \\textit{根据LLR得到的先验概率}}\n```\n\n<img src=\"/image-20250509181141613.png\" alt=\"image-20250509181141613\" style=\"zoom:50%;\" />\n\n#### 参考文献使用脚注而非尾注\n\n在beamer中一般不会把使用的参考文献放置在整个beamer的最后，这样不太方便查看，而作为页面的脚注放在帧的下方。这里也给出一个使用案例：\n\n+ 首先，为了将beamer脚注的样式调整为“[1]”的格式，我们再导言区重定义脚注的编号方式：`\\renewcommand{\\thefootnote}{[\\arabic{footnote}]}`\n\n+ 其次，使用时为了能够更加清晰突出文献可以写作\n  ```tex\n  \\emph{(Chu \\textit{et al}., 2022)}\\footnote{\\fontsize{7pt}{7pt}\\selectfont  M. Chu, A. Liu, V. K. N. Lau, C. Jiang, and T. Yang, “Deep Reinforcement Learning based End-to-end Multi-user Channel Prediction and Beamforming,” \\textit{IEEE Trans. Wirel. Commun.}, pp. 1–1, 2022, doi: 10.1109/TWC.2022.3183255.}\n  ```\n\n显示效果如下：\n\n![image-20250509181713987](/image-20250509181713987.png)\n\n\n\n### “演讲者备注”的实现——笔记页\n\n在beamer中，能不能像powerpoint中一样在答辩的时候偷偷看“小抄”呢？答案是肯定的，只是对于PDF放映软件的要求可能比较高，所以**对于不能使用自己设备的场景可能要谨慎使用beamer的双屏放映功能**。\n\n#### 笔记页的制作和放置\n\n+ **添加笔记**：在beamer中，可以简单的利用`\\note`命令为每个页面添加笔记（放置在frame环境内部即可），如果是section、maketitle之类的页面可以放在在后面。\n\n  + 在笔记中可以包含公式、列表等等一系列的环境～\n\n  + 如果页面有多个叠层，可以为不同叠层创建不同的笔记！例如：\n    ```tex\n    \\note<1->{第1个slide对应笔记页显示的内容，直到该帧的最后一个slide}\n    \\note<1>{只在第1个slide对应笔记页显示的内容}\n    \\note<2>{第2个slide对应笔记页显示的内容，直到该帧的最后一个slide}\n    ```\n\n    这一点相比在powerpoint的演讲者备注中手动标注这句“（点）”一下鼠标的方式，优雅多了～读完这部分的~~“小抄”~~（笔记），跳到下一页可以接着念，即使它属于同一个帧。\n\n  + 在`\\note`命令后面加上一个选项`[item]`，于是添加的不同笔记会被作为一个有序列表放置在笔记页，对于上述“**大段文字图片的叠层**”场景非常适用。\n    ![image-20250509190428270](/image-20250509190428270.png)\n\n+ **显示笔记**&**页面布局**——beamer默认是不显示笔记页的内容的，需要在导言区加入相应的`\\setbeameroption`\n\n  + 一页正文，一页笔记：`\\setbeameroption{show notes}`\n  + 将笔记页放置在第二屏：`\\setbeameroption{show notes on second screen=right}`。给定该选项后，会创建slides的双屏版本。可以指定在在左侧（left）、右侧（right）、底部（bottom）、顶部（top）放置第二屏幕显示笔记页。\n  + 仅展示笔记：`\\setbeameroption{show only notes}`\n\n+ **将笔记页放置在第二屏时可能存在的问题与相应解决方式：**\n\n  + 正文页面内容显示有问题，如文本不显示、字体颜色显示为白色、图片加载有问题等\n    ——【解决方案】在导言区加上对应代码：\n\n    ```tex\n    \\makeatletter \n    \\def\\beamer@framenotesbegin{% at beginning of slide\n         \\usebeamercolor[fg]{normal text}\n          \\gdef\\beamer@noteitems{}% \n          \\gdef\\beamer@notes{}% \n    }\n    \\makeatother\n    ```\n\n  + 原本应该出现在笔记（正文）页面超链接出现在了正文（笔记）页，导致超链接位置出错，影响放映时的跳转\n    ——【解决方案】使用下列patch，即在导言区引入`\\input{beamer-notes-patch}`，在文件夹目录上放置“[lrtfm](https://gist.github.com/lrtfm)”提供的[**beamer-notes-patch.tex**](https://gist.github.com/lrtfm/aeffae97d078c7261aba186af07100a7#file-beamer-notes-patch-tex)，重新编译两遍，即可获得正确的超链接位置。\n\n#### 双屏放映\n\n我也试用了知乎和网络推荐的不少软件（比如Présentation和pdfpc尝试了，之前常用的Adobe Acrobat和Sumatra PDF没找到双屏放映的方式），最后用下来感觉还是[pympress](https://github.com/Cimbali/pympress)最好用。虽然刚打开beamer会有点卡卡的，但是实际播放、显示笔记页、激光等等的功能还是非常完善的。同时在Windows和Mac上都可以使用～\n\n![image-20250509183245435](/image-20250509183245435.png)\n\n---\n\n## 其他应用\n\n### poster制作\n\n先咕咕咕着…… 给个小案例，来自之前科技论文写作的一个作业\n\n![image-20250509183441839](/image-20250509183441839.png)\n","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"LaTeX札记（七）：硕士学位论文相关","url":"/2024/12/28/latex-note-07/","content":"\n# $\\LaTeX$札记（七）——硕士学位论文相关\n\n这里提出的相关问题和相应解决方法主要针对Github上[TouchFishPioneer/SEU-master-thesis: 东南大学硕士研究生学位论文LaTeX模板](https://github.com/TouchFishPioneer/SEU-master-thesis)、[Reanon/SEUThesisLatexTemplate: 东南大学 硕士毕业论文 Latex 模版 网络空间安全学院](https://github.com/Reanon/SEUThesisLatexTemplate/tree/master)版本，主要针对电子信息硕士，即enginner选项开启时，进行修改，部分修改也可以用于学硕。\n\n主要分为以下部分：\n\n+ 封面调整：①封面大标题“工程硕士学位论文”->“电子信息硕士学位论文”；②大封面单行标题；③单独小封面论文标题段前间距问题；④领域名称；⑤中文内封面文字间距；⑥英文封面标题（待后续确认）；\n+ 目录调整：①“目录”章节是否出现在目录中；②目录的其他文字调整；英文缩略语部分的相应调整；\n+ 正文相关：①加粗希腊字母；②算法流程的宏包调整；③图名、表名、子图引用的相关问题；④浮动体相关设置；⑤正文引用的相关说明；⑥脚注的调整；⑦itemize间距；\n+ 其他杂项：①参考文献的排列；②参考文献的格式调整；③IEEE缩写->全称；④毕业/学位论文答辩委员会名单；\n+ Windows/Mac字体调整：主要是宋体加粗的调整。\n\n首先放一下目前研究生院最新的论文写作规范。但是至于要落实到何种地步——未知。。。毕竟往届的论文规范有一部分和这上面的差距不小，甚至他给出的优秀范例和他前文所说也不一致。\n\n<object data=\"东南大学研究生学位论文写作指南-1203V4.pdf\" type=\"application/pdf\" width=\"100%\" height=\"500px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"东南大学研究生学位论文写作指南-1203V4.pdf\">Download PDF</a>.</p></object>\n\n然后给出几条建议吧\n\n> 1. 这只是本人的调整，不保证完全符合学校、学院的全部要求。只能说尽力修改。\n> 2. 建议采用Overleaf，或实验室自行搭建的类Overleaf进行编译(Xelatex)，~~不太建议直接使用Windows安装的TexLive进行编译，否则相应字体有错误（如1.1 XXXX技术，按照规范要求使用宋体加粗，而Windows默认的衬线体加粗采用黑体）。~~  （文末给出windows和mac的调整方式。感叹一下，mac编译真的太快了！）\n> 3. 建议在撰写过程中，只编译目录、相应章节和参考文献，可以加快编译速度，如封面等可以最终再编译。\n> 4. 个人比较推荐使用tikz绘图（可参考[👉LaTeX札记（六）：MATLAB与TikZ绘图 | Levitate_](https://levitate-qian.github.io/2024/01/01/latex-note-06/)），修改比较方便，同时图片尺寸调整、文字调整都比较方便，但是编译真的很慢。。。\n\n这里给出一个调整后的“电子信息硕士学位论文”模板：[https://levitate.lanzoub.com/iRmnq2j8wcnc](https://levitate.lanzoub.com/iRmnq2j8wcnc)。（建议使用overleaf编译，如需采用Windows/Mac本地编译，请按照第五部分进行修改字体配置）\n\n再提供一个东大信息的beamer模板（非官方），对过去的做了一些修改\\~ [Levitate-Qian/SEU_radio_beamer_template: 东南大学信息学院非官方beamer模版](https://github.com/Levitate-Qian/SEU_radio_beamer_template)\n\n\n\n> 写在最前面：下面很多处修改起作用的前提是打开了`main.tex`文件的`engineer`，\n>\n> 第一行修改为\n>\n> ```tex\n> \\documentclass[algorithmlist,figurelist,tablelist,nomlist,engineer]{template/seumasterthesis}\n> ```\n>\n> 请使用XeLaTeX进行编译!!\n\n## 封面调整\n\n### 封面大标题调整\n\n【问题】封面“工程硕士学位论文”应当为“电子信息硕士学位论文”，内中文封面“工程硕士学位论文”应当为“硕士学位论文”\n\n【修改方式】首先在`figures/defined`文件夹中添加下面的`electronic_master.pdf`（即电子信息硕士学位论文的文字pdf，采用华文中宋），\n\n<object data=\"electronic_master.pdf\" type=\"application/pdf\" width=\"100%\" height=\"150px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"electronic_master.pdf\">Download PDF</a>.</p></object>\n\n随后在cls文件中搜索`master-engineer.png`，在470行附近的替换为\n\n```tex\n\\put(22,-7.3){\\includegraphics[scale=0.33]{figures/defined/electronic_master.pdf}}\n```\n\n在660行附近的替换为\n\n```tex\n\\includegraphics[scale=0.33]{figures/defined/electronic_master.pdf}\n```\n\n在790行附近的替换为\n\n```tex\n\\includegraphics[scale=0.35]{figures/defined/master.png}\n```\n\n### 大封面单行标题\n\n【问题】如果没有副标题，Ａ３大封面会报错\n\n【修改方式】cls文件,529行注释掉。感觉我们组标题都挺长的，所以我目前先取消注释了\n\n```\n\\erhao\\heiti\\@subtitle\\\\    % 修改3 -- Reanon 为了避免空副标题\n```\n\n\n\n### 单独小封面论文标题段前间距问题\n\n【问题】如果只生成小封面，不生成大封面会出现论文标题和“电子信息硕士学位论文”距离过近的情况\n\n【修改方式】这是因为大封面定义了`\\setlength{\\unitlength}{1cm}`，而单独生成小封面时候没有这句话了，也就造成段前间距出现了问题，在cls文件中搜索找到如下片段\n\n```tex\n\t\\ifengineer\n        \\vspace*{8.3cm}\n    \\else\n        \\vspace*{8.6cm}\n    \\fi\n```\n\n修改为\n\n```tex\n    \\ifengineer\n        \\setlength{\\unitlength}{1cm}\n        \\noindent\n        \\vspace*{8.3cm}\n    \\else\n    \t\\setlength{\\unitlength}{1cm}\n        \\noindent\n        \\vspace*{8.6cm}\n    \\fi\n```\n\n\n\n### 领域名称\n\n【问题1】根据研究生院最新发布的封面文件，“工程领域名称”应当改名为“领域名称”\n\n【修改方式】cfg文件第29行修改为\n\n```tex\n\\newcommand{\\engfieldpre}{领~~~~域~~~~名~~~~称}\n```\n\n【问题2】“通信工程（含宽带网络、移动通信等）”太长了一行打不下怎么办\n\n【修改方式】main.tex中`\\major`中使用minipage，例如\n\n```tex\n\\major{ \\begin{minipage}{\\linewidth}\\centering 通信工程（含宽带\\\\网络、移动通信等）\\end{minipage}}  \n```\n\n### 中文内封面文字间距\n\n【问题】中文内封面下划线姓名、导师等字符间距太过于松散\n\n【修改方式】搜索cls文件中`\\makebox[6cm][s]`，将下面片段中的`\\makebox[6cm][s]`均替换为`\\makebox[6cm][c]`，注意3.5cm的不需要替换，哪个是前面非下划线内容的，需要分散\n\n```tex\n\\begin{tabular}{cc}\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\mainmajorpre:  } &\n                \\underline{\n                    \\makebox[6cm][s] {\n                        \\xiaoerhao\\songti\\textbf{\\@major}\n                    }\n                } \\\\\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\authorpre:  } &\n                \\underline {\n                    \\makebox[6cm][s] {\n                        \\xiaoerhao\\songti\\textbf{\\@author}\n                    }\n                } \\\\\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\advisorpre:  } &\n                \\underline {\n                    \\makebox[6cm][s] {\n                        \\xiaoerhao\\songti\\textbf{\\@advisorname}\n                    }\n                }\n                \\\\\n                &\n                \\ifcoadvisor\n                \\underline{\n                    \\makebox[6cm][s] {\n                        \\xiaoerhao\\songti\\textbf{\\@coadvisorname}\n                    }\n                }\n                \\else\n                \\fi\n            \\end{tabular}\n```\n\n替换为\n\n```tex\n\\begin{tabular}{cc}\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\mainmajorpre:  } &\n                \\underline{\n                    \\makebox[6cm][c] {\n                        \\xiaoerhao\\songti\\bfseries\\@major\n                    }\n                } \\\\\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\authorpre:  } &\n                \\underline {\n                    \\makebox[6cm][c] {\n                        \\xiaoerhao\\songti\\textbf{\\@author}\n                    }\n                } \\\\\n                \\makebox[3.5cm][s]{\\xiaoerhao\\heiti\\advisorpre:  } &\n                \\underline {\n                    \\makebox[6cm][c] {\n                        \\xiaoerhao\\songti\\textbf{\\@advisorname}\n                    }\n                }\n                \\\\\n                &\n                \\ifcoadvisor\n                \\underline{\n                    \\makebox[6cm][c] {\n                        \\xiaoerhao\\songti\\textbf{\\@coadvisorname}\n                    }\n                }\n                \\else\n                \\fi\n            \\end{tabular}\n```\n\n\n\n### 英文封面标题（待后续确认后调整）\n\n## 目录调整\n\n### “目录”章节是否出现在目录中\n\n【问题】“目录”章节并未出现在目录中，我也不确定要不要出现\n\n【修改方式】如果需要的话，可以在`\\tableofcontents`前添加这段话\n\n```tex\n\\cleardoublepage\n\\addcontentsline{toc}{chapter}{目　　录}\n```\n\n\n\n### 目录的其他文字调整\n\n【问题】感觉目录中，“摘要”、“致谢”两个词中间应该空两个全角空格，而出现在正文标题中中间空一个全角空格比较合适。但是原来的调整通过\\quad并不精准。\n\n【修改方式】cfg文件第80、81、86、87行直接修改为全角空格（可能网站会吞空格，大家自行输入吧）\n\n```tex\n\\newcommand{\\@abstracttoc}{摘　　要}\n\\newcommand{\\@abstracttitle}{摘　要}\n\\newcommand{\\@acktoc}{致　　谢}\n\\newcommand{\\@acktitle}{致　谢}\n```\n\ncls文件第94行直接修改为全角空格\n\n```tex\ncontentsname={目　录},\n```\n\n\n\n### 英文缩略语部分的相应调整\n\n【问题1】如果想要同时显示缩略语的中文全称，并在最上面一行显示为“英文缩写  英文全称  中文全称”\n\n【修改方式】cls文件中：第一步，增加中文缩略语的定义`\\nomchinese`\n\n```tex\n\\newcommand{\\nomchinese}[1]{\\renewcommand{\\nomentryend}{\\hspace*{\\fill}\\makebox[5cm][l]{#1}}}\n```\n\n第二步，修改`\\nompreamble`，以在第一行显示“英文缩写  英文全称  中文全称”\n\n```tex\n\\renewcommand{\\nompreamble}{\\noindent \\makebox[1in][l]{\\bfseries 英文缩写} {\\bfseries 英文全称}\\hspace*{\\fill}\\makebox[5cm][l]{\\bfseries 中文全称}\\vspace{-3pt}}\n```\n\n第三步，修改条目“英文缩写”和“英文全称”之间的间距，cls文件搜索`\\printnomenclature[2in]`修改为`\\printnomenclature[1in]`\n\n正文引用：第四步，正文输入缩略语的格式为\n\n```tex\n\\nomenclature{6G}{6th Generation Mobile Communication\\nomchinese{第六代移动通信}}\n```\n\n【问题2】缩略语的行间距太过于松散\n\n【修改方式】cls文件1000行附近，搜索`\\printnomenclature`，在上一行添加这一行以设置缩略语间距为0\n\n```tex\n\\setlength{\\nomitemsep}{0pt}\n```\n\n【问题3】我采用xxx编译，怎么没有编译出来“英文缩略语”啊，我目前遇到的分两个情况\n\n+ Windows系统下，采用编译链进行编译的场景：请将编译链选择为“xelatex->makeindex->bibtex->xelatex*2”\n\n+ 较早的Overleaf（见于我们组自行搭建的Overleaf）：在cls文件`\\RequirePackage{nomencl}`，添加一行\n  ```tex\n  \\immediate\\write18{makeindex \\jobname.nlo -s nomencl.ist -o \\jobname.nls}\n  ```\n\n【问题4】我们专业一般这个部分的标题显示为“英文缩略语”，而非“术语与符号列表”，符号列表一般在第一章最后一节写。\n\n【修改方式】cls文件搜索`\\nomname`，修改以下\n\n```tex\n\\renewcommand{\\nomname}{英文缩略语}\n```\n\n\n\n## 正文相关\n\n### 加粗希腊字母\n\n原来使用`\\mathbf`加粗的希腊字母不行啦，使用`\\bm`来进行加粗\n\n### 算法流程的宏包调整\n\n【问题1】之前写的一些算法流程采用algorithmic宏包，但是这个模板默认的是algorithmicx宏包\n\n【修改方式】cls文件第133、134行附近，替换为algorithmic宏包\n\n【问题2】进一步想要让所有流程中所有英文变成中文\n\n【修改方式】重定义一些算法流程的名称，但不推荐（如有需要，可以自行取消注释）\n\n```tex\n% \\renewcommand{\\algorithmicif}{\\textbf{如果}}         % 替换 \\IF\n% \\renewcommand{\\algorithmicthen}{\\textbf{则}}         % 替换 \\THEN\n% \\renewcommand{\\algorithmicelse}{\\textbf{否则}}       % 替换 \\ELSE\n% \\renewcommand{\\algorithmicelsif}{\\textbf{否则如果}}   % 替换 \\ELSIF\n% \\renewcommand{\\algorithmicendif}{\\textbf{结束如果}}   % 替换 \\ENDIF\n% \\renewcommand{\\algorithmicfor}{\\textbf{对于}}        % 替换 \\FOR\n% \\renewcommand{\\algorithmicforall}{\\textbf{对于所有}} % 替换 \\FORALL\n% \\renewcommand{\\algorithmicdo}{\\textbf{执行}}         % 替换 \\DO\n% \\renewcommand{\\algorithmicendfor}{\\textbf{结束对于}}  % 替换 \\ENDFOR\n% \\renewcommand{\\algorithmicwhile}{\\textbf{当}}        % 替换 \\WHILE\n% \\renewcommand{\\algorithmicendwhile}{\\textbf{结束当}}  % 替换 \\ENDWHILE\n% \\renewcommand{\\algorithmicrepeat}{\\textbf{重复}}     % 替换 \\REPEAT\n% \\renewcommand{\\algorithmicuntil}{\\textbf{直到}}      % 替换 \\UNTIL\n```\n\n\n\n### 图名、表名、子图引用的相关问题\n\n【问题1】图名、表名中，编号和名称之间间隙过小，仅为一个普通空格\n\n【修改方式】cls文件搜索captionsetup，将两个的间隔“space”改为“quad”\n\n```tex\n\\captionsetup[table]{labelsep=quad}\n\\captionsetup[figure]{labelsep=quad}\n```\n\n【问题2】子图引用不显示()，只显示为1a、1b，而非1(a)，1(b)\n\n【修改方式】cls文件搜索subfig，修改相应条目\n\n```tex\n\\RequirePackage[labelformat=simple,justification=centering]{subfig}\n\\renewcommand\\thesubfigure{(\\alph{subfigure})}\n```\n\n\n\n### 浮动体相关设置\n\n【问题】原始并未对浮动体设置限制\n\n【修改方式】cls文件加入下面这段——根据自己需求进行调整\n\n```tex\n\\renewcommand{\\topfraction}{0.9}       % 页面顶部浮动体允许的最大比例\n\\renewcommand{\\bottomfraction}{0.8}    % 页面底部浮动体允许的最大比例\n\\renewcommand{\\textfraction}{0.1}      % 非浮动体内容的最小比例\n\\renewcommand{\\floatpagefraction}{0.9} % 完全被浮动体占据的页面最小比例\n\\setcounter{topnumber}{5}              % 单页顶部浮动体最大数量\n\\setcounter{bottomnumber}{3}           % 单页底部浮动体最大数量\n\\setcounter{totalnumber}{6}            % 单页浮动体总的最大数量\n```\n\n\n\n### 正文引用的相关说明\n\n【问题】引用了xxx，为什么和前后字符间距这么近啊\n\n【修改方式】引用的内容，数字和西文字符不会与中文字符产生一定的空格，需要手动补足。建议在引用公式、图片、表格、小节时候人为添加tie和空格，可以在文字和引用之间添加tie`~`防止换行，另外一半添加空格即可。如果引用的后边是一个标点符号，就不需要添加空格了。\n\n```tex\n式~\\eqref{eq:MMSE} 说明了xxx，如图~\\ref{fig:abc}，如表~\\ref{tab:xxx} 所示，第~\\ref{sec:AI_UL_sys}~节介绍了XXX。\n```\n\n\n\n### 脚注的调整\n\n【问题】按照要求，脚注使用加圈阿拉伯数字，而原来直接使用阿拉伯数字\n\n【修改方式】一般来说，脚注不会超过10个，所以直接采用pifont中的加权字符。在main.tex引言区加入，\n\n```tex\n\\usepackage{pifont}  % 引入 pifont 宏包\n\\renewcommand{\\thefootnote}{\\ding{\\numexpr171+\\value{footnote}}}\n```\n\n\n\n### itemize间距\n\n【问题】itemize段前、段后间距较大，不同条目之间间距也比较大\n\n【修改方式】main.tex引言区引用enumitem宏包，\n\n```tex\n\\usepackage{enumitem}\n```\n\n正文使用itemize时，调整一下，例如\n\n```tex\n\\begin{itemize}[topsep=5pt, itemsep=2pt, parsep=0pt, partopsep=0pt]\n    \\item AXXXXX\n    \\item BXXXXX\n    \\item CXXXXX\n\\end{itemize}\n```\n\n\n\n## 其他杂项\n\n### 参考文献的排列\n\n【问题】页面内引用的多篇参考文献排列按照输入key的顺序排列，而非按照数字顺序（个人觉得按照数字顺序比较好，毕竟都应用多篇参考文献了，应该没有什么先后顺序）\n\n【修改方式】cls文件搜索“natbib”，增加“sort”输入\n\n```tex\n\\RequirePackage[super,square,comma,compress,sort]{natbib}\n```\n\n\n\n\n\n### 参考文献的格式调整\n\n直接调整bst中的0、1即可。基本应该都能看懂.\n\n### IEEE缩写->全称\n\n【问题】在撰写IEEE论文时候，采用IEEEabbr对参考文献进行缩写，但是一般学位论文需要全称\n\n【修改方式】添加IEEEfull的bib文件即可，然后main.tex也要记得引用\n\n```tex\n\\thesisbib{IEEEfull,reference} \n```\n\n\n\n### 毕业/学位论文答辩委员会名单\n\n可以直接添加latex版本的名单。不需要的话注释即可\n\n```tex\n\\clearpage\n\\thispagestyle{empty}\n\\begin{center}\n    \\xiaoerhao\\songti\\bfseries 毕业/学位论文答辩委员会名单\n\\end{center}\n% Please add the following required packages to your document preamble:\n% \\usepackage{multirow}\n\\begin{table}[h]\n\\renewcommand\\arraystretch{1.3}\n\\centering\n\\begin{tabular}{|cc|ccc|}\n\\hline\n\\multicolumn{2}{|c|}{\\textbf{毕业/学位论文题目}}    & \\multicolumn{3}{l|}{东南大学 LATEX 论文模板使用手册}  \\\\ \\hline\n\\multicolumn{2}{|c|}{\\textbf{作　　者}} & \\multicolumn{3}{l|}{XXX} \\\\ \\hline\n\\multicolumn{2}{|c|}{\\textbf{专　　业}} & \\multicolumn{3}{l|}{通信工程（含宽带网络、移动通信）等}        \\\\ \\hline\n\\multicolumn{2}{|c|}{\\textbf{研究方向}} & \\multicolumn{3}{l|}{通信与信息系统}\\\\ \\hline\n\\multicolumn{2}{|c|}{\\textbf{导　　师}} & \\multicolumn{3}{l|}{XXX}  \\\\ \\hline\n\\multicolumn{1}{|c|}{\\multirow{7}{*}{\\bfseries \\parbox[t]{1em}{答辩委员会组成}}} & \\textbf{姓  名}   & \\multicolumn{1}{c|}{\\textbf{职  称}}        & \\multicolumn{1}{c|}{\\textbf{学科专业}} & \\textbf{工作单位} \\\\ \\cline{2-5} \n\\multicolumn{1}{|c|}{}    & \\multicolumn{1}{c|}{\\renewcommand\\arraystretch{1}\\begin{tabular}[c]{@{}c@{}}XXX\\\\ （主席）\\end{tabular}} & \\multicolumn{1}{c|}{研究员}  & \\multicolumn{1}{c|}{　信息与通信工程　}       & XX大学\\\\ \\cline{2-5} \n\\multicolumn{1}{|c|}{}    & XXX     & \\multicolumn{1}{c|}{\\renewcommand\\arraystretch{1}\\begin{tabular}[c]{@{}c@{}}研究员级\\\\ 高级工程师\\end{tabular}}   & \\multicolumn{1}{c|}{信息与通信工程}       & 　　XXX实验室　　 \\\\ \\cline{2-5} \n\\multicolumn{1}{|c|}{}    & \\multicolumn{1}{c|}{\\renewcommand\\arraystretch{1}\\begin{tabular}[c]{@{}c@{}} XXX\\\\ XXX\\end{tabular}}      & \\multicolumn{1}{c|}{副教授}  & \\multicolumn{1}{c|}{信息与通信工程}       &    \\multicolumn{1}{c|}{\\renewcommand\\arraystretch{1}\\begin{tabular}[c]{@{}c@{}}University of XXX\\\\ XXX\\end{tabular}}     \\\\ \\cline{2-5} \n\\multicolumn{1}{|c|}{}    & XXX     & \\multicolumn{1}{c|}{副研究员}  & \\multicolumn{1}{c|}{信息与通信工程}       & XX大学\\\\ \\cline{2-5} \n% \\multicolumn{1}{|c|}{}    &         & \\multicolumn{1}{c|}{}    & \\multicolumn{1}{c|}{}   &    \\\\ \\cline{2-5} \n\\multicolumn{1}{|c|}{}    & \\multicolumn{1}{c|}{\\renewcommand\\arraystretch{1}\\begin{tabular}[c]{@{}c@{}}XXX\\\\ （秘书）\\end{tabular}}   & \\multicolumn{1}{c|}{副教授} & \\multicolumn{1}{c|}{信息与通信工程}       & XX大学\\\\ \\hline\n\\end{tabular}\n\\end{table}\n\n\n备注：\n\n1、本表格适用于所有研究生。\n\n2、本表格排版在终版毕业/学位论文中，附在毕业/学位论文的最后。\n\n```\n\n## Windows/Mac字体调整\n\n由于在Windows/Mac环境下默认的衬线体——宋体（Songti）加粗变为非衬线体——黑体(Heiti)，不符合学校为“宋体加粗”的相关要求，我们需要对字体进行调整。而Overleaf中采用的字体设置默认就是正确的。\n\n首先，我们需要搜索cls文件中的所有`\\Songti`替换为`\\rmfamily`，其次cls文件中（可以加在模板60行font size前后）加上如下命令。\n\n### Windows环境下\n\n```tex\n\\setCJKmainfont[BoldFont={华文中宋},ItalicFont=KaiTi]{SimSun}% 华文中宋->方正小标宋\n\\setCJKsansfont[AutoFakeBold]{SimHei}%\n\\setCJKmonofont{FangSong}%\n```\n\n我们将宋体的加粗映射为“华文中宋/方正小标宋简体”，这个大家可以自己选择，“华文中宋”是Windows电脑默认就会安装的，而“方正小标宋简体”需要大家自行下载安装。\n\n### Mac环境下\n\n```tex\n\\setCJKmainfont[BoldFont=Songti SC Black,ItalicFont=Kaiti SC,BoldItalicFont=Kaiti SC Bold]{Songti SC}% Songti SC -> Songti SC Light\n\\setCJKsansfont{STHeiti}% \n\\setCJKmonofont{STFangsong}%\n```\n\n在Mac环境下，我们直接采用“宋体-简”的常规体(Regular)作为正文字体，黑体(Black)作为加粗字体，如果觉得默认的常规体太粗的话可以选择细体Songti SC Light作为默认字体，如果觉得基线不在一条线，可以选择粗体Songti SC Bold作为衬线的粗体字体。\n\n\n\n\n\n","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"秋招小结与建议——SEU to JOB","url":"/2024/11/19/seu-to-job/","content":"\n# 秋招小结\n\n大概从三月底慢慢开始刷力扣，五、六月份准备秋招，到现在基本也快要结束了，稍微分享一下秋招的经历吧~\n\n\n\n简历模板：[Levitate-Qian/latex-resume-template: 保研/求职latex简历模版](https://github.com/Levitate-Qian/latex-resume-template)\n\n---\n\n## BG\n\n+ 2本9硕，其他的相关背景我的个人简介页面也基本都有\n+ 研究生期间主要做的是AI通信，偏物理层\n+ 无实习经历\n+ 不考虑转码，所以投递的基本都是偏通信相关的岗位\n+ 区域主要考虑江浙沪，更局限的话就沪宁线上，其实能考虑的主要也就上海、南京、苏州、无锡\n\n\n\n## 投递的公司、岗位\n\n由于通信相关的岗位确实比较少，且我的区域限制得也比较“死”，所以和其他人比起来投递的并不算很多。\n\n### 私企\n\n简历挂&笔试挂（一律认为海笔！）：\n\n+ 大疆（上海） -- 无线算法工程师：\n  + 7.4投秋招，7.11发测评，7.15做测评（性格+行测），8.11笔试（1小时），9.20感谢信\n+ 联想（上海） -- 算法工程师（今年根本没有通信岗，不该投算法的）：简历挂\n+ 芯原（上海） -- 算法工程师（应该卡双九）：\n  + 8.19投秋招，8.24宣讲会，8.25笔试\n+ 汇川（苏州） -- 通信软件工程师：简历挂\n+ 荣耀（南京） -- 通信协议开发工程师：\n  + 8.26投秋招，9.15协议疑似招满了，后来问我要不要转岗，不想去了\n+ 小米（上海） -- 无线通信物理层软件工程师： **垃圾公司！！！** *（亏我以前还是米粉呢）* 投递的时候物理层、协议都有上海base，做完笔试了，两个岗全没上海base了，问我要不要转岗，不去了！！！而且到11月两个岗貌似又冒出来上海base了，早干啥了\n  + 8.26投秋招，8.27测评，9.5笔试，9.10上海直接没了？\n+ 比亚迪（上海/南京） -- 技术研发类：简历挂，或者说没人捞，池子太深了？（不理解）\n\n有流程的：\n\n+ 中兴（南京） -- 算法工程师（智算）：\n  + 中兴全力转大模型了，领军计划基本都是大模型，说是可以进去了再学大模型相关的。\n  + 流程拉的很长，5.7投领军班，5.16面试（貌似可以算作秋招领军计划得一面），6.12晚通过领军班，7.18发测评（性格+行测），7.23中兴捧月复赛面试，8.1一面（50分钟），9.4二面（20分钟），10.15洽谈（45分钟左右），ssp *（好像还是应该投上海的，貌似上海今年都开得不错）*\n+ TP联洲（上海） --  通信算法工程师：\n  + 面试体验都还是不错的，二面问了一些通信、机器学习八股。而且联洲貌似是唯一一个注意到我博客的（?），还问了我做的Power BI成绩报表（三面的时候）。\n  + 6.11投提前批，6.17发在线测评，6.20做测评（通信笔试），7.26一面（20分钟），7.31二面（40分钟），8.9终面（20分钟），8.13座谈会，8.28签约待处理，9.5 OC+意向书\n+ OPPO（南京）-- 通信AI算法工程师：\n  + 面试体验也很不错，二面虽然推迟了一会，但是感觉挺大佬的。\n  + 7.11投秋招，7.26发测评，7.26测评，7.27笔试（20道选择+3道编程），8.3一面（35分钟），8.17二面（30分钟），8.29 HR面（15分钟），9.3排序中，9.4线上签约沟通会，9.4 意向书\n+ 翱捷（上海） -- 无线通信工程师：\n  + 好像是挺wlb的一家公司，秋招所有面试里面应该算是问的比较细的了，对协议相关的问得很深入。\n  + 8.21投秋招，9.9一面（50分钟），10.12HR电话洽谈（10分钟左右），10.16谈薪\n+ vivo（上海） -- 5G通信协议工程师：\n  + 南京vivo大厦线下面试的，一面面完等一会接着二面，是我的初次线下面，还有点紧张。\n  + 不过vivo的秋招组织是比较混乱的，我要是9.13没有打通hr电话，那我就直接不会收到笔试链接，也不会有后面的面试。貌似他的笔试链接是在一天内发，发不完的就不发了，还是个栈。话说一开始还给我发的结构工程师的卷子，幸好后来又打通了。\n  + 8.22投秋招，8.23测评，9.13笔试（1小时），9.24业务面试+hr面（线下），10.28感谢信 *（泡池子没泡出来，不过身边也有人泡出来了，可能hr面要价高了？）*\n+ 华为（上海） -- 算法工程师-通信算法：\n  + 华为南研所线下面试的，由于我的项目就是和华为那个部门一起做的，所以问的很深入且开放，而且会问一下项目相关的通信和AI八股，我也没好好准备，哎😔。一直在准备手撕，结果只手撕了一个很简单的爬楼梯。\n  + 8.27投秋招，9.19发测评，9.20测评，10.14线下面试（大约一面30、二面40、三面30），速通池子，还在泡着呢~\n\n### 研究所&国企\n\n研究所——**全寄**：\n\n+ 607所（无锡） -- 先进信号处理算法研究岗 （简历挂，线下投递也没用啊）\n  + 6.19投提前批（开放日），寄，8.29投秋招（第二志愿：先进数据处理算法研究岗），9.2宣讲线下投简历\n+ 8511所（南京） -- 设计师 （现场面了一面就没有下文了，猜测因为有国奖？）\n  + 6.19投提前批（夏令营），寄，8.29投秋招，8.30宣讲线下投简历，现场一面\n+ 14所（南京） -- 算法工程师 （简历挂，线下投递也没用啊）\n+ 702所（无锡） -- 软件工程岗（双选会线下投简历，明确说不匹配）\n\n国企（很多后来不想参加了）：\n\n+ 南瑞继保（南京） -- 通信电子研发工程师（简历挂，9.6线下面试未入选）\n+ 江苏银行（南京） -- 2025届总行金融科技培养生（10.20笔试放弃）\n+ 中国移动 -- （10.21笔试放弃）\n+ 中国电信 -- （10.12笔试放弃）\n+ 国家电网（投的苏南某市局）\n  + 要投国家电网的话，建议提前考一个计算机二级。此外，今年提前批貌似身边听到通过的主要都是苏北，提前批苏南可能还是比较难。\n  + 电网提前批，通信专硕转入细分领域后没问题，填报时候有085402。\n  + 9.29投秋招，10.9线上测评（220题，140心理测评，71行测+企业文化，4多选电气相关，5材料分析），10.10 线上面试（3vs3辩论），10.24直接没收到线下面试通知，挂了，哈哈\n\n### 外企\n\n+ 梦中情企——微软（上海） -- MSRA Researcher：简历挂\n\n还有一些高通、联发科、瑞晟微、思科、英特尔、爱立信之类的外企，有的岗位不太对口，有的就没看到，所以都没报。三星投了，但是也没准备去，应该也是简历挂。\n\n\n\n## 总体建议\n\n总体来说，通信相关的岗位，今年应该相比去年行情略好一丢丢（真的就一丢丢），但远没有到互联网回暖的那种情况。通信相关的岗位总体还是越来越少的，而且目前主要还是协议开发之类的。\n\n> 最后，给出一些小建议吧~\n>\n> + *（这条还是当时中兴领军班上课的一个老师说的）* 建议可以**准备一个自我介绍的PPT**，一般线上面试都可以投屏，可以对着PPT自我介绍和介绍项目，相比空对空讲感觉上会好很多。当然线下面试就不行了。\n> + 力扣应该是需要刷的，但是**不转码好像没必要刷很多**，感觉我面试的相关岗位除了华为有手撕（只有一道，还很简单）外，其余对于代码的考察应该主要都在笔试中了。\n> + 简历**项目和项目相关的通信八股都需要好好准备**，答不上来八股真的很尴尬。\n> + 如果能够接受互联网的强度的话，**转码**也是个不错的选择，互联网今年升温真的很快！（不过互联网大概率也需要有相关实习经历和项目，需要早做准备）\n\n我最后去哪了，不重要~\n","tags":["秋招"],"categories":["总结"]},{"title":"【基本完结】LeetCode自用刷题记录","url":"/2024/03/30/LeetCode-problems/","content":"\n# LeetCode自用刷题思路\n\n自用的刷题记录，以防后续不记得之前自己怎么想的\\~ 正式的题解还是看**官方题解**和**“代码随想录”**吧\n\n> - 做题顺序&一些图片与思路：[代码随想录 (programmercarl.com)](https://programmercarl.com/)、[题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台](https://leetcode.cn/problemset/)、b站视频、自制等\n> - 点击👉右边或者👇下面的菜单栏🗂，可以调出目录\n> - 前期主要是用C语言刷的，但是C的功能太简陋了，从哈希表部分开始换用C++刷题。\n>   - C转C++教程：[C语言 转 C++ 简单教程\\_哔哩哔哩\\_bilibili](https://www.bilibili.com/video/BV1UE411j7Ti/?spm_id_from=333.337.search-card.all.click)（up主专栏有思维导图，喵啊~）\n\n\n\n> 明天就要华为面试了，但我已经什么都不记得了，祝我好运吧！随缘了\n>\n> ——2024年10月13日\n\n\n\n## 数组\n\n### [704. 二分查找](https://leetcode.cn/problems/binary-search/)\n\n> 给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。\n\n注意开闭区间\n\n``` c\nint search(int* nums, int numsSize, int target) {\n    int left = 0;\n    int right = numsSize - 1;\n    int middle = 0;\n    while (left <= right){\n        middle = (left + right) / 2;\n        if (nums[middle] == target) {\n            return middle;\n        }\n        else if (nums[middle] > target) {\n            right = middle - 1;\n        }\n        else {\n            left = middle + 1;\n        }\n    }\n    return -1;\n}\n```\n\n\n\n### [27. 移除元素](https://leetcode.cn/problems/remove-element/)\n\n> 给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。\n>\n> 不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。\n>\n> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n快指针指向原始数组，慢指针指向新数组。如果等于val，slow不加；不等于val，fast指向的值赋给slow指向的值\n\n```c\nint removeElement(int* nums, int numsSize, int val) {\n    int slow = 0;\n    for (int fast = 0; fast < numsSize; fast++) {\n        // 快指针指向原始数组，慢指针指向新数组。如果等于val，slow不加；不等于val，fast指向的值赋给slow指向的值\n        if (nums[fast] != val) {\n            nums[slow] = nums[fast];\n            slow++;\n        }\n    }\n    return slow;\n}\n```\n\n\n\n### [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)\n\n> 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。\n\n动态数组不行！\n\n中途比较，两头的数字一定是最大的，其平方一定在平方数组的末尾\n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* sortedSquares(int* nums, int numsSize, int* returnSize) {\n    *returnSize = numsSize;\n    \n    int left = 0;\n    int right = numsSize - 1;\n    \n    int* ans = (int*)malloc(sizeof(int) * numsSize);\n\n    // 中途比较，两头的数字一定是最大的，其平方一定在平方数组的末尾\n\n    for (int i = numsSize - 1; i >= 0; i--) {\n        if (nums[left] * nums[left] >= nums[right] * nums[right]) {\n            ans[i] = nums[left] * nums[left];\n            left++;\n        }\n        else {\n            ans[i] = nums[right] * nums[right];\n            right--;\n        }\n    }\n    return ans;\n}\n```\n\n\n\n### [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)\n\n> 给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**\n>\n> 找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组**`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。\n\n暴力解法过不了\n\n张开的窗口之和至少要能够装下target。首先移动end（必须到结尾），至少要装下target。接着，start向右，找最小的长度，装不下了，end向右。 \n\n```c\nint minSubArrayLen(int target, int* nums, int numsSize) {\n    int length = 100001;\n    int start = 0;\n    int sum = 0;\n    for(int end = 0; end < numsSize; end++) {\n        sum += nums[end];\n        while (sum >= target) { //这个while是精髓！！！ 滑动初始窗口\n            if ((end - start + 1) < length) {\n                length = end - start + 1;\n            }            \n            sum -= nums[start];\n            start++;\n        }\n    }\n    if (length < 100001) {\n        return length;\n    }\n    else {\n        return 0;\n    }\n}\n```\n\n\n\n### [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n> 给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。\n\n找规律，注意边界\n\n找规律，第一步先把第一行填满，后续每次转弯向右，每两次需要步长减一。注意，横纵坐标有没有超出范围，且二维数组第一位为行，第二位为列\n\n<img src=\"/image-20240326200626892.png\" alt=\"image-20240326200626892\" style=\"zoom:33%;\" />\n\n```c\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {\n    // 初始化返回的结果数组\n    *returnSize = n;\n    *returnColumnSizes = (int*)malloc(sizeof(int) * n);\n    int** ans = (int**)malloc(sizeof(int*) * n);\n    int i;\n    for (int i = 0; i < n; i++) {\n        ans[i] = (int*)malloc(sizeof(int) * n);\n        (*returnColumnSizes)[i] = n;\n    }\n\n    int shiftX = 0;\n    int shiftY = 0;\n    int inputNum = 1;\n    int directionX = 0; // 0往左，1往右\n    int directionY = 0; // 0往下，1往上\n    \n    for (int step = n; step > 0; step-- ) {\n        if (step == n) {\n            for (int i = 0; i < step; i++) {\n                ans[shiftY][shiftX] = inputNum;\n                inputNum++;\n                shiftX++;\n            }\n            shiftX--;\n        }\n        else {\n            // 先移动Y方向\n            if (directionY == 0) {\n                for (int i = 0; i < step; i++) {\n                    shiftY++;\n                    ans[shiftY][shiftX] = inputNum;\n                    inputNum++;\n                }\n                directionY = 1;\n            }\n            else {\n                for (int i = 0; i < step; i++) {\n                    shiftY--;\n                    ans[shiftY][shiftX] = inputNum;\n                    inputNum++;\n                }\n                directionY = 0;\n            }\n            //再移动X方向\n            if (directionX == 0) {\n                for (int i = 0; i < step; i++) {\n                    shiftX--;\n                    ans[shiftY][shiftX] = inputNum;\n                    inputNum++;\n                }\n                directionX = 1;\n            }\n            else {\n                for (int i = 0; i < step; i++) {\n                    shiftX++;\n                    ans[shiftY][shiftX] = inputNum;\n                    inputNum++;\n                }\n                directionX = 0;\n            }\n        }\n    }\n\n    return ans;\n}\n```\n\n\n\n## 链表\n\n> 链表和数组对比\n>\n> |      | 插入/删除 | 查询   | 使用场景                         |\n> | ---- | --------- | ------ | -------------------------------- |\n> | 数组 | $O(n)$    | $O(1)$ | 数据量固定，频繁查询，较少增删   |\n> | 链表 | $O(1)$    | $O(n)$ | 数据量不固定，频繁增删，较少查询 |\n>\n> + C：——《数据结构与算法/软件技术基础》周大为版\n>   ```c\n>   typedef struct node {\n>       int data;\n>       struct node *next;\n>   } linklist;\n>   ```\n>\n> + C++：\n>   ```cpp\n>   struct ListNode {\n>       int val;  // 节点上存储的元素\n>       ListNode *next;  // 指向下一个节点的指针\n>       ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数\n>   };\n>   ```\n>\n> ——代码随想录\n\n\n\n### [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。\n\n定义虚拟头节点dummyHead，以解决第一个节点就是val值的问题。\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeElements(struct ListNode* head, int val) {\n    struct ListNode* dummyHead = malloc(sizeof(struct ListNode));\n    dummyHead->next = head;\n    struct ListNode* p = dummyHead;\n    while(p->next != NULL) {\n        if (p->next->val == val) {\n            p->next = p->next->next;\n        }\n        else {\n            p = p->next;\n        }\n    }\n    return dummyHead->next;\n    \n}\n```\n\n\n\n### [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)\n\n> 你可以选择使用单链表或者双链表，设计并实现自己的链表。\n>\n> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。\n>\n> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。\n>\n> 实现 `MyLinkedList` 类：\n>\n> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。\n> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。\n> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\n> - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。\n> - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。\n> - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。\n\n找准指向的元素。前一个还是后一个。另外需要分类分析头尾的情况。\n\n```c\ntypedef struct MyLinkedList{\n    int val;\n    struct MyLinkedList* next;\n} MyLinkedList;\n\n\nMyLinkedList* myLinkedListCreate() {\n    // 定义虚拟头节点\n    MyLinkedList* head = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    head->next = NULL;\n    return head;\n}\n\nint myLinkedListGet(MyLinkedList* obj, int index) {\n    MyLinkedList* p = obj->next; //定义工作指针\n    for (int i = 0; p != NULL; i++) {\n        if (i == index) {\n            return p->val;\n        }\n        else {\n            p = p->next;\n        }\n    }\n    return -1;\n}\n\nvoid myLinkedListAddAtHead(MyLinkedList* obj, int val) {\n    MyLinkedList* newHead = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    newHead->next = obj->next;\n    newHead->val = val;\n    obj->next = newHead;\n}\n\nvoid myLinkedListAddAtTail(MyLinkedList* obj, int val) {\n    MyLinkedList* p = obj->next; //定义工作指针\n    MyLinkedList* newTail = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    newTail->val = val;\n    newTail->next = NULL;\n    if (p != NULL) {\n        while(p->next != NULL) {\n            p = p->next;\n        }\n        p->next = newTail;\n    }\n    else {\n        obj->next = newTail;\n    }\n    \n}\n\nvoid myLinkedListAddAtIndex(MyLinkedList* obj, int index, int val) {\n    MyLinkedList* p = obj->next; //工作指针\n    if (index == 0) {\n        myLinkedListAddAtHead(obj, val);\n    }\n    MyLinkedList* newAdd = (MyLinkedList*)malloc(sizeof(MyLinkedList));\n    newAdd->val = val;\n    for(int i = 0; p != NULL; i++) {\n        if (i == index - 1) {\n            newAdd->next = p->next;\n            p->next = newAdd;\n            break;\n        }\n        else {\n            p = p->next;\n        }\n    }\n}\n\nvoid myLinkedListDeleteAtIndex(MyLinkedList* obj, int index) {\n    MyLinkedList* p = obj->next;\n    if (index == 0){\n        if (p != NULL) {\n            obj->next = p->next;\n        }\n    }\n    else {\n        for (int i = 0; p->next != NULL; i++) {\n            if (i == index - 1) {\n                p->next = p->next->next; \n                if (p->next == NULL) {\n                    break;\n                }\n                else {\n                    p = p->next;\n                }    \n            }\n            else {\n                p = p->next;\n            }\n        }\n    }\n}\n\nvoid myLinkedListFree(MyLinkedList* obj) {\n    while(obj != NULL) {\n        MyLinkedList* temp =  obj;\n        obj = obj->next;\n        free(temp);\n    }\n}\n\n/**\n * Your MyLinkedList struct will be instantiated and called as such:\n * MyLinkedList* obj = myLinkedListCreate();\n * int param_1 = myLinkedListGet(obj, index);\n \n * myLinkedListAddAtHead(obj, val);\n \n * myLinkedListAddAtTail(obj, val);\n \n * myLinkedListAddAtIndex(obj, index, val);\n \n * myLinkedListDeleteAtIndex(obj, index);\n \n * myLinkedListFree(obj);\n*/\n```\n\ncpp版本\n\n```cpp\nclass MyLinkedList {\npublic:\n    struct ListNode {\n        int val;\n        ListNode *next;\n        ListNode(int x) : val(x), next(NULL) {}\n    };\n    ListNode* _dummyHead;\n    int _size;\n\n    MyLinkedList() {\n        _dummyHead = new ListNode(0);\n        _size = 0;\n    }\n    \n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        ListNode *p = _dummyHead->next;\n        for (int i = 0; i < index; i++) {\n            p = p->next;\n        }\n        return p->val;\n    }\n    \n    void addAtHead(int val) {\n        ListNode* p = new ListNode(val);\n        p->next = _dummyHead->next;\n        _dummyHead->next = p;\n        _size++;\n    }\n    \n    void addAtTail(int val) {\n        ListNode *p = _dummyHead;\n        while (p->next != nullptr) {\n            p = p->next;\n        }\n        p->next = new ListNode(val);\n        _size ++;\n    }\n    \n    void addAtIndex(int index, int val) {\n        if (index > _size) {\n            return;\n        }\n        ListNode *p = _dummyHead;\n        for (int i = 0; i < index; i++) {\n            p = p->next;\n        }\n        ListNode *newNode = new ListNode(val);\n        newNode->next = p->next;\n        p->next = newNode;\n        _size++;\n    }\n    \n    void deleteAtIndex(int index) {\n        if (index < 0 || index >= _size) {\n            return;\n        }\n        ListNode *p = _dummyHead;\n        for (int i = 0; i < index; i++) {\n            p = p->next;\n        }\n        p->next = p->next->next;\n        _size--;\n    }\n};\n\n/**\n * Your MyLinkedList object will be instantiated and called as such:\n * MyLinkedList* obj = new MyLinkedList();\n * int param_1 = obj->get(index);\n * obj->addAtHead(val);\n * obj->addAtTail(val);\n * obj->addAtIndex(index,val);\n * obj->deleteAtIndex(index);\n */\n```\n\n\n\n### [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n【双指针】注意链表不带头节点。所以双指针的工作和带头结点的不同。\n\n![image-20240326200013905](/image-20240326200013905.png)\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* reverseList(struct ListNode* head) {\n    //head 不带头节点\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    struct ListNode *p = NULL;\n    struct ListNode *q = head;\n    while (q != NULL) {\n        struct ListNode *r = q->next;\n        q->next = p;\n        p = q;\n        q = r;\n    }\n    // head->next = NULL;\n    head = p;\n    return head;\n}\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) { \n        if (head == NULL || head->next == NULL) {\n            return head;\n        }\n        ListNode *p = NULL;\n        ListNode *q = head;\n        while (q) {\n            ListNode *temp;\n            temp = q->next;\n            q->next = p;\n            p = q;\n            q = temp;\n        }\n        return p;\n    }\n};\n```\n\n### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n> 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n>\n> ![image-20240326195630531](/image-20240326195630531.png)\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* swapPairs(struct ListNode* head) {\n    typedef struct ListNode ListNode;\n    ListNode *dummyHead = (ListNode*)malloc(sizeof(ListNode));\n    ListNode *p = (ListNode*)malloc(sizeof(ListNode)); // 定义头节点和工作指针\n    dummyHead->next = head;\n    p = dummyHead;\n    while(p->next != NULL && p->next->next != NULL) {\n        ListNode *temp = (ListNode*)malloc(sizeof(ListNode));\n        temp = p->next;\n        p->next = p->next->next;\n        temp->next = p->next->next;\n        p->next->next = temp;\n        p = p->next->next;\n    }\n    return dummyHead->next;\n}\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode *dummyHead = new ListNode(0, head);\n        if (dummyHead->next == nullptr || dummyHead->next->next == nullptr) {\n            return dummyHead->next;\n        }\n        ListNode *p = dummyHead;\n        ListNode *temp;\n        while (p->next != nullptr && p->next->next != nullptr) {\n            temp = p->next;\n            p->next = p->next->next;\n            temp->next = p->next->next;\n            p->next->next = temp;\n            p = p->next->next;\n        }\n        return dummyHead->next;\n    }\n};\n```\n\n\n\n### [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n#### 解法一——暴力解法，两次遍历\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    typedef struct ListNode ListNode;\n    ListNode *dummyNode = (ListNode*)malloc(sizeof(ListNode));\n    dummyNode->next = head;\n    ListNode *p = dummyNode;\n    int count = 0;\n    while (p->next != 0) {\n        count++;\n        p = p->next;\n    }\n    p = dummyNode;\n    for (int i = 0; i < count - n; i++) {\n        p = p->next;\n    }\n    p->next = p->next->next;\n    return dummyNode->next;\n}\n```\n\n#### 解法二——双指针，让快慢指针间隔n位\n\n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    typedef struct ListNode ListNode;\n    ListNode *dummyNode = (ListNode*)malloc(sizeof(ListNode));\n    dummyNode->next = head;\n    ListNode *fast = dummyNode;\n    ListNode *slow = dummyNode;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        fast = fast->next;\n    }\n    while(fast-> next != NULL) {\n        fast = fast->next;\n        slow = slow->next;\n    }\n    slow->next = slow->next->next;\n    return dummyNode->next;\n}\n```\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // 定义虚拟头节点，方便统一处理\n        ListNode *dummyHead = new ListNode(0, head);\n        ListNode* slow = dummyHead;\n        ListNode* fast = dummyHead;\n        for (int i = 0; i < n; i++) {\n            fast = fast->next;\n        }\n        while (fast->next != nullptr) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        slow->next = slow->next->next;\n        return dummyHead->next;\n    }\n};\n```\n\n\n\n### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n>\n> 图示两个链表在节点 `c1` 开始相交**：**\n>\n> [![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n>\n> 题目数据 **保证** 整个链式结构中不存在环。\n>\n> **注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n计算链表长度的差，移动到剩余相同长度，一个一个节点比较\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    typedef struct ListNode ListNode;\n\n    ListNode *p = headA;\n    ListNode *q = headB;\n\n    // 计算链表长度的差\n    int lenA = 0, lenB = 0;\n    int gap = 0;\n    while (p != NULL) {\n        lenA++;\n        p = p->next;\n    }\n    while (q != NULL) {\n        lenB++;\n        q = q->next;\n    }\n\n    // 移动到相同长度\n    p = headA;\n    q = headB;\n    if (lenA > lenB) {\n        gap = lenA - lenB;\n        while(gap != 0) {\n            gap--;\n            p = p->next;\n        }\n    }\n    else {\n        gap = lenB - lenA;\n        while(gap != 0) {\n            gap--;\n            q = q->next;\n        }\n    }\n    \n    // 一个一个比较\n    while (p != NULL && q != NULL){\n        if (p == q) {\n            return p;\n        }\n        else {\n            p = p->next;\n            q = q->next;\n        }\n    }\n    return NULL;\n\n}\n```\n\nC++\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int lengthA = 0; \n        int lengthB = 0;\n        ListNode* p = headA;\n        while(p != NULL) {\n            lengthA++;\n            p = p->next;\n        }\n        ListNode* q = headB;\n        while(q != NULL) {\n            lengthB++;\n            q = q->next;\n        }\n        p = headA;\n        q = headB;\n        if (lengthA > lengthB) {\n            for (int i = 0; i < lengthA - lengthB; i++) {\n                p = p->next;\n            }\n        }\n        else {\n            for (int i = 0; i < lengthB - lengthA; i++) {\n                q = q->next;\n            }\n        }\n        for (int i = 0; i < min(lengthB, lengthA); i++) {\n            if(p == q) {\n                return p;\n            }\n            else {\n                p = p->next;\n                q = q->next;\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n官方题解——双指针的思路\n\n两者长度分别为$m,n$，假设公共部分为后$c$，则$m=a+c$, $n=b+c$\n\n开始先指向自己，走完自己全程指向对方\n\n+ 两链表相交：\n  + 长度相等：两个指针会同时到达两个链表相交的节点\n  + 长度不等：走到第一个公共节点的距离是相同的，第一个走的是$a+c+b$，第二个走的是$b+c+a$\n+ 两个链表不相交\n  + 长度相等：同时到达两个链表自己的尾节点变成NULL\n  + 长度不等：两个指针都会遍历完两个链表（自己加对方），变成NULL\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p = headA;\n        ListNode *q = headB;\n\n        while (p != NULL && q != NULL) {\n            p = p->next;\n            q = q->next;\n        }\n        if (p == NULL) {\n            p = headB;\n            while (q != NULL) {\n                p = p->next;\n                q = q->next;\n            }\n            q = headA;\n            while (p != NULL && q != NULL) {\n                if(p == q) {\n                    return p;\n                }\n                p = p->next;\n                q = q->next;\n            }\n        }\n        else {\n            q = headA;\n            while (p != NULL) {\n                p = p->next;\n                q = q->next;\n            }\n            p = headB;\n            while (p != NULL && q != NULL) {\n                if(p == q) {\n                    return p;\n                }\n                p = p->next;\n                q = q->next;\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n\n\n### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n> 给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n\n![img](/20220925103433.png)\n\n慢指针每次走一步，快指针每次走两部\n\n相遇时\n\n+ slow： $x+y$\n\n+ fast：$x+y+n(y+z)$​ 比slow多走了n圈\n\n+ 重要的等式！！！\n  $$\n  2(x+y)=x+y+n(y+z)\n  $$\n  于是可以推导出$x=n(y+z)-y = (n-1)(y+z)+z$，至少多走了一圈，所以$n\\ge 1$合理.\n\n+ 所以x和z的关系就是差了整数圈的关系！\n\n+ 所以从头节点走到环形入口的距离等于整数圈+相遇节点到入口。\n\n  + 所以从相遇点、头节点出发的两个指针，每次走一步，相遇的位置一定是环形入口。\n  + 代码注意后续这么动的时候，slow和fast在不在变，会导致判断条件有问题！\n\n1. 为何慢指针第一圈走不完一定会和快指针相遇? 可以认为快指针和慢指针是相对运动的，假设慢指针的速度是 1节点/秒，快指针的速度是 2节点/秒，当以慢指针为参考系的话（即慢指针静止），快指针的移动速度就是 1节点/秒，所以肯定会相遇。\n2. 为什么在第一圈就会相遇呢？ 设环的长度为 L，当慢指针刚进入环时，慢指针需要走 L 步(即 L 秒)才能走完一圈，此时快指针距离慢指针的最大距离为 L-1，我们再次以慢指针为参考系，如上所说，快指针在按照1节点/秒的速度在追赶慢指针，所以肯定能在 L 秒内追赶到慢指针。\n\n\n```c\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     struct ListNode *next;\n * };\n */\nstruct ListNode *detectCycle(struct ListNode *head) {\n    typedef struct ListNode ListNode;\n    ListNode *slow = head, *fast = head;\n    while (fast != NULL && fast->next != NULL) {\n        // 先追及\n        slow = slow->next;\n        fast = fast->next->next;\n\n        // 后从头开始\n        if (slow == fast) {\n            ListNode *p = head;\n            ListNode *q = slow;\n            while (p != q) {\n                p = p->next;\n                q = q->next;\n            }\n            return p;\n        }\n    }\n    return NULL;\n}\n```\n\n---\n\n以下开始以C艹为主\n\n## 哈希表\n\n> 当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n>\n> - 数组\n> - set （集合）\n> - map (映射)\n>\n> 这里数组就没啥可说的了，我们来看一下set。\n>\n> 在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n>\n> | 集合                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |\n> | -------------------- | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |\n> | `std::set`           | 红黑树   | 有序     | 否               | 否           | $O(\\log n)$ | $O(\\log n)$ |\n> | `std::multiset`      | 红黑树   | 有序     | 是               | 否           | $O(\\log n)$ | $O(\\log n)$ |\n> | `std::unordered_set` | 哈希表   | 无序     | 否               | 否           | $O(1)$      | $O(1)$`     |\n>\n> `std::unordered_set`底层实现为哈希表，`std::set` 和`std::multiset` 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\n>\n> | 映射                 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率    | 增删效率    |\n> | -------------------- | -------- | -------- | ---------------- | ------------ | ----------- | ----------- |\n> | `std::map`           | 红黑树   | key有序  | key不可重复      | key不可修改  | $O(\\log n)$ | $O(\\log n)$ |\n> | `std::multimap`      | 红黑树   | key有序  | key可重复        | key不可修改  | $O(\\log n)$ | $O(\\log n)$ |\n> | `std::unordered_map` | 哈希表   | key无序  | key不可重复      | key不可修改  | $O(1)$      | $O(1)$      |\n>\n> `std::unordered_map` 底层实现为哈希表，`std::map` 和`std::multimap` 的底层实现是红黑树。同理，`std::map` 和`std::multimap` 的key也是有序的。\n>\n> + 当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n> + 再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n>\n> ——代码随想录\n\n### [242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n\n> 给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。\n>\n> **注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。\n\n把小写字母表看作哈希表。\n\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if (s.length() != t.length()) {\n            return 0;\n        }\n\n        vector <int> alphabetS(26);\n        vector <int> alphabetT(26);\n\n        for (int i = 0; i < s.length(); i++) {\n            alphabetS[s[i] - 'a'] += 1;\n            alphabetT[t[i] - 'a'] += 1;\n        }\n\n        if (alphabetS == alphabetT) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n\n    }\n};\n```\n\n或者通过是不是都是0来判断，减少空间需求。\n\n```c\nbool isAnagram(char* s, char* t) {\n\n    if (strlen(s) != strlen(t)) {\n        return 0;\n    }\n\n    int *alphabet = (int*)malloc(sizeof(int) * 26);\n    for (int i = 0; i < 26; i++) {\n        alphabet[i] = 0;\n    }\n\n    for (int i = 0; i < strlen(s); i++) {\n        alphabet[s[i] - 'a'] += 1;\n        alphabet[t[i] - 'a'] -= 1;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (alphabet[i] != 0){\n            return 0;\n        }\n    }\n    return 1;\n\n}\n```\n\n\n\n### [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)\n\n> 给定两个数组 `nums1` 和 `nums2` ，返回 它们的 交集 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。\n\n#### 解法一——建立数组hash表\n\n```cpp\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        vector <int> hash(1001);\n        unordered_set <int> output;\n\n        for (int num:nums1) {\n            hash[num] += 1;\n        }\n        for (int num:nums2) {\n            if (hash[num] != 0) {\n                output.insert(num);\n            }\n        }\n        \n        vector <int> output_vec;\n        output_vec.assign(output.begin(), output.end());\n        return output_vec;\n\n    }\n};\n```\n\n#### 解法二——用无序set做\n\n```cpp\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set <int> nums1_set(nums1.begin(), nums1.end());\n        unordered_set <int> output_set;\n\n        for (int num:nums2) {\n            if (nums1_set.find(num) != 0) {\n                output_set.insert(num);\n            }\n        }\n\n        return vector <int> (output_set.begin(), output_set.end());\n    }\n};\n```\n\n### [202. 快乐数](https://leetcode.cn/problems/happy-number/)\n\n> 编写一个算法来判断一个数 `n` 是不是快乐数。\n>\n> **「快乐数」** 定义为：\n>\n> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。\n> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。\n>\n> 如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。\n\n无限循环是重点！！！\n\n重点是可能会陷入无限循环。\n需要先判断在不在之前存储的集合里面，再将sum添加进集合里面。\n同时集合.find的判定是和end()比。\n\n```cpp\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        unordered_set <int> results;\n        int sum = n;\n        int mod = n;\n\n        while (results.find(sum) == results.end()) {\n            results.insert(sum);\n            mod = sum;\n            sum = 0;\n            // 下列循环求mod的各位平方和\n            while (mod != 0) {\n                sum += (mod % 10) * (mod % 10);\n                mod /= 10;\n            }\n            // cout << sum << \" \";\n        }\n        if (sum == 1) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n};\n```\n\n### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n>\n> 你可以按任意顺序返回答案。\n\n#### 解法一——暴力解法\n\n复杂度$\\mathcal O(n^2)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for(int i = 0; i < n; i++){\n            for(int j = i + 1; j < n; j++){\n                if( nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {};\n    }\n};\n```\n\n#### 解法二——利用哈希表的思路\n\n利用键值对，在之前保存的键值对中找有没有能够匹配的元素。注意**find的时候，是find的键值对的键**，而非值，返回的是键值对的结构体。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map <int,int> nums_map;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums_map.find(target - nums[i]) != nums_map.end()) {\n                return {nums_map.find(target - nums[i])->second, i};\n            }\n            nums_map[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n\n### [454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)\n\n> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：\n>\n> - `0 <= i, j, k, l < n`\n> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`\n\n首先是无序的，但是需要次数，所以需要通过`unordered_map`。\n\n分组的思想降低for循环的次数\n\nmap新增值不需要判断是否存在键。\n\n```cpp\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map <int, int> sumTwo;\n        int counts = 0;\n\n        for (int num1:nums1) {\n            for (int num2:nums2) {\n                sumTwo[num1 + num2] += 1;\n            }\n        }\n\n        for (int num3:nums3) {\n            for (int num4:nums4) {\n                if (sumTwo.find(- (num3 + num4)) != sumTwo.end()) {\n                    counts += sumTwo[- (num3 + num4)];\n                }\n            }\n        }\n\n        return counts;\n    }\n};\n```\n\n### [383. 赎金信](https://leetcode.cn/problems/ransom-note/)\n\n> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。\n>\n> 如果可以，返回 `true` ；否则返回 `false` 。\n>\n> `magazine` 中的每个字符只能在 `ransomNote` 中使用一次。\n\n小写字母建立hash表\n\n```cpp\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        int alphabet[26];\n        if (magazine.length() < ransomNote.length()) {\n            return 0;\n        }\n        for (int i = 0; i < magazine.length(); i++) {\n            alphabet[magazine[i] - 'a'] += 1;\n        }\n        for (int j = 0; j < ransomNote.length(); j++) {\n            alphabet[ransomNote[j] - 'a'] -= 1;\n            if (alphabet[ransomNote[j] - 'a'] < 0) {\n                return 0;\n            }\n        }\n        return 1;\n    }\n};\n```\n\n### [15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请\n>\n> 你返回所有和为 `0` 且不重复的三元组。\n>\n> **注意：**答案中不可以包含重复的三元组。\n\n去重很困难。考虑双指针法\n\n去重的位置非常重要！同时要考虑使用双指针而非哈希表。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector <vector <int>> output;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0) { // 最左边的元素大于0，那么不可能和为0\n                return output;\n            }\n            if (i > 0 && nums[i] == nums[i - 1]) { //第一个数，去重\n                continue;\n            }\n            // 双指针启动！\n            int left = i + 1;\n            int right = nums.size() - 1;\n            while (left < right) {\n                if (nums[i] + nums[left] + nums[right] < 0) {\n                    left++;\n                }\n                else if (nums[i] + nums[left] + nums[right] > 0) {\n                    right--;\n                }\n                else {\n                    output.push_back({nums[i], nums[left], nums[right]});\n                    while (left < right && nums[left] == nums[left + 1]) {\n                        left++; // 第二个数，去重，要求左右顺序不能错。如果这个数和后一个一样，那么会导致第二个数有重复，所以右移\n                    }\n                    while (left < right && nums[right] == nums[right - 1]) {\n                        right--;// 第三个数，去重\n                    }\n                    //找到答案，同时收缩\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [18. 四数之和](https://leetcode.cn/problems/4sum/)\n\n> 给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：\n>\n> - `0 <= a, b, c, d < n`\n> - `a`、`b`、`c` 和 `d` **互不相同**\n> - `nums[a] + nums[b] + nums[c] + nums[d] == target`\n>\n> 你可以按 **任意顺序** 返回答案 。\n\n不要判断`nums[k] > target` 就返回了，三数之和 可以通过 `nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是`[-4, -3, -2, -1]`，`target`是`-10`，不能因为`-4 > -10`而跳过。但是我们依旧可以去做剪枝，逻辑变成`nums[i] > target && (nums[i] >=0 || target >= 0)`就可以了。\n\n这边的重点是第二个数要求`j > i+1`而非`j>0`，不然数相等时候会往右缩。\n\n同时注意不加`(long)`可能会溢出。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        vector <vector <int>> output;\n        //先要从小到大排\n        sort(nums.begin(), nums.end());\n\n        for (int i = 0; i < nums.size(); i++) {\n            // if (nums[i] > target && nums[i] >= 0) {\n            //     break; //剪枝处理，类似之前的首元素大于0，那么必然不行\n            // }\n            if (i > 0 && nums[i] == nums[i-1]) {\n                continue;\n            }\n            for (int j = i + 1; j < nums.size(); j++) {\n                // if (nums[i] + nums[j] > target && nums[i] + nums[j] >= 0) {\n                //     break; //剪枝处理，类似之前的首元素大于0，那么必然不行\n                // }\n                if (j > i+1 && nums[j] == nums[j-1]) {  // 这边的重点是j > i+1而非j>0\n                    continue;\n                }\n                // 双指针\n                int left = j + 1;\n                int right = nums.size() - 1;\n                while(left < right) {\n                    if ((long) nums[i] + nums[j] + nums[left] + nums[right] < target) { //会溢出\n                        left++;\n                    }\n                    else if ((long) nums[i] + nums[j] + nums[left] + nums[right] > target) {\n                        right--;\n                    }\n                    else {\n                        output.push_back({nums[i], nums[j], nums[left], nums[right]});\n                        while (left < right && nums[left] == nums[left+1]) {\n                            left++;\n                        }\n                        while (left < right && nums[right] == nums[right-1]) {\n                            right--;\n                        }\n                        left++;\n                        right--;\n                    }\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [204. 计数质数](https://leetcode.cn/problems/count-primes/)\n\n> 给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。\n\n埃氏筛\n\n枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。\n\n我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。\n\n这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。\n\n当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。\n\n作者：力扣官方题解\n\n\n```cpp\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        vector<int> isPrime(n, 1);\n        int output = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                output++;\n                if ((long long)i * i < n) {\n                    for (int j = i * i ; j < n ; j += i) {\n                        isPrime[j] = 0;\n                    }\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n\n\n## 字符串\n\n### [344. 反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n>\n> 不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n注意right的其实位置是length-1\n\n```cpp\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            int temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n            left++;\n            right--;\n        }\n    }\n};\n```\n\n### [541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)\n\n> 给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。\n>\n> - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。\n> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。\n\n还是写的有点复杂了，可以把两个大于等于k的条件再精简一下\n\n```cpp\nclass Solution {\npublic:\n    string reverseStr(string s, int k) {\n        int loop = s.length() / (2 * k) + 1;\n        for (int i = 0; i < loop; i++) {\n            // 如果不是最后一个loop，则反转当前loop前k个\n            if (i != loop - 1) {  //和下面last_loop >= k合并\n                int left = 2 * i * k;\n                int right = 2 * i * k + (k - 1);\n                while (left < right) {\n                    swap(s[left], s[right]);\n                    left++;\n                    right--;\n                }\n            }\n            else {\n                int last_loop = s.length() % (2 * k);\n                int left = 2 * i * k;\n                int right;\n                if (last_loop < k) { //0的情况也没事，不会进入while循环。\n                    right = s.length() - 1;\n                } \n                else {  //和上面i != loop - 1合并\n                    right = 2 * i * k + (k - 1);\n                }\n                while (left < right) {\n                    swap(s[left], s[right]);\n                    left++;\n                    right--;\n                }\n            }\n        }\n        return s;\n    }\n};\n```\n\n### [54. 替换数字(kamacoder)](https://kamacoder.com/problempage.php?pid=1064)\n\n> **题目描述**\n>\n> 给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 `a1b2c3`，函数应该将其转换为 `anumberbnumbercnumber`。\n>\n> **输入描述**\n>\n> 输入一个字符串 s,s 仅包含小写字母和数字字符。\n>\n> **输出描述**\n>\n> 打印一个新的字符串，其中每个数字字符都被替换为了number\n\n从后往前替换字符，复杂度低，左边不用管。\n\n![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20231030173058.png)\n\n注意处理完之后要左移一下，且判断条件注意边界。\n\n```cpp\n# include <iostream> \n\nusing namespace std;\n\nint main() {\n    string s;\n    while (cin >> s) {\n        int countNum = 0;\n        int oldSize = s.length();\n        for (int i = 0; i < oldSize; i++) {\n            if (s[i] >= '0' && s[i] <= '9') {\n                countNum++;\n            }\n        }\n        // cout << countNum << endl;\n        s.resize(s.size() + 5 * countNum);\n        for (int left = oldSize - 1, right = s.size() - 1; left >= 0; left--){\n            if (s[left] < '0' || s[left] > '9') { // 不应该有等号\n                s[right] = s[left];\n                right--;\n            }\n            else {\n                s[right--] = 'r';\n                s[right--] = 'e';\n                s[right--] = 'b';\n                s[right--] = 'm';\n                s[right--] = 'u';\n                s[right--] = 'n'; // 注意先减还是后减去\n            }\n        }\n        cout << s << endl;\n    }\n    return 0;\n}\n```\n\n### [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)\n\n> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。\n>\n> **单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。\n>\n> 返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。\n>\n> **注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n\n![fig](/mutable2.png)\n\n反转整个字符串。\n同时操作反转单词和去除空格，要定义一个变量表示当前单词头，然后快慢指针删除空格. （代码随想录中分开处理。）\n\n```cpp\nclass Solution {\npublic:\n    void reverseString (string &s, int left, int right) {\n        while (left < right) {\n            swap(s[left++], s[right--]);\n        }\n    }\n    string reverseWords(string s) {\n        // 反转整个字符串\n        reverseString (s, 0, s.length() - 1);\n\n        // 同时操作反转单词和去除空格，要定义一个变量表示当前单词头，然后快慢指针删除空格.\n        // 慢指针指向单词尾部时，从单词头到慢指针反转。\n        // 处理完一个单词后，注意单词之间有空格\n        int wordHead = 0;\n        int slow = 0;\n        for (int fast = 0; fast < s.length(); fast++) {\n            /*三种情况（前两种可以合并）：\n            ① fast=0 且 s[fast] 不为空，要传给slow\n            ② fast!=0 且 s[fast] 不为空，要传给slow \n            （这样不好处理最后一个单词）③ fast!=0 且 s[fast] 为空，s[fast-1] 不为空，要传给slow，同时从wordHead到slow-1逆转，wordHead移动到空格后\n            ③ fast!=0 且 s[fast] 不为空，s[fast+1] 为空或者句子结尾，要传给slow后，同时从wordHead到slow逆转，slow补齐空格，wordHead移动到空格后\n            所以先处理情况三*/\n            if (s[fast] != ' ') {\n                s[slow] = s[fast];\n                if (s[fast+1] == ' ' || fast+1 >= s.length()) {\n                    reverseString(s, wordHead, slow);\n                    s[++slow] = ' ';\n                    wordHead = slow + 1;\n                }\n                slow++;\n            }\n        }\n        // 重置string长度，注意slow移向上一个单词的后一个格了\n        s.resize(slow-1);\n        return s;\n    }\n};\n```\n\n### [55. 右旋字符串 (kamacoder)](https://kamacoder.com/problempage.php?pid=1065)\n\n> **题目描述**\n>\n> 字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 \n>\n> 例如，对于输入字符串 \"abcdefg\" 和整数 2，函数应该将其转换为 \"fgabcde\"。\n>\n> **输入描述**\n>\n> 输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。\n>\n> **输出描述**\n>\n> 输出共一行，为进行了右旋转操作后的字符串。\n\n#### 解法一——直接字符串提取拼接\n\n```cpp\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int k;\n    string s;\n    \n    cin >> k;\n    cin >> s;\n    \n    int length = s.length();\n    \n    string s1 = s.substr(0, length - k);\n    string s2 = s.substr(length - k, k);\n    \n    cout << s2 << s1;\n    return 0;\n}\n```\n\n#### 解法二——“整体反转字符串”+“两个反转单词”\n\n在原本字符串中处理，变成“整体反转字符串”+“两个反转单词”的过程。\n\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n// void reverseString (string &s, int left, int right) {\n//     while (left < right) {\n//         swap (s[left++], s[right--]);\n//     }\n// }\n\nint main() {\n    int k;\n    string s;\n    \n    cin >> k;\n    cin >> s;\n    \n    // int length = s.length();\n    // reverseString(s, 0, length-1);\n    // reverseString(s, 0, k-1);\n    // reverseString(s, k, length-1);\n    \n    reverse(s.begin(), s.end()); //左闭右开\n    reverse(s.begin(), s.begin() + k);\n    reverse(s.begin() + k, s.end());\n    \n    \n    cout << s;\n    return 0;\n}\n\n```\n\n### [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n\n>  给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。\n\n1. 注意：如果单纯通过一层for循环判断时候，当flag倒了的时候，可能前面部分字符还是重复了needle的少部分，所以需要回溯。\n\n   \n\n#### 解法一—— 暴力解法也能解，取所有的n长字串即可。\n\n```cpp\nclass Solution {\npublic:\n    int strStr(string haystack, string needle) {\n        int flag = 0;\n        int j = 0;\n        for (int i = 0; i < haystack.length(); i++) {\n            if (needle[j] == haystack[i]) {\n                flag++;\n                j++;\n                if (j == needle.length()) {\n                    return i - j + 1;\n                }\n            }\n            else {\n                flag = 0;\n                i = i - j;\n                j = 0;\n            }\n        }\n        return -1;\n    }\n};\n```\n#### 解法二——KMP算法\n\n1. KMP的经典思想就是:**当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。**\n\n2. 前缀表\n\n   + 为什么需要？不想完全回溯。\n     ![image-20240329202856323](/image-20240329202856323.png)\n\n   + 当前位置既然不能完全满足匹配串，那么至多能匹配上多少？也就是说可以少回溯多少呢？也就知道子串（匹配串）需要回溯到什么位置——这由当前位置的上一个前缀表值来确定。\n\n     ![image-20240329202910993](/image-20240329202910993.png)\n\n2. next数组的定义\n\n   + 初始化（前缀末尾（即最长相等前后缀长度）`j`、后缀末尾`i`）\n\n   + 前后缀不相等（防止越界`j>0`且`s[i]!=s[j]`时，`j`要连续回溯到`next[j-1]`）\n\n   + 前后缀相等（`j`可以递增，同时后缀`i`指向位置的前缀表值为`j`）\n\n   + 请注意这里最后一个为什么是2：这是由于B的时候发现匹配不上了，那么`j=3`也就要回溯到`j=next[j-1]=next[2]=1`这个位置。这里需要注意为什么明明是后缀的问题，要用前缀来看呢？因为后缀和前缀相等，所以后缀要回溯的值等于前缀需要回溯到的值（好乱啊55555555）\n     ![image-20240329203055212](/image-20240329203055212.png)\n\n     ![image-20240329202935587](/image-20240329202935587.png)\n\n```cpp\nclass Solution {\npublic:\n    void getNext (int* next, string &s) {\n        int j = 0; //前缀末尾，即最长相等前后缀长度\n        next[0] = 0;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s[i] != s[j]) {\n                j = next[j-1];\n            }\n            if (s[i] == s[j]) {\n                j++;\n            }\n            next[i] = j;\n        }\n    }\n    int strStr(string haystack, string needle) {\n        if (needle.length() == 0) {\n            return 0;\n        }\n\n        int next[needle.length()];\n        getNext(next, needle); //获取前缀表\n\n        int j = 0; //指向匹配串\n        for (int i = 0; i < haystack.length(); i++) { //i指向文本串\n            while (j > 0 && haystack[i] != needle[j]){ //注意这里也要连续回溯\n                j = next[j - 1];\n            }\n            if(haystack[i] == needle[j]) {\n                j++;\n                if (j == needle.length()) {\n                    return i - j + 1;\n                }\n            }\n        }\n        return -1;        \n    }\n};\n```\n\n### [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)\n\n> 给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复多次构成。\n\n#### 解法一——移动匹配\n\n那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s\n\n![图二](https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png)\n——来自代码随想录\n\n代码也来自代码随想录代码如下：\n\n```cpp\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        string t = s + s;\n        t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾\n        if (t.find(s) != std::string::npos) return true; // r\n        return false;\n    }\n};\n```\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(1)\n\n不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。\n\n\n\n#### 解法二——优化的KMP算法\n\n（不是很能看懂最后一步）\n\n假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是`x`，所以`s`是由`n * x`组成。\n\n因为字符串s的最长相同前后缀的长度一定是不包含`s`本身，所以 最长相同前后缀长度必然是`m * x`，而且` n - m = 1`，（这里如果不懂，看上面的推理）\n\n所以如果 `nx % (n - m)x = 0`，就可以判定有重复出现的子字符串。\n\n最长相等前后缀的长度为：`next[len - 1] `\n\n数组长度为：len。\n\n如果`len % (len - next[len - 1] ) == 0` ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。\n\n**数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。**\n\n```cpp\nclass Solution {\npublic:\n    bool repeatedSubstringPattern(string s) {\n        int j = 0;\n        int next[s.length()];\n        next[0] = 0;\n        int maxLoop = 1;\n        for (int i = 1; i < s.length(); i++) {\n            while (j > 0 && s[j] != s[i]) {\n                j = next[j - 1];\n            }\n            if (s[j] == s[i]) {\n                j++;\n            }\n            next[i] = j;\n            if (next[i] > maxLoop) {\n                maxLoop = next[i];\n            }\n        }\n        for (int i = 0; i < s.length(); i++) {\n            cout << next[i] << ' ';\n        }\n        if(s.length() % (s.length() - maxLoop) == 0) {\n            return true;\n        }\n        else{\n            return false;\n        }\n        \n    }\n};\n```\n\n## 双指针\n\n+ 数组\n\n  + [移除元素](#[27. 移除元素](https://leetcode.cn/problems/remove-element/))：通过两个指针在一个for循环下完成两个for循环的工作。\n\n+ 字符串\n\n  + [反转字符串](#[344. 反转字符串](https://leetcode.cn/problems/reverse-string/))：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。时间复杂度是O(n)。\n  + [替换数字](#[54. 替换数字(kamacoder)](https://kamacoder.com/problempage.php?pid=1064))：首先扩充数组到每个空格替换成\"number\"之后的大小。然后双指针从后向前替换空格。\n  + [反转字符串中的单词](#[151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/))：两次反转，同时要去除冗余空格，注意erase操作也是O(n)的操作\n\n+ 链表\n\n  + [反转链表](#[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/))：只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。\n\n  + [删除链表的倒数第 N 个结点](#[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/))：快指针多走N个节点\n\n  + [相交链表](#[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/))：计算链表长度的差，移动到剩余相同长度，一个一个节点比较\n\n  + [环形链表II](#[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/))：\n\n    如何通过双指针判断是否有环，而且还要找到环的入口。\n\n    **使用快慢指针（双指针法），分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。**\n\n+ N数之和\n\n  + 使用了哈希法解决了两数之和，但是哈希法并不适用于三数之和！去重不好操作\n  + [三数之和](#[15. 三数之和](https://leetcode.cn/problems/3sum/))：①先排序；②双指针的移动原则；③通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。\n  + [四数之和](#[18. 四数之和](https://leetcode.cn/problems/4sum/))：在三数之和的基础上再套一层for循环，依然是使用双指针法。\n  + 对于三数之和使用双指针法就是将原本暴力$O(n^3)$的解法，降为$O(n^2)$的解法，四数之和的双指针解法就是将原本暴力$O(n^4)$的解法，降为$O(n^3)$的解法。\n\n## 栈、队列\n\n> **我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。**\n>\n> deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。\n>\n> **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**\n>\n> STL 队列不被归类为容器，而被归类为container adapter（ 容器适配器）\n>\n> 队列是先进先出的数据结构，不允许有遍历行为，stack和queue不提供迭代器\n>\n> ——代码随想录\n\n### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\n\n> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\n>\n> 实现 `MyQueue` 类：\n>\n> - `void push(int x)` 将元素 x 推到队列的末尾\n> - `int pop()` 从队列的开头移除并返回元素\n> - `int peek()` 返回队列开头的元素\n> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\n>\n> **说明：**\n>\n> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\n> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n第2种实现的效率**远高于**第1种实现。原因是：\n\n- 在第2种实现中，元素只会在 `queueIn` 和 `queueOut` 之间转移一次，不会反复移动。\n- 第1种实现的入队每次都要移动所有元素两次，这种重复操作极大降低了效率。\n\n#### 双栈——操作均集中在push\n\n注意pop只会去掉顶上的元素，不会把顶上元素值返回回来。\n\n![image-20240401104414302](/image-20240401104414302.png)\n\n```cpp\nclass MyQueue {\npublic:\n    stack <int> left;\n    stack <int> right;\n    MyQueue() {\n        /* 双栈操作，定义两个栈\n        进队列时，先把右栈所有元素pop出压入左栈，再把加入元素压入左栈栈顶；接着左栈依次出栈，右栈依次入栈；\n        出队即右栈出栈pop即可\n        是否为空即判断右栈是否为空 */\n    }\n    \n    void push(int x) {\n        while (right.size() != 0) {\n            left.push(right.top());\n            right.pop();\n        }\n        left.push(x);\n        while (left.size() != 0) {\n            right.push(left.top());\n            left.pop();\n        }\n    }\n    \n    int pop() {\n        int output = right.top();\n        right.pop();\n        return output;\n    }\n    \n    int peek() {\n        return right.top();\n    }\n    \n    bool empty() {\n        if (right.size() == 0) {\n            return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n#### 双栈的官方题解——输入栈、输出栈\n\n将一个栈当作输入栈，用于压入 push传入的数据；另一个栈当作输出栈，用于 pop和 peek操作。\n\n每次 pop或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\n其实，在这个代码逻辑中**即使 `queueOut` 中有数据，入队（`push`）操作依然是可以正常工作的**。你的疑问可能源于对双栈模拟队列的工作机制的理解，我们一起来梳理一下这个逻辑。\n\n**双栈模拟队列的核心逻辑**：\n\n- **`queueIn`**：用于存储新入队的元素（入栈操作）。\n- **`queueOut`**：用于实现出队操作（栈顶弹出，模拟队列的队首）。\n\n双栈实现队列的原理是：\n1. **入队时**，只把数据压入 `queueIn`。\n2. **出队时**：\n   - 只有在 `queueOut` 为空时，才把 `queueIn` 中所有元素倒入 `queueOut`。\n   - 这样 `queueOut` 中的栈顶元素就对应队列的队首元素（先进先出）。\n\n**为什么入队不会出错？**\n\n1. 每次 **入队（`push`）** 只会把新元素加入到 `queueIn` 中，而不会影响 `queueOut`。\n2. **出队（`pop`）** 时，只有当 `queueOut` 为空时，才会将 `queueIn` 的数据转移到 `queueOut`。\n   - 如果 `queueOut` 中已有元素，出队操作会直接弹出 `queueOut` 栈顶的元素，无需转移数据。\n\n所以，即便 `queueOut` 中已有数据，`push` 新元素只会影响 `queueIn`，不会破坏现有的队列顺序。\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> queueIn;\n    stack<int> queueOut;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n      queueIn.push(x);\n    }\n    \n    int pop() {\n      if (queueOut.empty()) {\n        while (!queueIn.empty()) {\n          int x = queueIn.top();\n          queueOut.push(x);\n          queueIn.pop();\n        }\n      }\n      int x = queueOut.top();\n      queueOut.pop();\n      return x;\n    }\n    \n    int peek() {\n      int x = this->pop();\n      queueOut.push(x);\n      return x;\n    }\n    \n    bool empty() {\n      if (queueIn.empty() && queueOut.empty()) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n};\n```\n\n### [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)\n\n> 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。\n>\n> 实现 `MyStack` 类：\n>\n> - `void push(int x)` 将元素 x 压入栈顶。\n> - `int pop()` 移除并返回栈顶元素。\n> - `int top()` 返回栈顶元素。\n> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。\n>\n>  \n>\n> **注意：**\n>\n> - 你只能使用队列的标准操作 —— 也就是 `push to back`、`peek/pop from front`、`size` 和 `is empty` 这些操作。\n> - 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n#### 两个队列\n\n——将pop出来的前面的元素存在另一个queue里面\n\n![fig1](https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif)\n\n——官方题解\n\n```cpp\nclass MyStack {\npublic:\n    queue <int> queue1;\n    queue <int> queue2;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        queue1.push(x);\n    }\n    \n    int pop() {\n        while (queue1.size() > 1) {\n            queue2.push(queue1.front());\n            queue1.pop();\n        }\n        int output = queue1.front();\n        queue1.pop();\n        swap(queue1, queue2);\n        return output;\n    }\n    \n    int top() {\n        return queue1.back();\n    }\n    \n    bool empty() {\n        if (queue1.size() == 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n```\n\n#### 一个队列\n\n——将前面pop出来的继续push回去即可\n\n```cpp\nclass MyStack {\npublic:\n    queue <int> queue1;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        queue1.push(x);\n    }\n    \n    int pop() {\n        int queueSize = queue1.size();\n        for (int i = 0; i < queueSize - 1; i++) {\n            queue1.push(queue1.front());\n            queue1.pop();\n        }\n        int output = queue1.front();\n        queue1.pop();\n        return output;\n    }\n    \n    int top() {\n        return queue1.back();\n    }\n    \n    bool empty() {\n        if (queue1.size() == 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n};\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack* obj = new MyStack();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->top();\n * bool param_4 = obj->empty();\n */\n```\n\n\n\n### [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)\n\n> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n>\n> 有效字符串需满足：\n>\n> 1. 左括号必须用相同类型的右括号闭合。\n> 2. 左括号必须以正确的顺序闭合。\n> 3. 每个右括号都有一个对应的相同类型的左括号。\n\n注意右括号的情况要判断一下栈是否为空。注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。\n\n```cpp\nclass Solution {\npublic:\n    bool isValid(string s) {\n        if (s.length() % 2 != 0) {\n            return false;\n        }\n        stack <char> bracks;\n        for (int i  = 0; i < s.length(); i++) {\n            if (s[i] == '(' || s[i] == '[' || s[i] == '{') {\n                bracks.push(s[i]);\n            }\n            else {\n                switch (s[i]) {\n                    case ')':\n                        if (!bracks.empty() && bracks.top() == '(') {\n                            bracks.pop();\n                            break;\n                        }\n                        else {\n                            return false;\n                        }\n                    case ']':\n                        if (!bracks.empty() && bracks.top() == '[') {\n                            bracks.pop();\n                            break;\n                        }\n                        else {\n                            return false;\n                        }\n                    case '}':\n                        if (!bracks.empty() && bracks.top() == '{') {\n                            bracks.pop();\n                            break;\n                        }\n                        else {\n                            return false;\n                        }\n                    default:\n                        return false;\n                }\n            }\n        }\n        if (bracks.size() == 0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n};\n```\n\n少写一点判断的话\n\n```cpp\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> S;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == '(' || s[i] == '{' || s[i] == '[') {\n                S.push(s[i]);\n            }\n            else if (!S.empty() && ((s[i] == ')' && S.top() == '(') || (s[i] == ']' && S.top() == '[') || (s[i] == '}' && S.top() == '{'))) {\n                S.pop();\n            }\n            else {\n                return false;\n            }\n        }\n        if (S.empty()) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n};\n```\n\n\n\n### [1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n\n> 给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。\n>\n> 在 S 上反复执行重复项删除操作，直到无法继续删除。\n>\n> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n\n**字符串拼接的代价**：\n\n- 在 C++ 中，字符串的拼接操作（`+=`）会动态调整内存。如果你每次都将字符插入到字符串的\n\n  最前面，会导致：\n\n  - 多次内存重新分配。\n  - 数据从旧位置到新位置的频繁拷贝。\n\n- 因此，第一种实现的时间复杂度实际上更高。\n\n**第二种实现的优化**：\n\n- 在第二种代码中，字符逐个添加到 `sNew` 的末尾（`+=` 操作），这种方式更符合字符串的内存模型，避免了频繁的拷贝。\n- 最后再调用 `reverse`，将整体反转，代价是**一次 O(n)** 的操作，比第一种实现中频繁的插入效率高得多。\n\n#### 解法一——stack\n\n注意size会变\n\n```cpp\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        stack <char> words;\n        for (int i = 0; i < s.length(); i++) {\n            if (!words.empty() && s[i] == words.top()) {\n                words.pop();\n            }\n            else {\n                words.push(s[i]);\n            }\n        }\n        string sNew;\n        int wordsSize = words.size(); //注意size会变\n        for (int j = 0; j < wordsSize; j++) {\n            sNew = words.top() + sNew; //在前面加上字母\n            words.pop();\n        }\n        return sNew;\n    }\n};\n```\n\n貌似每次在前面加字母会带来大量的时间消耗和内存消耗，所以下面那个循环可以改成这个。\n\n![image-20240401144455896](/image-20240401144455896.png)\n\n```cpp\n while (!words.empty()) {\n            sNew += words.top() ; //在前面加上字母\n            words.pop();\n        }\n        reverse(sNew.begin(), sNew.end());\n```\n\n#### 解法二——以字符串为栈\n\n进一步的以字符串为栈,也是比较快的，消耗内存也比较小。\n\n```cpp\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        string sNew;\n        for (int i = 0; i < s.length(); i++) {\n            if (!sNew.empty() && s[i] == sNew.back()) {\n                sNew.pop_back();\n            }\n            else {\n                sNew.push_back(s[i]);\n            }\n        }\n        return sNew;\n    }\n};\n```\n\n### [150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)\n\n> 给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。\n>\n> 请你计算该表达式。返回一个表示表达式值的整数。\n>\n> **注意：**\n>\n> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。\n> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n> - 两个整数之间的除法总是 **向零截断** 。\n> - 表达式中不含除零运算。\n> - 输入是一个根据逆波兰表示法表示的算术表达式。\n> - 答案及所有中间计算结果可以用 **32 位** 整数表示。\n\n用栈来解决\n\n```cpp\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack <int> nums;\n        int result;\n        for (string token:tokens) {\n            if (token == \"+\" ) {\n                result = nums.top();\n                nums.pop();\n                result = nums.top() + result;\n                nums.pop();\n                nums.push(result);\n            }\n            else if (token == \"-\") {\n                result = nums.top();\n                nums.pop();\n                result = nums.top() - result;\n                nums.pop();\n                nums.push(result);\n            }\n            else if (token == \"*\") {\n                result = nums.top();\n                nums.pop();\n                result = nums.top() * result;\n                nums.pop();\n                nums.push(result);\n            }\n            else if (token == \"/\") {\n                result = nums.top();\n                nums.pop();\n                result = nums.top() / result;\n                nums.pop();\n                nums.push(result);\n            }\n            else { // 数字\n                nums.push(stoi(token));\n            }\n        }\n        return nums.top();\n    }\n};\n```\n\n### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n\n> 给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n>\n> 返回 *滑动窗口中的最大值* 。\n>\n> **示例 1：**\n>\n> ```\n> 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n> 输出：[3,3,5,5,6,7]\n> 解释：\n> 滑动窗口的位置                最大值\n> ---------------               -----\n> [1  3  -1] -3  5  3  6  7       3\n>  1 [3  -1  -3] 5  3  6  7       3\n>  1  3 [-1  -3  5] 3  6  7       5\n>  1  3  -1 [-3  5  3] 6  7       5\n>  1  3  -1  -3 [5  3  6] 7       6\n>  1  3  -1  -3  5 [3  6  7]      7\n> ```\n\n单调队列问题\n\n**只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。**\n\n那么这个维护元素单调递减的队列就叫做**单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列**\n\n设计单调队列的时候，pop，和push操作要保持如下规则：\n\n1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\n2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止\n\n**在单调队列中，我们维护的是非严格单调序列**（即**非递增**或**非递减**），确保**重复值不会一次性全部被移除**。具体来说，每次只会移除队列中的一部分元素，而不会影响同一值的其他副本。同时每次pop时候只会pop比较最前面的元素，不会对重复值造成影响\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int numsSize = nums.size();\n        deque <int> window; //这个双向队列里面存的是索引，而非数字本身，防止有重复，被误pop（？）\n        vector <int> output;\n\n        for (int i = 0; i < numsSize; i++) {\n            // push操作①： 如果该值比之前的大，那么就pop掉之前的直到剩下比它大的,确保队列递减\n            while (!window.empty() && nums[i] > nums[window.back()]) {\n                window.pop_back();\n            }\n            window.push_back(i); //push操作②：此时队列中剩下的只有比它大的，且在队头 \n\n            // 将之前的序号pop\n            if (!window.empty() && window.front() < i - k + 1) {\n                window.pop_front();\n            }\n\n            // 取出当前窗口的最大值\n            if (i >= k - 1) {\n                output.push_back(nums[window.front()]);\n            } \n        }\n        return output;\n    }\n};\n\n```\n\n###　[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。\n\n#### 解法一——对map的值进行排序\n\n注意力扣不能直接用cmp，得包装一层结构体，同时要将map转化为vector组才能排序。\n\n```cpp\nclass Solution {\npublic:\n    struct cmp{\n        bool operator ()(pair<int,int> &x, pair<int,int> &y) {\n            return x.second > y.second;\n        }\n    };\n    \n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map <int, int> numsMap; //无序即可，后续要排序\n        vector <int> output(k);\n        for (int num:nums) {\n            numsMap[num] ++;\n        }\n        cmp cp;\n        vector <pair<int,int>> numsMap_vector(numsMap.begin(), numsMap.end());\n        sort(numsMap_vector.begin(), numsMap_vector.end(), cp);\n        int i = 0; // output序号\n        for (auto p = numsMap_vector.begin(); p < numsMap_vector.begin() + k; p++) {\n            output[i++] = p->first; //这一这里p是一个指针\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——优先级序列\n\n要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。建立一个小顶堆，然后遍历「出现次数数组」：\n\n- 如果堆的元素个数小于 *k*，就可以直接插入堆中。\n- 如果堆的元素个数等于 *k*，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 *k* 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。\n- **堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\n\n优先级队列的基本操作与普通队列类似，不同的是**每次获得队内的元素是优先级最高的元素（要从堆的顶部开始）**，因此**使用的是top()方法**，而不是front()方法。如下：\n\n1. **push() ：入队**。向队列添加一个元素，无返回值；\n2. **pop() ：将队列中优先级最高的元素出队**。将队列中优先级最高的元素删除（出队），无返回值；\n3. **top() ：获得队列优先级最高的元素**。此函数返回值为队列中优先级最高的元素，常与pop()函数一起，先通过top()获得队列中优先级最高的元素，然后将其从队列中删除；\n4. **size() ：获得队列大小**。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名。\n5. **empty() ：判断队列是否为空**。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false。\n\n——[C++——优先级队列（priority_queue）_c++优先队列-CSDN博客](https://blog.csdn.net/jay_zzs/article/details/106549621)\n\n```cpp\nclass Solution {\npublic:\n    struct cmp_greater{\n        bool operator ()(pair<int,int> &x, pair<int,int> &y) {\n            return x.second > y.second;\n        }\n    };\n    struct cmp_less{\n        bool operator ()(pair<int,int> &x, pair<int,int> &y) {\n            return x.second < y.second;\n        }\n    };\n    \n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map <int, int> numsMap;\n        vector <int> output;\n        for (int num:nums) {\n            numsMap[num] ++;\n        }\n        \n        // // 建立优先级序列（用小顶堆, 大于当前节点的要下沉，大小为k）\n        // priority_queue <pair<int,int>, vector<pair<int,int>>, cmp_greater> pri_que; \n        // // 扫描所有频率值\n        // for (auto p = numsMap.begin(); p != numsMap.end(); p++) {\n        //     pri_que.push(*p);\n        //     if (pri_que.size() > k) {\n        //         pri_que.pop();\n        //     }\n        // }\n\n        // 建立优先级序列（用大顶堆, 小于当前节点的要下沉，大小不限制）\n        priority_queue <pair<int,int>, vector<pair<int,int>>, cmp_less> pri_que; \n        // 扫描所有频率值\n        for (auto p = numsMap.begin(); p != numsMap.end(); p++) {\n            pri_que.push(*p);\n        }\n\n        // 可以按照任意顺序输出， 注意优先级序列也没有begin和end\n        for (int i = 0; i < k; i++) {\n            output.push_back(pri_que.top().first); // 取数值\n            pri_que.pop();\n        }\n\n        return output;\n    }\n};\n```\n\n## 二叉树\n\n> 二叉树的种类：\n>\n> + 满二叉树\n> + 完全二叉树\n> + 二叉搜索树（二叉排序树）：**二叉搜索树是一个有序树**，左子树（若非空）上所有结点的值均小于它的根结点的值，右子树（若非空）上所有结点的值均大于它的根结点的值，左右子树也分别为二叉排序树。\n> + 平衡二叉搜索树[AVL（Adelson-Velsky and Landis）树]：它是一棵空树或它的左右两个子树的高度（深度）差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n>   + **C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是$O(\\log n)$​\n>   + 红黑树就是一种二叉平衡搜索树\n> + 辨析\n>   1. 平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？——是的，是二叉搜索树和平衡二叉树的结合。\n>   2. 平衡二叉树与完全二叉树的区别在于底层节点的位置？——是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。\n>   3. 堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？——堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 **但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树**。\n>\n> 二叉树的遍历：\n>\n> - 深度优先遍历\n>   - 前序遍历DLR（递归法，迭代法）\n>   - 中序遍历LDR（递归法，迭代法）\n>   - 后序遍历LRD（递归法，迭代法）\n> - 广度优先遍历\n>   - 层次遍历（迭代法）\n>\n> 二叉树的定义：\n>\n> + C++：\n>\n>   ```cpp\n>   struct TreeNode {\n>       int val;\n>       TreeNode *left;\n>       TreeNode *right;\n>       TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n>   };\n>   ```\n>\n> + C：——《数据结构与算法/软件技术基础》周大为版\n>   ```c\n>   typedef struct node {\n>       int data;\n>       struct node *lchild, *rchild;\n>   } bitree;\n>   bitree *root; //root指向根节点指针\n>   ```\n>\n> \n>\n> <img src=\"/20210219190809451.png\" alt=\"二叉树大纲\" style=\"zoom:50%;\" />\n>\n> ——代码随想录\n\n### 二叉树的深度优先DFS遍历（[144前序](https://leetcode.cn/problems/binary-tree-preorder-traversal/)/[145后序](https://leetcode.cn/problems/binary-tree-postorder-traversal/)/[94中序](https://leetcode.cn/problems/binary-tree-inorder-traversal/)）\n\n- [144.二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n- [145.二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n- [94.二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n\n#### 方法一——递归\n\n1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n前序\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void preorder (TreeNode *p, vector <int> &output) {\n        if (p != NULL) {\n            output.push_back(p->val);\n            preorder(p->left, output);\n            preorder(p->right, output);\n        }\n    }\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector <int> output;\n        preorder(root, output);\n        return output;\n    }\n};\n```\n\n中序\n\n```cpp\nclass Solution {\npublic:\n    void inorder (TreeNode *p, vector <int> &output) {\n        if (p != NULL){\n            inorder(p->left, output);\n            output.push_back(p->val);\n            inorder(p->right, output);\n        }\n    }\n\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector <int> output;\n        inorder(root, output);\n        return output;\n    }\n};\n```\n\n后序\n\n```cpp\nclass Solution {\npublic:\n    void postorder(TreeNode *p, vector<int> &output) {\n        if (p != NULL) {\n            postorder(p->left, output);\n            postorder(p->right, output);\n            output.push_back(p->val);\n        }\n    }\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector <int> output;\n        postorder(root, output);\n        return output;\n    }\n};\n```\n\n\n\n#### 方法二——非递归迭代\n\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。\n\n**因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！**\n\n前序——先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子\n\n<img src=\"/二叉树前序遍历（迭代法）.gif\" alt=\"二叉树前序遍历（迭代法）\" style=\"zoom:50%;\" />\n\n```cpp\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector <int> output;\n        stack <TreeNode*> S;\n        if (root == NULL) {\n            return output;\n        }\n        S.push(root); // 放入根节点\n        while (!S.empty()) {\n            TreeNode *p = S.top();\n            output.push_back(p->val); //根的值\n            S.pop();\n            if (p->right != NULL) { //先压入右子树, 先入栈后出\n                S.push(p->right);\n            }\n            if (p->left != NULL) { //后压入左子树\n                S.push(p->left);\n            } \n        }\n        return output;\n    }\n};\n```\n\n中序——在遍历左子树之前先把根节点入栈；当左子树遍历完成，根节点出栈，遍历右子树。**借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素**，\n\n```cpp\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector <int> output;\n        stack <TreeNode*> S;\n        TreeNode *p = root;\n        while (p != NULL || !S.empty()) { // 第一个条件是为了第一次能够满足，以能够先押入根节点\n            if (p != NULL) { // 指针访问到左边的最底层的\n                S.push(p);\n                p = p->left; // 左子树\n            }\n            else { // p为空，那么栈里面的就是他的祖先节点（如果目前是右子树的话甚至不一定是父节点），\n                p = S.top();\n                S.pop();\n                output.push_back(p->val); // 根节点\n                p = p->right; // 右子树\n            }\n        }\n        return output;\n    }\n};\n```\n\n后序\n$$\n\\text{DLR（先序）} \\xrightarrow{\\text{调整左右顺序}}\\text{DRL（逆先序）}\\xrightarrow{\\text{reverse}}\\text{LRD（后序）}\n$$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> postorderTraversal(TreeNode* root) {\n        vector <int> output;\n        stack <TreeNode*> S;\n        if (root == NULL) {\n            return output;\n        }\n        S.push(root);\n        while (!S.empty()) {\n            TreeNode *p = S.top();\n            S.pop();\n            output.push_back(p->val); // 压入根节点\n            if (p->left) {\n                S.push(p->left); //压入左节点，后出\n            }\n            if (p->right) {\n                S.push(p->right); //压入右节点，先出\n            }\n        }\n        reverse(output.begin(), output.end());\n        return output;\n    }\n};\n```\n\n#### 方法三——[二叉树的统一迭代法](https://programmercarl.com/二叉树的统一迭代法.html#思路)\n\n将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。\n\n如何标记呢，**就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。** 这种方法也可以叫做标记法。\n\n\n\n### 二叉树的层序（广度优先）BFS遍历（[102](https://leetcode.cn/problems/binary-tree-level-order-traversal/)/[107](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)/[199](https://leetcode.cn/problems/binary-tree-right-side-view/)/[637](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)/[429](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)/[515](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)/[116](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)/[117](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)）\n\n#### [102.二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n\n> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。\n\n基本思想：在上层先被访问的节点，他的下层孩子在该层也会被先访问到。因此使用**队列**，当一个元素出队，他的孩子将会进入队列。\n\n力扣的题目返回的是二维数组，需要对层也包裹一层，所以需要定义`qSize`来确定每层的大小，将每层的遍历结果输出到`output`中。\n\n##### 解法一——非递归迭代\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector <vector<int>> output;\n        if (root == NULL) {\n            return output;\n        }\n        queue <TreeNode*> Q;\n        Q.push(root);\n        while (!Q.empty()) {\n            int qSize = Q.size(); // 为了返回二维数组，需要知道每层有多少个\n            vector <int> outputLayer;\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front(); \n                outputLayer.push_back(p->val); //根节点出队\n                Q.pop();\n                if (p->left) {\n                    Q.push(p->left); //push左孩子入队\n                }\n                if (p->right) {\n                    Q.push(p->right); //push右孩子入队\n                }\n            }\n            output.push_back(outputLayer);\n        }\n        return output;\n    }\n};\n```\n\n##### 解法二——递归\n\n```cpp\nclass Solution {\npublic:\n    void levelorderTraversal (TreeNode *p, vector<vector<int>> &output, int depth) {\n        if (p == NULL) {\n            return ; //空指针返回父节点。为什么不把判定条件放在访问孩子前呢？因为无法判断是否为空树\n        }\n        if (output.size() == depth) {\n            output.push_back(vector<int>()); //当前层还没有加入过，创建对应层的数组\n        }\n        output[depth].push_back(p->val);\n        // 访问孩子，在孩子对应层的vector尾部加入\n        levelorderTraversal(p->left, output, depth+1);\n        levelorderTraversal(p->right, output, depth+1);\n    }\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector <vector<int>> output;\n        int depth = 0;\n        levelorderTraversal(root, output, depth);\n        return output;\n    }\n};\n```\n\n\n\n#### [107.二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n\n> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n\n对102的正向层次遍历reverse。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        vector<vector<int>> output;\n        queue <TreeNode*> Q;\n        if (root == NULL) {\n            return output;\n        }\n        Q.push(root);\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            vector <int> outputLayer;\n            for (int i = 0; i < qSize; i++) {\n                outputLayer.push_back(Q.front()->val);\n                if (Q.front()->left) {\n                    Q.push(Q.front()->left);\n                }\n                if (Q.front()->right) {\n                    Q.push(Q.front()->right);\n                }\n                Q.pop();\n            }\n            output.push_back(outputLayer);\n        }\n        reverse(output.begin(),output.end());\n        return output;\n    }\n};\n```\n\n\n\n#### [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)\n\n> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n\n每层层次遍历的最后一个元素。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector <int> output;\n        queue <TreeNode*> Q;\n        if (root == NULL) {\n            return output;\n        }\n        Q.push(root);\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++) {\n                if (i == qSize - 1) {// 每层的最后一个元素需要保存值\n                    output.push_back(Q.front()->val);\n                }\n                if (Q.front()->left) {\n                    Q.push(Q.front()->left);\n                }\n                if (Q.front()->right) {\n                    Q.push(Q.front()->right);\n                }\n                Q.pop();\n            }\n        }\n        return output;\n    }\n};\n```\n\n\n\n#### [637.二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)\n\n> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 $10^{-5}$以内的答案可以被接受。\n\n注意与答案相差$10^{-5}$以内的答案，所以要用double了。\n\n```cpp\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        vector<double> output;\n        queue <TreeNode*> Q;\n        if (root == NULL) {\n            return output;\n        }\n        Q.push(root);\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            double sumLayer = 0.0;\n            for (int i = 0; i < qSize; i++) {\n                sumLayer += Q.front()->val;\n                if (Q.front()->left) {\n                    Q.push(Q.front()->left);\n                }\n                if (Q.front()->right) {\n                    Q.push(Q.front()->right);\n                }\n                Q.pop();\n            }\n            output.push_back(sumLayer/qSize);\n        }\n        return output;\n    }\n};\n```\n\n\n\n#### [429.N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n\n> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。\n>\n> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n\n\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(Node* root) {\n        vector <vector<int>> output;\n        queue <Node*> Q;\n        if(root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            vector <int> outputLayer;\n            for (int i = 0; i < qSize; i++) {\n                Node* p = Q.front();\n                outputLayer.push_back(p->val);\n                for (int j = 0; j < p->children.size(); j++) {\n                    if (p->children[j] != NULL) {\n                        Q.push(p->children[j]);\n                    }\n                }\n                Q.pop();\n            }\n            output.push_back(outputLayer);\n        }\n        return output;\n    }\n};\n```\n\n\n\n#### [515.在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)\n\n> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。\n\n注意可能有负数\n\n```cpp\nclass Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        vector<int> output;\n        queue <TreeNode*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size(); \n            int maxLayer = INT_MIN; //注意有负数\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front(); \n                if (p->val > maxLayer) {\n                    maxLayer = p->val;\n                }\n                Q.pop();\n                if (p->left) {\n                    Q.push(p->left); //push左孩子入队\n                }\n                if (p->right) {\n                    Q.push(p->right); //push右孩子入队\n                }\n            }\n            output.push_back(maxLayer);\n        }\n        return output;\n    }\n};\n```\n\n\n\n\n\n#### [116.填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n\n> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\n>\n> ```\n> struct Node {\n>   int val;\n>   Node *left;\n>   Node *right;\n>   Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL`。\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        queue <Node*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++) {\n                Node *p = Q.front();\n                Q.pop();\n                if (i != qSize - 1) {\n                    p->next = Q.front();\n                }\n                if (p->left) {\n                    Q.push(p->left);\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                }\n            }\n        }\n        return root;\n    }\n};\n```\n\n\n\n#### [117.填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)\n\n> 给定一个二叉树：\n>\n> ```\n> struct Node {\n>   int val;\n>   Node *left;\n>   Node *right;\n>   Node *next;\n> }\n> ```\n>\n> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。\n>\n> 初始状态下，所有 next 指针都被设置为 `NULL` 。\n\n代码同116\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* next;\n\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\n\n    Node(int _val, Node* _left, Node* _right, Node* _next)\n        : val(_val), left(_left), right(_right), next(_next) {}\n};\n*/\n\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        queue <Node*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++) {\n                Node *p = Q.front();\n                Q.pop();\n                if (i != qSize - 1) {\n                    p->next = Q.front();\n                }\n                if (p->left) {\n                    Q.push(p->left);\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                }\n            }\n        }\n        return root;\n    }\n};\n```\n\n另见\n\n+ [104.二叉树的最大深度](#[104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/))\n+ [111.二叉树的最小深度](#[111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/))\n\n### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n\n> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。\n\n#### 解法一——递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        TreeNode* temp;\n        if (root != NULL) {\n            temp = root->left;\n            root->left = root->right;\n            root->right = temp;\n            invertTree(root->left);\n            invertTree(root->right);\n        }\n        return root;\n    }\n};\n```\n\n#### 解法二——迭代（深度优先）\n\nDLR\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == NULL) {\n            return root;\n        }\n        stack <TreeNode*> S;\n        S.push(root);\n        while (!S.empty()) {\n            TreeNode *p = S.top();\n            S.pop();\n            swap(p->left, p->right); //就这一步不一样\n            if (p->left) {\n                S.push(p->left);\n            }\n            if (p->right) {\n                S.push(p->right);\n            }\n        }\n        return root;\n    }\n};\n```\n\n#### 解法三——迭代（广度优先）\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        queue <TreeNode*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front();\n                Q.pop();\n                swap(p->left, p->right); //就这一步不一样\n                if (p->left) {\n                    Q.push(p->left);\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                }\n            }\n        }\n        return root;\n    }\n};\n```\n\n### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n\n> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。\n\n把NULL存进去的层序遍历。，遍历每一层时候，前半段用stack存进去，后半段pop对比。一个很垃圾的逻辑，一定程度上`NULL==0`，所以这里使用了非常丑陋的`76777777`来表示这个位置是NULL。\n\n```cpp\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        bool flagSymmetric = true;\n        int depth = 0;\n        bool flagNULL = false; // 判断下层是否全空\n        queue <TreeNode*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while(!Q.empty() && flagSymmetric && !flagNULL) {\n            int qSize = Q.size();\n            stack <int> S;\n            flagNULL = true; // 判断下层是否全空\n            // cout << qSize << \" \";\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (i < qSize / 2 || depth == 0) { // 第二个条件为了第一层，防止没有东西可pop\n                    if (p == NULL) {\n                        S.push(76777777);\n                    }\n                    else {\n                        S.push(p->val);\n                    }\n                }\n                else if (p == NULL) {\n                    if (S.top() != 76777777) {\n                        flagSymmetric = false;\n                        break;\n                    }\n                    S.pop();\n                }\n                else if (S.top() != p->val) { // 大于一半，且top和目前的val不等，那么不对称\n                    flagSymmetric = false;\n                    break;\n                }\n                else { //大于一半，且目前还对称\n                    S.pop();\n                }\n                // 将孩子加入队列，由于要对称，不需要考虑NULL的情况\n                if (p != NULL) {\n                    Q.push(p->left);\n                    Q.push(p->right);\n                    if (p->left || p->right){ //只要有一个不为0，下一层就不会全空\n                        flagNULL = false;\n                    }\n                }\n            }\n            depth++;\n        }\n        return flagSymmetric;\n    }\n};\n```\n\n\n\n#### 解法一——递归法\n\n总体思路就是左子树的左边要和右子树的右边相等\n\n```cpp\nclass Solution {\npublic:\n    bool checkSymmetric(TreeNode *p, TreeNode *q) {\n        if (!p && !q) { // 都空\n            return true;\n        }\n        else if (!p || !q) { //有一个空\n            return false;\n        }\n        else if (p->val != q->val) { // 非空且不等\n            return false;\n        }\n        // 左子树的左和右子树的右 && 左子树的右和右子树的左\n        return checkSymmetric(p->left, q->right) && checkSymmetric(p->right, q->left) ;\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        return checkSymmetric(root->left, root->right);\n    }\n};\n```\n\n#### 解法二——迭代法\n\n```cpp\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        queue <TreeNode*> Q;\n        Q.push(root->left);\n        Q.push(root->right);\n        while (!Q.empty()) {\n            TreeNode *p = Q.front(); // 左子树\n            Q.pop();\n            TreeNode *q = Q.front(); // 右子树\n            Q.pop();\n            if (p == NULL && q == NULL) { //都空\n                continue;\n            }\n            else if (p == NULL || q == NULL)  { //有一个空\n                return false;\n            }\n            else if (p->val != q->val) {\n                return false;\n            }\n            Q.push(p->left); //左子树左\n            Q.push(q->right); //右子树右\n            Q.push(p->right); //左子树右\n            Q.push(q->left); //右子树左\n        }\n        return true;\n    }\n};\n```\n\n这两道题目基本和本题是一样的，只要稍加修改就可以AC。\n\n#### [100.相同的树](https://leetcode.cn/problems/same-tree/)\n\n> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。\n>\n> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) {\n            return true;\n        }\n        else if (!p || !q) {\n            return false;\n        }\n        else if (p->val != q->val) {\n            return false;\n        }\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n\n    }\n};\n```\n\n#### [572.另一个树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)\n\n> 给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> 二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。\n\n先进行层次遍历，遍历到相同的节点值时候，开始比较是否是同一棵树\n\n```cpp\nclass Solution {\npublic:\n    bool isSametree (TreeNode *p, TreeNode *q) {\n        if (!p && !q) {\n            return true;\n        }\n        else if (!p || !q || p->val != q->val){\n            return false;\n        }\n        return isSametree(p->left, q->left) && isSametree(p->right, q->right);\n    }\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        // 先进行层次遍历，遍历到相同的节点值时候，开始比较是否是同一棵树\n        queue <TreeNode*> Q;\n        bool flagSubtree = false;\n        if (root && subRoot) {\n            Q.push(root);\n        }\n        while (!Q.empty() && !flagSubtree) {\n            TreeNode *p = Q.front();\n            Q.pop();\n            if (p->val == subRoot->val) {\n                flagSubtree = isSametree(p, subRoot);\n            }\n            // cout << p->val << \" \";\n            if (p->left) {\n                Q.push(p->left);\n            }\n            if (p->right) {\n                Q.push(p->right);\n            }\n        }\n        return flagSubtree;\n    }\n};\n```\n\n三种官方题解：\n\n+ 方法一：深度优先搜索暴力匹配\n+ 方法二：深度优先搜索序列上做串匹配\n+ 方法三：树哈希\n\n\n\n### [104.二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n\n> 给定一个二叉树 `root` ，返回其最大深度。\n>\n> 二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。\n\n\n\n#### 递归求解——深度优先遍历\n\n时间复杂度：$O(n)$，其中$n$为二叉树节点的个数。每个节点在递归中只被遍历一次。\n\n空间复杂度：$O(\\text{height})$，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n——力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // 如果根节点为空，则深度为0\n        if (root == NULL) {\n            return 0;\n        }\n\n        // 递归计算左右子树的深度\n        int leftDepth = maxDepth(root->left);\n        int rightDepth = maxDepth(root->right);\n\n        // 返回左右子树深度的最大值加上根节点本身的深度1\n        return max(leftDepth, rightDepth) + 1;\n    }\n};\n```\n\n#### 非递归迭代——广度优先遍历\n\n- 时间复杂度：$O(n)$，其中 *n* 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。\n- 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到$O(n)$​。\n\n——力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        queue <TreeNode*> Q;\n        int depth = 0;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            depth++;\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (p->left) {\n                    Q.push(p->left);\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                }\n            }\n        }\n        return depth;\n    }\n};\n```\n\n#### [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\n\n> 给定一个 N 叉树，找到其最大深度。\n>\n> 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\n>\n> N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n\n##### 递归\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        int depth = 0;\n        for (int i = 0; i < root->children.size(); i++) {\n            depth = max(depth, maxDepth(root->children[i]));\n        }\n        return depth + 1;\n    }\n};\n```\n\n##### 迭代\n\n```cpp\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        queue <Node*> Q;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        int depth = 0;\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            depth++;\n            for (int i = 0; i < qSize; i++){\n                Node* p = Q.front() ;\n                Q.pop();\n                for (int j = 0; j < p->children.size(); j++) {\n                    if (p->children[j]) {\n                        Q.push(p->children[j]);\n                    }\n                }\n            }            \n        }\n        return depth;\n    }\n};\n```\n\n\n\n### [111.二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n> 给定一个二叉树，找出其最小深度。\n>\n> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n>\n> **说明：**叶子节点是指没有子节点的节点。\n\n注意要考虑一条路到底的情况，即存在单边树的情况。左右孩子都为空的节点才是叶子节点！\n\n<img src=\"/image-20240402191845973.png\" alt=\"image-20240402191845973\" style=\"zoom: 80%;\" />\n\n\n\n#### 非递归迭代——广度优先遍历\n\n注意判断左右为空的时候是“且”，而非“或” **只有当左右孩子都为空的时候，才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点**\n\n时间复杂度：$O(N)$，其中 $N$ 是树的节点数。对每个节点访问一次。\n\n空间复杂度：$O(N)$，其中 $N$ 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。\n\n——力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        queue <TreeNode*> Q;\n        int depth = 0;\n        bool flag = true;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty() && flag) {\n            int qSize = Q.size();\n            depth++;\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (p->left == NULL && p->right == NULL) { //注意这里是且而非或\n                    flag = false; \n                    break;\n                }\n                if (p->left != NULL) {\n                    Q.push(p->left);\n                    if (p->right != NULL) {\n                        Q.push(p->right);\n                    }\n                }\n                else {\n                    Q.push(p->right); // flag为真时，left为空，right必然不为空，不为真时Q无意义\n                }\n            }\n        }\n        return depth;\n    }\n};\n```\n\n#### 递归——深度优先遍历\n\n必须要考虑单边树不存在的问题——需要分别考虑根节点左右孩子\n\n时间复杂度：$O(N)$，其中$N$是树的节点数。对每个节点访问一次。\n\n空间复杂度：$O(H)$，其中 $H$ 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为$O(N)$。平均情况下树的高度与节点数的对数正相关，空间复杂度为 $O(\\log N)$。\n\n——力扣官方题解\n\n遍历的顺序为后序（左右中）\n\n```cpp\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        // 必须要考虑单边树不存在的问题——需要分别考虑根节点左右孩子\n        else if (root->left == NULL) {\n            return minDepth(root->right) + 1;\n        }\n        else if (root->right == NULL) {\n            return minDepth(root->left) + 1;\n        }\n        return min(minDepth(root->left),minDepth(root->right)) + 1;\n    }\n};\n```\n\n### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)\n\n> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。\n>\n> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。\n\n#### 解法一——层次遍历\n\n```cpp\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        queue <TreeNode*> Q;\n        bool flagEnd = false;\n        int nums = 0;\n        if (root != NULL) {\n            Q.push(root);\n            nums++;\n        }\n        while (!Q.empty() && !flagEnd) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++) {\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (p->left) {\n                    Q.push(p->left);\n                    nums++;\n                }\n                else {\n                    flagEnd = true;\n                    break;\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                    nums++;\n                }\n                else {\n                    flagEnd = true;\n                    break;\n                }\n            }\n        }\n        return nums;\n    }\n};\n```\n\n\n\n\n\n#### 解法二——完全二叉树+二分法\n\n这个思路有个问题，二分法的判断标准是大了，小了，这里的判断是是否为NULL。\n\n通过每一次二分查找可以从上到下确定一层是往左走还是往右走。for循环包含depth次，每一次当前层指向right，下面的层都指向left，如果有值，那么该层应该指向right，为NULL则该层指向left，在进行下一层。当指向right的时候得注意nums要增加多少，**我感觉我现在就在凑**。\n\n```cpp\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        int depth = 0;\n        if (root == NULL) {\n            return 0;\n        }\n        // 先找出二叉树的最大深度\n        TreeNode *p = root;\n        while(p != NULL) {\n            p = p->left;\n            depth++;\n        }\n        vector <bool> direction(depth); //每一次指向的方向，右为0，左为1。\n        int nums = pow(2, depth - 1) - 1;//前(depth-1)层\n        // 二分查找最后一层的最后一个顶点\n        for (int i = 0; i < depth - 1; i++) { //depth次才能判断每次向左向右\n            TreeNode *p = root;\n            for (int j = 0; j < i; j++) { // 前i层已经确定方向\n                if (direction[j] == 1) {\n                    p = p->left;\n                }\n                else {\n                    p = p->right;\n                }\n            }\n            p = p->right;\n            for (int k = i + 1; k < depth - 1; k++) { //后面的层往左\n                p = p->left;\n            }\n            if (p == NULL) { //为NULL，该层指向left\n                direction[i] = 1;\n                // cout <<  \" NULL \";\n            }\n            else { //指向right\n                nums += pow(2, depth - i - 2);\n                // cout << p->val << \" \";\n            }\n        }\n        // cout << endl;\n        // for (int i = 0 ;i < depth-1; i++) {\n        //     cout << direction[i] << \" \";\n        // }\n        return nums + 1;\n    }\n};\n```\n\n原来官方题解也是这个办法啊，一定分析的比我好。。。\n\n具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数 kkk，如果第 kkk 个节点存在，则节点个数一定大于或等于 kkk，如果第 kkk 个节点不存在，则节点个数一定小于 kkk，由此可以将查找的范围缩小一半，直到得到节点个数。\n\n如何判断第 kkk 个节点是否存在呢？如果第 kkk 个节点位于第 hhh 层，则 kkk 的二进制表示包含 h+1h+1h+1 位，其中最高位是 111，其余各位从高到低表示从根节点到第 kkk 个节点的路径，000 表示移动到左子节点，111 表示移动到右子节点。通过位运算得到第 kkk 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 kkk 个节点是否存在。\n\n——力扣官方题解\n\n![fig1](https://assets.leetcode-cn.com/solution-static/222/1.png)\n\n#### 完全二叉树的性质\n\n完全二叉树总能拆分成许多的满二叉树。\n\n<img src=\"/20201124092634138.png\" alt=\"222.完全二叉树的节点个数1\" style=\"zoom: 67%;\" />\n\n```cpp\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        TreeNode *p = root->left;\n        TreeNode *q = root->right;\n        int leftDepth = 0;\n        int rightDepth = 0;\n        while (p != NULL) {\n            p = p->left;\n            leftDepth++;\n        }\n        while (q != NULL) {\n            q = q->right;\n            rightDepth++;\n        }\n        if (leftDepth == rightDepth) { //满二叉树\n            return (2 << leftDepth) - 1; //位运算，移位运算\n        }\n        return countNodes(root->left) + countNodes(root->right) + 1; // 加上根节点\n    }\n};\n```\n\n### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)\n\n> 给定一个二叉树，判断它是否是 平衡二叉树\n>\n> 本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\n\n#### 自顶向下的递归\n\n首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。\n\n```cpp\nclass Solution {\npublic:\n    int height (TreeNode* p) {\n        if (p == NULL){\n            return 0;\n        }\n        else {\n            return max(height(p->left), height(p->right)) + 1;\n        }\n    }\n    bool isBalanced(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        else {\n            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);\n        }\n    }\n};\n```\n\n\n\n#### 自底向上的递归\n\n自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n\n```cpp\nclass Solution {\npublic:\n    int height (TreeNode* p) {\n        if (p == NULL){\n            return 0;\n        }\n        int leftHeight = height(p->left);\n        int rightHeight = height(p->right);\n        if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        }\n        return max(height(p->left), height(p->right)) + 1;\n        \n    }\n    bool isBalanced(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        if (height(root) == -1) {\n            return false;\n        }\n        else {\n            return true;\n        }        \n    }\n};\n```\n\n### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)\n\n> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。\n>\n> **叶子节点** 是指没有子节点的节点。\n\n注意要回溯！！！所以要把之前的节点值存起来\n\n![257.二叉树的所有路径](/20210204151702443.png)\n\n#### 解法一——递归+使用栈\n\n函数参数我就使用了引用，即 `vector<int>& path` ，这是会拷贝地址的，所以 本层递归逻辑如果有`path.push_back(cur->val);` 就一定要有对应的 `path.pop_back()`\n\n```cpp\nclass Solution {\npublic:\n    void preorder(TreeNode *p, vector<int> &path,vector <string> &output) {\n        if (!p->left && !p->right){ //左右为空，终止，记录path\n            string s;\n            for (int i = 0; i < path.size(); i++){\n                s += to_string(path[i]);\n                s += \"->\";\n            }\n            s += to_string(p->val);\n            output.push_back(s);\n            return; \n        }\n        \n        if (p->left) {\n            path.push_back(p->val);\n            preorder(p->left, path, output);\n            path.pop_back();// 回溯\n        }\n        if (p->right) {\n            path.push_back(p->val);\n            preorder(p->right, path, output);\n            path.pop_back();// 回溯\n        }\n    }\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector <string> output;\n        if (root == NULL) {\n            return output;\n        }\n        vector <int> path;\n        preorder(root, path, output);\n        return output;\n    }\n};\n```\n\n#### 解法二——递归+使用字符串+隐式回溯\n\n注意path是不变的，隐式回溯了。\n\n使用的是 `string path`，这里并没有加上引用`&` ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响。 如图所示：\n\n```cpp\nclass Solution {\npublic:\n    void preorder(TreeNode *p, string path,vector <string> &output) {\n        if (!p->left && !p->right){ //左右为空，终止，记录path\n            output.push_back(path + to_string(p->val));\n            return; \n        }\n        \n        if (p->left) {\n            preorder(p->left, path + to_string(p->val) + \"->\", output); //注意path是不变的，隐式回溯了\n        }\n        if (p->right) {\n            preorder(p->right, path + to_string(p->val) + \"->\", output);\n        }\n    }\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector <string> output;\n        if (root == NULL) {\n            return output;\n        }\n        string path;\n        preorder(root, path, output);\n        return output;\n    }\n};\n```\n\n#### 解法三——迭代\n\n使用两个栈，一个存节点，一个存路径。因为路径拼接不易，所以直接存入整体路径。为了防止路径的top被污染，所以和取S的栈顶工作节点p一样，也把路径pathS先取出来，方便后续进一步使用。\n\n```cpp\nclass Solution {\npublic:\n    vector<string> binaryTreePaths(TreeNode* root) {\n        vector <string> output;\n        stack <string> path; // 存放路径\n        stack <TreeNode*> S; // 前序遍历\n        if (root != NULL) {\n            S.push(root);\n            path.push (to_string(root->val));\n        }\n        while (!S.empty()) {\n            TreeNode *p = S.top();\n            S.pop();\n            string pathS = path.top(); //取出路径防止后续拼接时候多拼接一部分\n            path.pop();\n            if (!p->left && !p->right) {\n                output.push_back(pathS);\n            }\n            if (p->right){\n                S.push(p->right);\n                path.push(pathS + \"->\" + to_string(p->right->val)); //考虑到stack出来拼接不方便，把存进去的时候直接把之前的也拼上\n            }\n            if (p->left){\n                S.push(p->left);\n                path.push(pathS + \"->\" + to_string(p->left->val));\n            }\n\n        }\n        return output;\n    }\n};\n```\n\n### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)\n\n> 给定二叉树的根节点 `root` ，返回所有左叶子之和。\n\n注意是左叶子，不是左节点。\n\n#### 解法一——层次遍历BFS\n\n```cpp\nlass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        queue <TreeNode*> Q;\n        int leftSum = 0;\n        if (root != NULL) {\n            Q.push(root);\n        }\n        while (!Q.empty()) {\n            int qSize = Q.size();\n            for (int i = 0; i < qSize; i++){\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (p->left){\n                    Q.push(p->left);\n                    if (!p->left->left && !p->left->right){\n                        leftSum += p->left->val;\n                    }\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                }\n            }\n        }\n        return leftSum;\n    }\n};\n```\n\n#### 解法二——深度优先DFS\n\n```cpp\nclass Solution {\npublic:\n    int preorder (TreeNode* p) {\n        int ans = 0;\n        if (p->left) {\n            if (!p->left->left && !p->left->right) {\n                ans += p->left->val;\n            }\n            else {\n                ans += preorder(p->left);\n            }\n        }\n        if (p->right) {\n            ans += preorder(p->right);\n        }\n        return ans;\n    }\n    int sumOfLeftLeaves(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        return preorder(root);\n    }\n};\n```\n\n### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n\n> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。\n>\n> 假设二叉树中至少有一个节点。\n\n#### 解法一——BFS+flag\n\n欸，我傻了，这个flag一点用也没有啊。删了也一样\n\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue <TreeNode*> Q;\n        int bottomLeftValue = root->val;\n        Q.push(root);\n        bool flagNULL = false;\n        while (!Q.empty() && !flagNULL){\n            int qSize = Q.size();\n            flagNULL = true;\n            for (int i = 0; i < qSize; i++){\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (i == 0){\n                    bottomLeftValue = p->val;\n                }\n                if (p->left){\n                    Q.push(p->left);\n                    flagNULL = false;\n                }\n                if (p->right) {\n                    Q.push(p->right);\n                    flagNULL = false;\n                }\n            }\n        }\n        return bottomLeftValue;\n    }\n};\n```\n\n#### 解法二——BFS，左右节点相反\n\n在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。\n\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue <TreeNode*> Q;\n        int bottomLeftValue = root->val;\n        Q.push(root);\n        while (!Q.empty() ){\n                TreeNode *p = Q.front();\n                Q.pop();\n                if (p->right){\n                    Q.push(p->right);\n                }\n                if (p->left) {\n                    Q.push(p->left);\n                }\n                bottomLeftValue = p->val;\n        }\n        return bottomLeftValue;\n    }\n};\n```\n\n#### DFS\n\n太难了，绕不清\n\n```cpp\nclass Solution {\npublic:\n    void preorder (TreeNode *p, int depth, int &bottomLeftValue, int &maxDepth){ // DLR最先遍历到的就是最左节点\n        int output = 0;\n        if(!p->left && !p->right){ //全空\n            if (depth > maxDepth) {\n                maxDepth = depth;\n                bottomLeftValue = p->val;\n            }\n        }\n        if (p->left) {\n            preorder(p->left, depth + 1, bottomLeftValue, maxDepth);\n        }\n        if (p->right) {\n            preorder(p->right, depth + 1, bottomLeftValue, maxDepth);\n        }\n    }\n    \n    int findBottomLeftValue(TreeNode* root) {\n        int depth = 0;\n        int maxDepth = 0;\n        int bottomLeftValue = 0;\n        preorder(root, depth + 1, bottomLeftValue, maxDepth);\n        return bottomLeftValue;\n    }\n};\n```\n\n### 路径总和（[112](https://leetcode.cn/problems/path-sum/)/[113](https://leetcode.cn/problems/path-sum-ii/)）\n\n#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)\n\n> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。\n>\n> **叶子节点** 是指没有子节点的节点。\n\n##### 迭代\n\n注意深度优先遍历回溯时候，可能无法减去双亲结点的值，所以得把双亲的值保存，类似于“[257. 二叉树的所有路径](#[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/))”中的保存方式。**此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。**\n\n```cpp\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        stack <pair<TreeNode*,int>> S;\n        if (root != NULL){\n            S.push(pair<TreeNode*,int>(root, root->val)); //根节点和为0\n        }\n        while (!S.empty()){\n            pair<TreeNode*,int> p = S.top();\n            S.pop();\n            if (!p.first->left && !p.first->right) { //叶子\n                if (p.second == targetSum) {\n                    return true;\n                }\n            }\n            if (p.first->right) {\n                S.push(pair<TreeNode*,int>(p.first->right, p.second + p.first->right->val));\n            }\n            if (p.first->left) {\n                S.push(pair<TreeNode*,int>(p.first->left, p.second + p.first->left->val));\n            }\n        }\n        return false;\n    }\n};\n```\n\n##### 递归\n\n1. 确定递归函数的参数和返回类型\n\n   参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。\n\n   再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：\n\n   - 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）\n   - 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在[236. 二叉树的最近公共祖先 (opens new window)](https://programmercarl.com/0236.二叉树的最近公共祖先.html)中介绍）\n   - 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）\n\n2. 确定终止条件\n\n   不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。\n\n   如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。\n\n3. 确定单层递归的逻辑\n\n```cpp\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        stack <pair<TreeNode*,int>> S;\n        if (root == NULL){ // 递归时候没有判断左右节点是否非空，所以这里开始的时候要判断\n            return false;\n        }\n        int count = targetSum - root->val; \n        if (!root->left && !root->right && count == 0) { // 利用减代替加可以少传递一个参数\n            return true;\n        }\n        if (hasPathSum(root->left, count)) { // 如果是true 立刻返回\n            return true;\n        }\n        if (hasPathSum(root->right, count)) {\n            return true;\n        }\n        return false;\n    }\n};\n```\n\n另一个版本——代码随想录\n\n```cpp\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if (!root) return false;\n        if (!root->left && !root->right && sum == root->val) {\n            return true;\n        }\n        return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val);\n    }\n};\n```\n\n#### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)\n\n> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。\n>\n> **叶子节点** 是指没有子节点的节点。\n\n##### 迭代\n\n思路类似“[257. 二叉树的所有路径](#[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/))”中的保存方式，知识这里路径的保存利用stack套vector，而非之前的stack套string\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        vector<vector<int>> output;\n        stack <pair<TreeNode*, int>> S;\n        stack <vector<int>> pathAll;\n        if (root) {\n            S.push(pair<TreeNode*, int>(root, root->val));\n            pathAll.push(vector<int>(1, root->val)); // 注意这里的vector写法\n        }\n        while(!S.empty()) {\n            pair<TreeNode*, int> p = S.top() ;\n            S.pop();\n            vector<int> path = pathAll.top();\n            pathAll.pop();\n            // for (int num:path){\n            //     cout << num << \" \";\n            // }\n            // cout << endl;\n            if (!p.first->left && !p.first->right && p.second == targetSum){\n                output.push_back(path);\n            }\n            if (p.first->right){\n                S.push(pair<TreeNode*,int>(p.first->right, p.second + p.first->right->val));\n                path.push_back(p.first->right->val);\n                pathAll.push(path);\n                path.pop_back();\n            }\n            if (p.first->left){\n                S.push(pair<TreeNode*,int>(p.first->left, p.second + p.first->left->val));\n                path.push_back(p.first->left->val);\n                pathAll.push(path);\n                path.pop_back();\n            }\n        }\n        return output;\n    }\n};\n```\n\n##### 递归\n\n不需要返回值\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> path;\n\n    void findPath(TreeNode* p, int targetSum) {\n        if (p == NULL) {\n            return;\n        }\n        path.push_back(p->val);\n        if (!p->left && !p->right && targetSum == 0) {\n            output.push_back(path);\n        }\n        if (p->left) {\n            findPath(p->left, targetSum - p->left->val);\n        }\n        if (p->right) {\n            findPath (p->right, targetSum - p->right->val);\n        }\n        path.pop_back();\n    }\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        if (root == NULL) {\n            return output;\n        }\n        findPath (root, targetSum - root->val);\n        return output;\n    }\n};\n```\n\n### 从遍历序列恢复二叉树\n\n+ 由DLR和LDR的遍历序列可以唯一地确定一棵二叉树\n+ 由LRD和LDR的遍历序列可以唯一地确定一棵二叉树\n+ 通过DLR或者LRD的遍历序列确定二叉树或子树的根节点，通过LDR确定左右子树的序列。\n\n#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)\n\n> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。\n\n一层一层切割\n\n- 第一步：如果数组大小为零的话，说明是空节点了。\n- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。\n- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点\n- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）\n- 第五步：切割后序数组，切成后序左数组和后序右数组\n- 第六步：递归处理左区间和右区间\n\n![img](/tree-1712473381702-3.jpg)![106.从中序与后序遍历序列构造二叉树](/20210203154249860.png)\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        // 递归\n        // 数组大小为0，空节点\n        if (inorder.empty() && postorder.empty()) {\n            return NULL;\n        }\n\n        //不为空，postorder的最后一个元素是根节点\n        TreeNode* p = new TreeNode (postorder[postorder.size() - 1]);\n\n        // 找到中序的切割点\n        int cutPoint;\n        for (cutPoint = 0; cutPoint < inorder.size(); cutPoint++) {\n            if (inorder[cutPoint] == postorder[postorder.size() - 1]) {\n                break;\n            }\n        }\n\n        // 分割中序 （左闭右开）\n        vector<int> inorder_left(inorder.begin(), inorder.begin() + cutPoint);\n        vector<int> inorder_right(inorder.begin() + cutPoint + 1, inorder.end()); //不包含分割点\n\n        // 分割后序 （左闭右开）中序数组大小一定是和后序数组的大小相同的\n        vector<int> postorder_left(postorder.begin(), postorder.begin() + inorder_left.size());\n        vector<int> postorder_right(postorder.begin() + inorder_left.size(), postorder.end() - 1); //不包含分割点，最后一个\n\n        // 对左右子树递归\n        p->left = buildTree(inorder_left, postorder_left);\n        p->right = buildTree(inorder_right, postorder_right);\n\n        return p;\n    }\n};\n```\n\n为了减少vector的查找时间，官方题解建立（元素，下标）键值对的哈希\n\n这里注意一个细节：为什么可以用下标减一来表示后序的每次根节点呢？因为他先构造右子树，每次的根节点刚好是最后一个，而当右子树构造完以后正好下标来到左子树。\n\n```cpp\nclass Solution {\n    int post_idx;\n    unordered_map<int, int> idx_map;\npublic:\n    TreeNode* helper(int in_left, int in_right, vector<int>& inorder, vector<int>& postorder){\n        // 如果这里没有节点构造二叉树了，就结束\n        if (in_left > in_right) {\n            return nullptr;\n        }\n\n        // 选择 post_idx 位置的元素作为当前子树根节点\n        int root_val = postorder[post_idx];\n        TreeNode* root = new TreeNode(root_val);\n\n        // 根据 root 所在位置分成左右两棵子树\n        int index = idx_map[root_val];\n\n        // 下标减一\n        post_idx--;\n        // 构造右子树\n        root->right = helper(index + 1, in_right, inorder, postorder);\n        // 构造左子树\n        root->left = helper(in_left, index - 1, inorder, postorder);\n        return root;\n    }\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        // 从后序遍历的最后一个元素开始\n        post_idx = (int)postorder.size() - 1;\n\n        // 建立（元素，下标）键值对的哈希表\n        int idx = 0;\n        for (auto& val : inorder) {\n            idx_map[val] = idx++;\n        }\n        return helper(0, (int)inorder.size() - 1, inorder, postorder);\n    }\n};\n\n```\n\n——官方题解\n\n#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。\n\n利用无序映射做\n\n这里利用`pre_index++`来表示前序的根节点也是和上述同理。更好理解的话还是把先序、中序的头尾都放在helper函数的输入里面。\n\n```cpp\nclass Solution {\n    int pre_index;\n    unordered_map <int, int> idx_map;\npublic:\n    TreeNode* helper (int in_begin, int in_end, vector<int> & preorder, vector<int>& inorder) {\n        if (in_begin > in_end) {\n            return NULL;\n        }\n\n        // 找到分割点\n        int cutPoint = idx_map[preorder[pre_index]]; // 这是分割点在inorder中的下标索引\n\n        //　建立节点\n        TreeNode *p = new TreeNode(preorder[pre_index]); // 分割点的值是preorder[begin]\n\n        // 前序的分割点递增\n        pre_index++;\n\n        //左右子树\n        p->left = helper(in_begin, cutPoint - 1, preorder, inorder);\n        p->right = helper(cutPoint + 1, in_end, preorder, inorder);\n\n        return p;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        pre_index = 0;\n        int index = 0;\n        for (int num:inorder) {\n            idx_map[num] = index++;\n        }\n        return helper(0, inorder.size() - 1, preorder, inorder);\n    }\n};\n```\n\n### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)\n\n> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:\n>\n> 1. 创建一个根节点，其值为 `nums` 中的最大值。\n> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。\n> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。\n>\n> 返回 *`nums` 构建的**最大二叉树*** 。\n\n思路非常类似于“从遍历序列恢复二叉树”，但是这里需要注意的是不需要建立哈希表存储索引和值的关系，因为你每次要在序列中找到最大值，还是需要通过for循环来寻找，因此unordered_map在这里作用不大。\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* helper (vector<int>& nums, int begin, int end) {\n        if (begin > end) {\n            return NULL;\n        }\n        // 递归求解，每次先找最大\n        int maxNumIndex = begin;\n        for(int i = begin + 1; i <= end; i++){ //从begin+1开始可以减少工作量哈\n            if (nums[i] > nums[maxNumIndex]) {\n                maxNumIndex = i;\n            }\n        }\n        TreeNode* root = new TreeNode(nums[maxNumIndex]);\n        root->left = helper(nums, begin, maxNumIndex - 1);\n        root->right = helper(nums, maxNumIndex + 1, end);\n        return root;\n    }\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n};\n```\n\n### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)\n\n> 给你两棵二叉树： `root1` 和 `root2` 。\n>\n> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。\n>\n> 返回合并后的二叉树。\n>\n> **注意:** 合并过程必须从两个树的根节点开始。\n\n#### 解法一——迭代+层次遍历+列举所有情况\n\n非常朴素的想法，层次遍历+列举所有情况，将左右操作都从第二个子树合并到第一个子树上，所有的节点不存在问题，都通过创建0节点解决。这里需要注意的是不光要将0节点加到队列中以保证两子树的队列长度一致，同时子树1是要返回的，那么他的具体节点也需要有。\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        // 层次遍历，在root1上操作\n        queue <TreeNode*> Q1;\n        queue <TreeNode*> Q2;\n        if (root1 != NULL || root2 != NULL) {\n            if (root1 == NULL) {\n                root1 = new TreeNode(0);\n            }\n            if (root2 == NULL) {\n                root2 = new TreeNode(0);\n            }\n            Q1.push(root1);\n            Q2.push(root2);\n        }\n        while (!Q1.empty() || !Q2.empty()) {\n            TreeNode *p1 = Q1.front();\n            Q1.pop();\n            TreeNode *p2 = Q2.front();\n            Q2.pop();\n            if (p1 && p2) {\n                p1->val += p2->val;\n            }\n            // left、right四种情况\n            // if (p1->left) {\n            //     Q1.push(p1->left);\n            //     if (p2->left) {\n            //         Q2.push(p2->left);\n            //     }\n            //     else {\n            //         Q2.push(new TreeNode(0));\n            //     }\n            // }\n            // if (p1->right) {\n            //     Q1.push(p1->right);\n            //     if (p2->right) {\n            //         Q2.push(p2->right);\n            //     }\n            //     else {\n            //         Q2.push(new TreeNode(0));\n            //     }\n            // }\n            // if (!p1->left && p2->left) {\n            //     p1->left = new TreeNode(0);\n            //     Q1.push(p1->left);\n            //     Q2.push(p2->left);\n            // }\n            // if (!p1->right && p2->right) {\n            //     p1->right = new TreeNode(0);\n            //     Q1.push(p1->right);\n            //     Q2.push(p2->right);\n            // }\n            // 其余的p1、p2左右子树均不存在的情况不需要考虑\n            // 综合一下只有两种情况，都不存在，和其他\n            if (p1->left || p2->left){\n                if(!p1->left){\n                    p1->left = new TreeNode(0);\n                }\n                if(!p2->left){\n                    p2->left = new TreeNode(0);\n                }\n                Q1.push(p1->left);\n                Q2.push(p2->left);\n            }\n            if (p1->right || p2->right){\n                if(!p1->right){\n                    p1->right = new TreeNode(0);\n                }\n                if(!p2->right){\n                    p2->right = new TreeNode(0);\n                }\n                Q1.push(p1->right);\n                Q2.push(p2->right);\n            }\n        }\n        return root1;\n    }\n};\n```\n\n#### 解法二——递归+深度优先\n\n如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；\n\n如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；**且即使其中一个有子树也不需要管了，毕竟另外一个直接空了**\n\n如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。\n\n——力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1 && !root2){\n            return NULL;\n        }\n        if (!root1 && root2) {\n            return root2;\n        }\n        if (root1 && !root2) {\n            return root1;\n        }\n        TreeNode *merged = new TreeNode (root1->val + root2->val);\n        merged->left = mergeTrees(root1->left, root2->left);\n        merged->right = mergeTrees(root1->right, root2->right);\n        return merged;\n    }\n};\n```\n\n### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)\n\n> 给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。\n>\n> 你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。\n\n二叉搜索树(二叉排序树)是一个有序树：\n\n- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n- 它的左、右子树也分别为二叉搜索树\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root) {\n            return NULL;\n        }\n        TreeNode *p = root;\n        while (p != NULL) {\n            if (p->val == val) {\n                return p;\n            }\n            if (p->val > val) {\n                p = p->left;\n            }\n            else {\n                p = p->right;\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root || root->val == val){\n            return root;\n        }\n        if (root->val > val) {\n            return searchBST(root->left, val);\n        }\n        else {\n            return searchBST(root->right, val);\n        }\n    }\n};\n```\n\n### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)\n\n> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。\n>\n> **有效** 二叉搜索树定义如下：\n>\n> - 节点的左子树只包含 **小于** 当前节点的数。\n> - 节点的右子树只包含 **大于** 当前节点的数。\n> - 所有左子树和右子树自身必须也是二叉搜索树。\n\n**不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了**，而是左子树都小于中间节点，右子树都大于中间节点。\n\n要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。\n\n#### 迭代——中序遍历\n\n定义flag，防止第一次比较order超范围有问题\n\n```cpp\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        // 中序遍历\n        stack <TreeNode*> S;\n        vector<int> order;\n        bool flag = true;\n        TreeNode *p = root;\n        while (p != NULL || !S.empty()){\n            if (p != NULL) {\n                S.push(p);\n                p = p->left;\n            }\n            else {\n                p = S.top();\n                S.pop();\n                if (flag) {\n                    order.push_back(p->val);\n                    flag = false;\n                    // cout << p->val << \" \";\n                }\n                else if (p->val > order[order.size() - 1]) {\n                    order.push_back(p->val);\n                    // cout << p->val << \" \";\n                }\n                else {\n                    return false;\n                }\n                p = p->right;\n            }\n        }\n        return true;\n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode *pre = NULL; //记录前一个，中序的前一个总比后一个小\n    bool isValidBST(TreeNode* root) {\n        if (root == NULL) {\n            return true;\n        }\n        bool validLeft = isValidBST(root->left);\n        \n        if (pre != NULL && pre->val >= root->val) {\n            return false;\n        }\n        pre = root;\n\n        bool validRight = isValidBST(root->right);\n        \n        return validLeft && validRight;\n    }\n};\n```\n\n### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)\n\n> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。\n>\n> 差值是一个正数，其数值等于两值之差的绝对值。\n\n**在有序数组求任意两数最小值差等价于相邻两数的最小值差**。\n\n迭代\n\n```cpp\nclass Solution {\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        stack <TreeNode*> S;\n        TreeNode *p = root;\n        int pre = -1;\n        int minDistance = INT_MAX;\n        while(p || !S.empty()){\n            if(p){\n                S.push(p);\n                p = p->left;\n            }\n            else {\n                p = S.top();\n                S.pop();\n                if((pre != -1) && (p->val - pre) < minDistance) {\n                    minDistance = p->val - pre;\n                }\n                pre = p->val;\n                p = p->right;\n            }\n        }\n        return minDistance;\n    }\n};\n```\n\n### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)\n\n> 给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。\n>\n> 如果树中有不止一个众数，可以按 **任意顺序** 返回。\n>\n> 假定 BST 满足如下定义：\n>\n> - 结点左子树中所含节点的值 **小于等于** 当前节点的值\n> - 结点右子树中所含节点的值 **大于等于** 当前节点的值\n> - 左子树和右子树都是二叉搜索树\n\n几个可以利用的特点：\n\n1. 中序遍历是有序的\n2. 遍历一次就可以找到所有的众数——如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），不仅要更新maxCount，而且要清空结果集\n\n递归\n\n```cpp\nclass Solution {\npublic:\n    int count;\n    int maxCount;\n    vector<int> output;\n    TreeNode* pre = NULL; //不能直接定义int类型，否则，NULL==0\n    void inorder(TreeNode* p){\n        if(p->left) {\n            inorder(p->left);\n        }\n        // 判断、计数\n        if (pre == NULL){\n            count = 1;\n        }\n        else if (pre->val == p->val) {\n            count++;\n        }\n        else { //不相等清零\n            count = 1;\n        }\n        pre = p; //更新节点\n        //比较\n        if (count > maxCount) {\n            maxCount = count;\n            output.clear();\n            output.push_back(p->val);\n        }\n        else if (count == maxCount) {\n            output.push_back(p->val);\n        }\n        if(p->right) {\n            inorder(p->right);\n        }        \n    }\n\n    vector<int> findMode(TreeNode* root) {\n        if (root == NULL) {\n            return output;\n        }\n        int maxCount = 0;\n        inorder(root);\n        return output;\n    }\n};\n```\n\n### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n![236.二叉树的最近公共祖先2](/202102041512582.png)\n\n- 如何从底向上遍历？\n- 遍历整棵树，还是遍历局部树？\n- 如何把结果传到根节点的？\n\n思路有点难想，一共分为两种情况：\n\n+ 情况一：p、q分属在一个顶点的左右子树上\n+ 情况二：p在q的子树下，q在p的子树下\n\n首先考虑“情况一”，在递归寻找的过程中，如果我能找到这个其中一个节点，我就回传（此时不需要考虑是否为叶子节点，为什么呢？此时其实就是“情况二”）。如果一个顶点的左右都有值，那就说明这个节点是公共节点，又因为我们是从下到上回溯的，所以碰到的一定是最近公共祖先（也就是最深的，再往上的一定至少有一边为NULL）。\n\n下面考虑“情况二”的问题。如果p在q的子树下或q在p的子树下，题目中又保证`p` 和 `q` 均存在于给定的二叉树中，且互不相同，那么是不是就可以说**假设我现在找到了p，如果我在后续的递归遍历中再也没有找到q，那么q一定就在p的子树中**，所以这就解决了一个节点属于另一个元素的孩子的问题。\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) {\n            return root; //NULL就直接回传，如果遇到需要找的p、q也回传，注意如果q（p）在p（q）的子树下就不往下递归了，虽然我没递归到，但是一定在这个下面。\n        }\n        // 左右子树递归寻找\n        TreeNode *left = lowestCommonAncestor(root->left, p, q);\n        TreeNode *right = lowestCommonAncestor(root->right,  p, q);\n        if (left && right) {\n            return root; // 如果左右子树都有，那他就是最近公共祖先\n        }\n        else if (left && !right) {\n            return left;\n        }\n        else if (right && !left) {\n            return right;\n        }\n        else { //都为空\n            return NULL;\n        }\n\n    }\n};\n```\n\n### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n>\n> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”\n\n+ **是**公共祖先：因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的值 一定是在$[p, q]$​区间的。即 `中节点->val > p->val && 中节点->val < q->val` 或者 `中节点->val > q->val && 中节点->val < p->val`。\n+ **最近**公共祖先：**如果一个节点值大于根节点，一个节点值小于根节点**，说明他们他们一个在根节点的左子树上一个在根节点的右子树上，**那么根节点就是他们的最近公共祖先节点**。【反证法】此时，如果最近公共祖先在左子树中，说明p、q必须都得在左子树中，和“一个结点值大于根节点”矛盾；如果最近公共祖先在右子树中，说明p、q必须都得在右子树中，和“一个结点值小于根节点”矛盾；只剩最后一种情况：根节点就是最近公共祖先呗\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root->val > p->val && root->val > q->val) { //p，q都在左子树\n            return lowestCommonAncestor(root->left, p, q);\n        }\n        if (root->val < p->val && root->val < q->val) { //p，q都在右子树\n            return lowestCommonAncestor(root->right, p, q);\n        }\n        if ((root->val <= p->val && root->val >= q->val) || (root->val >= p->val && root->val <= q->val)) { // 分叉点或者就是其中一个节点，其实这个就是上两个以外的else\n            return root;\n        }\n        return NULL;\n    }\n};\n```\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (root) {\n            if (root->val > p->val && root->val > q->val) { //p，q都在左子树\n                root = root->left;\n            }\n            else if (root->val < p->val && root->val < q->val) { //p，q都在右子树\n                root = root->right;\n            }\n            else { // 分叉点或者就是其中一个节点，其实这个就是上两个以外的else\n                return root;\n            }\n        }\n        return NULL;\n    }\n};\n```\n\n### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)\n\n> 给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。\n>\n> **注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。\n\n根据定义完成。\n\n+ 注意root因为要返回，所以不能直接对他操作\n+ 需要考虑空root的问题\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (root == NULL) { // 考虑空节点的问题\n            return new TreeNode(val);\n        }\n        TreeNode *p = root;\n        while (p) {\n            if (val > p->val)  {\n                if (p->right) {\n                    p = p->right;\n                }\n                else {\n                    p->right = new TreeNode(val);\n                    break;\n                }\n            }\n            else {\n                if (p->left) {\n                    p = p->left;\n                }\n                else {\n                    p->left = new TreeNode(val);\n                    break;\n                }\n            }\n        }\n        return root; // 注意root不能变\n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (root == NULL) { // 考虑空节点的问题,递归中其实就是最后一步\n            return new TreeNode(val);\n        }\n        if (val > root->val)  {\n            root->right = insertIntoBST(root->right, val); //接收到的就是返回的原始root，只是新增了子节点\n        }\n        else {\n            root->left = insertIntoBST(root->left, val);\n        }\n        return root; \n    }\n};\n```\n\n### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)\n\n> 给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n>\n> 一般来说，删除节点可分为两个步骤：\n>\n> 1. 首先找到需要删除的节点；\n> 2. 如果找到了，删除它。\n\n- 第一种情况：没找到删除的节点，遍历到空节点直接返回了\n- 找到删除的节点\n  - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点\n  - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点\n  - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点\n  - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n其实第五种情况简单来说就是，<u>删除节点</u>的左子树的任意一个元素，一定小于右子树的任意元素，那我直接放到右子树的最小元素的左子树上就好啦！\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == NULL) {\n            return root;\n        }\n        // 先要找到删除元素\n        TreeNode *p = root;\n        TreeNode *pParent = NULL;\n        bool direction = true; // 布尔值判断是在parent的左子树（true）还是右子树（false）\n        while (p) {\n            if (key > p->val) {\n                pParent = p;\n                p = p->right;\n                direction = false;\n            }\n            else if(key < p->val) {\n                pParent = p;\n                p = p->left;\n                direction = true;\n            }\n            else { //相等\n                break;\n            }\n        }\n        if (p == NULL) { //没找到\n            return root;\n        }\n        // 对删除元素操作\n        TreeNode *q = NULL; // q用于指示pParent后续指向何方\n        if (!p->left && !p->right) { // 全空\n            q = NULL;\n        }\n        else if (!p->left && p->right) { // 左空右不空\n            q = p->right;\n        }\n        else if (p->left && !p->right) { // 左不空右空\n            q = p->left;\n        }\n        else {// 左右都不空\n            q = p->right; //指向右子树，并将原来的左子树放在原来的右子树的最左下方\n            TreeNode *pLeft = p->left; //原来的左子树\n            p = p->right;\n            while (p->left) {\n                p = p->left; // 指向原来的右子树的最左下方\n            }\n            //此时p->left为空\n            p->left = pLeft;\n        }\n        // 将新子树节点放置在原来pParent下方，这里需要注意，万一删除的节点就是根节点的情况\n        if (pParent) { //删除的节点非根节点\n            if(direction) {\n                pParent->left = q;\n            }\n            else {\n                pParent->right = q;\n            }\n            return root;\n        }\n        else { //删除的节点就是根节点\n            return q;\n        }        \n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == NULL) {\n            return root;\n        }\n        \n        // 对删除元素操作\n        if (root->val == key) {\n            if (!root->left && !root->right) { // 全空\n                return NULL;\n            }\n            else if (!root->left && root->right) { // 左空右不空\n                return root->right;\n            }\n            else if (root->left && !root->right) { // 左不空右空\n                return root->left;\n            }\n            else {// 左右都不空          \n                TreeNode *rootRight = root->right;\n                while (rootRight->left) {\n                    rootRight = rootRight->left; // 指向原来的右子树的最左下方\n                }\n                //此时rootRight->left为空\n                rootRight->left = root->left;\n                // cout << rootRight->val << \" \";\n                return root->right;\n            }\n        }\n\n        // 递归寻找左右\n        if (root->val > key) {\n            root->left = deleteNode(root->left, key);\n        }\n        else {\n            root->right = deleteNode(root->right, key);\n        }\n        return root;\n    }\n};\n```\n\n### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)\n\n> 给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。\n>\n> 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n\n先找到两个临界点值。\n\n+ `low`：工作节点p满足`p->val >= low && p->left->val < low`， 则`p = p->right`\n+ `high`：工作节点p满足`p->val <= high && p->right->val > high`， 则`p = p->left`\n\n例如对于low的临界点来说，他一定是左孩子，双亲一定大于他，他本身的右孩子也一定大于他。**但是要注意右孩子可能还是会有小于low的情况出现！！！**所以要用while\n\n此外处理根节点不在范围内的问题时候，不能分开来考虑，例如先low，后high，否则可能有问题。\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        while (root && (root->val > high || root->val < low)) { // 不能分开来，先左后右\n            if (root->val > high) {\n                root = root->left;\n            }\n            else {\n                root = root->right;\n            }\n        }\n        if (!root) {\n            return root;\n        }\n        TreeNode *p = root;\n        // 找low的临界点\n        while (p) {\n            while (p->val >= low && p->left && p->left->val < low) { // 注意这里是while\n                p->left = p->left->right;\n            }\n            p = p->left; // 还没到临界点\n        }\n        p = root;\n        // 找high的临界点\n        while (p) {\n            while (p->val <= high && p->right && p->right->val > high) {// 注意这里是while\n                p->right = p->right->left;\n            }\n            p = p->right; // 还没到临界点\n        }\n        return root;\n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (root == NULL) {\n            return root;\n        }\n        if (root->val < low) {\n            return trimBST(root->right, low, high);\n        }\n        if (root->val > high) {\n            return trimBST(root->left, low, high);\n        }\n\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n\n        return root;\n    }\n};\n```\n\n### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\n\n> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 平衡 二叉搜索树。\n>\n> **平衡二叉树** 是指该树所有节点的左右子树的深度相差不超过 1。\n\n注意是所有节点的左右子树的深度相差不超过 1\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* helper (vector<int>&nums, int left, int right){\n        if (left > right) {\n            return NULL;\n        }\n        TreeNode* p = new TreeNode(nums[(left + right) / 2]);\n        p->left = helper(nums, left, (left + right) / 2 - 1);\n        p->right = helper(nums, (left + right) / 2 + 1, right);\n        return p;\n    }\n\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n};\n```\n\n### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)\n\n> 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。\n>\n> 提醒一下，二叉搜索树满足下列约束条件：\n>\n> - 节点的左子树仅包含键 **小于** 节点键的节点。\n> - 节点的右子树仅包含键 **大于** 节点键的节点。\n> - 左右子树也必须是二叉搜索树。\n\n逆中序遍历\n\n#### 迭代\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        stack <TreeNode*> S;\n        TreeNode *p = root;\n        int sum = 0;\n        while(p || !S.empty()){\n            if (p) {\n                S.push(p);\n                p = p->right;\n            }\n            else {\n                p = S.top();\n                S.pop();\n                sum += p->val;\n                p->val = sum;\n                p = p->left;\n            }\n        }\n        return root;\n    }\n};\n```\n\n#### 递归\n\n```cpp\nclass Solution {\npublic:\n    int sum = 0;\n    TreeNode* convertBST(TreeNode* root) {\n        if (root == NULL) {\n            return root;\n        }\n        if (root->right) {\n            root->right = convertBST(root->right);\n        }\n        sum += root->val;\n        root->val = sum;\n        if (root->left) {\n            root->left = convertBST(root->left);\n        }\n        return root;\n    }\n};\n```\n\n## 回溯\n\n> 回溯法也可以叫做回溯搜索法，它是一种搜索的方式。\n>\n> 回溯法，一般可以解决如下几种问题：\n>\n> - 组合问题：N个数里面按一定规则找出k个数的集合\n>   - 剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了。\n>   - 一个集合来求**组合**的话，就需要startIndex；多个集合取组合，各个集合之间相互不影响，那么就不用startIndex\n>   - **去重问题**——used\n>\n> - 切割问题：一个字符串按一定规则有几种切割方式\n> - 子集问题：一个N个数的集合里有多少符合条件的子集\n>   - 在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。\n>\n> - 排列问题：N个数按一定规则全排列，有几种排列方式\n> - 棋盘问题：N皇后，解数独等等\n>\n> **组合是不强调元素顺序的，排列是强调元素顺序**。\n>\n> **回溯法解决的问题都可以抽象为树形结构**！因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度就构成了树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**\n> ![回溯算法理论基础](/20210130173631174.png)\n>\n> + **在for循环上做剪枝操作是回溯法剪枝的常见套路！**\n>\n> 模板\n>\n> ```text\n> void backtracking(参数) {\n>     if (终止条件) {\n>         存放结果;\n>         return;\n>     }\n> \n>     for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {\n>         处理节点;\n>         backtracking(路径，选择列表); // 递归\n>         回溯，撤销处理结果\n>     }\n> }\n> ```\n>\n> <img src=\"/20210219192050666.png\" alt=\"回溯算法大纲\" style=\"zoom:50%;\" />\n>\n> ---\n>\n> 以下来自[回溯算法入门级详解 + 练习（持续更新）](https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw)\n>\n> 「回溯算法」强调了「深度优先遍历」思想的用途，用一个 **不断变化** 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 **回退** 操作对于搜索的合理性。\n>\n> 回溯算法用于 **搜索一个问题的所有的解** ，通过深度优先遍历的思想实现。\n>\n> 与动态规划的区别：\n>\n> + 共同点——用于求解多阶段决策问题。多阶段决策问题即：\n>\n>   + 求解一个问题分为很多步骤（阶段）；\n>\n>   + 每一个步骤（阶段）可以有多种选择。\n>\n> + 不同点\n>\n>     + 动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；\n>   + 回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。\n>\n> \n>\n> \n>\n\n### [77. 组合](https://leetcode.cn/problems/combinations/)\n\n> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。\n>\n> 你可以按 **任何顺序** 返回答案。\n\n回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。\n\n![77.组合1](/20201123195242899.png)\n\n#### 解法一——暴力回溯\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    void backtracking(int n, int k, int start) {\n        if (temp.size() == k) {\n            output.push_back(temp);\n            return;\n        }\n\n        for (int i = start; i <= n; i++) {\n            temp.push_back(i);\n            backtracking(n, k, i + 1); //递归\n            temp.pop_back(); //回溯\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        backtracking(n, k, 1);\n        return output;        \n    }\n};\n```\n\n#### 解法二——回溯+剪枝\n\n**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。\n\n1. 已经选择的元素个数：`path.size()`;\n2. 还需要的元素个数为: `k - path.size()`;\n3. 在集合n中至多要从该起始位置 : `n - (k - path.size()) + 1`，开始遍历\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    void backtracking(int n, int k, int start) {\n        if (temp.size() == k) {\n            output.push_back(temp);\n            return;\n        }\n\n        for (int i = start; i <= n - (k - temp.size()) + 1; i++) {\n            temp.push_back(i);\n            backtracking(n, k, i + 1); //递归\n            temp.pop_back(); //回溯\n        }\n    }\n\n    vector<vector<int>> combine(int n, int k) {\n        backtracking(n, k, 1);\n        return output;        \n    }\n};\n```\n\n### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)\n\n> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：\n>\n> - 只使用数字1到9\n> - 每个数字 **最多使用一次** \n>\n> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n\n隐含sum的回溯，通过两个方法剪枝\n\n+ i的范围，要保证后续有这么多的树可以取\n+ sum和target的关系，如果加上当前数target已经炸了，那么就不往下了，这里隐含了一点，i是从小到大排列的，加上这个比较小的都不行，后面的就都不用加了。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    \n    void backtracking(int k, int target, int start, int sum) {\n        if (temp.size() == k && sum == target) {\n            output.push_back(temp);\n            return;\n        }\n\n        for (int i = start; i <= 9 - (k - temp.size()) + 1; i++) {\n            if (sum + i > target) {\n                break;\n            }\n            temp.push_back(i);\n            backtracking (k, target, i + 1, sum + i); // 隐含sum的回溯\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum3(int k, int n) {\n        backtracking(k, n, 1, 0);\n        return output;\n    }\n};\n```\n\n### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)\n\n> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。\n>\n> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。![img](/200px-telephone-keypad2svg.png)\n\n注意alphabet的定义方式是大括号。此外`digitsStart`不能使用`stoi`，这个也不知道是为什么。此外需要注意为空的情况。\n\n```cpp\nclass Solution {\npublic:\n    vector<string> output;\n    string temp;\n    vector<string> alphabet = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    void backtracking(string digits, int start) {\n        if (start == digits.length()) {\n            output.push_back(temp);\n            return ;\n        }\n        int digitsStart = digits[start] - '0';\n        for (int i = 0; i < alphabet[digitsStart].length(); i++) {\n            temp.push_back(alphabet[digitsStart][i]);\n            backtracking(digits, start + 1);\n            temp.pop_back();\n        }\n    }\n\n    vector<string> letterCombinations(string digits) {\n        if (digits.length() == 0) {\n            return output;\n        }\n        backtracking(digits, 0);\n        return output;\n    }\n};\n```\n\n### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\n> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。\n>\n> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 \n>\n> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。\n\n- 组合没有数量要求\n- 元素可无限重复选取\n\n有两点需要注意：\n\n+ 递归的时候下一次的start是i，不是i+1，也不是start。不是start（因为是这个数及其以后的可选），也不是i+1（因为可以重复选取）\n+ 剪枝时候的判定条件`sum + candidates[i] > target`就`break`，数组需要有序\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    void backtracking (vector<int>& candidates, int target, int sum, int start) {\n        if (sum == target) {\n            output.push_back(temp);\n            return;\n        }\n\n        for (int i = start; i < candidates.size(); i++) {\n            if (sum + candidates[i] > target) {\n                break;\n            }\n            temp.push_back(candidates[i]);\n            backtracking(candidates, target, sum + candidates[i], i); // 隐含sum的回溯，注意这里是i不是start（因为是这个数及其以后的可选），也不是i+1（因为可以重复选取）\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end()); // 注意需要有序的时候，我们的break策略才是成立的\n        backtracking(candidates, target, 0, 0);\n        return output;\n    }\n};\n```\n\n差不多的写法，只是把target直接改了\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int>& candidates, int target, int startIdx) {\n        if (target < 0) {\n            return;\n        }\n        if (target == 0) {\n            output.emplace_back(temp);\n            return;\n        }\n        for (int i = startIdx; i < candidates.size(); i++) {\n            temp.emplace_back(candidates[i]);\n            backtracking(candidates, target - candidates[i], i);\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n        backtracking(candidates, target, 0);\n        return output;\n    }\n};\n```\n\n\n\n### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)\n\n> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。\n>\n> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。\n>\n> **注意：**解集不能包含重复的组合。 \n\ncandidates中有重复的数字，这个重复数字可以在同一个解里面使用，但是解集不能包含重复的元素。例如：\n\n```\n输入: candidates = [10,1,2,7,6,1,5], target = 8,\n输出:[[1,1,6],[1,2,5],[1,7],[2,6]]\n```\n\n所以不能直接通过以下方式将输入candidates数组去重来实现\n```cpp\n        sort(candidates.begin(), candidates.end());\n        auto end_unique = unique(candidates.begin(), candidates.end());\n        candidates.erase(end_unique, candidates.end());\n```\n\n**我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。\n\n![40.组合总和II](/20230310000918.png)\n\n与39题的区别：\n\n+ 同意元素不能无限取，所以递归时候是`i+1`。\n+ 加入了这一个判断`i > start && candidates[i] == candidates[i-1]`，以防止出现一摸一样的结果。第二部分很好理解，就是说如果这一个和上一个值是一样的，那我就跳过。但是注意到同一个树枝上面的元素是可以重复的，所以需要`i > start`这一约束，防止直接不让重复了，也就保证了示例中的`[1,1,6]`这组解还是能够出来。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    void backtracking (vector<int>& candidates, int target, int sum, int start) {\n        if (sum == target) {\n            output.emplace_back(temp);\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            if (i > start && candidates[i] == candidates[i-1]) {\n                continue;\n            }\n            if (sum + candidates[i] > target) {\n                break;\n            }\n            temp.emplace_back(candidates[i]);\n            backtracking(candidates, target, sum + candidates[i], i + 1);\n            temp.pop_back();\n        }\n    }\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        backtracking(candidates, target, 0, 0);\n        return output;\n    }\n};\n```\n\n### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)\n\n> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 回文串 。返回 `s` 所有可能的分割方案。\n>\n> **回文串** 是向前和向后读都相同的字符串。\n\n#### 解法一——暴力回溯\n\n检测到是回文串送入temp\n\n+ 在处理组合问题的时候，递归参数需要传入start，表示下一轮递归遍历的起始位置，这个start就是切割线。\n+ 为了方便处理回文串，也要传入start和end，就可以减少切割。\n+ `start == s.length() - 1`时，最后一个值还没有传入\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> output;\n    vector<string> temp;\n\n    bool isPalindrome (string s, int start, int end) {\n        for (int i = start, j = end; i < j; i++, j--) {\n            if (s[i] != s[j]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    void backtracking (string s, int start) {\n        if (start > s.length() - 1) { // 注意这里是>，而非==，因为最后一个start也要存入\n            output.emplace_back(temp);\n            return;\n        }\n\n        for (int i = start; i < s.length(); i++) {\n            if (isPalindrome(s, start, i)) {\n                temp.emplace_back(s.substr(start, i - start + 1));\n            }\n            else {\n                continue;\n            }\n            backtracking(s, i + 1);\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<string>> partition(string s) {\n        backtracking(s, 0);\n        return output;\n    }\n};\n```\n\n#### 解法二——回溯+优化回文串的识别\n\n给定字符串`\"abcde\"`, 在已知`\"bcd\"`不是回文字串时, 不再需要去双指针操作`\"abcde\"`而可以直接判定它一定不是回文字串。\n\n具体来说, 给定一个字符串`s`, 长度为`n`, 它成为回文字串的充分必要条件是`s[0] == s[n-1]`且`s[1:n-1]`是回文字串。\n\n![image-20240410155458022](/image-20240410155458022.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> output;\n    vector<string> temp;\n    vector<vector<bool>> isPalindrome; //放事先计算好的是否回文子串的结果\n\n    void computePalindrome (string &s) {\n        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 \n        isPalindrome.resize(s.length(), vector<bool> (s.length(), true)); // 创建二维数组，长度为s.length() x s.length()，全部赋值为true\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for(int j = i + 1; j < s.length(); j++) {\n                // 需要保证计算[i, j]区间时候，[i+1, j-1]区间已经计算完毕\n                isPalindrome[i][j] = (s[i] == s[j]) && isPalindrome[i+1][j-1];\n                // if (j == i) {isPalindrome[i][j] = true;} // 等于的时候必然是true，不需要重新赋值\n                // else if (j - i == 1) {isPalindrome[i][j] = (s[i] == s[j]);} //差一位的时候，第二个条件相当于已经满足了，因为是true\n                // else {isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i+1][j-1]);}\n            }\n        }\n    }\n\n    void backtracking (string s, int start) {\n        if (start > s.length() - 1) { // 注意这里是>，而非==，因为最后一个start也要存入\n            output.emplace_back(temp);\n            return;\n        }\n\n        for (int i = start; i < s.length(); i++) {\n            if (isPalindrome[start][i]) {\n                temp.emplace_back(s.substr(start, i - start + 1));\n                backtracking(s, i + 1);\n                temp.pop_back();\n            }           \n        }\n    }\n\n    vector<vector<string>> partition(string s) {\n        computePalindrome(s);\n        backtracking(s, 0);\n        return output;\n    }\n};\n```\n\n### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)\n\n> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。\n>\n> - 例如：`\"0.1.2.201\"` 和` \"192.168.1.1\"` 是 **有效** IP 地址，但是 `\"0.011.255.245\"`、`\"192.168.1.312\"` 和 `\"192.168@1.1\"` 是 **无效** IP 地址。\n>\n> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。\n\n先考虑暴力回溯，在考虑剪枝\n\n#### 解法一——暴力回溯，temp是字符串数组\n\n注意这里不需要代码中对i的for循环，这个本来就是递归要做的循环，还是没有理解透啊，加入这个循环以后会导致缺数。\n\n这里也考虑了一点剪枝的问题\n\n+ 比如`j < start + 3`，就是每个segment值不会大于255，那么就不会大于3.\n+ 此外`if (segment > 4) {continue;}`，就是对于segment分段总数的限制。\n\n```cpp\nclass Solution {\npublic:\n    vector<string> output;\n    vector<string> temp;\n    bool isValidSegment (string sSegment) { // 左右皆为闭\n        if (sSegment.size() > 1 && sSegment[0] == '0') { // 多位前导0的情况\n            return false;\n        }\n        // cout << sSegment << \",\";\n        int num = stoi(sSegment);\n        if (num < 0 || num > 255){\n            return false;\n        }\n        else {\n            return true;\n        }\n    }\n\n    void backtracking(string s, int start, int segment) {\n        if (start == s.length() && segment == 4){\n            // string tempOutput = temp[0] + \".\" + temp[1] + \".\" + temp[2] + \".\" + temp[3];\n            // cout << temp[0] + \".\" + temp[1] + \".\" + temp[2] + \".\" + temp[3] << endl;\n            output.emplace_back(temp[0] + \".\" + temp[1] + \".\" + temp[2] + \".\" + temp[3]);\n            return;\n        }\n\n\n        // for (int i = start; i < s.length(); i++){\n            for (int j = start; j < start + 3 && j < s.length(); j++) {\n                string sSegment = s.substr(start, j - start + 1);\n                if (segment > 4) {\n                    continue;\n                }\n                if (isValidSegment(sSegment)) {\n                    temp.emplace_back(sSegment);\n                    backtracking(s, j + 1, segment + 1);\n                    temp.pop_back();\n                }\n            }\n        // }\n    }\n\n    vector<string> restoreIpAddresses(string s) {\n        backtracking(s, 0, 0);\n        return output;\n    }\n};\n```\n\n#### 解法二——temp就是对源字符串加点\n\n[代码随想录](https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF)的方法\n\n![93.复原IP地址](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png)\n\n```cpp\nfor (int i = startIndex; i < s.size(); i++) {\n    if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法\n        s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点\n        pointNum++;\n        backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2\n        pointNum--;                         // 回溯\n        s.erase(s.begin() + i + 1);         // 回溯删掉逗点\n    } else break; // 不合法，直接结束本层循环\n}\n```\n\n### [78. 子集](https://leetcode.cn/problems/subsets/)\n\n> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。\n>\n> 数组的 **子集** 是从数组中选择一些元素（可能为空）。\n\n其实还是一个组合问题，和顺序无关。\n\n**子集是收集树形结构中树的所有节点的结果**。\n\n**而组合问题、分割问题是收集树形结构中叶子节点的结果**。\n\n#### 解法一——递归\n\n##### 思路一——每个元素有选和不选两个情况\n\n递归的过程就是每次去掉一个数，再求子集。而每个元素又选和不选两个情况\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking (vector<int> nums, int start) {\n        if (start == nums.size()) {\n            output.emplace_back(temp);\n            return;\n        }\n\n        temp.emplace_back(nums[start]);\n        backtracking(nums, start + 1);\n        temp.pop_back();\n        backtracking(nums, start + 1);\n        \n    }\n\n    vector<vector<int>> subsets(vector<int>& nums) {\n        // vector<int> empty;\n        // output.emplace_back(empty);\n        backtracking(nums, 0);\n        return output;\n    }\n};\n```\n\n##### 思路二——遍历整个树的所有节点\n\n![78.子集](/78.子集.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking (vector<int> nums, int start) {\n        output.emplace_back(temp);\n        if (start >= nums.size()) {\n            return;\n        }\n\n        for (int i = start; i < nums.size(); i++) {\n            temp.emplace_back(nums[i]);\n            backtracking(nums, i + 1);\n            temp.pop_back();\n        }\n        \n        // backtracking(nums, start + 1);\n        \n    }\n\n    vector<vector<int>> subsets(vector<int>& nums) {\n        // vector<int> empty;\n        // output.emplace_back(empty);\n        backtracking(nums, 0);\n        return output;\n    }\n};\n```\n\n#### 解法二——枚举迭代\n\n创建一个0，1的mask实现枚举，相当于一个二进制的数组和当前数组取`与`。\n\n其中，`<<`是左移运算，每次乘2.\n\n+ `1 << numsSize`创建$0\\sim 2^{numsSize-1}$的二进制序列长度。\n+ `1 << i`判断该mask下，这个数字要不要push进去。注意`1 << 0`出来的是`001`，`1 << 1`出来的是`010`，`1 << 2`出来的是`100`，刚好与mask的各个位置吻合。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> output;\n        vector<int> temp;\n        int numsSize = nums.size();\n        for (int mask = 0; mask < (1 << numsSize); mask++) {\n            temp.clear();\n            for (int i = 0; i < numsSize; i++) {\n                if (mask & (1 << i)) {\n                    temp.emplace_back(nums[i]);\n                }\n            }\n            output.emplace_back(temp);\n        }\n        return output;\n    }\n};\n```\n\n### [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)\n\n> 给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。\n>\n> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。\n\n#### 解法一——递归\n\n套路类似“40. 组合总和 II”，先排序，如果和上一个相同的话，那就continue\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int> nums, int start) {\n        output.emplace_back(temp);\n\n        for  (int i = start; i < nums.size(); i++) {\n            if (i > start && nums[i] == nums[i-1]) {\n                continue;\n            }\n            temp.emplace_back(nums[i]);\n            backtracking(nums, i + 1);\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        backtracking(nums, 0);\n        return output;\n    }\n};\n```\n\n\n\n\n\n#### 解法二——枚举迭代\n\nmask需要考虑去重，i不需要考虑去重。\n\n要加入一个判断`if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1])`，这个不好想啊！\n\n对于当前选择的数*x*，若前面有与其相同的数 *y*，且没有选择 *y*，此时包含 *x* 的子集，必然会出现在包含 *y* 的所有子集中。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        int numSize = nums.size();\n        sort(nums.begin(), nums.end());\n        for (int mask = 0; mask < (1 << numSize); mask++) {\n            temp.clear();\n            bool flag = true;\n            for (int i = 0; i < numSize; i++) {\n                if (mask & (1 << i)) {\n                    if(i > 0 && (mask >>(i-1) & 1) == 0 && nums[i] == nums[i-1]) {\n                        flag = false;\n                        break;\n                    }\n                    temp.emplace_back(nums[i]);\n                }\n            }\n            if (flag) {\n                output.emplace_back(temp);\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [491. 非递减子序列](https://leetcode.cn/problems/non-decreasing-subsequences/)\n\n> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。\n>\n> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n\n\n\n求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。所以和子集问题并不一样！！！\n\n#### 解法一——深搜\n\n定义之前的最大值`last`\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int> nums, int start, int last) {\n        if (start == nums.size()) {\n            if (temp.size() >= 2) {\n                output.emplace_back(temp);\n            }\n            return;\n        }\n\n        if (nums[start] >= last) { // 输入并递归\n            temp.emplace_back(nums[start]);\n            backtracking(nums, start + 1, nums[start]);\n            temp.pop_back();\n        }\n        if (nums[start] != last) {\n            backtracking(nums, start + 1, last);\n        }\n    }\n\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        backtracking(nums, 0, INT_MIN);\n        return output;\n    }\n};\n```\n\n#### 解法二——回溯+set去重\n\n以下写法` if (i > start && nums[i] == nums[i-1])`是**错误**的，因为可能重复值并不出现在相邻元素，即使改成` if (i > start && nums[i] == last)`也不对，需要判断之前的所有元素才行。如测试用例`[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]`\n\n```cpp\nvoid backtracking(vector<int> nums, int start, int last) {\n        if (temp.size() >= 2) {\n            output.emplace_back(temp);\n        }\n\n        for(int i = start; i < nums.size(); i++){ \n            if (i > start && nums[i] == nums[i-1]) {\n                continue;\n            }\n            if (nums[i] >= last) {\n                temp.emplace_back(nums[i]);\n                backtracking(nums, i+1, nums[i]);\n                temp.pop_back();\n            }\n            // else {\n            //     backtracking(nums, i+1, last);\n            // }\n        }\n    }\n```\n\n所以需要用到set来记录之前的数据。\n\n```cpp\n    void backtracking(vector<int> nums, int start, int last) {\n        if (temp.size() >= 2) {\n            output.emplace_back(temp);\n        }\n\n        unordered_set<int> thisLayer;\n        for(int i = start; i < nums.size(); i++){ // 使用set对本层元素进行去重\n            if (i > start && thisLayer.find(nums[i]) != thisLayer.end()) {\n                continue;\n            }\n            if (nums[i] >= last) {\n                temp.emplace_back(nums[i]);\n                thisLayer.insert(nums[i]);\n                backtracking(nums, i+1, nums[i]);\n                temp.pop_back();\n            }\n        }\n    }\n```\n\n或者用数组来作为哈希\n\n```cpp\n    void backtracking(vector<int> nums, int start, int last) {\n        if (temp.size() >= 2) {\n            output.emplace_back(temp);\n        }\n\n        int thisLayer[201] = {0};\n        for(int i = start; i < nums.size(); i++){ \n            if (i > start && thisLayer[nums[i] + 100] != 0) {\n                continue;\n            }\n            if (nums[i] >= last) {\n                temp.emplace_back(nums[i]);\n                thisLayer[nums[i] + 100]++;\n                backtracking(nums, i+1, nums[i]);\n                temp.pop_back();\n            }\n        }\n    }\n```\n\n此外可以不定义last元素。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int> nums, int start) {\n        if (temp.size() >= 2) {\n            output.emplace_back(temp);\n        }\n\n        int thisLayer[201] = {0};\n        for(int i = start; i < nums.size(); i++){ \n            if ((!temp.empty() && nums[i] < temp.back()) || thisLayer[nums[i] + 100] != 0) {\n                continue;\n            }\n            temp.emplace_back(nums[i]);\n            thisLayer[nums[i] + 100]++;\n            backtracking(nums, i+1);\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> findSubsequences(vector<int>& nums) {\n        // sort(nums.begin(), nums.end());\n        backtracking(nums, 0);\n        return output;\n    }\n};\n```\n\n### [46. 全排列](https://leetcode.cn/problems/permutations/)\n\n> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。\n\n排列问题\n\n排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:\n\n![46.全排列](/20211027181706.png)\n\n因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。**而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次**。\n\n这里的used数组和非递减子集中的set含义非常像，虽然这边是用于标记是否使用过，上文是用于是否有重复元素。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n    \n    void backtracking(vector<int> nums, vector<bool> &used) {\n        if (temp.size() == nums.size()) { // 终止条件\n            output.emplace_back(temp);\n            return;\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (used[i]) {\n                continue;\n            }\n            used[i] = true;\n            temp.emplace_back(nums[i]);\n            backtracking(nums, used);\n            temp.pop_back();\n            used[i] = false;\n        }\n    }\n\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<bool> used (nums.size(), false);\n        backtracking(nums, used);\n        return output;\n    }\n};\n```\n\n### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)\n\n> 给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。\n\n#### 解法一——利用`unordered_map`\n\n相当于定义了一个hash表，存储每个数字(first，键)能用多少次(second，值)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int> nums,  unordered_map<int,int> &used) {\n        if (temp.size() == nums.size()) {\n            output.emplace_back(temp);\n            return;\n        }\n\n        for (auto p = used.begin(); p != used.end(); p++) { \n            if (p->second == 0 ) {\n                continue;\n            }\n            p->second--;\n            temp.emplace_back(p->first);\n            backtracking(nums, used);\n            temp.pop_back();\n            p->second++;\n        }\n    }\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        unordered_map<int,int> used;\n        for (int num:nums) {\n            used[num] ++;\n        }\n        backtracking(nums, used);\n        return output;\n    }\n};\n```\n\n#### 解法二——利用used数组，并对其限制条件\n\n只要设定一个规则，保证在填第idx 个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」\n\n这里涉及两个条件，关系为“或”，第二个条件很好理解，用过了就不能用了，第一个条件有点难理解：\n\n+ `i > 0 && nums[i] == nums[i-1] && used[i-1] == false`\n+ `used[i] == true`\n\n`i > 0 && nums[i] == nums[i-1] && used[i-1] == false`限制了从左到右填入的顺序，属于是“同层（树层）剪枝”\n\n![image-20240411144113495](/image-20240411144113495.png)\n\n![47.全排列II2](/20201124201406192.png)\n\n如果该作`i > 0 && nums[i] == nums[i-1] && used[i-1] == true`，则变成“不同层（树枝）剪枝”，情况复杂很多\n\n<img src=\"/image-20240411144439089.png\" alt=\"image-20240411144439089\" style=\"zoom:33%;\" />\n\n![47.全排列II3](/20201124201431571.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> output;\n    vector<int> temp;\n\n    void backtracking(vector<int> nums,  vector<bool> &used) {\n        if (temp.size() == nums.size()) {\n            output.emplace_back(temp);\n            // cout << \"return \" << endl;\n            return;\n        }\n\n        for (int i = 0; i < nums.size(); i++) { \n            // for (bool jj:used) {\n            //     cout << jj << \" \";\n            // }\n            if ((i > 0 && nums[i] == nums[i-1] && used[i-1] == false) || used[i] == true) {\n                // cout << \"continue \"<< endl;\n                continue;\n            }\n            // cout << endl;\n            temp.emplace_back(nums[i]);\n            used[i] = true;\n            backtracking(nums, used);\n            used[i] = false;\n            temp.pop_back();\n        }\n    }\n\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<bool> used(nums.size(), false);\n        backtracking(nums, used);\n        return output;\n    }\n};\n\n```\n\n### [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)\n\n> 给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n>\n> 所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n>\n> - 例如，行程 `[\"JFK\", \"LGA\"]` 与 `[\"JFK\", \"LGB\"]` 相比就更小，排序更靠前。\n>\n> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n\n一个机场映射多个机场，同时由于字典顺序小的行程，所以需要里面套的是有序的map：两种表示\n\n+ `unordered_map<string, multiset> targets`：`unordered_map<出发机场, 到达机场的集合> targets`遍历multiset不能删除元素\n+ `unordered_map<string, map<string, int>> targets`：`unordered_map<出发机场, map<到达机场, 航班次数>> targets`可以使用\"航班次数\"这个字段的数字做相应的增减，来标记到达机场是否使用过了。\n\n有几个点需要注意：\n\n+ 最终的路径长度应该是比ticket长度要大1的\n+ 在使用迭代器遍历元素时候，如果要改变元素值，需要使用`&`，即`for (auto &p : airports[last])`\n+ vector，map元素遍历时候的写法要注意。**难还难在容器的选择和使用上**\n+ 该题目的情况下，应该采用有返回值的回溯比较好。\n\n```cpp\nclass Solution {\npublic:\n    vector<string> output;\n    unordered_map <string, map<string, int>> airports;\n\n    bool backtracking (string last, int ticketsSize) {\n        if (output.size() == ticketsSize + 1) {\n            return true;\n        }\n\n        for (auto &p : airports[last]) {\n            if (p.second !=  0) {\n                p.second--;\n                output.emplace_back(p.first);\n                if (backtracking(p.first, ticketsSize)) {\n                    return true;\n                }\n                output.pop_back();\n                p.second++;\n            }\n        }\n        return false;\n    }\n\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        int ticketsSize = tickets.size();\n        // 建立unordered_map存储一对多的机场关系\n        for (auto p: tickets) {\n            airports[p[0]][p[1]] ++;\n        }\n        output.emplace_back(\"JFK\");\n        backtracking(output.back(), ticketsSize);\n        return output;\n    }\n};\n```\n\n### [51. N 皇后](https://leetcode.cn/problems/n-queens/)\n\n> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\n>\n> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。\n>\n> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。\n>\n> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。\n\n根据题意暴力回溯即可，和代码随想录不同。\n\n+ 利用 columns 数组记录每个皇后的位置，最后再构建棋盘\n+ 这样判断是否合理时候比较简单，只需要考虑列不同、左斜、右斜等几种情况即可。\n+ 其实还可以进一步简化，当第一行只需要一半即可，因为偶数时候必定有对称的情况，奇数时候除了第一行刚好为中间，其余也有对称情况。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> output;\n    vector<int> columns; //n个位置，表示第n个皇后在第n行的第几个格子\n    void backtracking (int n, int row) {\n        if (row == n) {\n            vector<string> temp(n, string(n, '.'));            \n            for (int i = 0; i < n; i++) {\n                // if (!(n % 2) && columns[0] == n / 2) { // 奇数列情况，中间的情况是不能反转的\n                temp[i][columns[i]] = 'Q';\n            }\n            output.emplace_back(temp);\n            // cout << endl;\n            return;\n        }\n        bool flag = false; // flag检测列标是否和前面元素冲突\n        for(int column = 0; column < n; column++) { //第row元素的列标, 一定有一个反转的情况成立\n            flag = false;\n            for (int j = 0; j < row; j++) { // j表示前面的行\n                if (columns[j] == column || (row - j) == (columns[j] - column) || (row - j) == - (columns[j] - column)) { // 列标重合，斜线\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) { // 没问题，回溯\n                columns.emplace_back(column);\n                backtracking(n, row + 1);\n                columns.pop_back();\n            }\n        }\n\n    }\n\n    vector<vector<string>> solveNQueens(int n) {\n        backtracking(n, 0);\n        return output;\n    }\n};\n```\n\n### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)\n\n> 编写一个程序，通过填充空格来解决数独问题。\n>\n> 数独的解法需 **遵循如下规则**：\n>\n> 1. 数字 `1-9` 在每一行只能出现一次。\n> 2. 数字 `1-9` 在每一列只能出现一次。\n> 3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）\n>\n> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。\n\n```cpp\nclass Solution {\npublic:\n    bool backtracking(vector<vector<char>>& board, int row, int column) {\n        if (row >= 9 || column >= 9) {\n            return true;\n        }\n        if (board[row][column] < '1' || board[row][column] > '9') { // 注意这里是或的关系\n            int num = 1;\n            for (num = 1; num < 10; num++) {\n                // cout << row << \" \" << column << \" \" << num << endl;\n                if (isValid(board, row, column, num)) {\n                    board[row][column] = num + '0';\n                    // cout << row << \" \" << column << \" \" << num << endl;\n                    if (column == 9 - 1) {\n                        if (backtracking(board, row + 1, 0)) {\n                            return true;\n                        } // 换行\n                    }\n                    else {\n                        if (backtracking(board, row, column + 1)) {\n                            return true;\n                        } // 继续\n                    }\n                    board[row][column] = '.';\n                }\n            }\n            if (num == 10 && board[row][column] == '.') {\n                return false; // 不能让一元素为.，说明前面是有错的, 注意已经自增过了，所以这里是10\n            }\n        }\n        if (column == 9 - 1) {\n            if (backtracking(board, row + 1, 0)) {\n                return true;\n            } // 换行\n        }\n        else {\n            if (backtracking(board, row, column + 1)) {\n                return true;\n            } // 继续\n        }\n        return false;\n    }\n    \n    bool isValid (vector<vector<char>>& board, int row, int column, int num) {\n        // cout << row << \" \" << column << \" \" << num << endl;\n        for (int i = 0; i < 9; i++) { // 检查同一行\n            if (board[row][i] - '0' == num) {\n                return false;\n            }\n        }\n        for (int j = 0; j < 9; j++) { // 检查同一列\n            if (board[j][column] - '0' == num) {\n                return false;\n            }\n        }\n        int blockLeft = (column / 3) * 3;\n        int blockTop = (row / 3) * 3;\n        for (int i = blockLeft; i < blockLeft + 3; i++) {\n            for (int j = blockTop; j < blockTop + 3; j++) {\n                if (board[j][i] - '0' == num) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    void solveSudoku(vector<vector<char>>& board) {\n        backtracking(board, 0, 0);\n    }\n};\n```\n\n代码随想录的解答略有区别，主要是他直接把每个顶点的循环放在backtracking里面了，这样里面每一次跑都会进入两层for循环，如果有值就continue；此外循环可以直接通过` for (char k = '1'; k <= '9'; k++)`来进行，就不需要补`+'0'`的操作了。\n\n\n\n## 贪心算法\n\n> **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。\n>\n> 如何验证可不可以用贪心算法呢？**最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**。\n>\n> 贪心算法一般分为如下四步：\n>\n> - 将问题分解为若干个子问题\n> - 找出适合的贪心策略\n> - 求解每一个子问题的最优解\n> - 将局部最优解堆叠成全局最优解\n>\n> ![贪心算法大纲](/20210917104315.png)\n>\n> 区间类问题——先排序\n\n### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)\n\n> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n>\n> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n\n#### 解法一——两重for循环\n\n优先满足胃口大的\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int output = 0;\n        int gStart = g.size() - 1;\n        for (int i = s.size() - 1; i >= 0; i--) { // 优先满足胃口大的\n            for (int j = gStart; j >= 0; j--) {\n                // cout << s[i] << \" \" << g[j] << endl;\n                if (s[i] >= g[j]) {\n                    \n                    output++;\n                    gStart = j - 1; // 从目前满足的下一个开始\n                    break;\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——一层for循环\n\n```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int output = 0;\n        int sStart = s.size() - 1;\n        for (int i = g.size() - 1; i >= 0; i--) { // 优先满足胃口大的\n            if (sStart >= 0 && s[sStart] >= g[i]) {\n                output++;\n                sStart--;\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)\n\n> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n>\n> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。\n> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n>\n> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n>\n> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。\n\n+ 局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。\n+ 其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点\n\n考虑的因素\n\n+ 单调坡度只记录首尾\n+ 需要考虑平坡（两种情况）\n  ![img](/20230108174452.png)\n+ 只有一个或两个元素——两个元素判断是否是平坡\n\n#### 解法一——贪心\n\n起点终点、平坡比较难判断。。。（还是没太想清楚，后面仔细想想）\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        if (nums.size() <= 1) {\n            return nums.size();\n        }\n\n        int index0, index1; \n        int output = (nums[1] - nums[0] == 0) ? 1 : 2; \n        for (index0 = 0, index1 = 1; index1 < nums.size() - 1; index1++) {\n            cout << \" index0: \" << nums[index0] << \" index1: \" << nums[index1] << \" index2:\" << nums[index1+1];\n            cout << \" prev: \" << (nums[index1] - nums[index0]) << \" curr: \" << (nums[index1+1] - nums[index1])<< endl;\n            if (((nums[index1] - nums[index0]) * (nums[index1 + 1] - nums[index1]) < 0) || ((nums[index1] - nums[index0]) == 0) && (nums[index1 + 1] - nums[index1]) != 0) { //满足摆动\n                output++;\n                index0 = index1;\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n考虑用动态规划的思想来解决这个问题。\n\n1. *up*[*i*] 表示以前 *i* 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。\n2. *down*[*i*] 表示以前 *i* 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。\n\n$$\n\\begin{aligned}\n& u p[i]= \\begin{cases}u p[i-1], & \\text { nums }[i] \\leq n u m s[i-1] \\\\\n\\max (u p[i-1], \\text { down }[i-1]+1), & \\text { nums }[i]>\\text { nums }[i-1]\\end{cases} \\\\\n& \\operatorname{down}[i]= \\begin{cases}\\operatorname{down}[i-1], & \\text { nums }[i] \\geq \\text { nums }[i-1] \\\\\n\\max (u p[i-1]+1, \\text { down }[i-1]), & \\text { nums }[i]<\\text { nums }[i-1]\\end{cases}\n\\end{aligned}\n$$\n\n仅需要前一个状态来进行转移，所以我们维护两个变量即可。\n\n——官方题解\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int numSize = nums.size();\n        if (numSize < 2) {\n            return numSize;\n        }\n        vector <int> up(numSize) ;\n        vector <int> down(numSize);\n        up[0] = down[0] = 1; //长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。\n        for(int i = 1; i < numSize; i++) {\n            if (nums[i] > nums[i-1]) { // 比上一个大\n                up[i] = max(up[i-1], down[i-1] + 1); //上摆情况是在“上一元素上摆”和“上一元素下摆的基础上加上这个元素上摆”\n                down[i] = down[i-1]; // 加入这个元素不能组成下摆\n            }\n            else if (nums[i] < nums[i-1]) { // 比上一个元素小，不可能上摆\n                down[i] = max(down[i-1], up[i-1] + 1);\n                up[i] = up[i-1];\n            }\n            else { // 相等\n                up[i] = up[i-1];\n                down[i] = down[i-1];\n            }\n        }\n        return max(up[numSize-1], down[numSize-1]);\n    }\n};\n```\n\n仅需要前一个状态来进行转移，所以我们维护两个变量即可。每有一个「峰」到「谷」的下降趋势，*down* 值才会增加，每有一个「谷」到「峰」的上升趋势，*up* 值才会增加。且过程中 *down* 与 *up* 的差的绝对值值恒不大于 1，\n\n```cpp\nclass Solution {\npublic:\n    int wiggleMaxLength(vector<int>& nums) {\n        int numSize = nums.size();\n        if (numSize < 2) {\n            return numSize;\n        }\n        int up = 1, down = 1; //长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」 之和\n        for(int i = 1; i < numSize; i++) {\n            if (nums[i] > nums[i-1]) { // 比上一个大\n                up =  down + 1); //上摆情况是在“上一元素上摆”和“上一元素下摆的基础上加上这个元素上摆”\n            }\n            else if (nums[i] < nums[i-1]) { // 比上一个元素小，不可能上摆\n                down =  up + 1;\n            }\n        }\n        return max(up, down);\n    }\n};\n```\n\n### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n> **子数组**是数组中的一个连续部分。**子数组** 是数组中连续的 **非空** 元素序列。\n\n#### 解法一——贪心\n\n局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。\n\n全局最优：选取最大“连续和”\n\n**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。\n\n注意“连续和”为负数的时候前一个数字一定为负数，所以应该要舍弃。其关键在于：**不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数**。\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int sum = 0;\n        int output = INT_MIN;\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i];\n            if (sum > output) {\n                output = sum;\n            }\n            if (sum <= 0) {\n                sum = 0;\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n其实和贪心的思路很类似，只是把sum变成了dp数组。但是思路比贪心好想。\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        if (nums.size() == 0) {\n            return 0;\n        }\n        vector<int> dp(nums.size());\n        dp[0] = nums[0];\n        int output = dp[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dp[i] = max(dp[i-1] + nums[i], nums[i]);\n            if (dp[i] > output) {\n                output = dp[i];\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n>\n> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 返回 *你能获得的 **最大** 利润* 。\n\n#### 解法一——贪心\n\n**其实最终利润是可以分解的，那么本题就很容易了！**\n\n假如第 0 天买入，第 3 天卖出，那么利润为：`prices[3] - prices[0]`。相当于`(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])`。**此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！**\n\n但是不同的天的是可以叠加的。所以可以一天一天的利润考虑，只要有利润>0就买。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int output = 0;\n        int profitDay = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            profitDay = prices[i] - prices[i-1];           \n            if (profitDay > 0) {\n                output += profitDay;\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n- `dp[i][0]` 表示第i天持有股票所得现金。\n- `dp[i][1]` 表示第i天不持有股票所得最多现金\n\n如果第$i$天持有股票即`dp[i][0]`， 那么可以由两个状态推出来\n\n- 第$i-1$天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`\n- 第$i$天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int> (2));\n        dp[0][0] -= prices[0]; // 第0天持有股票目前的利润\n        dp[0][1] = 0; // 第0天不持有股票\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]); // 第i-1天有股票不动，或第i-1天没有股票买进\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]); // 第i-1天没有股票不动，或第i-1天有股票卖出\n        }\n        return dp[prices.size()-1][1];\n    }\n};\n```\n\n### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)\n\n> 给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n>\n> 判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。\n\n**转化为跳跃覆盖范围究竟可不可以覆盖到终点！**每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。\n\n**贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点**。\n\n```cpp\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        int maxIndex = 0;\n        int numSize = nums.size();\n        for (int i = 0; i <= maxIndex && i < numSize; i++) {\n            maxIndex = max(maxIndex, i + nums[i]);\n            if (maxIndex >= numSize - 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)\n\n> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。\n>\n> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:\n>\n> - `0 <= j <= nums[i]` \n> - `i + j < n`\n>\n> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。\n\n生成到每个位置所需的最少跳跃次数。每个位置的最少跳跃次数是连续的。只要每一次在这个最小跳跃次数覆盖范围内找下一次的覆盖范围即可。\n\n```cpp\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int minJump = 0; //记录当前位置需要最少几次跳跃到达\n        int maxIndex = 0; //记录当前能到达的最远位置\n        int premaxIndex = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if(premaxIndex < 0) {\n                minJump++;\n                premaxIndex = maxIndex - i;\n            }\n            if (nums[i] + i > maxIndex) { // 可以更新maxIndex\n                maxIndex = nums[i] + i;\n            }\n            premaxIndex--;\n            // cout << i << \" \" << minJump << \" \" << maxIndex << endl;\n        }\n        return minJump;\n    }\n};\n```\n\n另一个思路\n\n```cpp\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int maxJump = 0; // 最远到\n        int jumpTimes = 0; // 目前的位置要跳几次\n        int preMaxJump = 0; // 上一次最远到\n\n        for(int i = 0; i < nums.size(); i++) {\n            if (i <= preMaxJump) {\n                if (nums[i] + i > maxJump) { // 能跳的比目前的远\n                    maxJump = nums[i] + i;\n                }\n            }\n            else {\n                jumpTimes++;\n                preMaxJump = maxJump;\n                if (nums[i] + i > maxJump) { // 能跳的比目前的远\n                    maxJump = nums[i] + i;\n                }\n            }\n        }\n        return jumpTimes;\n    }\n};\n```\n\n\n\n### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：\n>\n> - 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。\n>\n> 重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。\n>\n> 以这种方式修改数组后，返回数组 **可能的最大和**\n\n#### 解法一——逻辑复杂的分类讨论\n\n分三种情况：\n\n+ 负数：①负数个数>=k，②负数个数<k\n+ 0：有无0\n+ 正数\n\n其实0和负数可以统一考虑，当非正数<k时，倒数的那个数字反转剩余次数即可。\n\n先排序，优先反转小的负数，这里考虑的一些情况：\n\n+ 负数或0：k用完没有？用完了那就只能是负数了\n+ 正数：k还有没有没用完，只需要考虑模2为1的情况，也就是得翻转一个数的情况，没用完有两种情况\n  + 前面有负数，且那个负数绝对值比正数最小的要小，反转最大的负数\n  + 前面没有负数了，或者负数绝对值比正数最小的要大，反转最小的正数\n+ 还有一个情况，全是负数，那么可能出现出循环k还没用完的情况，那需要考虑是否需要反转最大的负数。\n\n```cpp\nclass Solution {\npublic:\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        bool flagNotPositive = true; //非正数\n        int output = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] <= 0) {\n                if (k > 0) {\n                    output -= nums[i];\n                }\n                else {\n                    output += nums[i];\n                }\n                k--;\n            }\n            else {\n                if (flagNotPositive == true) {\n                    flagNotPositive = false;\n                    if (k > 0 && k % 2 == 1) {\n                        if (i > 0 && -nums[i-1] < nums[i] ) {\n                            output += 2 * nums[i-1];\n                        }\n                        else {\n                            output -= 2 * nums[i];\n                        }\n                    }\n                }\n                output += nums[i];\n            }\n            // cout << nums[i] << \" \" << output << endl;\n        }\n        if (k > 0 && k % 2 == 1 &&  nums[nums.size()-1] < 0) {\n            output += 2 * nums[nums.size()-1];\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——贪心\n\n这里思路和我最大的不同就是按照绝对值大小排序。。。能减轻很多负担\n\n- 第一步：将数组按照绝对值大小从大到小排序，**注意要按照绝对值的大小**\n- 第二步：从前向后遍历，遇到负数将其变为正数，同时K--\n- 第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完\n- 第四步：求和\n\n两次贪心：\n\n+ 局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。\n+ 一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大，全局最优：整个 数组和 达到最大。\n\n```cpp\nclass Solution {\nstatic bool cmp(int a, int b) {\n    return abs(a) > abs(b);\n}\npublic:\n    int largestSumAfterKNegations(vector<int>& nums, int k) {\n        sort (nums.begin(), nums.end(), cmp);\n        int output = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] < 0 && k-- > 0) {\n                nums[i] = - nums[i];\n            }\n            output += nums[i];\n        }\n        if (k > 0 && k % 2 == 1) {\n            output -= 2 * nums[nums.size()-1]; // 不管最后一个数原本是正负均成立，因为转成正数了\n        }\n        return output;\n    }\n};\n```\n\n### [134. 加油站](https://leetcode.cn/problems/gas-station/)\n\n> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。\n>\n> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。\n>\n> 给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。\n\n#### 解法一——暴力解法+一点点优化\n\n如果x到达不了y+1，那么x-y之间的点也不可能到达y+1，因为中间任何一点的油都是拥有前面的余量的，所以下次遍历直接从y+1开始\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int n = gas.size();\n        // if (accumulate(gas.begin(), gas.end(), 0) < accumulate(gas.begin(), gas.end(), 0)) {\n        //     return -1;\n        // }\n        for (int i = 0; i < n; i++) {\n            int gasSum = 0;\n            int j = 0;\n            for (j = 0; j < n; j++) {\n                int station = (i + j) % n;\n                gasSum = gasSum + gas[station] - cost[station];\n                if (gasSum < 0) {\n                    // cout << \"break\" << endl;\n                    break;\n                }\n                // cout <<  station << \" \" << gasSum << endl;\n            }\n            if (j == n) { // 说明转完一圈了\n                return i;\n            }\n            else {\n                i = i + j;\n            }\n        }\n        return -1;\n    }\n};\n```\n\n#### 解法二——贪心\n\n首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。\n\n局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。\n\n```cpp\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int curSum = 0;\n        int totalSum = 0;\n        int start = 0;\n        for (int i = 0; i < gas.size(); i++) {\n            curSum += gas[i] - cost[i];\n            totalSum += gas[i] - cost[i];\n            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0\n                start = i + 1;  // 起始位置更新为i+1\n                curSum = 0;     // curSum从0开始\n            }\n        }\n        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了\n        return start;\n    }\n};\n```\n\n——代码随想录\n\n###  [135. 分发糖果](https://leetcode.cn/problems/candy/)\n\n> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。\n>\n> 你需要按照以下要求，给这些孩子分发糖果：\n>\n> - 每个孩子至少分配到 `1` 个糖果。\n> - 相邻两个孩子评分更高的孩子会获得更多的糖果。\n>\n> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。\n\n#### 解法一——两次贪心\n\n两次贪心的策略：\n\n- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。\n- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况。\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        vector<int> candys(ratings.size(), 1);\n        for (int i = 1; i < ratings.size(); i++) {//从左到右贪心\n            if (ratings[i] > ratings[i-1]) {\n                candys[i] = candys[i-1] + 1;\n            }\n        }\n        for (int j = ratings.size() - 2; j >= 0; j--) {// 从右往左贪心，注意更新值的时候比较的值要已经更新过了\n            if (ratings[j] > ratings[j+1]) {\n                candys[j] = max(candys[j] , candys[j+1] + 1);\n            }\n        }\n        return accumulate(candys.begin(), candys.end(), 0);\n    }\n};\n```\n\n#### 解法二——常数空间遍历\n\n我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为 pre：\n\n+ 如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 pre+1 个糖果即可。\n  <img src=\"/1.png\" alt=\"fig1\" style=\"zoom:33%;\" />\n+ 否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。\n  + 我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。\n    <img src=\"/2.png\" alt=\"fig2\" style=\"zoom: 33%;\" />\n  + 同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。\n    <img src=\"/3.png\" alt=\"fig3\" style=\"zoom: 33%;\" />\n\n我们只要记录当前递减序列的长度 dec，最近的递增序列的长度 inc 和前一个同学分得的糖果数量 pre 即可。\n\n——力扣官方题解\n\n可以同时考虑两边的问题，只是右边的问题通过前面递减序列加1得到。（真的想不到啊）\n\n```cpp\nclass Solution {\npublic:\n    int candy(vector<int>& ratings) {\n        int pre = 1;\n        int dec = 0;\n        int inc = 1;\n        int output = 1;\n        for (int i = 1; i < ratings.size(); i++) {\n            if (ratings[i] > ratings[i-1]) {\n                dec = 0;\n                output += ++pre;\n                inc = pre;\n            }\n            else if (ratings[i] == ratings[i-1]) { //相等=》归一\n                dec = 0;\n                pre = 1;\n                output += pre;\n                inc = 1;\n            }\n            else { //小于\n                // cout << \" A \" << dec << \" B \" << inc << \" \";\n                dec ++;\n                if (dec == inc) { // 合并入最后一个上升节点\n                    dec ++;\n                }\n                output += dec; //而非pre，因为最新加入的这个元素一定是1，但是递减序列中前面的元素还需要+1\n                pre = 1;\n            }\n            // cout << output << \" \";\n        }\n        return output;\n    }\n};\n```\n\n### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)\n\n> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。\n>\n> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。\n>\n> 注意，一开始你手头没有任何零钱。\n>\n> 给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。\n\n账单是20的情况，为什么要优先消耗一个10和一个5呢？**因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！**\n\n局部最优：遇到账单20，优先消耗美元10，完成本次找零。\n\n全局最优：完成全部账单的找零。\n\n```cpp\nclass Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int note5 = 0;\n        int note10 = 0;\n        for (int i = 0; i < bills.size(); i++) {\n            if (bills[i] == 5) {\n                note5 ++;\n            }\n            else if (bills[i] == 10) {\n                note5 --;\n                note10 ++;\n                if (note5 < 0) {\n                    return false;\n                }\n            }\n            else { // 20 dollar\n                if (note10 > 0 && note5 > 0) {\n                    note10--;\n                    note5--;\n                }\n                else if (note5 >= 3) {\n                    note5 = note5 - 3;\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)\n\n> 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。\n>\n> 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。\n\n在按照身高从大到小排序后：\n\n**局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性**\n\n**全局最优：最后都做完插入操作，整个队列满足题目队列属性**\n\n#### 解法一——插入用数组\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (vector<int> x, vector<int> y) {\n        return x[0] > y[0] || (x[0] == y[0] && x[1] < y [1]);\n        // 保证这个元素前面的值比他大或相等\n    }\n\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        int peopleSize = people.size();\n        // 先考虑身高，前面的都比他大或者相等，相等的时候k越小越靠前\n        sort (people.begin(), people.end(), cmp);\n        // for (int i = 0; i < peopleSize; i++) {\n        //     cout << \"[\" << people[i][0] << \",\" << people[i][1] << \"],\";\n        // }\n        // cout << endl;\n        // 只需要按照k为下标重新插入队列即可，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点\n        vector<vector<int>> Q;\n        for (int i = 0; i < peopleSize; i++) {\n            Q.insert(Q.begin() + people[i][1], people[i]);\n        }\n\n        return Q;\n    }\n};\n```\n\n#### 解法二——插入用链表\n\nlist内部使用链表实现\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (vector<int> x, vector<int> y) {\n        return x[0] > y[0] || (x[0] == y[0] && x[1] < y [1]);\n        // 保证这个元素前面的值比他大或相等\n    }\n\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        int peopleSize = people.size();\n        // 先考虑身高，前面的都比他大或者相等，相等的时候k越小越靠前\n        sort (people.begin(), people.end(), cmp);\n\n        // 只需要按照k为下标重新插入队列即可，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点\n        list<vector<int>> Q;\n        for (int i = 0; i < peopleSize; i++) {\n            int position = people[i][1];\n            list<vector<int>>::iterator it = Q.begin();\n            while (position--) {\n                it++;\n            }\n            Q.insert(it, people[i]);\n        }\n        return vector<vector<int>> (Q.begin(), Q.end());\n    }\n};\n```\n\n### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)\n\n> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。\n>\n> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `xstart`，`xend`， 且满足  `xstart ≤ x ≤ xend`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。\n>\n> 给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。\n\n思路就是先排序，先按照start从小到大排序，如果start相等则按照end从小到大排序。\n\n然后遍历每个point，找当前遍历过的所有点里哪个end最小，一旦一个点的start超过了这个最小的end，那就不得不射一箭了。射完箭以后minEnd需要重置。\n\n最后要补射一箭，因为最后一个区间没有射箭呢。\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (vector<int> x, vector<int> y) {\n        if (x[0] == y[0]) {return x[1] < y[1];}\n        return x[0] < y[0]; // 小的在前\n    }\n    int findMinArrowShots(vector<vector<int>>& points) {\n        sort (points.begin(), points.end());\n        int arrow = 0;\n        int minEnd = INT_MAX;\n        for (int i = 0; i < points.size(); i++) {\n            if (points[i][1] < minEnd) { // 当前的end比之前的end还要小\n                minEnd = points[i][1];  \n            }\n            if (points[i][0] > minEnd) { //start坐标大于之前的最小的end，必须射箭\n                arrow++;\n                minEnd = points[i][1]; \n            }\n        }\n        return arrow + 1; // 最后一部分没有射箭\n    }\n};\n```\n\n### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)\n\n> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。\n\n思路——排序加哈希表\n\n先按照每个区间的长度排序，区间长度一致按照start从小到大。然后再建立哈希表保存左闭右开区间的元素。\n\n这个思路是错误的，并不是说区间长度越小越不容易造成重叠的。\n\n【反例】万一有这么一组数字`[[-100,1],[1,2],[2,3],[3,100],[-3,7]]`。按照以上的逻辑会首先排成`[[1,2],[2,3],[-3,7],[-100,1],[3,100]]`，然后得到的结果应该去除`[-100,1],[3,100]`这两个，保留以下三个`[1,2],[2,3],[-3,7]`。然后正确的应该是保留四个`[1,2],[2,3],[-100,1],[3,100]`，去除一个`[-3,7]`\n\n想复杂了，其实和452是一样的！！！\n\n#### 解法一——贪心+左边缘\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (const vector<int> &x, const vector<int> &y) {\n        // if (x[0] == y[0]) {\n        //     return x[1] < y[1];\n        // }\n        return x[0] < y[0];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), cmp);\n        int erase = 0;\n        int minEnd = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] < minEnd) {\n                erase++;\n                if (intervals[i][1] < minEnd) {\n                    minEnd = intervals[i][1];\n                }\n            }\n            else {//大于之前的区间了，重新计数\n                minEnd = intervals[i][1];\n            }\n        }\n        return erase;\n    }\n};\n```\n\n#### 解法二——贪心+右边缘\n\n![img](/20230201164134.png)\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (const vector<int> &x, const vector<int> &y) {\n        // if (x[0] == y[0]) {\n        //     return x[1] < y[1];\n        // }\n        return x[1] < y[1];\n    }\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1; //非重叠区间至少有一个\n        int minEnd = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] >= minEnd) {\n                count++;                \n                minEnd = intervals[i][1];\n            }\n        }\n        return intervals.size() - count;\n    }\n};\n```\n\n### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)\n\n> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n>\n> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。\n>\n> 返回一个表示每个字符串片段的长度的列表。\n\n在遍历的过程中相当于是要找每一个字母的边界，**如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了**。此时前面出现过所有字母，最远也就到这个边界了。\n\n记录下每个字母出现的end位置，从前往后遍历，当前字母的end位置更加靠后了，更新maxEnd，如果end更前则不用管。当走到maxEnd的时候，分割这个片段。\n\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        int alphabet[26] = {0}; // 记录每个字母出现的end位置\n        for (int i = 0; i < s.size(); i++) {\n            alphabet[s[i] - 'a'] = i;\n        }\n        int maxEnd = alphabet[s[0] - 'a']; //当前片段目前能够分割的最后位置\n        int prevEnd = -1; // 上一次的end（不含）\n        vector <int> output;\n        for (int i = 0; i < s.size(); i++) {\n            if (alphabet[s[i] - 'a'] > maxEnd) {\n                maxEnd = alphabet[s[i] - 'a'];\n            }\n            if (i == maxEnd) {\n                output.emplace_back(maxEnd - prevEnd);\n                prevEnd = maxEnd;\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)\n\n> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。\n\n```cpp\nclass Solution {\npublic:\n    static bool cmp (const vector<int> &x, const vector<int> &y){\n        return x[0] < y[0];\n    }\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort (intervals.begin(), intervals.end(), cmp);\n        vector<int> temp(2,0);\n        temp[0] = intervals[0][0];//当前区间左边缘\n        temp[1] = intervals[0][1];//当前区间右边缘（含）\n        vector<vector<int>> output;\n        for (int i = 1; i < intervals.size(); i++) {\n            if (intervals[i][0] > temp[1]) { // 保存上一个区间\n                output.emplace_back(temp);\n                temp = intervals[i];\n            }\n            else { // 左边缘小于等于当前右边缘\n                temp[1] = max(temp[1], intervals[i][1]);\n            }\n        }\n        output.emplace_back(temp); // 保存最后一个区间\n        return output;\n    }\n};\n```\n\n### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)\n\n> 当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。\n>\n> 给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。\n\nn / 10 * 10 - 1 最后一位必然是9，比别的大或等于，所以可以不考虑最后一位。只考虑前几位即可。\n\n```cpp\nclass Solution {\npublic:\n    bool isIncreaseingDigits(int n) {\n        int prev = n % 10;\n        n /= 10;\n        while (n != 0) {\n            // cout << n%10 << \" \" << prev <<\" \";\n            if (n % 10 > prev) {\n                return false;\n            }\n            prev = n % 10;\n            n /= 10;\n        }\n        return true;\n    }\n    int monotoneIncreasingDigits(int n) {\n        if (n < 10 || isIncreaseingDigits(n)) {\n            return n;\n        }\n        int prev = n; // 前缀部分，每次只需要判断前缀是否为单调递增即可，因为最后一位必然是9.\n        int divideTime = 0;\n        while (!isIncreaseingDigits(prev - 1)) {\n            // n / 10 * 10 - 1 最后一位必然是9，比别的大或等于，所以可以不考虑最后一位。\n            prev = prev / 10;\n            divideTime++;\n        }\n        while(divideTime != 0){\n            prev *= 10;\n            divideTime--;\n        }\n\n        return prev - 1;\n    }\n};\n```\n\n代码随想录的方法使用字符串操作。\n\n### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)\n\n> 给定一个二叉树，我们在树的节点上安装摄像头。\n>\n> 节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**\n>\n> 计算监控树的所有节点所需的最小摄像头数量。\n\n深度优先，后序遍历\n\n两个注意点：\n\n+ 空节点命名为哪个状态，应当是`1`已经覆盖，因为叶子节点实际上并不需要单独的摄像头\n+ 根节点返回0的情况，即根节点还没有摄像头覆盖，需要+1\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int inorder (TreeNode* p, int &numCamera) {  \n        // 0: 未覆盖； 1: 已覆盖； 2: 摄像头\n        if (p == NULL) {\n            return 1;\n        }\n\n        int left = inorder(p->left, numCamera);\n        int right = inorder(p->right, numCamera);\n\n        if (left == 0 || right == 0) { // 包含00，01，10，02，20\n            numCamera++;\n            return 2; // 摄像头\n        }\n        else if (left == 2 || right == 2) { // 包含22，21，12\n            return 1; // 已经覆盖\n        }\n        else { //11\n            return 0;\n        }\n\n    }\n    int minCameraCover(TreeNode* root) {\n        int numCamera = 0;\n        if (root == nullptr ) {\n            return 0;\n        }\n        if (inorder(root, numCamera) == 0) {\n            return numCamera + 1;\n        }\n        return numCamera;\n    }\n};\n```\n\n\n\n\n\n## 动态规划\n\n> 动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的。\n>\n> 大家知道动规是由**前一个状态**推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。\n>\n> 动态规划问题：\n>\n> 1. 确定dp数组（dp table）以及下标的含义\n> 2. 确定递推公式\n> 3. dp数组如何初始化\n> 4. 确定遍历顺序\n> 5. 举例推导dp数组\n>\n> <img src=\"/动态规划-总结大纲1.jpg\" alt=\"img\" style=\"zoom:33%;\" />\n>\n> + 只是求排列组合数时候可以用动规，但是要给出所有答案得用回溯。\n>\n> 背包问题\n>\n> ![416.分割等和子集1](/20230310000726.png)\n\n### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)\n\n> **斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n>\n> ```\n> F(0) = 0，F(1) = 1\n> F(n) = F(n - 1) + F(n - 2)，其中 n > 1\n> ```\n>\n> 给定 `n` ，请计算 `F(n)` 。\n\n#### 解法一——直接递推\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n == 1) {\n            return 1;\n        }\n        int prev0 = 0;\n        int prev1 = 1;\n        int temp;\n        while (n != 1) {\n            temp = prev0 + prev1;\n            prev0 = prev1;\n            prev1 = temp;\n            n--;\n        }\n        return temp;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n```cpp\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        vector<int> dp(n + 1);\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++){\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n};\n```\n\n### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)\n\n> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n>\n> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n```cpp\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int dp[46] = {0};\n        dp[1] = 1; // 上1楼只有一种方式\n        dp[2] = 2; //上2楼有两种方式\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2]; // 上到这个楼层有两个方式，一个台阶、两个台阶\n        }\n        return dp[n];\n    }\n};\n```\n\n### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\n> 给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n>\n> 你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。\n>\n> 请你计算并返回达到楼梯顶部的最低花费。\n\n```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int dp[3] = {0};\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        \n        for (int i = 2; i < cost.size(); i++) {\n            // 到第二层有两种方式：下标0直接2步上来，下标1一步上来\n            dp[2] = min(dp[0], dp[1]) + cost[i];\n            dp[0] = dp[1];\n            dp[1] = dp[2];\n        }\n        return min(dp[0], dp[1]);\n    }\n};\n```\n\n### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)\n\n> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n>\n> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n>\n> 问总共有多少条不同的路径？\n>\n> ![img](/1697422740-adxmsI-image.png)\n\n\n\n#### 解法一——动态规划硬解\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> roadMap (m, vector<int> (n,0));\n        roadMap[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                }\n                else if (j == 0) {\n                    roadMap[i][j] = roadMap[i - 1][j];\n                }\n                else if (i == 0) {\n                    roadMap[i][j] = roadMap[i][j - 1];\n                }\n                else {\n                    roadMap[i][j] = roadMap[i - 1][j] + roadMap[i][j - 1];\n                }\n            }\n        }\n        return roadMap[m - 1][n - 1];\n    }\n};\n```\n\n改一下，更简单、更快一点\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> roadMap (m, vector<int> (n,0));\n        roadMap[0][0] = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    roadMap[i][j] = 1;\n                }\n                else {\n                    roadMap[i][j] = roadMap[i - 1][j] + roadMap[i][j - 1];\n                }\n            }\n        }\n        return roadMap[m - 1][n - 1];\n    }\n};\n```\n\n#### 解法二——数论方法\n\n组合问题\n\n无论怎么走，走到终点都需要 `m + n - 2` 步，一定有`m - 1`要往下走，那么就需要$\\mathbf C_{m+n-2}^{m-1}$​次\n$$\n\\begin{gathered}\n\\mathbf A_n^m=\\frac{n!}{(n-m)!}\\\\ \n\\mathbf C_n^m = \\frac{n!}{(n-m)!m!}\n\\end{gathered}\n$$\n则计算\n$$\n\\mathbf C_{m+n-2}^{m-1} = \\frac{(m+n-2)!}{(n-1)!(m-1)!} = \\frac{(m+n-2)\\cdots(n+1)n}{(m-1)\\cdots1}\n$$\n\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        long long output = 1;\n        for (int numerator = n, denominator = 1; numerator < m + n - 1; numerator++, denominator++ ) {\n            output = output * numerator / denominator;\n        }\n        return output;\n    }\n}; \n```\n\n### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)\n\n> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n>\n> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n>\n> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n>\n> 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。\n> ![img](/robot1.jpg)\n\n#### 解法一——动态规划\n\n```cpp\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int temp = -1;\n        // 初始化 第一行 第一列\n        for (int i = 0; i < obstacleGrid.size(); i++) {\n            if (obstacleGrid[i][0] == 1) {\n                temp = 0;\n            }\n            obstacleGrid[i][0] = temp;\n        }\n        temp = -1;\n        for (int j = 1; j < obstacleGrid[0].size(); j++) {\n            if (obstacleGrid[0][0] == 0 || obstacleGrid[0][j] == 1) {\n                temp = 0;\n            }\n            obstacleGrid[0][j] = temp;\n        }\n        for (int i = 1; i < obstacleGrid.size(); i++) {\n            for (int j = 1; j < obstacleGrid[0].size(); j++) {\n                if (obstacleGrid[i][j] == 1) {\n                    obstacleGrid[i][j] = 0;\n                }\n                else { // 不需要分类讨论了。障碍和两边都挡住的就是0啊，那加上去也没影响\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1];\n                }\n            }\n        }\n        // for (int i = 0; i < obstacleGrid.size(); i++) {\n        //     for (int j = 0; j < obstacleGrid[0].size(); j++) {\n        //         cout << obstacleGrid[i][j] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        return - obstacleGrid[obstacleGrid.size() - 1][obstacleGrid[0].size() - 1];\n    }\n};\n```\n\n### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)\n\n> 给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。\n>\n> 返回 *你可以获得的最大乘积* 。\n\n\n\n#### 解法一——数论？技巧？\n\n我们知道正方形面积最大，所以分出来的数字一定比较接近。所以我直接遍历了分n种的情况，每次算当前的成绩比较。\n\n但是这里需要注意，因为不是整除，所以可能需要考虑向上向下取整两种情况。\n\n向下取整的情况最后一个比较好考虑，就是普通的因子+余数。\n\n向上取整的要稍微想一想，是普通的因子+余数-之前i-1个因子每个都多考虑了1。或者利用以下这组关系\n$$\n(n/i+1)\\cdot(i-1)+x = (n/i)\\cdot i+ n\\%i = n\n$$\n\n```cpp\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        long long maxNum  = 0;\n        for (int i = 2; i <= n; i++) {\n            long long prod = 1;\n            if (n % i > i - n % i){  // 说明要进位\n                int factor = n / i + 1;\n                for (int j = 0; j < i - 1; j++) {\n                    prod *= factor;\n                }\n                prod *= n % i + n / i - (i - 1);\n            }\n            else {\n                int factor = n / i;\n                for (int j = 0; j < i - 1; j++) {\n                    prod *= factor;\n                }\n                prod *= (factor + n % i);\n            }\n            if (maxNum < prod) {\n                maxNum = prod;\n            }\n        }\n        return maxNum;\n    }\n};\n```\n\n#### 解法二——动态规划\n\ndp[i]：分拆数字i，可以得到的最大乘积为dp[i]。\n\n dp[i]最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到dp[i].\n\n+ 一个是j * (i - j) 直接相乘。\n+ 一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。\n\n注意第一种情况表示i-j不拆；第二种情况会拆分i-j，因为我们保存在数组中的值必定是拆分过的，那么也就没有保存i-j这个本身的值，例如dp[2]=1，但是如果一个数乘上2，反而还要比1大呢。\n\n在遍历过程中会j和i-j的地位是完全对等的，也就是说拆j和拆i-j是完全一致的。\n\n所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});\n\n```cpp\n当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！class Solution {\npublic:\n    int integerBreak(int n) {\n        int dp[59] = {0};\n        dp[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            for (int j = 1; j <= i/2; j++) {\n                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));\n            }\n        }\n        return dp[n];\n    }\n}; \n```\n\n### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)\n\n> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。\n\n![96.不同的二叉搜索树1](/20210107093129889.png)\n\n当1为头结点的时候，其右子树有两个节点，这两个节点的布局，和n为2的时候两棵树的布局是一样的！\n\n当3为头结点的时候，其左子树有两个节点，这两个节点的布局，和n为2的时候两棵树的布局也是一样的！\n\n当2为头结点的时候，其左右子树都只有一个节点，布局和n为1的时候只有一棵树的布局也是一样的！\n\ndp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量\n\n元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量\n\n元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量\n\n元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量\n\n有2个元素的搜索树数量就是dp[2]。\n\n有1个元素的搜索树数量就是dp[1]。\n\n有0个元素的搜索树数量就是dp[0]。\n\n所以`dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]`\n\n**意思是当有3个元素的时候，1、2、3每个元素都有可能当根节点，而每个元素作为根节点的时候的，左右子树所有有可能的序列类型。**\n\n在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]\n\nj相当于是头结点的元素，从1遍历到i为止。\n\n所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量\n\n——代码随想录\n\n代码中的递推公式使用的是\n$$\ndp[i] +=dp[j]*dp[i-j-1],\\quad j = 0,1,\\cdots, i-1\n$$\n\n```cpp\nclass Solution {\npublic:\n    int numTrees(int n) {\n        int dp[20];\n        dp[0] = 1; //为0的子树有一种\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                dp[i] += dp[j] * dp[i - j - 1]; // 左子树从0到i-1个元素，右子树从i-1到0个元素；\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n### 0-1背包问题\n\n#### 0-1背包问题——二维数组\n\n1. 确定dp数组以及下标的含义\n\n   `dp[i][j]`表示从下标为$[0-i]$的物品里任意取，放进容量为$j$​的背包，价值总和最大是多少，即二维数组中的数字是最大价值\n\n   <img src=\"/image-20240417111706222-1713323828602-1.png\" alt=\"image-20240417111706222\" style=\"zoom:33%;\" />\n\n2. 确定递推公式：`dp[i][j]`有两种情况得到\n\n   1. 不放物品`i`：$dp[i][j] = dp[i-1][j]$\n   2. 放物品`i`：$dp[i][j] = dp[i-1][j-\\text{weight}[i]]+\\text{value}[i]$\n\n   即递推公式为$dp[i][j] = \\max\\,\\{dp[i-1][j],dp[i-1][j-\\text{weight}[i]]+\\text{value}[i]\\}$\n\n3. dp数组如何初始化\n\n   1. 第一列：背包重量为0的情况，必然为0\n   2. 第一行（递推需要`i-1`状态）：背包重量小于`weight[0]`的为0，大于等于的为`value[0]`\n\n   ```cpp\n   // 初始化 dp\n   vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));\n   for (int j = weight[0]; j <= bagweight; j++) {\n       dp[0][j] = value[0];\n   }\n   ```\n\n4. 确定遍历顺序：有两个遍历的维度：物品与背包重量\n\n   1. 那么我先给出先遍历物品，然后遍历背包重量的代码。\n\n      ```cpp\n      // weight数组的大小 就是物品个数\n      for(int i = 1; i < weight.size(); i++) { // 遍历物品\n          for(int j = 0; j <= bagweight; j++) { // 遍历背包容量\n              if (j < weight[i]) dp[i][j] = dp[i - 1][j];\n              else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n      \n          }\n      }\n      ```\n\n   2. 先遍历背包，再遍历物品，也是可以的！（注意这里使用的二维dp数组）\n\n      ```cpp\n      // weight数组的大小 就是物品个数\n      for(int j = 0; j <= bagweight; j++) { // 遍历背包容量\n          for(int i = 1; i < weight.size(); i++) { // 遍历物品\n              if (j < weight[i]) dp[i][j] = dp[i - 1][j];\n              else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n          }\n      }\n      ```\n\n5. 举例推导dp数组\n\n#### 0-1背包问题——滚动数组\n\n在使用二维数组的时候，递推公式：`dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;\n\n**其实可以发现如果把`dp[i - 1]`那一层拷贝到`dp[i]`上，表达式完全可以是：`dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])`;**\n\n**与其把`dp[i - 1]`这一层拷贝到`dp[i]`上，不如只用一个一维数组了**，只用`dp[j]`（一维数组，也可以理解是一个滚动数组）。\n\n这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。\n\n+ 遍历顺序问题：\n\n+ 举一个例子（物品i=0时，背包重量j从0开始）：物品0的重量weight[0] = 1，价值value[0] = 15\n\n  如果正序遍历\n\n  dp[1] = dp[1 - weight[0]] + value[0] = 15\n\n  dp[2] = dp[2 - weight[0]] + value[0] = 30 （因为这里用的是用到了dp[1]，而这个dp[1]已经被上一步更新过了）\n\n  此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。\n\n+ 所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。\n\n```cpp\nfor(int i = 0; i < weight.size(); i++) { // 遍历物品\n        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n```\n\n#### [46. 携带研究材料 (kamacoder)](https://kamacoder.com/problempage.php?pid=1046)\n\n> 题目描述\n>\n> 小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。 \n>\n> 小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。\n\n##### 二维数组\n\n```cpp\n# include <iostream>\n# include <vector>\nusing namespace std;\n\nint main() {\n    int itemNum;\n    int maxWeight;\n    cin >> itemNum >> maxWeight;\n    vector<int> weight(itemNum);\n    vector<int> value(itemNum);\n    \n    for (auto &weighti:weight) {\n        cin >> weighti;\n    }\n    for(auto &valuei:value) {\n        cin >> valuei;\n    }\n    \n    // 初始化二维矩阵\n    vector<vector<int>> dp(itemNum, vector<int>(maxWeight + 1, 0)); // 注意这里要加1\n    for (int j = weight[0]; j <= maxWeight; j++) { // 注意这里有等号\n        dp[0][j] = value[0];\n    }\n    \n    \n    // 开始遍历, 先遍历物品，后遍历背包大小\n    for (int i = 1; i < itemNum; i++) {\n        for (int j = 0; j <= maxWeight; j++) { // 注意这里有等号\n            if (weight[i] > j) { // 这个物品比目前能承载的最大重量还要大\n                dp[i][j] = dp[i - 1][j];\n            }\n            else {\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);\n                // 这边的j - weight[i]是不会超范围的，因为他不是在前一个基础上加，而是直接找过去到前面的\n            }\n        }\n    }\n    cout << dp[itemNum - 1][maxWeight] << endl;\n    return 0;\n}\n```\n\n##### 滚动数组\n\n```cpp\n include <iostream>\n# include <vector>\nusing namespace std;\n\nint main() {\n    int itemNum;\n    int maxWeight;\n    cin >> itemNum >> maxWeight;\n    vector<int> weight(itemNum);\n    vector<int> value(itemNum);\n    \n    for (auto &weighti:weight) {\n        cin >> weighti;\n    }\n    for(auto &valuei:value) {\n        cin >> valuei;\n    }\n    \n    // 初始化二维矩阵\n    vector<int> dp(maxWeight + 1, 0); // 注意这里要加1\n\n    \n    \n    // 开始遍历, 先遍历物品，后遍历背包大小\n    for (int i = 0; i < itemNum; i++) {\n        for (int j = maxWeight; j >= weight[i]; j--) { // 注意这里有等号\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n    cout << dp[maxWeight] << endl;\n    return 0;\n}\n```\n\n### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)\n\n> 给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n- 背包的体积为sum / 2\n- 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值\n- 背包如果正好装满，说明找到了总和为 sum / 2 的子集。\n- 背包中每一个元素是不可重复放入。\n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int maxWeight = sum / 2;\n        vector <int> dp(maxWeight + 1, 0);\n\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = maxWeight; j >= nums[i]; j--) {\n                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);\n            }\n        }\n        return dp[maxWeight] == maxWeight;\n    }\n};\n```\n\n01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。\n\n或者采用true/false。\n\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        // 0-1背包\n        int sum = 0;\n        for (int num:nums) {\n            sum += num;\n        }\n        if (sum % 2) {// 奇数\n            return false;\n        }\n        vector<bool> dp(sum/2 + 1,false);\n        dp[0] = true;\n\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = sum/2; j >= nums[i]; j--) {\n                dp[j] = dp[j] || dp[j - nums[i]];\n            }\n        }\n        return dp[sum/2];\n\n    }\n};\n```\n\n\n\n### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)\n\n> 有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。\n>\n> 每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：\n>\n> - 如果 `x == y`，那么两块石头都会被完全粉碎；\n> - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。\n>\n> 最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。\n\n因为是“最小”的可能重量，所以分组由我们决定。\n\n用归纳法可以证明，无论按照何种顺序粉碎石头，最后一块石头的重量总是可以表示成\n$$\n\\sum_{i=1}^{n-1}k_i\\times stones_i, k_i\\in\\{-1,1\\}\n$$\n我们将这组$\\{k_i\\}$对应的石头划分成两堆，$k_i=1$的石头分至一堆，$k_i=-1$的石头分至另一堆。由于这是最小非负值所对应的$\\{k_i\\}$，这两堆石头重量之差的绝对值也是所有划分当中最小的。\n\n所以问题就转化成了分成两组，是他们的绝对值最小。那么可以利用“416.分割等和子集”的思路。\n\n```cpp\nclass Solution {\npublic:\n    int lastStoneWeightII(vector<int>& stones) {\n        int sum = accumulate(stones.begin(), stones.end(), 0);\n        int maxWeight = sum / 2;\n\n        vector<int> dp(maxWeight + 1, 0);\n\n        for (int i = 0; i < stones.size(); i++) {\n            for (int j = maxWeight; j >= stones[i]; j--) {\n                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);\n            }\n        }\n        return (sum - dp[maxWeight]) - dp[maxWeight];\n    }\n};\n```\n\n### [494. 目标和](https://leetcode.cn/problems/target-sum/)\n\n> 给你一个非负整数数组 `nums` 和一个整数 `target` 。\n>\n> 向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：\n>\n> - 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `\"+2-1\"` 。\n>\n> 返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。\n\n\n\n分成两堆，一堆取正，一堆取负数。那么有\n$$\n\\left\\{\n\\begin{array}{l}\npositive +negtive = target\\\\\npositive - negetive = sum\n\\end{array}\n\\right.\n$$\n所以postive之和就要等于(target+sum)/2。\n\ndp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法。只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。\n\n例如：dp[j]，j 为5，\n\n- 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。\n- 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。\n- 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包\n- 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包\n- 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包\n\n那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\n\n所以求组合类问题的公式，都是类似这种：\n\n```text\ndp[j] += dp[j - nums[i]]\n```\n\n——代码随想录\n\nj是背包大小，dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\n\n```cpp\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if ((sum + target) % 2 != 0 || abs(target) > sum) {\n            return 0;\n        }\n        int positiveSum = (sum + target) / 2;\n\n        vector<int> dp(positiveSum + 1, 0);\n        dp[0] = 1;\n\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = positiveSum; j >= nums[i]; j--) {\n                dp[j] += dp[j - nums[i]];\n            }\n        }\n        return dp[positiveSum];\n    }\n};\n```\n\n### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)\n\n> 给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。\n>\n> 请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。\n>\n> 如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。\n\n\n\n`dp[i][j]`：最多有i个0和j个1的strs的最大子集的大小为`dp[i][j]`。\n\n递推关系：有上一个字符串推出结果，假设当前字符串种有zeroNum个0，oneNum个1，上一个字符串至多有`dp[i - zeroNum][j - oneNum]`个子集，那么当前的可以保存下的子集的数量就要加一。\n\n```cpp\nclass Solution {\npublic:\n    int findMaxForm(vector<string>& strs, int m, int n) {\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n        for (auto s:strs) {\n            int one = 0;\n            int zero = 0;\n            for (auto c:s) {\n                if (c == '0') {\n                    zero++;\n                }\n                else {\n                    one++;\n                }\n            }\n            for (int i = m; i >= zero; i--) {\n                for (int j = n; j >= one; j--) {\n                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + 1);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n\n### 完全背包问题\n\n#### 完全背包问题\n\n有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。\n\n**完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。\n\n首先再回顾一下01背包的核心代码\n\n```cpp\nfor(int i = 0; i < weight.size(); i++) { // 遍历物品\n    for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n    }\n}\n```\n\n我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。\n\n而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：\n\n```cpp\n// 先遍历物品，再遍历背包\nfor(int i = 0; i < weight.size(); i++) { // 遍历物品\n    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n\n    }\n}\n```\n\n——代码随想录\n\n求组合数：[动态规划：518.零钱兑换II (opens new window)](https://programmercarl.com/0518.零钱兑换II.html)\n\n求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://programmercarl.com/0377.组合总和Ⅳ.html)、[动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)](https://programmercarl.com/0070.爬楼梯完全背包版本.html)\n\n求最小数（组合问题）：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.零钱兑换.html)、[动态规划：279.完全平方数](https://programmercarl.com/0279.完全平方数.html)\n\n**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。\n\n**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。\n\n####  [52. 携带研究材料(kamacoder)](https://kamacoder.com/problempage.php?pid=1052)\n\n> 题目描述\n>\n> 小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。\n>\n> 小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int N, V;\n    cin >> N >> V;\n    \n    vector<int> weight(N);\n    vector<int> value(N);\n    vector<int> dp(V + 1, 0);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> weight[i] >> value[i];\n        for (int j = weight[i]; j <= V; j++) {\n            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n        }\n    }\n    \n    cout << dp[V] << endl;\n    \n    return 0;\n}\n```\n\n### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/)\n\n> 给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。\n>\n> 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。\n>\n> 假设每一种面额的硬币有无限个。 \n>\n> 题目数据保证结果符合 32 位带符号整数。\n\n求组合方式。\n\n本题要求凑成总和的组合数，元素之间明确要求没有顺序。\n\n所以纯完全背包是能凑成总和就行，不用管怎么凑的。\n\n本题是求凑出来的方案个数，且每个方案个数是为组合数。\n\n那么本题，两个for循环的先后顺序可就有说法了。\n\n我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。\n\n代码如下：\n\n```cpp\nfor (int i = 0; i < coins.size(); i++) { // 遍历物品\n    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量\n        dp[j] += dp[j - coins[i]];\n    }\n}\n```\n\n假设：coins[0] = 1，coins[1] = 5。\n\n那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。\n\n**所以这种遍历顺序中dp[j]里计算的是组合数！**\n\n如果把两个for交换顺序，代码如下：\n\n```cpp\nfor (int j = 0; j <= amount; j++) { // 遍历背包容量\n    for (int i = 0; i < coins.size(); i++) { // 遍历物品\n        if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];\n    }\n}\n```\n\n背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。\n\n**此时dp[j]里算出来的就是排列数！**\n\n可能这里很多同学还不是很理解，**建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）**\n\n```cpp\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1);\n        dp[0] = 1;\n\n        for (int i = 0; i < coins.size(); i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                dp[j] += dp[j - coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)\n\n> 给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。\n>\n> 题目数据保证答案符合 32 位整数范围。\n\n**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。\n\n**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。\n\n如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！\n\n所以本题遍历顺序最终遍历顺序：**target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历**。\n\n——代码随想录\n\n```cpp\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        vector<int> dp(target + 1);\n        dp[0] = 1;\n\n        for (int j = 0; j <= target; j++) {\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i] <= j && dp[j] < INT_MAX - dp[j - nums[i]]) {  //C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] < INT_MAX - dp[i - num]。\n                    dp[j] += dp[j - nums[i]];\n                }\n            }\n        }\n\n        return dp[target];\n    }\n};\n```\n\n### [57. 爬楼梯 (kamacoder)](https://kamacoder.com/problempage.php?pid=1067)\n\n> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 \n>\n> 每次你可以爬至多m (1 <= m < n)个台阶。你有多少种不同的方法可以爬到楼顶呢？ \n>\n> 注意：给定 n 是一个正整数\n\n求排列数。背包体积是n，物品大小是1到m。\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<int> dp(n + 1);\n    dp[0] = 1;\n    \n    for (int j = 0; j <= n; j++) {\n        for (int i = 1; i <= m; i++){\n            if (i <= j) {\n                dp[j] += dp[j - i];\n            }\n        }\n    }\n    \n    cout << dp[n];\n    return 0;\n}\n```\n\n### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)\n\n> 给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。\n>\n> 计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。\n>\n> 你可以认为每种硬币的数量是无限的。\n\n\n\n首先这是个组合问题。 初始值怎么取很重要！\n\n```cpp\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 0; i < coins.size(); i++) {\n            for (int j = coins[i]; j <= amount; j++) {\n                if (dp[j - coins[i]] != INT_MAX) {\n                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);\n                }\n            }\n        }\n        if (dp[amount] == INT_MAX) {\n            return -1;\n        }\n        return dp[amount];\n    }\n};\n```\n\n### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)\n\n> 给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。\n>\n> **完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。\n\n组合问题。dp[j]表示的是最小数量。j就表示序列嘛，i就是完全平方数啊，或者说完全平方数的根。背包的元素就是$i^2$。\n\n```cpp\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n\n        for (int i = 1; i * i <= n; i++) {\n            for (int j = i * i; j <= n; j++) {\n                if (dp[j - i*i] != INT_MAX) {\n                    dp[j] = min(dp[j], dp[j - i * i] + 1);\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```\n\n官方题解的好像更好理解\n$$\nf[i] = 1 +\\min_{j=1}^{\\lfloor\\sqrt{i}\\rfloor} f[i-j^2]\n$$\n\n```cpp\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 1; i <= n; i++) {\n            int minN = INT_MAX;\n            for (int j = 1; j * j <= i; j++) {\n                minN = min(minN, dp[i - j * j]);\n            }\n            dp[i] = minN + 1;\n        }\n        return dp[n];\n    }\n};\n```\n\n\n\n### [139. 单词拆分](https://leetcode.cn/problems/word-break/)\n\n> 给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。\n>\n> **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n完全背包，排序问题。\n\ndp[j]表示s从0开始截取的长度是否能够通过字典中的值组成。\n\ndp[j]为true的前提是dp[k]为true且从k+1到j区间的字符串在字典中出现。\n\n#### 解法一——遍历物品时候直接遍历字典列表\n\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        vector<bool> dp(s.length() + 1, false);\n        dp[0] = true;\n\n        for (int j = 1; j <= s.length(); j++) {\n            for (int i = 0; i < wordDict.size(); i++) {\n                if (j - (int) wordDict[i].length() >= 0) { // 这里需要加一个int 否则他出不来负数\n                    string sSub = s.substr(j - wordDict[i].length(), wordDict[i].length());\n                    if (dp[j - wordDict[i].length()] && wordDict[i] == sSub){\n                        dp[j] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n};\n```\n\n#### 解法二——遍历物品时候，遍历截取的字符串长度\n\n——代码随想录\n\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n        vector<bool> dp(s.size() + 1, false);\n        dp[0] = true;\n        for (int i = 1; i <= s.size(); i++) {   // 遍历背包\n            for (int j = 0; j < i; j++) {       // 遍历物品\n                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)\n                if (wordSet.find(word) != wordSet.end() && dp[j]) {\n                    dp[i] = true;\n                }\n            }\n        }\n        return dp[s.size()];\n    }\n};\n```\n\n### 多重背包问题\n\n#### 多重背包问题\n\n有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。\n\n实现方式——把每种商品遍历的个数放在01背包里面在遍历一遍。\n\n#### [56. 携带矿石资源 (kamacoder)](https://kamacoder.com/problempage.php?pid=1066)\n\n> 你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。 \n>\n> 给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int C, N;\n    cin >> C >> N;\n    \n    vector<int> weights(N), values(N), maxNums(N);\n    for (auto &weight:weights) {\n        cin >> weight;\n    }\n    for (auto &value:values) {\n        cin >> value;\n    }\n    for (auto &maxNum:maxNums) {\n        cin >> maxNum;\n    }\n    \n    vector<int> dp(C + 1);\n    \n    for (int i = 0; i < N; i++) { // 遍历物品\n        for (int j = C; j >= weights[i]; j--) {\n            for (int k = 1; k <= maxNums[i] && (j - k * weights[i]) >= 0; k++) {\n                dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);\n            }\n        }\n    }\n    cout << dp[C] << endl;\n    return 0;\n}\n```\n\n### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)\n\n> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。\n>\n> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。\n\n**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。\n\n决定dp[i]的因素就是第i房间偷还是不偷。两种情况，不偷和偷，**不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额**\n\n如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。\n\n如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，\n\n然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 1) {\n            return nums[0];\n        }\n\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); \n            // 两种情况，不偷和偷，不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额\n        }\n\n        return dp[nums.size() - 1];\n    }\n};\n```\n\n### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)\n\n> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。\n>\n> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。\n\n#### 解法一——建立二维数组\n\n建立二维数组，分两种情况，偷0【1】和不偷0【0】\n\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 1) {\n            return nums[0];\n        }\n        else if (nums.size() == 2) {\n            return max(nums[0], nums[1]);\n        }\n\n        vector<vector<int>> dp(nums.size(),vector<int>(2));\n        // 分两种情况，偷0【1】和不偷0【0】\n        dp[0][0] = 0;\n        dp[0][1] = nums[0];\n        dp[1][0] = nums[1];\n        dp[1][1] = max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.size() - 1; i++) { // 结尾单独考虑\n            dp[i][0] = max(dp[i - 1][0], dp[i - 2][0] + nums[i]);\n            dp[i][1] = max(dp[i - 1][1], dp[i - 2][1] + nums[i]);\n        }\n        // 考虑最后一家\n        dp[nums.size() - 1][0] = max(dp[nums.size() - 2][0], dp[nums.size() - 3][0] + nums[nums.size() - 1]); // 不偷0\n        dp[nums.size() - 1][1] = dp[nums.size() - 2][1]; // 偷0\n\n        return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]);        \n    }\n};\n```\n\n#### 解法二——利用上一题的代码，分两个子函数\n\n三种情况：\n\n+ 情况一：考虑不包含首尾元素\n+ 情况二：考虑包含首元素，不包含尾元素\n+ 情况三：考虑包含尾元素，不包含首元素\n\n情况二、三 包括情况一。\n\n```cpp\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        if (start == end) {\n            return nums[start];\n        }\n        vector<int> dp(nums.size(), 0);\n        dp[start] = nums[start];\n        dp[start + 1] = max(nums[start], nums[start + 1]);\n\n        for (int i = start + 2; i <= end; i++) {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); \n            // 两种情况，不偷和偷，不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额\n        }\n\n        return dp[end];\n    }\n    int rob(vector<int>& nums) {\n        if (nums.size() == 1) {\n            return nums[0];\n        }\n        int situation2 = robRange(nums, 0, nums.size() - 2);\n        int situation3 = robRange(nums, 1, nums.size() - 1);\n\n        return max(situation2, situation3);\n    }\n};\n```\n\n### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)\n\n> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。\n>\n> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。\n>\n> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。\n\n#### 解法一——二维数组记录\n\n递归，得知道当前节点的子节点有没有没抢劫。采用后序遍历。\n\n这里处理起来就复杂在：\n\n+ 左右子树：4种情况——有无。\n+ 左右偷不偷：4种情况——各自偷不偷。只有左右孩子都不偷，这次才能偷。而当前不偷则应该上一轮四种情况都可以。\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> dp;\n    vector<int> temp; // 索引0表示不偷， 索引1表示偷\n\n    void robPostOrder (TreeNode *p) {\n        if (p->left) {\n            robPostOrder(p->left);\n        }\n        if (p->right) {\n            robPostOrder(p->right);\n        }\n\n        // 当前节点的四种情况：左右子树都有、有一个、都没有\n        if (p->left && p->right) {\n            // 这里有四个情况啊：左偷右不偷、左不偷右偷、左偷右偷、左不偷右不偷。四种情况这次都可以不偷，但是只有最后一种情况这次可以偷\n            // 当前不偷：那就是左右索引上一次的偷的和（这里应该是加而不是取最大值）当前不偷上一次也可以不偷啊，\n            temp[0] = max(dp[dp.size() - 2][1] + dp[dp.size() - 1][1], max(dp[dp.size() - 2][0] + dp[dp.size() - 1][0], max(dp[dp.size() - 2][1] + dp[dp.size() - 1][0], dp[dp.size() - 2][0] + dp[dp.size() - 1][1]))); \n            // 当前偷：那就是左右索引上一次的不偷的和（这里应该是加而不是取最大值）（相当于是当前索引上上次可能偷的和）\n            temp[1] = dp[dp.size() - 2][0] + dp[dp.size() - 1][0] + p->val; \n            dp.pop_back(); // 需要把子树的pop掉，不然根节点找不到左子树的\n            dp.pop_back();\n        }\n        else if (p->left || p->right) { // 有一个非空\n            // 当前不偷：那就是非空子树上一次的偷的值\n            temp[0] = max(dp[dp.size() - 1][1], dp[dp.size() - 1][0]); \n            // 当前偷：那就是非空子树上一次的不偷的值（相当于是当前索引上上次可能偷的值）\n            temp[1] = dp[dp.size() - 1][0] + p->val; \n            dp.pop_back();\n        }\n        else { // 根节点\n            temp[0] = 0; // 不偷\n            temp[1] = p->val; // 偷\n        }\n        cout << temp[0] << \" \" <<  temp[1] << endl;\n        dp.emplace_back(temp);\n    }\n\n    int rob(TreeNode* root) {\n        if(root == nullptr) {\n            return 0;\n        }\n        temp.emplace_back(0);\n        temp.emplace_back(0);\n        robPostOrder(root);\n        // for (auto p:dp) {\n        //     cout << p[0] << \" \" <<  p[1] << endl;\n        // }\n        return max(dp[dp.size() - 1][0], dp[dp.size() - 1][1]);\n    }\n};\n```\n\n#### 解法二——一个数组即可\n\n——代码随想录\n\n做了几点简化：\n\n+ 它不需要我的二维数组才保存dp，直接每次返回当前节点偷或者不偷的情况\n+ 不偷的情况不需要我的四个和取max，只需要两边各取max即可。\n+ 空节点也不需要单独考虑，直接返回0，0即可。\n\n```cpp\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        vector<int> result = robTree(root);\n        return max(result[0], result[1]);\n    }\n    // 长度为2的数组，0：不偷，1：偷\n    vector<int> robTree(TreeNode* cur) {\n        if (cur == NULL) return vector<int>{0, 0};\n        vector<int> left = robTree(cur->left);\n        vector<int> right = robTree(cur->right);\n        // 偷cur，那么就不能偷左右节点。\n        int val1 = cur->val + left[0] + right[0];\n        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况\n        int val2 = max(left[0], left[1]) + max(right[0], right[1]);\n        return {val2, val1};\n    }\n};\n```\n\n### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)\n\n> 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n>\n> 你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n>\n> 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n#### 解法一——贪心\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int low = INT_MAX;\n        int output = 0;\n        for (int i = 0; i < prices.size(); i++) {\n            low = min(low, prices[i]);\n            output = max(output, prices[i] - low);\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = - prices[0]; // 第0天买入股票，手头剩下\n        dp[0][1] = 0; // 第0天抛出股票\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(dp[i-1][0], - prices[i]);\n            dp[i][1] = max(dp[i-1][1], prices[i] + dp[i-1][0]);\n        }\n        return dp[prices.size() - 1][1];\n    }\n};\n```\n\n从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int len = prices.size();\n        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组\n        dp[0][0] -= prices[0];\n        dp[0][1] = 0;\n        for (int i = 1; i < len; i++) {\n            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);\n            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n        }\n        return dp[(len - 1) % 2][1];\n    }\n};\n```\n\n### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)\n\n> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。\n>\n> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。\n>\n> 返回 *你能获得的 **最大** 利润* 。\n\n贪心见前一部分，给出动规解法\n\n与买卖股票1的区别——$dp[i][0]$不止和上次也没持有比较，还和上次持有但是买了有关。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = - prices[0]; // 持有\n        dp[0][1] = 0; // 不持有\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);\n        }\n        return dp[prices.size() - 1][1];\n    }\n};\n```\n\n### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)\n\n> 给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。\n>\n> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n分四个状态：第一笔持有、第一笔卖出、第二笔持有、第二笔卖出\n\n如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。\n\n在动态规划结束后，由于我们可以进行不超过两笔交易，因此最终的答案在 0，sell1，sell2中，且为三者中的最大值。然而我们可以发现，由于在边界条件中 sell1和 sell2的值已经为 0，并且在状态转移的过程中我们维护的是最大值，因此 sell1和 sell2最终一定大于等于 0。同时，如果最优的情况对应的是恰好一笔交易，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从 sell1转移至 sell2，因此最终的答案即为 sell2\n\n——力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int>(4));\n        dp[0][0] = - prices[0]; // 第一次持有\n        dp[0][1] = 0; // 第一次卖出\n        dp[0][2] = - prices[0]; // 第二次持有,第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了\n        dp[0][3] = 0; // 第二次卖出\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(- prices[i], dp[i-1][0]);\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);\n            dp[i][2] = max(dp[i][1] - prices[i], dp[i-1][2]); // 之前错在这里，应该要在这里引入第一次卖出的结果\n            dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);\n        }\n        // cout << dp[prices.size() - 1][1] << \" \" << dp[prices.size() - 1][3];\n        return dp[prices.size() - 1][3];\n    }\n};\n```\n\n### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)\n\n> 给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。\n>\n> 设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n和上一题一致，只是换成了循环\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int> (2 * k));\n        for (int j = 0; j < k; j++) {\n            dp[0][2 * j] = - prices[0]; // 2*j的位置是持有，2*j+1的位置是不持有\n        }\n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(- prices[i], dp[i-1][0]); // 2*j的位置是持有\n            dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1]); //2*j+1的位置是不持有\n            for (int j = 1; j < k; j++) {\n                dp[i][2 * j] = max(dp[i-1][2 * j - 1] - prices[i], dp[i-1][2 * j]); // 2*j的位置是持有\n                dp[i][2 * j + 1] = max(dp[i-1][2 * j] + prices[i], dp[i-1][2 * j + 1]); //2*j+1的位置是不持有\n            }\n        }\n        return dp[prices.size() - 1][2 * k - 1];\n    }\n};\n```\n\n\n\n\n\n### [309. 买卖股票的最佳时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n> 给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `*i*` 天的股票价格 。\n>\n> 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:\n>\n> - 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。\n>\n> **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        vector<vector<int>> dp(prices.size(), vector<int>(3));\n        dp[0][0] = - prices[0]; // 持有\n        dp[0][1] = 0; // 不持有且不在不在冷冻期\n        dp[0][2] = 0; // 冷冻期\n\n        for(int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]); // 持有只有两种：上一期持有，上次不持有-price[i]\n            dp[i][1] = max(dp[i-1][1], dp[i-1][2]); // 上一次在冷冻期，或者上一次不持有\n            dp[i][2] = dp[i-1][0] + prices[i]; // 上一期持有，本期抛售\n            // cout << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << endl;\n        }\n        return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);\n\n    }\n};\n```\n\n### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\n\n> 给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。\n>\n> 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。\n>\n> 返回获得利润的最大值。\n>\n> **注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        vector<vector<int>> dp(prices.size(), vector<int>(2));\n        dp[0][0] = - prices[0]; // 持有\n        dp[0][1] = 0;// 未持有 \n        for (int i = 1; i < prices.size(); i++) {\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);\n            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);\n        }\n        return max(dp[prices.size() - 1][0], dp[prices.size() - 1][1]);\n    }\n};\n```\n\n### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)\n\n> 给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n>\n> **子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> dp(nums.size(), 1); // 考虑当前元素加入时候的最长值\n        int output = 1;\n        for (int i = 1; i < nums.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) { // 通过之前的遍历\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n            if (dp[i] > output) {\n                output = dp[i];\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)\n\n> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。\n>\n> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。\n\n这道题看上去和动规没啥关系啊！原来我这是贪心的解法啊\n\n```cpp\nclass Solution {\npublic:\n    int findLengthOfLCIS(vector<int>& nums) {\n        int temp = 1;\n        int output = 1;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] > nums[i-1]) {\n                temp++;\n            }\n            else {\n                temp = 1;\n            }\n            if (temp > output) {\n                output = temp;\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)\n\n> 给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。\n\n#### 解法一——二维数组\n\n`dp[i][j] `：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为`dp[i][j]`。\n\n减一是为了方便初始化。\n\n```cpp\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        vector<vector<int>> dp(nums1.size() + 1, vector<int>(nums2.size() + 1));\n        // dp[i+1][j+1]表示截至nums1的i位置，nums2的j位置最长重复子数组是多少\n        int output = 0;\n        for (int i = 0; i < nums1.size(); i++) {\n            for (int j = 0; j < nums2.size(); j++) {\n                if (nums1[i] == nums2[j]) {\n                    dp[i+1][j+1] = dp[i][j] + 1; // 注意这里是和谁比\n                }\n                if (output < dp[i+1][j+1]) {\n                    output = dp[i+1][j+1];\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——滚动数组\n\n![718.最长重复子数组](/2021011215282060-20230310134554486.jpg)\n\n`dp[i][j]`都是由`dp[i - 1][j - 1]`推出。那么压缩为一维数组，也就是`dp[j]`都是由`dp[j - 1]`推出。也就是相当于可以把上一层`dp[i - 1][j]`拷贝到下一层`dp[i][j]`来继续用。**此时遍历B数组的时候，就要从后向前遍历，这样避免重复覆盖**。\n\n注意，不相等要赋零初始化。\n\n```cpp\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> dp(nums2.size() + 1);\n        int output = 0;\n\n        for (int i = 0; i < nums1.size(); i++) {\n            for (int j = nums2.size() - 1; j >= 0 ; j--) {\n                if (nums1[i] == nums2[j]) {\n                    dp[j+1] = dp[j] + 1;\n                }\n                else {\n                    dp[j+1] = 0; // 不相等要附零\n                }\n                if (output < dp[j+1]) {\n                    output = dp[j+1];\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)\n\n> 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n>\n> 一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n>\n> - 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n>\n> 两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n滚动数组太难想了。\n\n#### 解法一——二维数组\n\n每行对应不同的text1序列，到text1的第几位了，之前的元素最多能和text2重合几位\n\n```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> dp(text1.size() + 1, vector<int> (text2.size() + 1));\n        \n        for (int i = 0; i < text1.size(); i++) {\n            for (int j = 0; j < text2.size(); j++) {\n                if (text1[i] == text2[j]) {\n                    dp[i+1][j+1] = dp[i][j] + 1;\n                }\n                else {\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]); // 注意这里不是dp[i][j]\n                }\n            }\n        }\n        return dp[text1.size()][text2.size()];\n    }\n};\n```\n\n#### 解法二——滚动数组\n\n太绕了,还是二维数组吧\n\n```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<int> dp(text2.size() + 1);\n        int output = 0;\n        for (int i = 0; i < text1.size(); i++) {\n            int temp = 0;  // 存储上一位没有+1的值\n            for (int j = 0; j < text2.size(); j++) { \n                /* 这里会存在一个矛盾，当text1[i] == text2[j]时候，我要加1，我希望这里的dp[j]是没有加1过的\n                但是当text1[i] != text2[j]时候，我需要在两种情况下（①i和j+1；②i+1和j）取最大，希望这里的dp[j]是加1过的\n                */\n                if (text1[i] == text2[j]) {\n                    int old = dp[j+1];\n                    dp[j+1] = temp + 1;\n                    temp = max(old, temp); // 这里需要比较的是dp[j+1]原来的值和原来的temp，\n                }\n                else {\n                    dp[j+1] = max(dp[j+1], temp);\n                    temp = dp[j+1];\n                }\n                // int newlen = max(temp, dp[j+1]);\n                // if (text1[i] == text2[j]) {\n                //     dp[j+1] = temp+1;\n                // }\n                // temp = newlen;\n                if (dp[j+1] > output) {\n                    output = dp[j+1];\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)\n\n> 在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。\n>\n> 现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足：\n>\n> -  `nums1[i] == nums2[j]`\n> - 且绘制的直线不与任何其他连线（非水平线）相交。\n>\n> 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n>\n> 以这种方法绘制线条，并返回可以绘制的最大连线数。\n\n**难就难在这一步抽象！**： 直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。\n\n就转换成了上一道题的问题。这里我还是用滚动数组来试一下。\n\n```cpp\nclass Solution {\npublic:\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> dp(nums2.size() + 1);\n        int output = 0;\n        for (int i = 0; i < nums1.size(); i++) {\n            int temp = 0;\n            for (int j = 0; j < nums2.size(); j++) {\n                int newlen = max(dp[j+1], temp); // 先存一下到当前位置最多连线数量是多少，不考虑该位置相等加一的问题。\n                if (nums1[i] == nums2[j]) { // 相等了也是在temp的基础上加\n                    dp[j+1] = temp + 1;\n                }\n                temp = newlen;\n                if (output < dp[j+1]) {\n                    output = dp[j+1];\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n>给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n>\n>**子数组**是数组中的一个连续部分。\n>\n>**子数组** 是数组中连续的 **非空** 元素序列。\n\n```cpp\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0] = nums[0];\n        int output = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dp[i] = max(dp[i-1] + nums[i], nums[i]); // 如果之前的加上这个数反而还不如这个数字，那就没意义了\n            if (dp[i] > output) {\n                output = dp[i];\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)\n\n> 给定字符串 **s** 和 **t** ，判断 **s** 是否为 **t** 的子序列。\n>\n> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`\"ace\"`是`\"abcde\"`的一个子序列，而`\"aec\"`不是）。\n>\n> **进阶：**\n>\n> 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？\n\n#### 解法一——双指针\n\n```cpp\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        if (s.length() > t.length()) {\n            return false;\n        }\n        int start = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = start; j < t.length(); j++) {\n                cout << i << \" \" << j << endl;\n                if (s[i] == t[j]) {\n                    start = j + 1;\n                    if (start == t.length() && i != s.length() - 1) { // 防止超出去\n                        return false;\n                    }\n                    break;\n                }\n                if (j == t.length() - 1 && s[i] != t[j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n```cpp\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        vector<vector<int>> dp(s.length() + 1, vector<int>(t.length() + 1));\n\n        for (int i = 0; i < s.length(); i++) {\n            for(int j = 0; j < t.length(); j++) {\n                if (s[i] == t[j]) {\n                    dp[i+1][j+1] = dp[i][j] + 1;\n                }\n                else {\n                    dp[i+1][j+1] = dp[i+1][j]; // 未匹配，保留上一个匹配的值\n                }\n            }\n        }\n        return dp[s.length()][t.length()] == s.length();\n    }\n};\n```\n\n### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)\n\n> 给你两个字符串 `s` 和 `t` ，统计并返回在 `s` 的 **子序列** 中 `t` 出现的个数，结果需要对 $10^9 + 7$​ 取模。\n\n或者也可以把i为1的情况放进去一起考虑，后来发现不需要乘了，而是加的关系。但是第0行还是需要初始化的\n\n```cpp\nclass Solution {\npublic:\n    int numDistinct(string s, string t) {\n        vector<vector<unsigned long long>> dp(t.length() + 1, vector<unsigned long long> (s.length() + 1)); // t才是要找的子序列\n        // dp[i+1][j+1]表示截至t的第i个字母，s的第j个字母有多少种方案。\n        int temp = 0;\n        for (int j = 0; j < s.length(); j++) {\n            if (t[0] == s[j]) {\n                dp[1][j+1] = ++temp;\n            }\n            else {\n                dp[1][j+1] = dp[1][j]; // 不等那么就保留前面的\n            }\n            // cout << 1 << \" \" << j+1 << \" \" << dp[1][j+1] << \" \" << temp << endl;\n        }\n        if (temp == 0) {\n            return 0;\n        }\n        for (int i = 1; i < t.length(); i++) {\n            temp = 0; // 当前字母i有几种\n            for (int j = i; j < s.length(); j++) {\n                if(t[i] == s[j]) {\n                    temp++;\n                    dp[i+1][j+1] = dp[i+1][j] + dp[i][j]; // 因为这里要考虑乘法，所以需要单独考虑s的第0个字母。\n                }\n                else {\n                    dp[i+1][j+1] = dp[i+1][j];\n                }\n                // cout << i+1 << \" \" << j+1 << \" \" << dp[i+1][j+1] << \" \" << temp << endl;\n            }\n            if (temp == 0) {\n                return 0;\n            }\n        }\n        return dp[t.length()][s.length()];\n    }\n}; \n```\n\n### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)\n\n> 给定两个单词 `word1` 和 `word2` ，返回使得 `word1` 和 `word2` **相同**所需的**最小步数**。\n>\n> **每步** 可以删除任意一个字符串中的一个字符。\n\n求最大公共子串？然后再减一下。\n\n```cpp\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));\n\n        for (int i = 0; i < word1.size(); i++) {\n            for (int j = 0; j < word2.size(); j++) {\n                if (word1[i] == word2[j]) {\n                    dp[i+1][j+1] = dp[i][j] + 1;\n                }\n                else {\n                    dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n                }\n            }\n        }\n        return (word1.size() + word2.size() - 2 * dp[word1.size()][word2.size()]);\n    }\n};\n```\n\n### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)\n\n> 给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n>\n> 你可以对一个单词进行如下三种操作：\n>\n> - 插入一个字符\n> - 删除一个字符\n> - 替换一个字符\n\n\n\n我们可以发现，如果我们有单词 A 和单词 B：\n\n对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；\n\n同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；\n\n对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -> c，和修改单词 B 的第一个字母 c -> b 是等价的。\n\n这样以来，本质不同的操作实际上只有三种：\n\n+ 在单词 A 中插入一个字符；\n+ 在单词 B 中插入一个字符；\n+ 修改单词 A 的一个字符\n\n——力扣官方题解\n\n**两个单词都可以操作！**\n\n```cpp\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));\n        // 边界条件需要初始化，毕竟你一个单词万一是空的这么说直接啥也不需要了？\n        // dp[0][0] = 0;\n        for (int i = 0; i < word1.size(); i++) {\n            dp[i+1][0] = i+1;\n        }\n        for (int j = 0; j < word2.size(); j++) {\n            dp[0][j+1] = j+1;\n        }\n        for (int i = 0; i < word1.size(); i++) {\n            for (int j = 0; j < word2.size(); j++) {\n                if (word1[i] == word2[j]) {\n                    dp[i+1][j+1] = dp[i][j];\n                }\n                else  {\n                    // 否则三种操作，A加一个单词，B加一个单词，A换一个字符\n                    dp[i+1][j+1] = min({dp[i][j+1], dp[i+1][j], dp[i][j]}) + 1;\n                }\n            }\n        }\n        return dp[word1.size()][word2.size()];\n    }\n};\n```\n\n### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)\n\n> 给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。\n>\n> **回文字符串** 是正着读和倒过来读一样的字符串。\n>\n> **子字符串** 是字符串中的由连续字符组成的一个序列。\n>\n> 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n\n#### 解法一——双指针\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int left, right;\n        int output = 1; // 0位置的\n\n        for (int center = 1; center < s.length(); center++)  {\n            output ++; // 独自的\n            // 区分奇偶，偶数往左找\n            if (s[center] == s[center - 1]) { // 偶\n                left = center - 1;\n                right = center;\n                while (left >= 0 && right < s.length() && s[left] == s[right]) {\n                    output++;\n                    left--;\n                    right++;                    \n                }\n            }\n            // 奇数是必然有的情况，不需要else\n            left = center - 1;\n            right = center + 1;\n            while (left >= 0 && right < s.length() && s[left] == s[right]) {\n                output++;\n                left--;\n                right++;                    \n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——动态规划\n\n布尔类型的`dp[i][j]`：表示区间范围`[i,j]` （注意是左闭右闭）的子串是否是回文子串，如果是`dp[i][j]`为true，否则为false。\n\n遍历时候，需要的元素出现在左下角。\n\n![647.回文子串](/20210121171032473-20230310132134822.jpg)\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        vector<vector<bool>> dp(s.length(), vector<bool>(s.length(), false));\n        int output = 0;\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (s[i] == s[j] && (j - i <= 1 || dp[i+1][j-1])) {\n                    output++;\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n不如双指针好理解。\n\n\n\n### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)\n\n> 给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。\n>\n> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n\n```cpp\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        vector<vector<int>> dp(s.length(), vector<int>(s.length()));\n        // 保存的是区间内回文子串最长是多少\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (s[i] == s[j]) {\n                    if (j - i <= 1) {\n                        dp[i][j] = j - i + 1;\n                    }\n                    else {\n                        dp[i][j] = dp[i+1][j-1] + 2;\n                    }\n                }\n                else {\n                    dp[i][j] = max(dp[i+1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[0][s.length() - 1];\n    }\n};\n```\n\n## 单调栈\n\n### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)\n\n> 给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n只要存下标就好了\n\n```cpp\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        stack<int> S; //栈底元素对应的温度最大（只要存下标！！！） 栈里面的元素递增\n        int numSize = temperatures.size();\n        vector<int> output(numSize);\n        S.push(numSize - 1);\n        for (int i = numSize - 2; i >= 0; i--) {\n            while (!S.empty() && temperatures[i] >= temperatures[S.top()]) {\n                S.pop();\n            }\n            if (S.empty()) {\n                output[i] = 0;\n            }\n            else {\n                output[i] = S.top() - i;\n            }\n            S.push(i);\n        }\n        return output;\n    }\n};\n```\n\n### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)\n\n> `nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。\n>\n> 给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。\n>\n> 对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。\n>\n> 返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。\n\n单调栈+哈希表\n\n```cpp\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        map<int, int> nums1Index;\n        stack<int> S; // 这道题可以直接存数值了\n        vector<int> output(nums1.size());\n        for (int i = 0; i < nums1.size(); i++) {\n            nums1Index[nums1[i]] = i + 1;\n        }\n        for (int j = nums2.size() - 1; j >= 0; j--) {\n            if (nums1Index[nums2[j]] == 0) {\n                S.push(nums2[j]);\n                continue;\n            }\n            while (!S.empty() && nums2[j] >= S.top()) {\n                S.pop();\n            }\n            // cout << nums1Index[nums2[j]] - 1 << endl;\n            if (S.empty()) {\n                output[nums1Index[nums2[j]] - 1] = -1;\n            }\n            else {\n                output[nums1Index[nums2[j]] - 1] = S.top();\n            }\n            S.push(nums2[j]);\n        }\n        return output;\n    }\n};\n```\n\n### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)\n\n> 给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。\n>\n> 数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。\n\n模一下？做两遍，第一遍不操作output；\n\n```cpp\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        stack<int> S; // 先存一遍，但不操作output；\n        vector<int> output(nums.size());\n\n        for (int i = nums.size() - 1; i >= 0; i--)  {\n            while (!S.empty() && (nums[i] >= S.top())) {\n                S.pop();\n            }\n            S.push(nums[i]);\n        }\n        for (int i = nums.size() - 1; i >= 0; i--)  {\n            while (!S.empty() && (nums[i] >= S.top())) {\n                S.pop();\n            }\n            if (S.empty()) {\n                output[i] = -1;\n            }\n            else {\n                output[i] = S.top();\n            }\n            S.push(nums[i]);\n        }\n        return output;\n    }\n};\n```\n\n### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)\n\n> 给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n>\n> ![img](/rainwatertrap.png)\n>\n> （PS：怎么想到了注水法功控，虽然好像不完全是一回事情！）\n\n```cpp\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int output = 0;\n        stack<int> S; // 还是应该存下标\n        for (int i = 0; i < height.size(); i++) {\n            while (!S.empty() && height[i] >= height[S.top()]) {\n                int last = height[S.top()];\n                // cout << i << \" \" << S.top() << \" \" ;\n                S.pop(); //只有在每pop一次才相当于积攒了一部分水\n                if (!S.empty()) { // S空了左边是挡不住水的\n                    int length = i - S.top() - 1; // 因为减完包含了最左边挡住的柱子\n                    output += length * (min(height[S.top()] , height[i]) - last); // 距离*高度\n                }\n                // cout << output << endl;\n            }            \n            S.push(i);\n        }\n        return output;\n    }\n};\n```\n\n### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)\n\n> 给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n>\n> 求在该柱状图中，能够勾勒出来的矩形的最大面积。\n>\n> ![img](/histogram.jpg)\n\n\"42. 接雨水\" 是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。\n\n太绕了，吐血\n\n```cpp\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        stack <int> S; // 保存下标；\n        heights.insert(heights.begin(), 0);\n        heights.push_back(0);\n        S.push(0);\n        int output = 0;\n        int temp = 0;\n        int last = 0;\n        for (int i = 1; i < heights.size(); i++) {\n            while (!S.empty() && heights[i] < heights[S.top()]) {\n                last = heights[S.top()];\n                S.pop();\n                if (!S.empty()) {\n                    temp = (i - S.top() - 1) * last; // 不在S里面的值都比边缘高\n                }\n                else {\n                    temp = (i + 1) * heights[i];\n                }\n                if (temp > output) {\n                    output = temp;\n                }\n            }\n            // if (S.empty()) {\n            //     cout << i << \" \" << output << \" \" << last << endl;\n            // } \n            // else {\n            //     cout << i << \" \" << output << \" \" << last << \" \" << S.top() << endl;\n            // }\n            S.push(i);\n        }\n        return output;\n    }\n};\n```\n\n## 图论\n\n> 深搜(DFS)和广搜(BFS)\n>\n> - dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。\n> - bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。\n>\n> **DFS**\n>\n> 回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：\n>\n> ```cpp\n> void dfs(参数) {\n>     if (终止条件) {\n>         存放结果;\n>         return;\n>     }\n> \n>     for (选择：本节点所连接的其他节点) {\n>         处理节点;\n>         dfs(图，选择的节点); // 递归\n>         回溯，撤销处理结果\n>     }\n> }\n> ```\n>\n> **BFS**——一圈一圈搜索\n>\n> ![图三](/20220825103900.png)\n>\n> 仅仅需要一个容器，能保存我们要遍历过的元素就可以，**那么用队列，还是用栈，甚至用数组，都是可以的**。\n>\n> 广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）\n>\n> ```cpp\n> int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向\n> // grid 是地图，也就是一个二维数组\n> // visited标记访问过的节点，不要重复访问\n> // x,y 表示开始搜索节点的下标\n> void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {\n>     queue<pair<int, int>> que; // 定义队列\n>     que.push({x, y}); // 起始节点加入队列\n>     visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点\n>     while(!que.empty()) { // 开始遍历队列里的元素\n>         pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素\n>         int curx = cur.first;\n>         int cury = cur.second; // 当前节点坐标\n>         for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历\n>             int nextx = curx + dir[i][0];\n>             int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标\n>             if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过\n>             if (!visited[nextx][nexty]) { // 如果节点没被访问过\n>                 que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点\n>                 visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问\n>             }\n>         }\n>     }\n> \n> }\n> ```\n>\n> ——代码随想录\n\n### [797. 所有可能的路径](https://leetcode.cn/problems/all-paths-from-source-to-target/)\n\n> 给你一个有 `n` 个节点的 **有向无环图（DAG）**，请你找出所有从节点 `0` 到节点 `n-1` 的路径并输出（**不要求按特定顺序**）\n>\n>  `graph[i]` 是一个从节点 `i` 可以访问的所有节点的列表（即从节点 `i` 到节点 `graph[i][j]`存在一条有向边）。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> temp;\n    vector<vector<int>> output;\n    void dfs(vector<vector<int>>& graph, int node) {\n        if (node == graph.size() - 1) {\n            output.emplace_back(temp);\n            return;\n        }\n        for (auto nodeNext:graph[node]) {\n            temp.emplace_back(nodeNext);\n            dfs(graph, nodeNext);\n            temp.pop_back();\n        }\n    }\n    vector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\n        if (graph.empty()) {\n            return output;\n        }\n        temp.emplace_back(0);\n        dfs(graph, 0);\n        temp.pop_back();\n        return output;\n    }\n};\n```\n\n### [200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)\n\n> 给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。\n>\n> 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。\n>\n> 此外，你可以假设该网格的四条边均被水包围。\n\n#### 解法一——DFS\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void dfs (vector<vector<char>> &grid, vector<vector<bool>> &visited, int x, int y) {\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                continue; //超范围\n            }\n            if (!visited[xNext][yNext] && grid[xNext][yNext] == '1') {\n                // cout << xNext << \" \" << yNext << \" \"  << endl;\n                visited[xNext][yNext] = true;\n                dfs(grid, visited, xNext, yNext);\n            }\n        }\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size(); // 行\n        int m = grid[0].size(); // 列\n        vector<vector<bool>> visited(n, vector<bool> (m, false));\n        int output = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == '1') {\n                    // cout << i << \" \" << j << \" \" << output << endl;\n                    // 未访问过，且是陆地\n                    visited[i][j] = true;\n                    output++;\n                    dfs(grid, visited, i, j); // 将所有链接到的陆地标记为true\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——BFS\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void bfs (vector<vector<char>> &grid, vector<vector<bool>> &visited, int x, int y) {\n        queue<pair<int, int >> Q;\n        visited[x][y] = true; // 以起始点为圆心广搜\n        Q.push({x, y});\n        while(!Q.empty()) {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            int xCur = cur.first;\n            int yCur = cur.second;\n            for (int i = 0; i < 4; i++) {\n                int xNext = xCur + dir[i][0];\n                int yNext = yCur + dir[i][1];\n                if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                    continue; //超范围\n                }\n                if (!visited[xNext][yNext] && grid[xNext][yNext] == '1') {\n                    visited[xNext][yNext] = true;\n                    Q.push({xNext, yNext});\n                }\n            }\n            \n        }\n    }\n\n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size(); // 行\n        int m = grid[0].size(); // 列\n        vector<vector<bool>> visited(n, vector<bool> (m, false));\n        int output = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == '1') {\n                    // cout << i << \" \" << j << \" \" << output << endl;\n                    // 未访问过，且是陆地\n                    // visited[i][j] = true;\n                    output++;\n                    bfs(grid, visited, i, j); // 将所有链接到的陆地标记为true\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)\n\n> 给你一个大小为 `m x n` 的二进制矩阵 `grid` 。\n>\n> **岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。\n>\n> 岛屿的面积是岛上值为 `1` 的单元格的数目。\n>\n> 计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。\n\n考虑使用广搜。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n\n    int bfs(vector<vector<int>> &grid, vector<vector<bool>> &visited, int x, int y) {\n        queue <pair<int, int>> Q;\n        Q.push({x, y});\n        visited[x][y] = true;\n        int areaSize = 1;\n        while (!Q.empty()) {\n            pair<int, int> cur = Q.front();\n            Q.pop();\n            for (int i = 0; i < 4; i++) {\n                int xNext = cur.first + dir[i][0];\n                int yNext = cur.second + dir[i][1];\n                if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                    continue;\n                }\n                if (!visited[xNext][yNext] && grid[xNext][yNext] == 1) {\n                    visited[xNext][yNext] = true;\n                    Q.push({xNext, yNext});\n                    areaSize++;\n                }\n            }\n        }\n        return areaSize;\n    }\n\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\n        int output = 0;\n        for (int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[0].size(); j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    int areaSize = bfs(grid, visited, i, j);\n                    // cout << i << \" \" << j << \" \" << areaSize << endl;\n                    output = max(areaSize, output);\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)\n\n> 给你一个大小为 `m x n` 的二进制矩阵 `grid` ，其中 `0` 表示一个海洋单元格、`1` 表示一个陆地单元格。\n>\n> 一次 **移动** 是指从一个陆地单元格走到另一个相邻（**上、下、左、右**）的陆地单元格或跨过 `grid` 的边界。\n>\n> 返回网格中 **无法** 在任意次数的移动中离开网格边界的陆地单元格的数量。\n\n#### 解法一——深搜+visited数组\n\n思路：通过深搜，标记边缘点能够联通的位置。再统计内部其余未被visit的点。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void dfs (vector<vector<int>>& grid, vector<vector<bool>> &visited, int x, int y) {\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()){\n                continue;\n            }\n            if (!visited[xNext][yNext] && grid[xNext][yNext] == 1) {\n                visited[xNext][yNext] = true;\n                dfs(grid, visited, xNext, yNext);\n            }\n        }\n    }\n    int numEnclaves(vector<vector<int>>& grid) {\n        vector<vector<bool>> visited(grid.size(), vector<bool> (grid[0].size()));\n        for (int j = 0; j < grid[0].size(); j++) { // 第一行和最后一行\n            if (!visited[0][j] && grid[0][j] == 1){\n                visited[0][j] = true;\n                dfs(grid, visited, 0, j);\n            }\n            if (!visited[grid.size() - 1][j] && grid[grid.size() - 1][j] == 1){\n                visited[grid.size() - 1][j] = true;\n                dfs(grid, visited, grid.size() - 1, j);\n            }\n        }\n        for (int i = 1; i < grid.size() - 1; i++) { // 第一列和最后一列\n            if (!visited[i][0] && grid[i][0] == 1){\n                visited[i][0] = true;\n                dfs(grid, visited, i, 0);\n            }\n            if (!visited[i][grid[0].size() - 1] && grid[i][grid[0].size() - 1] == 1){\n                visited[i][grid[0].size() - 1] = true;\n                dfs(grid, visited, i, grid[0].size() - 1);\n            }\n        }\n        int count = 0;\n        for (int i = 1; i < grid.size() - 1; i++) {\n            for(int j = 1; j < grid[0].size() - 1; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};\n```\n\n#### 解法二——深搜+优化空间\n\n不使用visited数组，直接对grid进行操作。visit过就将对应位置置零。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n    void dfs (vector<vector<int>>& grid, int x, int y) {\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()){\n                continue;\n            }\n            if (grid[xNext][yNext] == 1) {\n                grid[xNext][yNext] = 0;\n                dfs(grid, xNext, yNext);\n            }\n        }\n    }\n    int numEnclaves(vector<vector<int>>& grid) {\n        for (int j = 0; j < grid[0].size(); j++) { // 第一行和最后一行\n            if (grid[0][j] == 1){\n                grid[0][j] = 0;\n                dfs(grid,  0, j);\n            }\n            if (grid[grid.size() - 1][j] == 1){\n                grid[grid.size() - 1][j] = 0;\n                dfs(grid,  grid.size() - 1, j);\n            }\n        }\n        for (int i = 1; i < grid.size() - 1; i++) { // 第一列和最后一列\n            if (grid[i][0] == 1){\n                grid[i][0] = 0;\n                dfs(grid, i, 0);\n            }\n            if (grid[i][grid[0].size() - 1] == 1){\n                grid[i][grid[0].size() - 1] = 0;\n                dfs(grid, i, grid[0].size() - 1);\n            }\n        }\n        int count = 0;\n        for (int i = 1; i < grid.size() - 1; i++) {\n            for(int j = 1; j < grid[0].size() - 1; j++) {\n                if (grid[i][j] == 1) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};\n```\n\n### [130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)\n\n> 给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` ，找到所有被 `'X'` 围绕的区域，并将这些区域里所有的 `'O'` 用 `'X'` 填充。\n\n与边缘相连的陆地不能沉没，用'T'表示。最后对中心处理，没有和边缘相连的陆地'O'沉没掉变成'X'，而相连的'T'改成'O'。\n\n#### 解法一——广搜\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    void bfs(vector<vector<char>> &board, int x, int y) {\n        queue <pair<int, int>> Q;\n        Q.push({x, y});\n        while (!Q.empty()) {\n            pair<int,int> cur = Q.front();\n            Q.pop();\n            for (int i = 0; i < 4; i++) {\n                int xNext = cur.first + dir[i][0];\n                int yNext = cur.second + dir[i][1];\n                if (xNext <= 0 || yNext <= 0 || xNext >= board.size() - 1 || yNext >= board[0].size() - 1) {\n                    continue;\n                }\n                if (board[xNext][yNext] == 'O') {\n                    board[xNext][yNext] = 'T';\n                    Q.push({xNext, yNext});\n                }\n            }\n        }\n        \n    }\n    void solve(vector<vector<char>>& board) {\n        for (int j = 0; j < board[0].size(); j++) {// 首尾行\n            if (board[0][j] == 'O') {\n                bfs(board, 0, j);\n            }\n            if (board[board.size() - 1][j] == 'O') {\n                bfs(board, board.size() - 1, j);\n            }\n        }\n        for (int i = 1; i < board.size() - 1; i++) {// 首尾列\n            if (board[i][0] == 'O') {\n                bfs(board, i, 0);\n            }\n            if (board[i][board[0].size() - 1] == 'O') {\n                bfs(board, i, board[0].size() - 1);\n            }\n        }\n        for (int i = 1; i < board.size() - 1; i++) {\n            for (int j = 1; j < board[0].size() - 1; j++) {\n                // cout << board[i][j] << \" \";\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n                else if (board[i][j] == 'T') {\n                    board[i][j] = 'O';\n                }\n            }\n            // cout << endl;\n        }\n    }\n};\n```\n\n#### 解法二——深搜\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    void dfs (vector<vector<char>>& grid, int x, int y) {\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext <= 0 || yNext <= 0 || xNext >= grid.size() - 1 || yNext >= grid[0].size() - 1){\n                continue;\n            }\n            if (grid[xNext][yNext] == 'O') {\n                grid[xNext][yNext] = 'T';\n                dfs(grid, xNext, yNext);\n            }\n        }\n    }\n    void solve(vector<vector<char>>& board) {\n        for (int j = 0; j < board[0].size(); j++) {// 首尾行\n            if (board[0][j] == 'O') {\n                dfs(board, 0, j);\n            }\n            if (board[board.size() - 1][j] == 'O') {\n                dfs(board, board.size() - 1, j);\n            }\n        }\n        for (int i = 1; i < board.size() - 1; i++) {// 首尾列\n            if (board[i][0] == 'O') {\n                dfs(board, i, 0);\n            }\n            if (board[i][board[0].size() - 1] == 'O') {\n                dfs(board, i, board[0].size() - 1);\n            }\n        }\n        for (int i = 1; i < board.size() - 1; i++) {\n            for (int j = 1; j < board[0].size() - 1; j++) {\n                // cout << board[i][j] << \" \";\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n                else if (board[i][j] == 'T') {\n                    board[i][j] = 'O';\n                }\n            }\n            // cout << endl;\n        }\n    }\n};\n```\n\n### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)\n\n> 有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。\n>\n> 这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。\n>\n> 岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\n>\n> 返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。\n\n想法：建一个表格表示每个位置能够流到哪里。建立表格的原则是低的能向高的覆盖。\n\n原来想一并把output结果处理的，结果还是不行。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    vector<vector<int>> output; \n    void dfs(vector<vector<int>>& heights, vector<vector<int>>& flows, int x, int y) {\n        // vector<int> temp(2);\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= heights.size() || yNext >= heights[0].size()) {\n                continue;\n            }\n            if (heights[xNext][yNext] >= heights[x][y]) {\n                // next位置能流到当前位置\n                // cout << x << \" \" << y << \" \" << flows[x][y] << \"|| \" << xNext << \" \" << yNext << \" \" << flows[xNext][yNext] ;\n                if (flows[xNext][yNext] == flows[x][y]) { // 33,22,11,00\n                    continue;\n                }\n                else if (flows[xNext][yNext] + flows[x][y] >= 3 && flows[xNext][yNext] < 3)  { // 32,23,31,13,30,03,12,21\n                    // temp[0] = xNext;\n                    // temp[1] = yNext;\n                    // output.emplace_back(temp);\n                    flows[xNext][yNext] = 3;\n                }\n                else { //01,10,02,20\n                    flows[xNext][yNext] = max(flows[xNext][yNext], flows[x][y]);\n                }\n                // cout << \" || \" << flows[xNext][yNext] << endl;\n                dfs(heights, flows, xNext, yNext);\n            }\n        }\n    }\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        vector<int> temp(2);\n        // // 两个角落的先传进去\n        // temp[0] = 0; temp[1] = heights[0].size() - 1; output.emplace_back(temp);\n        // if (heights[0].size() == 1 && heights.size() == 1) {\n        //     return output;\n        // }\n        // temp[1] = 0; temp[0] = heights.size() - 1; output.emplace_back(temp);\n\n        vector<vector<int>> flows(heights.size(), vector<int>(heights[0].size()));\n        // 初始化左上为1(太平洋)、右下为2（大西洋）、右上角、左下角角落为3（全都可以）\n        for (int i = 0; i < heights.size(); i++) {// 首尾列\n            flows[i][0] += 1;\n            flows[i][heights[0].size() - 1] += 2;\n        }\n        for (int j = 1; j < heights[0].size() - 1; j++) {// 首尾行\n            flows[0][j] += 1;\n            flows[heights.size() - 1][j] += 2;\n        }\n        flows[0][heights[0].size() - 1] = 3;\n        flows[heights.size() - 1][0] = 3;\n        // 遍历\n        for (int i = 0; i < heights.size(); i++) {// 首尾列\n            // if (flows[i][0] == 3) {\n            //     temp[0] = i; temp[1] = 0; output.emplace_back(temp);\n            // }\n            dfs(heights, flows, i, 0);\n            // if (heights[0].size() == 1){\n            //     continue;\n            // }\n            // if (flows[i][heights[0].size() - 1] == 3) {\n            //     temp[0] = i; temp[1] = heights[0].size() - 1; output.emplace_back(temp);\n            // }\n            dfs(heights, flows, i, heights[0].size() - 1);\n        }\n        for (int j = 1; j < heights[0].size() - 1; j++) {// 首尾行\n            // if (flows[0][j] == 3) {\n            //     temp[0] = 0; temp[1] = j; output.emplace_back(temp);\n            // }\n            dfs(heights, flows, 0, j);\n            // if (heights.size() == 1){\n            //     continue;\n            // }\n            // if (flows[heights.size() - 1][j] == 3) {\n            //     temp[0] = heights.size() - 1; temp[1] = j; output.emplace_back(temp);\n            // }\n            dfs(heights, flows, heights.size() - 1, j);\n        }\n         for (int i = 0; i < heights.size() ; i++) {\n            for (int j = 0; j < heights[0].size() ; j++) {\n                if (flows[i][j] == 3){\n                    temp[0] = i;\n                    temp[1] = j;\n                    output.emplace_back(temp);\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n改了一下能够一遍处理的\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    vector<vector<int>> output; \n    void dfs(vector<vector<int>>& heights, vector<vector<int>>& flows, int x, int y) {\n        vector<int> temp(2);\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= heights.size() || yNext >= heights[0].size()) {\n                continue;\n            }\n            if (heights[xNext][yNext] >= heights[x][y]) {\n                // next位置能流到当前位置\n                // cout << x << \" \" << y << \" \" << flows[x][y] << \"|| \" << xNext << \" \" << yNext << \" \" << flows[xNext][yNext] ;\n                if (flows[xNext][yNext] == flows[x][y]) { // 33,22,11,00\n                    continue;\n                }\n                else if (flows[xNext][yNext] + flows[x][y] >= 3 && flows[xNext][yNext] < 3)  { // 32,23,31,13,30,03,12,21\n                    temp[0] = xNext;\n                    temp[1] = yNext;\n                    output.emplace_back(temp);\n                    flows[xNext][yNext] = 3;\n                }\n                else { //01,10,02,20\n                    flows[xNext][yNext] = max(flows[xNext][yNext], flows[x][y]);\n                }\n                // cout << \" || \" << flows[xNext][yNext] << endl;\n                dfs(heights, flows, xNext, yNext);\n            }\n        }\n    }\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        vector<int> temp(2);\n        // // 两个角落的先传进去\n        // temp[0] = 0; temp[1] = heights[0].size() - 1; output.emplace_back(temp);\n        // if (heights[0].size() == 1 && heights.size() == 1) {\n        //     return output;\n        // }\n        // temp[1] = 0; temp[0] = heights.size() - 1; output.emplace_back(temp);\n\n        vector<vector<int>> flows(heights.size(), vector<int>(heights[0].size()));\n        // 初始化左上为1(太平洋)、右下为2（大西洋）、右上角、左下角角落为3（全都可以）\n        for (int i = 0; i < heights.size(); i++) {// 首尾列\n            flows[i][0] += 1;\n            flows[i][heights[0].size() - 1] += 2;\n        }\n        for (int j = 1; j < heights[0].size() - 1; j++) {// 首尾行\n            flows[0][j] += 1;\n            flows[heights.size() - 1][j] += 2;\n        }\n        flows[0][heights[0].size() - 1] = 3;\n        flows[heights.size() - 1][0] = 3;\n        for (int i = 0; i < heights.size(); i++) {// 首尾列\n            if (flows[i][0] == 3) {\n                temp[0] = i; temp[1] = 0; output.emplace_back(temp);\n            }\n            if (heights[0].size() != 1 && flows[i][heights[0].size() - 1] == 3) {\n                temp[0] = i; temp[1] = heights[0].size() - 1; output.emplace_back(temp);\n            }\n        }\n        for (int j = 1; j < heights[0].size() - 1; j++) {// 首尾行\n            if (flows[0][j] == 3) {\n                temp[0] = 0; temp[1] = j; output.emplace_back(temp);\n            }\n            if (heights.size() != 1 && flows[heights.size() - 1][j] == 3) {\n                temp[0] = heights.size() - 1; temp[1] = j; output.emplace_back(temp);\n            }\n        }\n        // 遍历\n        for (int i = 0; i < heights.size(); i++) {// 首尾列\n            dfs(heights, flows, i, 0);\n            if (heights[0].size() == 1){\n                continue;\n            }\n            dfs(heights, flows, i, heights[0].size() - 1);\n        }\n        for (int j = 1; j < heights[0].size() - 1; j++) {// 首尾行\n            dfs(heights, flows, 0, j);\n            if (heights.size() == 1){\n                continue;\n            }\n            dfs(heights, flows, heights.size() - 1, j);\n        }\n        //  for (int i = 0; i < heights.size() ; i++) {\n        //     for (int j = 0; j < heights[0].size() ; j++) {\n        //         if (flows[i][j] == 3){\n        //             temp[0] = i;\n        //             temp[1] = j;\n        //             output.emplace_back(temp);\n        //         }\n        //     }\n        // }\n        return output;\n    }\n};\n```\n\n### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)\n\n> 给你一个大小为 `n x n` 二进制矩阵 `grid` 。**最多** 只能将一格 `0` 变成 `1` 。\n>\n> 返回执行此操作后，`grid` 中最大的岛屿面积是多少？\n>\n> **岛屿** 由一组上、下、左、右四个方向相连的 `1` 形成。\n\n暴力思路——每次改一个，看结果怎么变化。\n\n思路：一遍深搜先把每个位置对应的岛屿大小保存。第二遍只检测原来为0的位置，通过四个方向的岛屿面积累加得到。这里保存岛屿大小时候需要把岛屿的编号也保存，以保证独立性。由于统计岛屿大小时候无法直接录入最终的岛屿面积，所以只保存编号。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    int count;\n    void dfs (vector<vector<int>>& grid,int x, int y, int islandIndex) {\n        // cout << x << \" \" << y << \" \" << count << endl;\n        for (int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                continue;\n            }\n            if (grid[xNext][yNext] == 1) {\n                grid[xNext][yNext] = islandIndex;\n                count ++;\n                dfs(grid, xNext, yNext, islandIndex);\n            }\n        }\n    } \n    \n    // int islandAreaSum  (vector<vector<int>> areaIndex, int x, int y, unordered_map <int, int> areaMap) {\n    //     int area = 0;\n    //     for (int i = 0; i < 4; i++) {\n    //         int xNext = x + dir[i][0];\n    //         int yNext = y + dir[i][1];\n    //         if (xNext < 0 || yNext < 0 || xNext >= areaIndex.size() || yNext >= areaIndex[0].size()) {\n    //             continue;\n    //         }\n    //         if (areaIndex[xNext][yNext] != 0) {\n    //             // cout << xNext << \" | \" << yNext << \" \" <<areaMap[areaIndex[xNext][yNext]] << endl;\n    //             area += areaMap[areaIndex[xNext][yNext]];\n    //             areaMap[areaIndex[xNext][yNext]] = 0; // 置零只能加一次，同时这个局部变量不影响全局\n    //         }\n    //     }\n    //     // cout << x << \" \" << y << \" \" << area << endl;\n    //     return area + 1;\n    // }\n\n    int largestIsland(vector<vector<int>>& grid) {\n        // vector<vector<int>> areaIndex(grid.size(), vector<int>(grid[0].size())); // 保存每个位置的编号\n        unordered_map <int, int> areaMap; // 保存编号和面积的关系\n        bool allOne = true;\n\n        // 一遍深搜先把每个位置对应的岛屿大小保存。\n        int islandIndex = 2;\n        for (int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 0) {\n                    allOne = false;\n                }\n                if (grid[i][j] == 1) {\n                    grid[i][j] = islandIndex;\n                    count = 1;\n                    dfs(grid,  i, j, islandIndex);\n                    areaMap[islandIndex] = count;\n                    islandIndex++;\n                    // cout << count << \" \";\n                }\n            }\n        }\n\n        if (allOne) {\n            return grid.size() * grid[0].size();\n        }\n\n        // 二次深搜搜原来为0的位置，累加能得到的最大面积\n        int maxArea = 0;\n        \n        \n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 0) {\n                    // 检查四个方向陆地面积的和\n                    unordered_set<int> temp;\n                    int area = 0;\n                    for (int k = 0; k < 4; k++) {\n                        int xNext = i + dir[k][0];\n                        int yNext = j + dir[k][1];\n                        if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                            continue;\n                        }\n                        if (temp.find(grid[xNext][yNext]) == temp.end()) {\n                            // cout << xNext << \" | \" << yNext << \" \" <<areaMap[areaIndex[xNext][yNext]] << endl;\n                            area += areaMap[grid[xNext][yNext]];\n                            temp.insert(grid[xNext][yNext]);\n                            // areaMap[areaIndex[xNext][yNext]] = 0; \n                        }\n                    }\n                    maxArea = max(area + 1, maxArea);\n                    // maxArea = max(islandAreaSum(grid, i, j, areaMap), maxArea);\n                }\n            }\n        }\n        return maxArea;\n    }\n};\n```\n\n### [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)\n\n> 字典 `wordList` 中从单词 `beginWord` 和 `endWord` 的 **转换序列** 是一个按下述规格形成的序列 `beginWord -> s1 -> s2 -> ... -> sk`：\n>\n> - 每一对相邻的单词只差一个字母。\n> -  对于 `1 <= i <= k` 时，每个 `si` 都在 `wordList` 中。注意， `beginWord` 不需要在 `wordList` 中。\n> - `sk == endWord`\n>\n> 给你两个单词 `beginWord` 和 `endWord` 和一个字典 `wordList` ，返回 *从 `beginWord` 到 `endWord` 的 **最短转换序列** 中的 **单词数目*** 。如果不存在这样的转换序列，返回 `0` 。\n\n- 图中的线是如何连在一起的\n- 起点和终点的最短路径长度\n\n**这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径**。因为广搜就是以起点中心向四周扩散的搜索。\n\n```cpp\nclass Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_set<string> wordSet(wordList.begin(), wordList.end());\n        if (wordSet.find(endWord) == wordSet.end()) {\n            return 0;\n        }\n        unordered_map<string, int> isVisited; // 保存到这个单词的路径长度\n        // 使用广搜\n        queue<string> Q;\n        Q.push(beginWord);\n        isVisited[beginWord] = 1;\n\n        while (!Q.empty()) {\n            string cur = Q.front();\n            Q.pop();\n            for (int i = 0; i < cur.length(); i++) {\n                string newWord = cur;\n                for (int j = 0; j < 26; j++) {\n                    newWord[i] = 'a' + j;\n                    if (newWord == endWord) {\n                        return isVisited[cur] + 1;\n                    }\n                    if (wordSet.find(newWord) != wordSet.end() && isVisited[newWord] == 0) {\n                        isVisited[newWord] = isVisited[cur] + 1;\n                        Q.push(newWord);\n                    }\n                }\n            }\n        }\n        return 0;\n    }\n};\n```\n\n### [841. 钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/)\n\n> 有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。\n>\n> 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。\n>\n> 给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。\n\n和上一题的思路类似，利用广度搜索。但是可以不定义isVisited为int了，bool就够了，外面放一个count计数满为止。\n\n```cpp\nclass Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        int count = 1; // 0号房间一定能够进入\n        queue <int> Q;\n        vector<bool> visited(rooms.size(), false);\n        visited[0] = true;\n        for (auto room:rooms[0]) {\n            Q.push(room);\n            visited[room] = true;\n            count++;\n            if (count == rooms.size()) {\n                return true;\n            }\n        }\n\n        while(!Q.empty()) {\n            int cur = Q.front();\n            Q.pop();\n            for (int i = 0; i < rooms[cur].size(); i++) {\n                if (visited[rooms[cur][i]] == false) { // 说明还没有过\n                    Q.push(rooms[cur][i]);\n                    visited[rooms[cur][i]] = true;\n                    count++;\n                    if (count == rooms.size()) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n};\n```\n\n### [463. 岛屿的周长](https://leetcode.cn/problems/island-perimeter/)\n\n> 给定一个 `row x col` 的二维网格地图 `grid` ，其中：`grid[i][j] = 1` 表示陆地， `grid[i][j] = 0` 表示水域。\n>\n> 网格中的格子 **水平和垂直** 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。\n>\n> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。\n\n#### 解法一——深搜\n\n深搜把\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    int count = 0;\n    void dfs(vector<vector<int>>& grid,  int x, int y) {\n        for(int i = 0; i < 4; i++) {\n            int xNext = x + dir[i][0];\n            int yNext = y + dir[i][1];\n            if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size()) {\n                count++;\n                continue;\n            }\n            if (grid[xNext][yNext] == 1 ) {\n                grid[xNext][yNext] = 2;\n                dfs(grid,  xNext, yNext);\n            }\n            else if (grid[xNext][yNext] == 0){\n                count++;\n            }\n        }\n    }\n    int islandPerimeter(vector<vector<int>>& grid) {\n        // vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false)) ;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 1) {\n                    grid[i][j] = 2;\n                    dfs(grid,  i, j);\n                    return count;\n                }\n            }\n        }\n        return 0;\n    }\n};\n```\n\n#### 解法二——遍历\n\n遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。\n\n```cpp\nint islandPerimeter(vector<vector<int>>& grid) {\n        // vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false)) ;\n        int count = 0;\n        int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 1) {\n                    for(int k = 0; k < 4; k++) {\n                        int xNext = i + dir[k][0];\n                        int yNext = j + dir[k][1];\n                        if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size() || grid[xNext][yNext] == 0) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n```\n\n### 并查集\n\n#### 模板\n\n大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。\n\n并查集主要有两个功能：\n\n- 将两个元素添加到一个集合中。\n- 判断两个元素在不在同一个集合\n\n```cpp\nint n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好\nvector<int> father = vector<int> (n, 0); // C++里的一种数组结构\n\n// 并查集初始化\nvoid init() {\n    for (int i = 0; i < n; ++i) {\n        father[i] = i;\n    }\n}\n// 并查集里寻根的过程\nint find(int u) {\n    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩\n}\n\n// 判断 u 和 v是否找到同一个根\nbool isSame(int u, int v) {\n    u = find(u);\n    v = find(v);\n    return u == v;\n}\n\n// 将v->u 这条边加入并查集\nvoid join(int u, int v) {\n    u = find(u); // 寻找u的根\n    v = find(v); // 寻找v的根\n    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回\n    father[v] = u;\n}\n```\n\n通过模板，我们可以知道，并查集主要有三个功能。\n\n1. 寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个\n2. 将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上\n3. 判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点\n\n#### [2492. 两个城市间路径的最小分数](https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/)\n\n> 给你一个正整数 `n` ，表示总共有 `n` 个城市，城市从 `1` 到 `n` 编号。给你一个二维数组 `roads` ，其中 `roads[i] = [ai, bi, distancei]` 表示城市 `ai` 和 `bi` 之间有一条 **双向** 道路，道路距离为 `distancei` 。城市构成的图不一定是连通的。\n>\n> 两个城市之间一条路径的 **分数** 定义为这条路径中道路的 **最小** 距离。\n>\n> 城市 `1` 和城市 `n` 之间的所有路径的 **最小** 分数。\n>\n> **注意：**\n>\n> - 一条路径指的是两个城市之间的道路序列。\n> - 一条路径可以 **多次** 包含同一条道路，你也可以沿着路径多次到达城市 `1` 和城市 `n` 。\n> - 测试数据保证城市 `1` 和城市`n` 之间 **至少** 有一条路径。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> parent  = vector<int> (100005,0);\n\n    void init() {\n        for (int i = 0; i < 100005; ++i) {\n            parent[i] = i;\n        }\n    }\n    int findparent( int x) {\n        // if (parent[x] != x) {\n        //     parent[x] = findparent(parent, parent[x]);\n        // }\n        // return parent[x];\n        return x == parent[x] ? x : (parent[x] = findparent(parent[x])); // 路径压缩\n    }\n    void add(int x, int y) {\n        int fx = findparent(x);\n        int fy = findparent(y);\n        parent[fx] = fy;\n    }\n    int minScore(int n, vector<vector<int>>& roads) {\n\n        // vector<int> parent(n + 1);\n        init();\n\n        for (auto& rd : roads) {\n            int x = rd[0];\n            int y = rd[1];\n            add(x, y);\n        }\n        int res = INT_MAX;\n        int f0 = findparent(1);\n        cout << f0 << \" \";\n        for (auto& rd : roads) {\n            int x = rd[0];\n            int fx = findparent( x);\n            // int fy = findparent(parent, rd[1]);\n            cout << fx << \" \";\n            if (fx == f0 ) {\n                res = min(res, rd[2]);\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)\n\n> 有一个具有 `n` 个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。\n>\n> 请你确定是否存在从顶点 `source` 开始，到顶点 `destination` 结束的 **有效路径** 。\n>\n> 给你数组 `edges` 和整数 `n`、`source` 和 `destination`，如果从 `source` 到 `destination` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。\n\n```cpp\nclass Solution {\npublic:\n    int parent[200001];\n\n    void init() {\n        for (int i = 0; i < 200001; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int findParent(int u) {\n        return u == parent[u] ? u : (parent[u] = findParent(parent[u]));\n    } \n \n    bool isSame(int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        return u == v;\n    }\n\n    void join(int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        if (u == v) {\n            return;\n        }\n        parent[u] = v;\n    }\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        init();\n        for (auto edge:edges) {\n            join(edge[0], edge[1]);\n        }\n        // for(int i = 0; i < edges.size(); i++) {\n        //     join(edges[i][0], edges[i][1]);\n        // }\n        return isSame(source, destination);\n    }\n};\n```\n\n### [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)\n\n> 树可以看成是一个连通且 **无环** 的 **无向** 图。\n>\n> 给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。\n>\n> 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。\n\n大致思路就是后面的加入得边的两个端点不能是相同的祖先。\n\n```cpp\nclass Solution {\npublic:\n    int parent[1001];\n    void init() {\n        for (int i = 0; i < 1001; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int findParent(int u) {\n        return u == parent[u] ? u : (parent[u] = findParent(parent[u]));\n    }\n\n    bool isSame(int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        return u == v;\n    }\n\n    void join(int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        parent[u] = v;\n    }\n\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        init();\n        for (auto edge:edges) {\n            if (isSame(edge[0], edge[1])) {\n                return edge;\n            }\n            join(edge[0], edge[1]);\n        }\n        return {0, 0};\n    }\n};\n```\n\n### [685. 冗余连接 II](https://leetcode.cn/problems/redundant-connection-ii/)\n\n> 在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。\n>\n> 输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。\n>\n> 结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。\n>\n> 返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。\n\n三种情况：\n\n+ 出现入度为2的节点\n\n  ![img](/685.冗余连接II1.png)\n\n+ 存在有向环\n  ![img](/685.冗余连接II2.png)\n\n```CPP\nclass Solution {\npublic:\n    int parent[1001];\n    void init() {\n        for(int i = 0; i < 1001; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int findParent (int u) {\n        return u == parent[u] ? u : (parent[u] = findParent(parent[u]));\n    }\n    bool isSame (int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        return u == v;\n    }\n    void join (int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        // u是v的根节点；\n        parent[v] = u;\n    }\n\n    bool isTreeRemove (vector<vector<int>> &edges, vector<int> removeEdge) {\n        init();\n        for (auto edge:edges) {\n            // if (edge[0] == removeEdge[0] && edge[1] == removeEdge[1]) {\n            if(edge == removeEdge) {\n                continue;\n            }\n            if (isSame(edge[0], edge[1])) {\n                return false;\n            }\n            join(edge[0], edge[1]);\n        }\n        return true;\n    }\n\n    vector<int> getRemove (vector<vector<int>> &edges) {\n        init();\n        for (auto edge:edges) {\n            if (isSame(edge[0], edge[1])) {\n                return edge;\n            }\n            join(edge[0], edge[1]);\n        }\n        return {0, 0};\n    }\n\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        int inDegree[1001];\n        stack <vector<int>> S; // 保存入度大于2的节点\n        for (auto edge:edges) {\n            inDegree[edge[1]] ++;          \n        }\n        for (auto edge:edges) {\n            if (inDegree[edge[1]] == 2) {\n                S.push(edge);\n            }\n            \n        }\n        // 存在入度为2的节点\n        if (!S.empty()) {\n            if (isTreeRemove(edges, S.top())) {\n                return S.top();\n            }\n            else {\n                S.pop();\n                return S.top();\n            }\n        }\n        // 存在有向环\n        return getRemove(edges);\n    }\n};class Solution {\npublic:\n    int parent[1001];\n    void init() {\n        for(int i = 0; i < 1001; i++) {\n            parent[i] = i;\n        }\n    }\n    \n    int findParent (int u) {\n        return u == parent[u] ? u : (parent[u] = findParent(parent[u]));\n    }\n    bool isSame (int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        return u == v;\n    }\n    void join (int u, int v) {\n        u = findParent(u);\n        v = findParent(v);\n        // u是v的根节点；\n        parent[v] = u;\n    }\n\n    bool isTreeRemove (vector<vector<int>> &edges, vector<int> removeEdge) {\n        init();\n        for (auto edge:edges) {\n            // if (edge[0] == removeEdge[0] && edge[1] == removeEdge[1]) {\n            if(edge == removeEdge) {\n                continue;\n            }\n            if (isSame(edge[0], edge[1])) {\n                return false;\n            }\n            join(edge[0], edge[1]);\n        }\n        return true;\n    }\n\n    vector<int> getRemove (vector<vector<int>> &edges) {\n        init();\n        for (auto edge:edges) {\n            if (isSame(edge[0], edge[1])) {\n                return edge;\n            }\n            join(edge[0], edge[1]);\n        }\n        return {0, 0};\n    }\n\n    vector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n        int inDegree[1001];\n        stack <vector<int>> S; // 保存入度大于2的节点\n        for (auto edge:edges) {\n            inDegree[edge[1]] ++;          \n        }\n        for (auto edge:edges) {\n            if (inDegree[edge[1]] == 2) {\n                S.push(edge);\n            }\n            \n        }\n        // 存在入度为2的节点\n        if (!S.empty()) {\n            if (isTreeRemove(edges, S.top())) {\n                return S.top();\n            }\n            else {\n                S.pop();\n                return S.top();\n            }\n        }\n        // 存在有向环\n        return getRemove(edges);\n    }\n};\n```\n\n## 增补——热题100\n\n### [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)\n\n> 给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。\n>\n> **字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        vector<vector<string>> output;\n        unordered_map <string, vector<string>> hashMap;\n        vector<int> count(26);\n        for (int i = 0; i < strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(), str.end());\n            hashMap[str].emplace_back(strs[i]);\n        }\n        for(auto str:hashMap) {\n            output.emplace_back(str.second);\n        }\n        return output;\n    }\n};\n```\n\n### [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)\n\n> 给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n>\n> 请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n- 怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。\n- 因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:\n  **[100，4，200，1，3，4，2]**\n  去重后的哈希序列为：**[100，4，200，1，3，2]**\n\n——力扣题解评论\n\n我写的和题解反的，但是结果都一样\n\n```cpp\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> hashSet;\n        // 先去重\n        for(auto num:nums) {\n            hashSet.insert(num);\n        }\n        int output = 0;\n        for(auto num:hashSet) {\n            // 要防止后续的数字继续遍历，所以要确保开始遍历一定是结尾！！！题解的写法是保一定是开头\n            if (hashSet.find(num + 1) == hashSet.end()) {\n                int count = 1;\n                int cur = num;\n                while (hashSet.find(cur - 1) != hashSet.end()) {\n                    // cout << num << \" \" << cur << \" \" <<  count << endl;\n                    count++;\n                    cur--;\n                }\n                output = max(output, count);\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [283. 移动零](https://leetcode.cn/problems/move-zeroes/)\n\n> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n```cpp\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int left = 0;\n        int right = 0;\n        for (int right = 0; right < nums.size(); right++) {\n            if (nums[right] != 0 ) {\n                nums[left++] = nums[right];\n            }\n        }\n        for (right = 0; left < nums.size(); left++) {\n            nums[left] = 0;\n        }\n    }\n};\n```\n\n### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)\n\n> 给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n>\n> 找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n>\n> 返回容器可以储存的最大水量。\n>\n> **说明：**你不能倾斜容器。\n\n#### 解法一——单调栈\n\n很慢，能过\n\n单调栈，栈内元素从小到大\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        vector <int> increasingVector;\n        increasingVector.emplace_back(0);\n        int output = 0;\n        for (int i = 1; i < height.size(); i++) {\n            for (int j = 0; j < increasingVector.size(); j++) {\n                int temp = min(height[i], height[increasingVector[j]]) * (i - increasingVector[j]);\n                output = max(temp, output);\n            }\n            if (height[i] > height[increasingVector[increasingVector.size() - 1]]) {\n                increasingVector.emplace_back(i);\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——双指针\n\n左右两个指针总是移动较小的那个\n\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        int output = 0;\n        int left = 0;\n        int right = height.size() - 1;\n        int h;\n        while(left < right) {\n            if (height[left] < height[right]) {\n                h = height[left];\n                left++;\n            }\n            else {\n                h = height[right];\n                right--;\n            }\n            int temp = (right - left + 1) * h;\n            output = max(temp, output);\n        }\n        return output;\n    }\n};\n```\n\n### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n\n> 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长** **子串** 的长度。\n\n还以为是KMP算法。不需要KMP，使用滑动窗口就可以了。\n\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if (s.length() <= 1) {\n            return s.length();\n        }\n        vector<bool> hashMap(128, false);\n        int left = 0;\n        hashMap[s[left] - ' '] = true;\n        int output = 1;\n        for (int right = 1; right < s.length(); right++) {\n            if (hashMap[s[right] - ' ']) { // 之前存过了\n                while (s[left] != s[right]) {\n                    hashMap[s[left] - ' '] = false;\n                    left++;\n                }\n                // 此时正好检测到s[left] == s[right], 哈希表不需要动\n                left++;\n            }\n            else {\n                hashMap[s[right] - ' '] = true;\n            }\n            // cout << right << \" \" << left << \" \" << endl;\n            output = max(output, right - left + 1);\n        }\n        return output;\n    }\n};\n```\n\n### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)\n\n> 给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n>\n> **异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）\n\n想复杂了！滑动窗口\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> output;\n        if (s.length() < p.length()) {\n            return output;\n        }\n        vector<int> sCount(26);\n        vector<int> pCount(26);\n\n        for(int i = 0; i < p.length(); i++) {\n            sCount[s[i] - 'a'] ++;\n            pCount[p[i] - 'a'] ++;\n        }\n\n        if (sCount == pCount) {\n            output.emplace_back(0);\n        }\n\n        for (int j = 0; j < s.length() - p.length(); j++) {\n            sCount[s[j] - 'a'] --;\n            sCount[s[j + p.length()] - 'a'] ++ ;\n            if (sCount == pCount) {\n                output.emplace_back(j + 1);\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)\n\n> 给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。\n>\n> 子数组是数组中元素的连续非空序列。\n\n连续，那好像好办一点！\n\n#### 解法一——暴力解法，但是超时\n\n```cpp\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        int output = 0;\n        vector<int> preSum(nums.size()); // 记录到当前位置之前能够组成的数字大小\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j <= i; j++) {\n                preSum[j] += nums[i];\n                if (preSum[j] == k) {\n                    output++;\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n#### 解法二——前缀和建表\n\n定义`pre[i]`表示$[0,\\dots, i]$的和，那么`pre[i]`可以有`pre[i-1]`递推得到，`pre[i] = pre[i-1] + nums[i]`。要使得$[j,\\dots, i]$的和为$k$，`pre[j-1] + k == pre[i]`。也就是说到i位置时候，要找和为k的子序列，只需要找到之前和为`pre[i]-k`的子序列有多少个。\n\n```cpp\nclass Solution {\npublic:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> preSum;\n        preSum[0] = 1;\n        int output = 0;\n        int pre = 0;\n        for (auto num:nums) {\n            pre += num;\n            output += preSum[pre - k];\n            preSum[pre] ++;\n        }\n        return output;\n    }\n};\n```\n\n### [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)\n\n> 给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `\"\"` 。\n\n很凌乱的做法,5555\n\n```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        string output;\n        \n        vector<int> sCount(100); // 计数用\n        vector<int> tCount(100); // 计数用\n        vector<bool> originMap(100, false);\n        vector<bool> tMap(100, false); // 判断对应字母有没有满足\n        vector<int> leftRight(2);\n        \n        if (s.length() < t.length()) {\n            return output;\n        }\n        for (int i = 0; i < t.length(); i++) {\n            tCount[t[i] - 'A'] ++;\n            tMap[t[i] - 'A'] = true;\n        }\n        int left = 0;\n        int right = 0;\n        int len = INT_MAX;\n        for (right = 0; right < s.length(); right++) {\n            if (tCount[s[right] - 'A'] != 0) {\n                sCount[s[right] - 'A'] ++;\n                // cout << right << \" \" << sCount[s[right] - 'A'] << \" \" << tCount[s[right] - 'A'] << endl;\n                if (sCount[s[right] - 'A'] >= tCount[s[right] - 'A']) {\n                    tMap[s[right] - 'A'] = false;\n                }\n                // 如果都清空了\n                if (tMap == originMap) {\n                    // cout << \"C\" << \" \";\n                    // 先让left右移，看看能右移到什么程度还能满足要求\n                    while (tMap == originMap && left < right) {\n                        // cout << \"B\" << \" \";\n                        if (tCount[s[left] - 'A'] == 0) {\n                            left++;\n                            continue;\n                        }\n                        else {\n                            if (sCount[s[left] - 'A'] > tCount[s[left] - 'A']) {\n                                sCount[s[left] - 'A'] --;\n                                left++;\n                                // cout << \"A\" << \" \";\n                            }\n                            else {\n                                break;\n                            }\n                        }\n                    }\n                    // 全false，说明满足\n                    if (right - left + 1 < len) {\n                        leftRight[0] = left;\n                        leftRight[1] = right;\n                        len = right - left + 1;\n                    }\n                }\n            }\n            \n        }\n        if (len == INT_MAX) {\n            return \"\";\n        }\n        else {\n            return s.substr(leftRight[0], len);\n        }\n        \n    }\n};\n```\n\n### [189. 轮转数组](https://leetcode.cn/problems/rotate-array/)\n\n> 给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。\n\n####  解法一——队列\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        queue <int> Q;\n        k = k % nums.size();\n\n        for (int i = 0; i < k; i++) {\n            Q.push(nums[i]);\n        }\n        for (int i = k; i < nums.size() + k; i++) {\n            Q.push(nums[i % nums.size()]);\n            nums[i % nums.size()] = Q.front();\n            Q.pop();\n        }\n    }\n};\n```\n\n#### 解法二——两次反转\n\n类似卡码网55\n\n```cpp\nclass Solution {\npublic:\n    void reverseVector(vector<int> & nums, int start, int end) {\n        while (start < end) {\n            swap(nums[start++],nums[end--]);\n        }\n    }\n    void rotate(vector<int>& nums, int k) {\n        reverseVector(nums, 0, nums.size() - 1);\n        k = k % nums.size();\n        reverseVector(nums, 0, k - 1);\n        reverseVector(nums, k, nums.size() - 1);\n    }\n};\n```\n\n### [238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)\n\n> 给你一个整数数组 `nums`，返回 *数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积* 。\n>\n> 题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。\n>\n> 请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。\n\n不要使用除法咋做啊。注意本来除法也不行，有0的问题\n\n#### 解法一——左右乘积列表\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int> answer(nums.size());\n        vector<int> left(nums.size(), 1);\n        vector<int> right(nums.size(), 1);\n        left[0] = nums[0];\n        right[nums.size() - 1] = nums[nums.size() - 1];\n        for (int i = 1; i < nums.size();i++) {\n            left[i] = left[i - 1] * nums[i];\n            right[nums.size() - 1 - i] =  right[nums.size() - i] * nums[nums.size() - 1 - i];\n        }\n        answer[0] = right[1];\n        answer[nums.size() - 1] = left[nums.size() - 2];\n        for (int i = 1; i < nums.size() - 1;i++) {\n            answer[i] = left[i - 1] * right[i + 1];\n        }\n        return answer;\n    }\n};\n```\n\n#### 解法二——空间复杂度为$\\mathcal O(1)$\n\n右侧不用一个vector来存\n\n```cpp\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int> answer(nums.size(), 1);\n\n        for (int i = 1; i < nums.size(); i++) {\n            answer[i] = answer[i - 1] * nums[i - 1];\n        }\n        \n        int right = nums[nums.size() - 1];\n        for (int i = nums.size() - 2; i >= 0; i--) {\n            answer[i] *= right;\n            right *= nums[i];\n        }\n        return answer;\n    }\n};\n```\n\n### [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)\n\n> 给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。\n>\n> 请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。\n\n排序的时间复杂度是$o(n^2)$啊，而且要没有额外的空间的话哈希表好像也不好使。\n\n#### 解法一——原始数组作为hash表\n\n我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在O(1) 的时间查找该元素是否在哈希表中。\n\n**对于一个长度为 $N$ 的数组，其中没有出现的最小正整数只能在 $[1, N+1]$ 中。这是因为如果 $[1, N]$ 都出现了，那么答案是 $N+1$，否则答案是 $[1, N]$​ 中没有出现的最小正整数。**\n\n【怎么标记呢？】\n\n+ 我们将数组中所有小于等于 0 的数修改为 $N+1$\n+ 我们遍历数组中的每一个数 $x$，它可能已经被打了标记，因此原本对应的数为 $|x|$，其中 $|\\,|$ 为绝对值符号。如果 $|x| \\in [1, N]$，那么我们给数组中的第 $|x| - 1$ 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；\n+ 在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1N+1N+1，否则答案是第一个正数的位置加 111。\n\n**用下标的正负作为bool类型的hash表**\n\n```cpp\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] <= 0) {\n                nums[i] = nums.size() + 1; // 如果要出现N+1的情况，里面存的数字应该是1~N，所以这边要避开N\n            }\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (abs(nums[i]) <= nums.size()) {\n                nums[abs(nums[i]) - 1] = - abs(nums[abs(nums[i]) - 1]); // 这里要防止反转两次\n            }\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n        return nums.size() + 1;\n    }\n};\n```\n\n#### 解法二——类似排序？直接交换到对应下标位置去\n\n```cpp\nclass Solution {\npublic:\n    int firstMissingPositive(vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            while (nums[i] >=1 && nums[i] <=nums.size() && nums[i] != nums[nums[i] - 1]) { \n                // 第三个条件防止死循环，另外这里是while!换回去的那个元素还得接着换\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != i + 1) {\n                return i + 1;\n            }\n        }\n        return nums.size() + 1;\n    }\n};\n```\n\n### [73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)\n\n> 给定一个 `m x n` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**\n\n#### 解法一——记录行列\n\n一个简单的思路，先遍历一遍记录哪些行列需要标记为0。\n\n```cpp\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        vector<bool> row(matrix.size(), false);\n        vector<bool> column(matrix[0].size(), false);\n        for (int i = 0; i < matrix.size(); i++) {\n            for (int j = 0; j < matrix[0].size(); j++) {\n                if (matrix[i][j] == 0) {\n                    row[i] = true;\n                    column[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < matrix.size(); i++) {\n            for (int j = 0; j < matrix[0].size(); j++) {\n                if (row[i] == true || column[j] == true) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n};\n```\n\n#### 解法二——使用标记变量\n\n这两个解法真的太离谱了，不想写\n\n【两个标记变量】\n\n我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。\n\n【一个标记变量】\n\n这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。\n\n\n\n### [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)\n\n> 给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n写的一坨shit\n\n```cpp\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> output;\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int length = m * n;\n        int x = 0;\n        int y = 0;\n        int count = n;\n        int dir[4][2] = {0,1,1,0,0,-1,-1,0}; // 01右；10下；0-1左；-10上\n        int countDir = 0;\n\n        for (int i = 0; i < length; i++) {\n            output.emplace_back(matrix[x][y]);\n            // cout << count << \" || \";\n            if(count <= 1) { // count = 1 换方向\n                countDir = (countDir + 1) % 4;\n                m -= abs(dir[countDir][0]);\n                n -= abs(dir[countDir][1]);\n                count = abs(dir[countDir][0]) * m + abs(dir[countDir][1]) * n + 1;\n            }\n            // cout << i <<\" \"  <<count << \" || \" << x << \" \" << y << \" || \" << countDir << \" \" << dir[countDir][0] << \" \" << dir[countDir][1] << endl;\n            x += dir[countDir][0];\n            y += dir[countDir][1];\n            count --;\n        }\n        return output;\n    }\n};\n```\n\n### [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)\n\n> 给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n>\n> 你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n\n#### 解法一——旋转矩阵的思路，一圈一圈来\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        int length = n;\n        int dir[4][2] = {0,1,1,0,0,-1,-1,0};\n        queue <int> Q;\n        int x, y;\n        while(length >= 1) {\n            Q = queue<int> (); // 记得要清空\n            y = (n - length) / 2;\n            x = n - (n - length) / 2 - 1;\n            // cout << x << \" \" << y << endl;\n\n            for (int i = 0; i < length - 1; i++) { // 往上\n                Q.push(matrix[x][y]);\n                x += dir[3][0];\n                y += dir[3][1];\n                // cout << x << \" \" << y << endl;\n            }\n            \n            //绕圈\n            for (int i = 0; i < (length - 1) * 4; i ++) {\n                // length-1为一组\n                Q.push(matrix[x][y]);\n                matrix[x][y] = Q.front();\n                Q.pop();\n                x += dir[i/(length - 1)][0];\n                y += dir[i/(length - 1)][1];\n                // cout << x << \" \" << y << endl;\n            }\n            length -= 2;\n        }\n    }\n};\n```\n\n也可以不用这么多空间，点对点来旋转\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        for (int i = 0; i < n/2; i++) { // 一共n/2圈向下取整\n            for (int j = i; j < n - i - 1; j++) {\n                int temp = matrix[i][j];\n                // 对应的四个位置坐标分别为\n                matrix[i][j] = matrix[n - j - 1][i];\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n                matrix[j][n - i - 1] = temp;\n            }\n        }\n    }\n};\n```\n\n#### 解法二——用翻转代替旋转\n\n旋转90°实际上就是线上下翻转，在主对角线反转。\n\n![image-20240527170107807](/image-20240527170107807.png)\n\n```cpp\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        // 上下翻转\n        for(int i = 0; i < n / 2; i++) {\n            for (int j = 0; j < n; j++) {\n                swap(matrix[i][j], matrix[n - i - 1][j]);\n            }\n        }\n        // 主对角线反转\n        for (int i = 0; i < n; i++) {\n            for(int j = 0; j < i; j++) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n    }\n};\n```\n\n### [240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)\n\n> 编写一个高效的算法来搜索 *m* × *n* 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n>\n> - 每行的元素从左到右升序排列。\n> - 每列的元素从上到下升序排列。\n\n【Z 字形查找】\n\n我们可以从矩阵 $\\textit{matrix}$ 的右上角 $(0, n-1)$进行搜索。在每一步的搜索过程中，如果我们位于位置$(x, y)$，那么我们希望在以 $\\textit{matrix}$ 的左下角为左下角、以$(x, y)$ 为右上角的矩阵中进行搜索，即行的范围为 $[x, m - 1]$，列的范围为 $[0, y]$：\n\n+ 如果 $\\textit{matrix}[x, y] = \\textit{target}$，说明搜索完成；\n\n+ 如果 $\\textit{matrix}[x, y] > \\textit{target}$，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 $y$ 列的元素都是严格大于 $\\textit{target}$ 的，因此我们可以将它们全部忽略，即将 $y$ 减少 1；\n\n+ 如果 $\\textit{matrix}[x, y] < \\textit{target}$，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 xxx 行的元素都是严格小于$\\textit{target}$ 的，因此我们可以将它们全部忽略，即将 $x$ 增加 1。\n\n作者：力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int x = 0, y = n - 1;\n        while(x < m && y >= 0) {\n            if(matrix[x][y] == target) {\n                return true;\n            }\n            if (matrix[x][y] > target) {\n                y--;\n            }\n            else{\n                x++;\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)\n\n> 给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n>\n> **回文** 序列是向前和向后读都相同的序列。\n\n#### 解法一——栈保存数值\n\n空间复杂度O(n)\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        stack<int> S;\n        ListNode *p = head;\n        while (p != NULL) {\n            S.push(p->val);\n            p = p->next;\n        }\n        p = head;\n        while (p != NULL) {\n            if(p->val != S.top()) {\n                return false;\n            }\n            S.pop();\n            p = p->next;\n        }\n        return true;\n    }\n};\n```\n\n#### 解法二——快慢指针反转后面的链表\n\n1. 找到前半部分链表的尾节点。\n2. 反转后半部分链表。\n3. 判断是否回文。\n4. 恢复链表。\n5. 返回结果。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        if (head == nullptr) {\n            return true;\n        }\n        ListNode *p = head;\n        ListNode *q = head;\n        while (q->next != nullptr && q->next->next != nullptr) {\n            p = p->next;\n            q = q->next->next;\n        }\n        // 反转链表\n        ListNode *p1 = nullptr;\n        ListNode *q1 = p->next;\n        while (q1 != nullptr) {\n            ListNode * temp = q1->next;\n            q1->next = p1;\n            p1 = q1;\n            q1 = temp;\n        }\n        // ListNode *r = head;\n        // while (r != nullptr) {\n        //     cout << r->val;\n        //     r = r->next;\n        // }\n        // 比较\n        q = head;    \n        p = p1;    \n        while (p != nullptr) {\n            if (p->val != q->val) {\n                return false;\n            }\n            p = p->next;\n            q = q->next;\n        }\n        return true;\n    }\n};\n```\n\n### [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n> 给你一个链表的头节点 `head` ，判断链表中是否有环。\n>\n> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。\n>\n> *如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。\n\n快慢指针，能够重合就是有环，快指针走到头了就是没环。\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (head == nullptr) {\n            return false;\n        }\n        ListNode *slow = head;\n        ListNode *fast = head;\n        while (fast->next != nullptr && fast->next->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n            if(fast == slow) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\n\n> 将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n>\n> ![img](/merge_ex1.jpg)\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode* p1 = list1;\n        ListNode *p2 = list2;\n        if (list1 == nullptr ) {\n            return list2;\n        }\n        else if (list2 == nullptr) {\n            return list1;\n        }\n        ListNode *p;\n        if (list1->val < list2->val)  {\n            p= p1;\n            p1 = p1->next;\n        }\n        else {\n            p = p2;\n            p2 = p2->next;\n        }\n        ListNode *head = p;\n        while (p1 != nullptr && p2 != nullptr) {\n            if (p1->val >= p2->val) {\n                p->next = p2;\n                p = p->next;\n                p2 = p2->next;\n            }\n            else {\n                p->next = p1;\n                p = p->next;\n                p1 = p1->next;\n            }\n        }\n        if (p1 == nullptr) {\n            p->next = p2;\n        }\n        else {\n            p->next = p1;\n        }\n        return head;\n    }\n};\n```\n\n### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)\n\n> 给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n>\n> 请你将两个数相加，并以相同形式返回一个表示和的链表。\n>\n> 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n>\n> ![img](/addtwonumber1.jpg)\n\n**进位标志**（Carry Flag, CF）\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        if(l1 == nullptr) {\n            return l2;\n        }\n        else if (l2 == nullptr){\n            return l1;\n        }\n        ListNode *p1 = l1;\n        ListNode *p2 = l2;\n        bool CF = false;\n        p1->val = p1->val + p2->val;\n        if(p1->val >= 10) {\n            p1->val -= 10;\n            CF = true;\n        }\n        while (p1->next != nullptr || p2->next != nullptr) {\n            if (p1->next == nullptr) {\n                p1->next = new ListNode(0);\n            }\n            else if (p2->next == nullptr) {\n                p2->next = new ListNode(0);\n            }\n            p1 = p1->next;\n            p2 = p2->next;\n            p1->val = p1->val + p2->val;\n            if (CF) {\n                p1->val += 1;\n            }\n            if(p1->val >= 10) {\n                p1->val -= 10;\n                CF = true;\n            }\n            else {\n                CF = false;\n            }\n        }\n        if (CF) {\n            p1->next = new ListNode(1);\n        }\n        return l1;\n    }\n};\n```\n\n### [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\n\n> 给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。\n>\n> `k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。\n>\n> 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。\n> ![img](/reverse_ex1.jpg)\n>\n> ![img](/reverse_ex2.jpg)\n\n+ 双指针\n\nhair--dummyHead\n\npre-slow\n\ntail--fast\n\nnex--fast->next\n\n绕也绕不清\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic: \n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode *dummyHead = new ListNode (0, head);\n        ListNode *slow = dummyHead;\n        ListNode *fast = dummyHead;\n        // bool isEnd = false;\n        int i;\n        ListNode *pNext ;\n        while (fast != nullptr) {\n            for (i = 0; i < k && fast != nullptr; i++) {\n                fast = fast->next;\n            }\n            if (fast == nullptr) {\n                return dummyHead->next;\n            }\n            // cout << fast ->val << endl;\n            pNext = fast->next;\n            //反转链表\n            ListNode *p = slow;\n            ListNode *q = slow->next;\n            while (q != pNext) { // 这个判断条件！！是pNext，不是fast，不然会导致最后一个fast对应位置没指回去，不用担心q已经跑到前面去了怎么办，还有p比他慢一步\n                ListNode *temp = q->next;\n                q->next = p;\n                p = q;\n                q = temp;\n            }\n            ListNode* tmp;\n            // 这边往下是真的很难想清。可以想象第一次\n            slow->next->next = pNext;  // 这是让原来的head的下一个指向下一次的起点，而非dummyHead\n            // cout<< slow->next->val << endl;\n            // cout << pNext->val << endl;\n            tmp = slow->next;\n            // cout << tmp->val << endl;\n            slow->next = p; // 这里用p就好了，这个是为了让dummyHead指向新的head\n            // cout << slow->next->val << endl;\n            slow = tmp;\n            fast = tmp;\n            // ListNode *qqq = dummyHead;\n            // while(qqq->next != NULL) {\n            //     cout << qqq->next->val << \" \";\n            //     qqq = qqq->next;\n            // }\n            // cout << endl;\n        }\n        return dummyHead->next;\n\n\n    }\n};\n```\n\n再贴一个官方题解：\n\n```cpp\nclass Solution {\npublic:\n    // 翻转一个子链表，并且返回新的头与尾\n    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {\n        ListNode* prev = tail->next;\n        ListNode* p = head;\n        while (prev != tail) {\n            ListNode* nex = p->next;\n            p->next = prev;\n            prev = p;\n            p = nex;\n        }\n        return {tail, head};\n    }\n\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* hair = new ListNode(0);\n        hair->next = head;\n        ListNode* pre = hair;\n\n        while (head) {\n            ListNode* tail = pre;\n            // 查看剩余部分长度是否大于等于 k\n            for (int i = 0; i < k; ++i) {\n                tail = tail->next;\n                if (!tail) {\n                    return hair->next;\n                }\n            }\n            ListNode* nex = tail->next;\n            // 这里是 C++17 的写法，也可以写成\n            // pair<ListNode*, ListNode*> result = myReverse(head, tail);\n            // head = result.first;\n            // tail = result.second;\n            tie(head, tail) = myReverse(head, tail);\n            // 把子链表重新接回原链表\n            pre->next = head;\n            tail->next = nex;\n            pre = tail;\n            head = tail->next;\n        }\n\n        return hair->next;\n    }\n};\n```\n\n### [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)\n\n> 给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。\n>\n> 构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。\n>\n> 例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。\n>\n> 返回复制链表的头节点。\n>\n> 用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：\n>\n> - `val`：一个表示 `Node.val` 的整数。\n> - `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。\n>\n> 你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。\n\n#### 解法一——回溯\n\n```cpp\n/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    unordered_map<Node*, Node*> connectedNode;\n    Node* copyRandomList(Node* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        if (!connectedNode.count(head)) {\n            Node* newHead = new Node(head->val);\n            connectedNode[head] = newHead;\n            newHead->next = copyRandomList(head->next);\n            newHead->random = copyRandomList(head->random);\n        }\n        return connectedNode[head];\n    }\n};\n```\n\n#### 解法二——迭代 + 节点拆分\n\n注意到方法一需要使用哈希表记录每一个节点对应新节点的创建情况，而我们可以使用一个小技巧来省去哈希表的空间。\n\n我们首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 A→A′→B→B′→C→C′ 。对于任意一个原节点 S，其拷贝节点 S′ 即为其后继节点。\n\n——力扣官方题解\n![img](/2-1717660182142-1.png)\n\n![img](/3-1717660191799-4.png)\n\n```cpp\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (head == nullptr) {\n            return nullptr;\n        }\n        // 新节点连进来\n        for (Node* p = head; p != nullptr; p = p->next->next) {\n            Node* newP = new Node(p->val);\n            newP->next = p->next;\n            p->next = newP;\n        }\n        // 新节点的指针域\n        for (Node* p = head; p != nullptr; p = p->next->next) {\n            Node* newP = p->next;\n            if (p->random != nullptr) {\n                newP->random = p->random->next;\n            }\n            else  {\n                newP = nullptr;\n            }\n        }\n        //断开\n        Node* newHead = head->next;\n        for (Node* p = head; p != nullptr; p = p->next) {\n            Node* newP = p->next;\n            p->next = p->next->next;\n            if (newP->next != nullptr) {\n                newP->next = newP->next->next;\n            }\n        }\n        return newHead;\n    }\n};\n```\n\n### [148. 排序链表](https://leetcode.cn/problems/sort-list/)\n\n> 给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。\n\n对链表自顶向下归并排序的过程如下。\n\n找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。\n\n1. 对两个子链表分别排序。\n2. 将两个排序后的子链表合并，得到完整的排序后的链表。\n3. 上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。\n\n作者：力扣官方题解\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    \n    ListNode* sortList(ListNode* head) {\n        return sortTwoList (head, nullptr);\n    }\n\n    ListNode* sortTwoList(ListNode* head, ListNode* tail) {\n        if (head == nullptr) { // 链表为空\n            return head;\n        }\n        if (head->next == tail) { // 只剩一个元素\n            head->next = nullptr;\n            return head;\n        }\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast != tail) {\n            slow = slow->next;\n            fast = fast->next;\n            if (fast != tail) {\n                fast = fast->next;\n            }\n        }\n        ListNode* mid = slow;\n        return mergeTwoList(sortTwoList(head, mid), sortTwoList(mid, tail));\n    }\n\n    ListNode *mergeTwoList(ListNode* head1, ListNode* head2) {\n        if (head1 == nullptr) {\n            return head2;\n        }\n        else if (head2 == nullptr) {\n            return head1;\n        }\n        ListNode *p1 = head1;\n        ListNode *p2 = head2;\n\n        ListNode *p;\n        if (head1->val < head2->val) {\n            p = p1;\n            p1 = p1->next;\n        }\n        else {\n            p = p2;\n            p2 = p2->next;\n        }\n        ListNode * head = p;\n        while (p1 != nullptr && p2 != nullptr) {\n            if (p1->val < p2->val) {\n                p->next = p1;\n                p = p->next;\n                p1 = p1->next;\n            }\n            else{\n                p->next = p2;\n                p = p->next;\n                p2 = p2->next;\n            }\n        }\n        if (p1 == nullptr) {\n            p->next = p2;\n        }\n        else {\n            p->next = p1;\n        }\n        return head;\n    }\n};\n```\n\n### [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)\n\n> 给你一个链表数组，每个链表都已经按升序排列。\n>\n> 请你将所有链表合并到一个升序链表中，返回合并后的链表。\n\n#### 最naive的思想——存起来呗\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int findMin(vector<int> minNum) {\n        int tempMin = INT_MAX;\n        int tempMinPos = -1;\n        for (int i = 0; i < minNum.size(); i++) {\n            if (minNum[i] < tempMin) {\n                tempMin = minNum[i];\n                tempMinPos = i;\n            }\n        }\n        return tempMinPos;\n    }\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int K = lists.size();\n\n        if (K == 0) {\n            return nullptr;\n        }\n\n        vector<int> minNum(K);\n        \n        vector<ListNode*> p;\n        int headIndex = -1;\n        int headNum = INT_MAX;\n        for(int i = 0; i < K; i++) {\n            p.emplace_back(lists[i]);\n            if (lists[i] != nullptr) {\n                minNum[i] = lists[i]->val;\n                if (headIndex == -1 || headNum > minNum[i]) {\n                    headIndex = i;\n                    headNum = minNum[i];\n                }\n            }\n            else {\n                minNum[i] = INT_MAX;\n            }\n        }\n        if (headIndex == -1) {\n            return nullptr;\n        }\n        ListNode* head = p[headIndex];\n        p[headIndex] = p[headIndex]->next;\n        if (p[headIndex] != nullptr) {\n            minNum[headIndex] = p[headIndex]->val;\n        }\n        else {\n            minNum[headIndex] = INT_MAX;\n        }\n        // 在minNum中最小值，直到最小值为INT_MAX\n        ListNode* temp = head;\n        int minPos = findMin(minNum);\n        while (minPos != -1) {\n            temp->next = p[minPos];\n            temp = temp->next;\n            p[minPos] = p[minPos]->next;\n            if (p[minPos] != nullptr) {\n                minNum[minPos] = p[minPos]->val;\n            }\n            else {\n                minNum[minPos] = INT_MAX;\n            }\n            minPos = findMin(minNum);\n        }\n        \n        return head;\n    }\n};\n```\n\n#### 分治合并\n\n<img src=\"/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        return merge(lists, 0, lists.size() - 1);\n    }\n\n    ListNode* merge(vector <ListNode*> &lists, int left, int right) {\n        if (left == right) {\n            return lists[left];\n        }\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right) / 2;\n        return mergeTwoLists(merge(lists, left, mid), merge(lists, mid + 1, right));\n    }\n\n    ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {\n        if((!head1) || (!head2)) {\n            return head1 ? head1 : head2;\n        }\n        ListNode *p1 = head1;\n        ListNode *p2 = head2;\n\n        ListNode *p;\n        if (head1->val < head2->val) {\n            p = p1;\n            p1 = p1->next;\n        }\n        else {\n            p = p2;\n            p2 = p2->next;\n        }\n        ListNode * head = p;\n        while (p1 != nullptr && p2 != nullptr) {\n            if (p1->val < p2->val) {\n                p->next = p1;\n                p = p->next;\n                p1 = p1->next;\n            }\n            else{\n                p->next = p2;\n                p = p->next;\n                p2 = p2->next;\n            }\n        }\n        if (p1 == nullptr) {\n            p->next = p2;\n        }\n        else {\n            p->next = p1;\n        }\n        return head;\n    }\n};\n```\n\n\n\n### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)\n\n> 请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。\n>\n> 实现 `LRUCache` 类：\n>\n> - `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存\n> - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。\n> - `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。\n>\n> 函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。\n\n\n\nLRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n\n+ 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\n+ 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\n\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：\n\n+ 对于 get 操作，首先判断 key 是否存在：\n\n  + 如果 key 不存在，则返回 −1；\n\n  + 如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\n\n+ 对于 put 操作，首先判断 key 是否存在：\n  + 如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\n  + 如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\n\n——力扣官方题解\n\n想不到双向链表，纯粹抄——主要要想到双向链表，这样比较好处理头尾的操作。\n\n```cpp\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode *prev;\n    DLinkedNode *next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacityA;\n\npublic:\n    LRUCache(int capacity) {\n        capacityA = capacity;\n        size = 0;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) { // key不存在\n            return -1;\n        }\n        else {\n            DLinkedNode* node = cache[key];\n            moveToHead(node);\n            return node->value;\n        }\n    }\n    \n    void put(int key, int value) {\n        //如果不存在\n        if (!cache.count(key)) {\n            DLinkedNode* node = new DLinkedNode(key, value);\n            cache[key] = node;\n            addToHead(node);\n            size++;\n            if (size > capacityA) {\n                // 超出容量\n                DLinkedNode *removed = removeTail();\n                cache.erase(removed->key);\n                delete removed;\n                size--;\n            }\n        }\n        else {\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    DLinkedNode* removeTail() {\n        DLinkedNode *node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)\n\n> 给你一棵二叉树的根节点，返回该树的 **直径** 。\n>\n> 二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。\n>\n> 两节点之间路径的 **长度** 由它们之间边数表示。\n\n每个节点的直径为（左子树深度+右子树深度）+1，而他的父节点的节点深度等于max（左子树深度，右子树深度）+1.\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int diameter;\n\n    int depth(TreeNode* p) {\n        if (p == NULL) {\n            return 0;\n        }\n        int depthL = depth(p->left);\n        int depthR = depth(p->right);\n        diameter = max(diameter, depthL + depthR + 1);\n        return max(depthL, depthR) + 1;\n    }\n\n    int diameterOfBinaryTree(TreeNode* root) {\n        diameter = 1;\n        depth(root);\n        return diameter - 1;\n    }\n};\n```\n\n### [230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)\n\n> 给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。\n\n二叉搜索树的中序排列是有序的——中序排列即可\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack <TreeNode*> S;\n        TreeNode *p = root;\n        int count = 0;\n        while (p || !S.empty()){\n            if (p != nullptr) {\n                S.push(p);\n                p = p->left;\n            }\n            else{\n                count++;\n                p = S.top();\n                // cout << count << \" \";\n                if (count == k) {\n                    return p->val;\n                }\n                S.pop();\n                p = p->right;\n            }\n        }\n        return 0;\n    }\n};\n```\n\n### [114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)\n\n> 给你二叉树的根结点 `root` ，请你将它展开为一个单链表：\n>\n> - 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。\n> - 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。\n\n#### 解法一——遍历+一个数组（非原地）\n\n不知道为啥我写的超出内存限制，他写的就不超出。\n\n```cpp\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        // TreeNode *dummyHead = new TreeNode(0, nullptr, root);\n        // dummyHead->right = root;\n        // TreeNode* p = dummyHead->right;\n        stack<TreeNode*> S;\n        vector<TreeNode*> V;\n        if (root == nullptr) {\n            return ;\n        }\n        S.push(root);\n        // V.emplace_back(dummyHead);\n        while(!S.empty()) {\n            TreeNode *p = S.top();\n            V.emplace_back(p);\n            if (p->right) {\n                S.push(p->right);\n            }\n            if (p->left) {\n                S.push(p->left);\n            }\n        }\n        // TreeNode *q = V[0];\n        for(int i = 1; i < V.size(); i++) {\n            TreeNode *prev = V[i - 1];\n            TreeNode *curr = V[i];\n            prev->right = curr;\n            prev->left = nullptr;\n            // q = Q.front();\n            // Q.pop();\n        }\n    }\n};\n\n```\n\n```cpp\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        auto v = vector<TreeNode*>();\n        auto stk = stack<TreeNode*>();\n        TreeNode *node = root;\n        while (node != nullptr || !stk.empty()) {\n            while (node != nullptr) {\n                v.push_back(node);\n                stk.push(node);\n                node = node->left;\n            }\n            node = stk.top(); stk.pop();\n            node = node->right;\n        }\n        int size = v.size();\n        for (int i = 1; i < size; i++) {\n            auto prev = v.at(i - 1), curr = v.at(i);\n            prev->left = nullptr;\n            prev->right = curr;\n        }\n    }\n};\n\n```\n\nchatgpt的分析结果：你在第一个代码中同时使用了栈（`stack<TreeNode*> S`）和向量（`vector<TreeNode*> V`）。栈用于深度优先遍历，而向量用于存储访问顺序，这使得你在遍历每个节点时需要额外存储两次节点信息。这会增加内存使用，特别是在树很大的时候。\n\n第二个代码将遍历结果直接存入向量，而栈只用于辅助遍历，这样减少了节点的重复存储。\n\n#### 解法二——寻找前驱节点\n\n注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。\n\n具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。\n\n作者：力扣官方题解\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if (!root) {\n            return;\n        }\n        subflatten(root);\n    }\n    TreeNode* subflatten(TreeNode* p) {\n        TreeNode* left = p->left;\n        TreeNode* right = p->right;\n        TreeNode* last = p;\n        p->left = nullptr;\n        if (left != nullptr) {\n            p->right = left;\n            last = subflatten(left);\n        }\n        if (right != nullptr) {\n            last->right = right; // 注意这里是last的右孩子\n            last = subflatten(right);\n        }\n        return last; // 链表的最后一位\n    }\n};\n```\n\n### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)\n\n> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。\n>\n> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n\n迭代隐式回溯\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int rootSum(TreeNode* root, long targetSum) {\n        if (root == nullptr) {\n            return 0;\n        }\n        int output = 0;\n        if (root->val == targetSum) {\n            output++;\n        }\n        output += rootSum(root->left, targetSum - root->val);\n        output += rootSum(root->right, targetSum - root->val);\n        return output;\n    }\n    int pathSum(TreeNode* root, int targetSum) {\n        if (root == nullptr) {\n            return 0;\n        }\n        \n        int output = rootSum(root, targetSum);\n        output += pathSum(root->left, targetSum);\n        output += pathSum(root->right, targetSum);\n        return output;\n    }\n};\n```\n\n### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)\n\n> 二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。\n>\n> **路径和** 是路径中各节点值的总和。\n>\n> 给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。\n\n思路和“[543. 二叉树的直径]”类似，但是注意这里需要考虑当贡献大于0时候在加上。\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int pathSum;\n    int maxPath(TreeNode * p) {\n        if (p == nullptr) {\n            return 0;\n        }\n        int leftSum = maxPath(p->left);\n        int rightSum = maxPath(p->right);\n\n\t\n        // 注意下列和直径的区别，需要考虑贡献度\n        // int leftSum = maxPath(p->left);\n        // int rightSum = maxPath(p->right);\n        // pathSum = max(pathSum, max(leftSum + rightSum + p->val, max(rightSum + p->val, max(leftSum + p->val, p->val))));\n        // return max(max(leftSum, 0), max(rightSum, 0)) + p->val;\n\n        int leftSum = max(maxPath(p->left), 0);\n        int rightSum = max(maxPath(p->right), 0);\n\n        pathSum = max(pathSum, leftSum + rightSum + p->val);\n        return max(leftSum, rightSum) + p->val; \n\n    }\n\n    int maxPathSum(TreeNode* root) {\n        pathSum = root->val;\n        maxPath(root);\n        return pathSum;\n    }\n};\n```\n\n### [994. 腐烂的橘子](https://leetcode.cn/problems/rotting-oranges/)\n\n> 在给定的 `m x n` 网格 `grid` 中，每个单元格可以有以下三个值之一：\n>\n> - 值 `0` 代表空单元格；\n> - 值 `1` 代表新鲜橘子；\n> - 值 `2` 代表腐烂的橘子。\n>\n> 每分钟，腐烂的橘子 **周围 4 个方向上相邻** 的新鲜橘子都会腐烂。\n>\n> 返回 *直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 `-1`* 。\n\nBFS\n\n碰到1不动，碰到2开始广搜。\n\n注意对于如下的例子，两头一起烂才是最快的\n```\n[[2,1,1],\n [1,1,1],\n [0,1,2]]\n```\n\n所以不能只考虑每个点的，然后再找最小的。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0,1,1,0,-1,0,0,-1};\n    int bfs (vector<vector<int>>& grid, int x, int y) {\n        int time = 0;\n        queue<pair<int, int>> Q;\n        vector<vector<bool>> visited(grid.size(), vector<bool>(grid[0].size(), false));\n        visited[x][y] = true;\n        Q.push({x, y});\n\n        while (!Q.empty()) {\n            int currLoopNum = Q.size();\n            for (int i = 0; i < currLoopNum; i++) {\n                pair<int, int> curr = Q.front();\n                Q.pop();\n                int xCurr = curr.first;\n                int yCurr = curr.second;\n                for (int i = 0; i < 4; i++) {\n                    int xNext = xCurr + dir[i][0];\n                    int yNext = yCurr + dir[i][1];\n                    if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size() || grid[xNext][yNext] == 2) { // 2说明就是中心烂橘子，不需要重新计算\n                        continue;\n                    }\n                    if ((grid[xNext][yNext] == 1 || grid[xNext][yNext] == 3) && visited[xNext][yNext] == false) {\n                        Q.push({xNext, yNext});\n                        visited[xNext][yNext] = true;\n                        grid[xNext][yNext] = 3;\n                        // cout << xNext << \" \" << yNext;\n                    }\n                }\n            }\n            time ++;\n            // cout << time << endl;\n        }\n        // cout << \"A\";\n        return time - 1;\n    }\n\n    int orangesRotting(vector<vector<int>>& grid) {\n        int row = grid.size();\n        int column = grid[0].size();\n        int time = 0;\n        queue<pair<int, int>> Q;\n        bool flagOne = false;\n        \n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                if (grid[i][j] == 2) {\n                    Q.push({i, j});\n                }\n                if (grid[i][j] == 1) {\n                    flagOne = true;\n                }\n            }\n        }\n        if (Q.size() == 0 && flagOne == false) { // 考虑没有烂橘子\n            return 0;\n        }\n\n        while (!Q.empty()) {\n            int currLoopNum = Q.size();\n            for (int i = 0; i < currLoopNum; i++) {\n                pair<int, int> curr = Q.front();\n                Q.pop();\n                int xCurr = curr.first;\n                int yCurr = curr.second;\n                for (int i = 0; i < 4; i++) {\n                    int xNext = xCurr + dir[i][0];\n                    int yNext = yCurr + dir[i][1];\n                    if (xNext < 0 || yNext < 0 || xNext >= grid.size() || yNext >= grid[0].size() || grid[xNext][yNext] == 2) { // 2说明就是中心烂橘子，不需要重新计算\n                        continue;\n                    }\n                    if (grid[xNext][yNext] == 1 ) {\n                        Q.push({xNext, yNext});\n                        grid[xNext][yNext] = 2;\n                        // cout << xNext << \" \" << yNext;\n                    }\n                }\n            }\n            time ++;\n            // cout << time << endl;\n        }\n\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                if (grid[i][j] == 1) {\n                    // cout << i << \" \" << j;\n                    return -1;\n                }\n            }\n        }\n        return time - 1;\n    }\n};\n```\n\n为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 cnt=cnt−1 ，最后搜索结束时如果 cnt 大于 0 ，说明有新鲜橘子没被腐烂，返回 −1 ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 1 改为 2，最后看网格中是否有值为 1 即新鲜的橘子即可。\n\n### [207. 课程表](https://leetcode.cn/problems/course-schedule/)\n\n> 你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。\n>\n> 在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。\n>\n> - 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。\n>\n> 请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。\n\n不能成环？\n结果答案是拓扑排序，太难了\n\n![image-20241006105916273](/image-20241006105916273.png)\n\n用一个栈来存储所有**已经搜索完成的节点**。假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。\n\n方法一： 从入度思考(从前往后排序)， 入度为0的节点在拓扑排序中一定排在前面, 然后删除和该节点对应的边, 迭代寻找入度为0的节点。\n\n方法二： 从出度思考(从后往前排序)， 出度为0的节点在拓扑排序中一定排在后面, 然后删除和该节点对应的边, 迭代寻找出度为0的节点。\n\n#### 深度优先——栈\n\n对于图中的任意一个节点，它在搜索的过程中有三种状态，即：\n\n- 「未搜索」：我们还没有搜索到这个节点；\n\n- 「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；\n\n- 「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。\n\n\n通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。\n\n- 我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：\n\n  - 如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；\n\n  - 如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；\n\n  - 如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。\n\n- 当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。\n\n\n作者：力扣官方题解\n\n![image-20241006134104937](/image-20241006134104937.png)\n\n```cpp\nclass Solution {\npublic:\n    bool valid = true;\n\n    void dfs(vector<vector<int>>& edges, vector<int>& visited, int u) {\n        visited[u] = 1; // 1 搜索中\n        for (int v:edges[u]) {\n            if (visited[v] == 0) {\n                dfs(edges, visited, v);\n                if (valid == false) {\n                    return;\n                }\n            }\n            if (visited[v] == 1) {\n                valid = false;\n                return;\n            }\n        }\n        visited[u] = 2; // 搜索完成\n    }\n\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> edges(numCourses);\n        vector<int> visited(numCourses, 0); // 0 未搜索\n\n        for (int i = 0; i < prerequisites.size(); i++) {\n            vector<int> prerequisite = prerequisites[i];\n            edges[prerequisite[1]].emplace_back(prerequisite[0]);\n        }\n        for (int i = 0; i < numCourses && valid; i++) {\n            if (visited[i] == 0) {\n                dfs(edges, visited, i);\n            }\n        }\n        return valid;\n    }\n};\n```\n\n#### 广度优先——队列\n\n我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。\n\n\n\n作者：力扣官方题解\n\n\n![image-20241006134142872](/image-20241006134142872.png)\n\n```cpp\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> edges(numCourses);\n        vector<int> indeg(numCourses);\n\n        for (int i = 0; i < prerequisites.size(); i++) {\n            vector<int> prerequisite = prerequisites[i];\n            edges[prerequisite[1]].emplace_back(prerequisite[0]); // 1是0的先修课\n            indeg[prerequisite[0]] ++;\n        }\n\n        queue <int> Q;\n        for (int i = 0; i < numCourses; i++) {\n            if (indeg[i] == 0) { // 入度为0，加入队列删除边\n                Q.push(i);\n            }\n        }\n        int visited = 0;\n        while (!Q.empty()) {\n            visited++;\n            int u = Q.front();\n            Q.pop();\n            for (int v:edges[u]) {\n                indeg[v] --;\n                if (indeg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return visited == numCourses; // 如果没环，应该就都结束了\n    }\n};\n```\n\n\n\n#### [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)\n\n> 现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。\n>\n> - 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。\n>\n> 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> output; // 数组模拟栈\n    bool valid = true;\n\n    void dfs(vector<vector<int>>& edges, vector<int>& visited, int u) {\n        visited[u] = 1; // 1 搜索中\n        for (int v:edges[u]) {\n            if (visited[v] == 0) {\n                dfs(edges, visited, v);\n                if (valid == false) {\n                    return;\n                }\n            }\n            if (visited[v] == 1) {\n                valid = false;\n                return;\n            }\n        }\n        visited[u] = 2; // 搜索完成\n        output.emplace_back(u);\n    }\n\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> edges(numCourses);\n        vector<int> visited(numCourses, 0); // 0 未搜索\n\n        for (int i = 0; i < prerequisites.size(); i++) {\n            vector<int> prerequisite = prerequisites[i];\n            edges[prerequisite[1]].emplace_back(prerequisite[0]);\n        }\n        for (int i = 0; i < numCourses && valid; i++) {\n            if (visited[i] == 0) {\n                dfs(edges, visited, i);\n            }\n        }\n        if (!valid) {\n            return {};\n        }\n        reverse(output.begin(), output.end());\n        return output;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> edges(numCourses);\n        vector<int> indeg(numCourses);\n        vector<int> output;\n\n        for (int i = 0; i < prerequisites.size(); i++) {\n            vector<int> prerequisite = prerequisites[i];\n            edges[prerequisite[1]].emplace_back(prerequisite[0]); // 1是0的先修课\n            indeg[prerequisite[0]] ++;\n        }\n\n        queue <int> Q;\n        for (int i = 0; i < numCourses; i++) {\n            if (indeg[i] == 0) { // 入度为0，加入队列删除边\n                Q.push(i);\n            }\n        }\n        int visited = 0;\n        while (!Q.empty()) {\n            visited++;\n            int u = Q.front();\n            Q.pop();\n            output.emplace_back(u);\n            for (int v:edges[u]) {\n                indeg[v] --;\n                if (indeg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        if ( visited == numCourses ) {\n            return output;\n        }\n        else {\n            return {};\n        }\n    \n    }\n};\n```\n\n### [208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)\n\n> **[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 \"try\"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。\n>\n> 请你实现 Trie 类：\n>\n> - `Trie()` 初始化前缀树对象。\n> - `void insert(String word)` 向前缀树中插入字符串 `word` 。\n> - `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。\n> - `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。\n\nTrie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。非典型指的是节点设计不同。**一次建树，多次查询**\n\n```cpp\nstruct TrieNode {\n    bool isEnd; //该结点是否是一个串的结束\n    TrieNode* next[26]; //字母映射表\n};\n```\n\n字母映射表next `TrieNode* next[26]`中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值.\n\n1. Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。\n2. 查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。\n3. Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 $O(m^n)$。\n\n作者：路漫漫我不畏\n```cpp\nclass Trie {\npublic:\n    bool isEnd;\n    Trie* next[26];\n\n    Trie() {\n        isEnd = false;\n        memset(next, 0, sizeof(next));\n    }\n    \n    void insert(string word) { // 这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。\n\n        Trie* node = this;\n        for (auto c:word) {\n            if (node->next[c - 'a'] == NULL) {\n                node->next[c - 'a'] = new Trie();\n            }\n            node = node->next[c - 'a'];\n        }\n        node->isEnd = true;\n    }\n    \n    bool search(string word) { // 从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false\n        Trie* node = this;\n        for  (auto c:word) {\n            node = node->next[c - 'a'];\n            if (node == NULL) {\n                return false;\n            }\n        }\n        return node->isEnd;\n    }\n    \n    bool startsWith(string prefix) { // 和search的区别只在最后的判断\n        Trie* node = this;\n        for  (auto c:prefix) {\n            node = node->next[c - 'a'];\n            if (node == NULL) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */\n```\n\n在你的`Trie`实现中：\n\n- `Trie* node = this;`是用来从当前对象（即根节点）开始操作的。\n- 如果你用`new Trie()`，那意味着你创建了一个新的`Trie`对象，这个对象和原来的`Trie`无关，并且是一个全新的空的前缀树。所以这里的区别在于，你是想要操作当前已有的前缀树，还是想要创建一个新的空的前缀树。\n\n总结\n\n- `this`指针是对已有对象的引用。\n- 新建对象（使用`new`）是创建一个新的实例，它和原始对象没有直接关系。\n- 使用`this`的场景是想操作已有对象的内部，而使用`new`则是为了创建一个新对象来存储新的数据或状态。\n\n### [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n> 数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。\n\n有效括号对数，`（`必须要再`）`之前\n\n```cpp\nclass Solution {\npublic:\n    vector<string> output;\n    string temp;\n\n    void backtracking(int n, int usedLeft, int usedRight) {\n        if (usedLeft == n) {\n            for (int i = 0; i < n - usedRight; i++) { // 补齐右括号\n                temp.push_back(')');\n            }\n            output.emplace_back(temp);\n            for (int i = 0; i < n - usedRight; i++) { // 不要忘记这边要pop掉\n                temp.pop_back();\n            }\n            return;\n        }\n\n        if (usedLeft < n) {\n            // 选择加入‘(’， 不管什么情况都可以，只要还有n\n            temp.push_back('(');\n            backtracking(n, usedLeft + 1, usedRight);\n            temp.pop_back();\n        }\n        if (usedLeft > usedRight) {\n                temp.push_back(')');\n                backtracking(n, usedLeft, usedRight + 1);\n                temp.pop_back();\n            }\n    }\n\n    vector<string> generateParenthesis(int n) {\n        backtracking(n, 0, 0);\n        return output;\n    }\n};\n```\n\n### [79. 单词搜索](https://leetcode.cn/problems/word-search/)\n\n> 给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。\n>\n> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n\n图论解法——广度优先好像有问题，比如之前visited过的元素，那条路径被废弃了，万一在后面需要visit，就不行了。无法回溯回去——所以下面的解法是错的。。。\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n\n    bool bfs(vector<vector<char>>& board, string word, int x, int y){\n        queue <pair<int, int>> Q;\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\n        Q.push({x, y});\n        visited[x][y] = true;\n        int len = 1;\n\n        cout << x << \" \" << y << endl;\n\n        while(!Q.empty()) {\n            int qSize = Q.size();\n            cout <<  qSize << \" \";\n            for (int j = 0; j < qSize; j++) {\n                pair<int, int> curr = Q.front();\n                int xCurr = curr.first;\n                int yCurr = curr.second;\n                Q.pop();\n                for (int i = 0; i < 4; i++) {\n                    int xNext = xCurr + dir[i][0];\n                    int yNext = yCurr + dir[i][1];\n                    if (xNext < 0 || yNext < 0 || xNext >= board.size() || yNext >= board[0].size() || board[xNext][yNext] != word[len] || visited[xNext][yNext] == true) {\n                        continue;\n                    }\n                    Q.push({xNext, yNext});\n                    visited[xNext][yNext] = true;\n                }\n            }\n            len++;\n            cout << len << endl;\n        }\n        return len - 1 == word.size();\n    }\n\n\n    bool exist(vector<vector<char>>& board, string word) {\n        // bool output = false;\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board[0].size(); j++) {\n                if (board[i][j] == word[0]) {\n                    if (bfs(board, word, i, j) == true) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n下面是正确写法——深搜，虽然好像写的又臭又长，len和判断逻辑应该写在dfs里面的\n\n```cpp\nclass Solution {\npublic:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};\n\n    bool dfs(vector<vector<char>>& board, string word, vector<vector<bool>>& visited,  int x, int y, int len){\n\n\n        if (len == word.size()) {\n            return true;\n        }\n\n        bool output = false;\n                for (int i = 0; i < 4; i++) {\n                    int xNext = x + dir[i][0];\n                    int yNext = y + dir[i][1];\n                    if (xNext < 0 || yNext < 0 || xNext >= board.size() || yNext >= board[0].size() || board[xNext][yNext] != word[len] || visited[xNext][yNext] == true) {\n                        continue;\n                    }\n                    visited[xNext][yNext] = true;\n                    output = output || dfs(board, word, visited, xNext, yNext, len+1);\n                    visited[xNext][yNext] = false;\n                }\n                return output;\n        \n    }\n\n\n    bool exist(vector<vector<char>>& board, string word) {\n        // bool output = false;\n        vector<vector<bool>> visited(board.size(), vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board[0].size(); j++) {\n                if (board[i][j] == word[0]) {\n                    visited[i][j] = true;\n                    if (dfs(board, word, visited, i, j, 1) == true) {\n                        return true;\n                    }\n                    visited[i][j] = false;\n                }\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n\n> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n>\n> 请必须使用时间复杂度为 `O(log n)` 的算法。\n\n注意开闭区间。\n\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0; \n        int right = nums.size() - 1;\n        int output = nums.size();\n        while (left <= right) {\n            int mid = (left + right) / 2 ;\n            if (target <= nums[mid]) {\n                output = mid;\n                right = mid - 1;\n            }\n            else {\n                left = mid + 1;\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/) \n\n>给你一个满足下述两条属性的 `m x n` 整数矩阵：\n>\n>- 每行中的整数从左到右按非严格递增顺序排列。\n>- 每行的第一个整数大于前一行的最后一个整数。\n>\n>给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。\n\n非严格递增\n\n```cpp\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int row = matrix.size();\n        int column = matrix[0].size();\n        int left = 0;\n        int right = row * column - 1;\n\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int midX = mid / column; // 看看清啊，这里要除和模的是谁\n            int midY = mid % column;\n\n            if (matrix[midX][midY] == target) {\n                return true;\n            }\n            else if (target > matrix[midX][midY]) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n            }\n        }\n        return false;\n    }\n};\n```\n\n### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n> 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。\n>\n> 如果数组中不存在目标值 `target`，返回 `[-1, -1]`。\n>\n> 你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            }\n            else if (nums[mid] > target) {\n                right = mid - 1;\n            }\n            else {\n                int leftBound = mid;\n                while (leftBound >= 0 && nums[leftBound] == target) {\n                    leftBound--;\n                }\n                int rightBound = mid;\n                while (rightBound < nums.size() && nums[rightBound] == target) {\n                    rightBound++;\n                }\n                return {leftBound+1, rightBound-1};\n            }\n        }\n        return {-1, -1};\n    }\n};\n```\n\n官方题解在二分查找上做文章，加入了一个选项，确定是不是最小的/最大的范围。\n\n### [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)\n\n> 整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。\n>\n> 在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。\n>\n> 给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。\n>\n> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n先找分界点，再二分查找\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // 先找分界点\n        int min = 0;\n        int left = 1;\n        int right = nums.size() - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[0] < nums[mid]) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n                min = mid;\n            }\n        }\n        left = min;\n        right = left + nums.size() - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int i = mid % nums.size();\n            if (target < nums[i]) right = mid - 1;\n            else if (target > nums[i]) left = mid + 1;\n            else return i;\n        }\n        return -1;\n    }\n};\n```\n\n### [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)\n\n> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：\n>\n> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`\n> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`\n>\n> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。\n>\n> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。\n>\n> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n```cpp\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        int min = 0;\n        int left = 1;\n        int right = nums.size() - 1;\n        while(left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > nums[0]) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n                min = mid;\n            }\n        }\n        return nums[min];\n    }\n};\n```\n\n### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)\n\n> 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。\n>\n> 算法的时间复杂度应该为 `O(log (m+n))` 。\n\n#### 解法一——不满足时间复杂度要求\n\n直接找中间的\n\n```cpp\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        double output;\n        int p1 = 0;\n        int p2 = 0;\n        int prev = -1;\n        int curr = -1;\n        for (int i = 0; i <= (nums1.size() + nums2.size()) / 2; i++) {\n            prev = curr;\n            if (p1 < nums1.size() && (p2 >= nums2.size() || nums1[p1] < nums2[p2])) {\n                curr = nums1[p1++];\n            }\n            else {\n                curr = nums2[p2++];\n            }\n        }\n        if ((nums1.size() + nums2.size()) % 2 == 0) { //偶数\n            return (prev + curr) / 2.0;\n        }\n        else  {\n            return curr;\n        }\n    }\n};\n```\n\n#### 解法二——第k小数\n\n要求$O(\\log(m+n))$的复杂度\n\n题目是求中位数，其实就是求第 `k` 小数的一种特殊情况\n\n更一般的情况 A[1] ，A[2] ，A[3]，A[k/2] ... ，B[1]，B[2]，B[3]，B[k/2] ... ，如果 A[k/2]<B[k/2] ，那么A[1]，A[2]，A[3]，A[k/2]都不可能是第 k 小的数字。\n\n不断地去找第k小的数字，排除的去掉。\n\n作者：windliang\n\n```cpp\nclass Solution {\npublic:\n    int getKthElement(vector<int>& nums1, vector<int>& nums2, int k) {\n        int p1 = 0, p2 = 0;\n        while(1) {\n            int nums1Size = nums1.size();\n            int nums2Size = nums2.size();\n            if (p1 == nums1Size) {\n                return nums2[p2 + k - 1];\n            }\n            if (p2 == nums2Size) {\n                return nums1[p1 + k - 1];\n            }\n            if (k == 1) {\n                return min(nums1[p1], nums2[p2]) ;\n            }\n            int p1Next = min(p1 + k/2 - 1, nums1Size - 1);\n            int p2Next = min(p2 + k/2 - 1, nums2Size - 1);\n            if (nums1[p1Next] <= nums2[p2Next]) {\n                k -= p1Next - p1 + 1;\n                p1 = p1Next + 1;\n            }\n            else {\n                k -= p2Next - p2 + 1;\n                p2 = p2Next + 1;\n            }\n        }\n    }\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if ((nums1.size() + nums2.size()) % 2) { // 奇数\n            return getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / 2 + 1));\n        }\n        else {\n            return (getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / 2)) + getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / 2) + 1)) /2.0;\n        }\n    }\n};\n```\n\n### [155. 最小栈](https://leetcode.cn/problems/min-stack/)\n\n> 设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。\n>\n> 实现 `MinStack` 类:\n>\n> - `MinStack()` 初始化堆栈对象。\n> - `void push(int val)` 将元素val推入堆栈。\n> - `void pop()` 删除堆栈顶部的元素。\n> - `int top()` 获取堆栈顶部的元素。\n> - `int getMin()` 获取堆栈中的最小元素。\n\n再找一个辅助栈，专门存最小值\n\n```cpp\nclass MinStack {\npublic:\n    stack<int> S;\n    stack<int> minS;\n\n    MinStack() {\n        minS.push(INT_MAX);\n    }\n    \n    void push(int val) {\n        S.push(val);\n        if (val < minS.top()) {\n            minS.push(val);\n        }\n        else {\n            minS.push(minS.top());\n        }\n    }\n    \n    void pop() {\n        S.pop();\n        minS.pop();\n    }\n    \n    int top() {\n        return S.top();\n    }\n    \n    int getMin() {\n        return minS.top();\n    }\n};\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack* obj = new MinStack();\n * obj->push(val);\n * obj->pop();\n * int param_3 = obj->top();\n * int param_4 = obj->getMin();\n */\n```\n\n\n\n### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)（▲）\n\n> 给定一个经过编码的字符串，返回它解码后的字符串。\n>\n> 编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。\n>\n> 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n>\n> 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n\n\nGPT的修改结果，思路更加清晰，我原来想得太乱了\n\n\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> times;             // 栈存储重复次数\n        stack<string> strings;        // 栈存储中间结果\n        string temp;\n        string output;\n\n        for (int i = 0; i < s.size(); i++) {\n            if (isdigit(s[i])) {      // 判断是否为数字\n                int num = 0;\n                while (isdigit(s[i])) {\n                    num = num * 10 + (s[i] - '0');\n                    i++;\n                }\n                times.push(num);\n                i--; // 回退一个位置，以便后续的 '[' 可以正确处理\n            } else if (s[i] == '[') {\n                strings.push(output); // 将当前的 output 保存\n                output = \"\";          // 清空 output，准备存储新的子字符串\n            } else if (s[i] == ']') {\n                string tempTimes = output;\n                output = strings.top(); // 取出上一次的字符串\n                strings.pop();\n                int repeat = times.top();\n                times.pop();\n                for (int j = 0; j < repeat; j++) {\n                    output += tempTimes; // 拼接重复的字符串\n                }\n            } else { // 字母\n                output.push_back(s[i]);\n            }\n        }\n\n        return output;\n    }\n};\n```\n\n### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)\n\n> 给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。\n>\n> 请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。\n>\n> 你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n#### 解法一——基于快排和快速选择\n\n首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：\n\n分解： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。\n解决： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。\n合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。\n上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。\n\n**所以只要某次划分的 q为倒数第k个下标的时候，我们就已经找到了答案。**\n\n作者：力扣官方题解\n\n还是没完全看懂，为啥要do while啊，防止多加吗—— 帮助程序在有大量重复数字时快速收敛边界。 快速收敛就是让`j`尽可能接近当前区间中间位置。\n\n**在特别用例中，存在大量在`x`和`nums[i]`和`nums[j]`都相等的情况。**\n\n**所以会有许多次`i++,j--`，这让j`更进一步地接近中间位置。**\n\n```cpp\nclass Solution {\npublic:\n    int quickSelect(vector<int>& nums, int l, int r, int k) {\n        if (l == r) {\n            return nums[k];\n        }\n        int partition = nums[l];\n        int low = l -1; \n        int high = r +1;\n        while (low < high) {\n            // while(nums[low] < partition) {\n            //     low++;\n            // }\n            // while(nums[high] > partition) {\n            //     high--;\n            // }\n            do {low++;} while (nums[low] < partition);\n            do {high--;} while (nums[high] > partition);\n            if (low < high) {\n                swap(nums[low], nums[high]);\n            }\n\n        }\n        if (k <= high) {\n            return quickSelect(nums, l, high, k);\n        }\n        else {\n            return quickSelect(nums, high + 1, r, k);\n        }\n    }\n    int findKthLargest(vector<int>& nums, int k) {\n        return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\n    }\n};\n```\n\n#### 解法二——堆\n\n小根堆\n\n```cpp\nclass Solution {\npublic:\n    int findKthLargest(vector<int>& nums, int k) {\n        priority_queue<int, vector<int>, greater<>> pq;\n\n        for(int i = 0; i < k; i++) {\n            pq.push(nums[i]);\n        }\n        for(int i = k; i < nums.size(); i++) {\n            if (pq.top() < nums[i]) {\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n        return pq.top();\n    }\n};\n```\n\n### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)\n\n> **中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。\n>\n> - 例如 `arr = [2,3,4]` 的中位数是 `3` 。\n> - 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。\n>\n> 实现 MedianFinder 类:\n>\n> - `MedianFinder() `初始化 `MedianFinder` 对象。\n> - `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。\n> - `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。\n\n用两个优先队列，分别存最大和最小？\n\n当我们尝试添加一个数 num 到数据结构中，我们需要分情况讨论：\n\nnum≤max{queMin}\n\n此时 num 小于等于中位数，我们需要将该数添加到 queMin 中。新的中位数将小于等于原来的中位数，因此我们可能需要将 queMin 中最大的数移动到 queMax 中。\n\nnum>max{queMin}\n\n此时 num 大于中位数，我们需要将该数添加到 queMin 中。新的中位数将大于等于原来的中位数，因此我们可能需要将 queMax 中最小的数移动到 queMin 中。\n\n作者：力扣官方题解\n\n奇数，qMin比qMax多存一个。偶数相同\n\n```cpp\nclass MedianFinder {\npublic:\n    priority_queue<int, vector<int>, less<>> Qmin;\n    priority_queue<int, vector<int>, greater<>> Qmax; \n\n    MedianFinder() {\n\n    }\n    \n    void addNum(int num) {\n        if (Qmin.empty() || num <= Qmin.top()) {\n            Qmin.push(num);\n            if (Qmax.size() + 1 < Qmin.size()) {\n                Qmax.push(Qmin.top());\n                Qmin.pop();\n            }\n        }\n        else {\n            Qmax.push(num);\n            if (Qmax.size() > Qmin.size()) {\n                Qmin.push(Qmax.top());\n                Qmax.pop();\n            }\n        }\n    }\n    \n    double findMedian() {\n        if (Qmin.size() > Qmax.size()) {\n            return Qmin.top();\n        }\n        else {\n            return (Qmax.top() + Qmin.top()) / 2.0;\n        }\n    }\n};\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder* obj = new MedianFinder();\n * obj->addNum(num);\n * double param_2 = obj->findMedian();\n */\n```\n\n### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)\n\n> 给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n>\n> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> output(numRows);\n\n        for (int i = 0; i < numRows; i++) {\n            output[i].resize(i + 1);\n            output[i][0] = output[i][i] = 1;\n            for (int j = 1; j < i; j++) {\n                output[i][j] = output[i - 1][j - 1] + output[i - 1][j];\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)\n\n> 给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n>\n> **子数组** 是数组中<u>连续</u>的 **非空** 元素序列。\n>\n> 测试用例的答案是一个 **32-位** 整数。\n\n考虑和300题类似的思路，每次回退计算。但是超时\n\n```cpp\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector<int> dp(nums.size()); // 包含该数的最长子数组乘积\n        dp[0] = nums[0];\n        int output = nums[0];\n        for (int i = 1;  i < nums.size(); i++) {\n            dp[i] = nums[i];\n            int temp = 1;\n            for (int j = i; j >= 0; j--) {\n                temp *= nums[j];\n                dp[i] = max(dp[i], temp);\n                if (temp == 0) {\n                    break;\n                }\n            }\n            if (dp[i] > output) {\n                output = dp[i];\n            }\n        }\n        return output;\n    }\n};\n```\n\n用两个正负两个数组\n\n```cpp\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector<int> dpPlus(nums.size()); // 正序列（绝对值最大）\n        vector<int> dpMinus(nums.size()); // 负序列（绝对值最大）\n        dpPlus[0] = nums[0];\n        dpMinus[0] = nums[0];\n        int output = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dpPlus[i] = max(nums[i], max(dpPlus[i - 1] * nums[i], dpMinus[i - 1] * nums[i]));\n            dpMinus[i] = min(nums[i], min(dpPlus[i - 1] * nums[i], dpMinus[i - 1] * nums[i]));\n            if (dpPlus[i] > output) {\n                output = dpPlus[i];\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)\n\n> 给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。\n\n考虑有`\"()(()\"`的情况，所以单纯的记数左括号作为dp是不对的\n\n所以考虑以下的思路：\n\n+ `(`均为0\n+ `)`分上一个是`(`（增加2）还是`)`（还得继续往前找）\n  + `(`（增加2），$dp[i] = dp[i-2]+2$\n  + `)`（继续往前找），要把上一个元素序列扣掉（它的长度是$dp[i-1]$），去看$dp[i-dp[i-1]-1]$是不是`(`，是的话$dp[i] = dp[i-1]+ dp[i-dp[i-1]-2]+2$\n\n```cpp\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        vector<int> dp(s.size(), 0);\n        int output = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '(') {\n                dp[i] = 0;\n            }\n            else if (i >= 1 && s[i - 1] == '(') {\n                if (i >= 2) {\n                    dp[i] = dp[i-2] + 2;\n                }\n                else {\n                    dp[i] = 2;\n                }\n            }\n            else if (i >= 1 && s[i - 1] == ')') {\n                if ((i - dp[i-1] - 1 >= 0) && (s[i - dp[i-1] - 1] == '(')) {\n                    if (i - dp[i-1] - 2 >= 0) {\n                        dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2;\n                    }\n                    else {\n                        dp[i] = dp[i-1] + 2;\n                    }\n                }\n            }\n            output = max(output, dp[i]);\n        }\n        return output;\n    }\n};\n```\n\n官方题解更加简洁\n\n```cpp\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        int maxans = 0, n = s.length();\n        vector<int> dp(n, 0);\n        for (int i = 1; i < n; i++) {\n            if (s[i] == ')') {\n                if (s[i - 1] == '(') {\n                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                }\n                maxans = max(maxans, dp[i]);\n            }\n        }\n        return maxans;\n    }\n};\n```\n\n### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)\n\n> 给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n>\n> **说明：**每次只能向下或者向右移动一步。\n\n```cpp\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int row = grid.size();\n        int column = grid[0].size();\n        vector<int> dp(column, 0);\n        int temp = 0;\n\n        for(int j = 0; j < column; j++) {\n            temp += grid[0][j];\n            dp[j] = temp;\n        }\n\n        for (int i = 1; i < row; i++) {\n            dp[0] = dp[0] + grid[i][0];\n            for (int j = 1; j < column; j++) {\n                dp[j] = min(dp[j] , dp[j - 1]) + grid[i][j];\n            }\n        }\n        return dp[column - 1];\n    }\n};\n```\n\n### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)\n\n> 给你一个字符串 `s`，找到 `s` 中最长的 回文子串。\n\n和32挺像的。但是区别就是不光两个元素啊！所以会有其他的问题，比如一个滚动数组好像是不够的。\n\n```cpp\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        vector<vector<int>> dp(s.size(), vector<int> (s.size(), 0));\n        int len = 0;\n        string output;\n        for (int i = s.size() - 1; i >= 0; i--) {\n            for (int j = i; j < s.size(); j++) {\n                if (s[i] == s[j] && (j - i <= 1 || dp[i+1][j-1])) {\n                    dp[i][j] = true;\n                    if (j - i >= len) {\n                        len = j - i;\n                        output = s.substr(i, j - i + 1);\n                    }\n                }\n            }\n        }\n        return output;\n    }\n};\n```\n\n### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)\n\n> 给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n>\n> 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n#### 解法一——不考虑线性复杂度\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        // int output = nums[0];\n        if (nums.size() == 1) {\n            return nums[0];\n        }\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i-1] != nums[i]) {\n                return nums[i-1];\n            }\n            else {\n                i++;\n            }\n        }\n        return nums[nums.size() - 1];\n    }\n};\n```\n\n#### 解法二——位运算\n\n真的想不到啊。。。\n\n对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。\n\n+ 任何数和 0 做异或运算，结果仍然是原来的数，即 $a⊕0=a$。\n+ 任何数和其自身做异或运算，结果是 0，即 $a⊕a=0$。\n+ 异或运算满足交换律和结合律，即 $a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b$。\n\n作者：力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int single = 0;\n        for(int num:nums) {\n            single ^= num;\n        }\n        return single;\n    }\n};\n```\n\n### [169. 多数元素](https://leetcode.cn/problems/majority-element/)\n\n> 给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。\n>\n> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n#### 解法一——不考虑复杂度\n\n① 先排序再找\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        if(nums.size() == 1){\n            return nums[0];\n        }\n        sort(nums.begin(), nums.end());\n        int count = 1;\n        for (int i = 1; i < nums.size(); i++) {\n            if(nums[i] == nums[i-1]) {\n                count++;\n                if (count > (nums.size() / 2)) {\n                    return nums[i];\n                }\n            }\n            else {\n                count = 1;\n            }\n        }\n        return 0;\n    }\n};\n```\n\n更简单的写法：\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        return nums[nums.size()/2];\n    }\n};\n```\n\n② 哈希表\n\n#### 解法二——Boyer-Moore 投票算法\n\n如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。\n\n太形象了——“同归于尽消杀法” ：\n\n由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。\n\n1. 第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count = 1。\n2. 如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count++；\n3. 如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力count --。（即使双方都死光，这块高地的旗帜 winner 依然不变，因为已经没有活着的士兵可以去换上自己的新旗帜）\n4. 当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。\n\n就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去，直到少数阵营都死光，那么最后剩下的几个必然属于多数阵营，winner 就是多数阵营。（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）\n\nhttps://leetcode.cn/problems/majority-element/solution/javashi-pin-jiang-jie-xi-lie-majority-element-by-s/\n\n```cpp\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        int count = 1;\n        int curr = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            if (curr == nums[i]) {\n                count++;\n            }\n            else if (count == 0) {\n                curr = nums[i];\n                count = 1;\n            }\n            else {\n                count--;\n            }\n        }\n        return curr;\n    }\n};\n```\n\n### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)\n\n> 给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n>\n> 我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n>\n> 必须在不使用库内置的 sort 函数的情况下解决这个问题。\n\n#### 解法一——排序（冒泡）\n\n```cpp\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        for(int i = 0; i < nums.size(); i++) {\n            for (int j = 1; j < nums.size() - i; j++) {\n                if (nums[j - 1] > nums[j]) {\n                    swap(nums[j - 1], nums[j]);\n                }\n            }\n        }\n    }\n};\n```\n\n#### 解法二——直接统计，反正就三个颜色\n\n```cpp\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int color[3] = {0};\n        for(int i = 0; i < nums.size(); i++) {\n            color[nums[i]]++;\n        }\n        for(int i = 0; i < color[0]; i++) {\n            nums[i] = 0;\n        }\n        for(int i = color[0]; i < color[0] + color[1]; i++) {\n            nums[i] = 1;\n        }\n        for(int i = color[0] + color[1]; i < nums.size(); i++) {\n            nums[i] = 2;\n        }\n    }\n};\n```\n\n#### 解法三——单指针\n\n遍历两边\n\n```cpp\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int p = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 0) {\n                swap(nums[i], nums[p]);\n                p++;\n            }\n        }\n        for (int i = p; i < nums.size(); i++) {\n            if (nums[i] == 1) {\n                swap(nums[i], nums[p]);\n                p++;\n            }\n        }\n    }\n};\n```\n\n#### 解法四——双指针(▲)\n\n两个指针一个指向0，一个指向1\n\n```cpp\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int p0 = 0, p1 = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if(nums[i] == 1) {\n                swap(nums[i], nums[p1]);\n                p1++;\n            }\n            else if (nums[i] == 0) {\n                swap(nums[i], nums[p0]);\n                if (p0 < p1) {\n                    swap(nums[i], nums[p1]);\n                }\n                p0++;\n                p1++;\n            }\n        }\n\n    }\n};\n```\n\n### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)（▲）\n\n> 整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。\n>\n> - 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n>\n> 整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n>\n> - 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n> - 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n> - 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n>\n> 给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n>\n> 必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n<img src=\"/image-20241010160245605.png\" alt=\"image-20241010160245605\" style=\"zoom:50%;\" />\n\n如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：\n\n1. 我们希望下一个数 **比当前数大**，这样才满足 “下一个排列” 的定义。因此只需要 **将后面的「大数」与前面的「小数」交换**，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。\n2. 我们还希望下一个数 **增加的幅度尽可能的小**，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：\n   1. 在 **尽可能靠右的低位** 进行交换，需要 **从后向前** 查找\n   2. 将一个 **尽可能小的「大数」** 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换\n   3. 将「大数」换到前面后，需要将「大数」后面的所有数 **重置为升序，升序排列就是最小的排列**。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列\n\n作者：Imageslr\n\n```cpp\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        if (nums.size() <= 1) {\n            return;\n        }\n        int i = nums.size() - 2;\n        // 找到从后往前的第一个相邻升序对\n        while (i >=0 && nums[i] >= nums[i+1])  {\n            i--;\n        }\n\n        if (i >= 0) {// 非最后一个排列\n            //找到尽可能小的「大数」\n            int k = nums.size() - 1;\n            while (k >= 0 && nums[i] >= nums[k]) {\n                k--;\n            }\n            swap(nums[i], nums[k]);\n        }\n        reverse(nums.begin() + i + 1, nums.end());\n    }\n};\n```\n\n### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)（▲）\n\n> 给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。\n>\n> 假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。\n>\n> 你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。\n\n二分法：\n\n定义$cnt[i]$是数组中小于i的数的个数，$cnt[]$随数字增大有单调性（*target* 前 *cnt*[*i*]≤*i*，*target* 后 *cnt*[*i*]>*i*）\n\n1. 如果测试用例的数组中 target 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于 target 的数 i 满足 cnt[i]=i，大于等于 target 的数 j 满足 cnt[j]=j+1。\n\n2. 如果测试用例的数组中 target 出现了三次及以上，那么必然有一些数不在 nums 数组中了，这个时候相当于我们用 target 去替换了这些数，我们考虑替换的时候对 cnt[] 数组的影响。如果替换的数 i 小于 target ，那么 [i,target−1] 的 cnt 值均减一，其他不变，满足条件。如果替换的数 j 大于等于 target，那么 [target,j−1] 的 cnt 值均加一，其他不变，亦满足条件。\n\n\n作者：力扣官方题解\n\n```cpp\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int left = 1;\n        int right = nums.size() - 1;\n        int output = -1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int i = 0; i < nums.size(); i++) {\n                cnt += (nums[i] <= mid);\n            }\n            if (cnt <= mid) {\n                left = mid + 1;\n            }\n            else {\n                right = mid - 1;\n                output = mid;\n            }\n        }\n        return output;\n    }\n};\n```\n\n## 华为手撕准备\n\n### 54. 螺旋矩阵\n\n1. visited矩阵\n2. 模拟\n\n```cpp\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};\n        vector<int> output;\n        int row = matrix.size();\n        int column = matrix[0].size();\n        int x = 0;\n        int y = 0;\n        int upBound = 0, downBound = row - 1, leftBound = 0, rightBound = column - 1;\n                \n\n        while (1) {\n            for (int j = leftBound; j <= rightBound; j++) {\n                output.push_back(matrix[upBound][j]);\n            }\n            upBound++;\n            if (upBound > downBound) {\n                break;\n            }\n            for (int i = upBound; i <= downBound; i++) {\n                output.push_back(matrix[i][rightBound]);\n            }\n            rightBound--;\n            if (rightBound < leftBound) {\n                break;\n            }\n            for (int j = rightBound; j >= leftBound; j--) {\n                output.push_back(matrix[downBound][j]);\n            }\n            downBound--;\n            if (downBound < upBound) {\n                break;\n            }\n            for (int i = downBound; i >= upBound; i--) {\n                output.push_back(matrix[i][leftBound]);\n            }\n            leftBound++;\n            if (rightBound < leftBound) {\n                break;\n            }\n        }\n        return output;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        vector<int> output;\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int length = m * n;\n        int x = 0;\n        int y = 0;\n        int count = n;\n        int dir[4][2] = {0,1,1,0,0,-1,-1,0}; // 01右；10下；0-1左；-10上\n        int countDir = 0;\n\n        for (int i = 0; i < length; i++) {\n            output.emplace_back(matrix[x][y]);\n            // cout << count << \" || \";\n            if(count <= 1) { // count = 1 换方向\n                countDir = (countDir + 1) % 4;\n                m -= abs(dir[countDir][0]);\n                n -= abs(dir[countDir][1]);\n                count = abs(dir[countDir][0]) * m + abs(dir[countDir][1]) * n + 1;\n            }\n            // cout << i <<\" \"  <<count << \" || \" << x << \" \" << y << \" || \" << countDir << \" \" << dir[countDir][0] << \" \" << dir[countDir][1] << endl;\n            x += dir[countDir][0];\n            y += dir[countDir][1];\n            count --;\n        }\n        return output;\n    }\n};\n```\n\n### 买卖股票\n\n1. 只能买卖一次\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(vector<int>& prices) {\n           int len = prices.size();\n           vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组\n           dp[0][0] -= prices[0];\n           dp[0][1] = 0;\n           for (int i = 1; i < len; i++) {\n               dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);\n               dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);\n           }\n           return dp[(len - 1) % 2][1];\n       }\n   };\n   ```\n\n2. 可以买卖无数次：$dp[i][0]$不止和上次也没持有比较，还和上次持有但是卖了有关。\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(vector<int>& prices) {\n           vector<vector<int>> dp(2, vector<int> (2));\n           dp[0][0] = -prices[0];\n           dp[0][1] = 0;\n           for(int i = 1; i < prices.size(); i++) {\n               dp[i % 2][0] = max(dp[(i-1) % 2][0], dp[(i-1) % 2][1]-prices[i]); // 持有股票\n               dp[i % 2][1] = max(dp[(i-1) % 2][1], dp[(i-1) % 2][0]+prices[i]); // 不持有股票\n           }\n           return dp[(prices.size() - 1)%2][1];\n       }\n   };\n   ```\n\n3. 最多可以完成 **两笔** 交易。\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(vector<int>& prices) {\n           int n = prices.size();\n           int buy1 = -prices[0], sell1 = 0;\n           int buy2 = -prices[0], sell2 = 0;\n           for (int i = 1; i < n; ++i) {\n               buy1 = max(buy1, -prices[i]);\n               sell1 = max(sell1, buy1 + prices[i]);\n               buy2 = max(buy2, sell1 - prices[i]);\n               sell2 = max(sell2, buy2 + prices[i]);\n           }\n           return sell2;\n       }\n   };\n   ```\n\n4. 最多可以完成k笔交易的通解\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(int k, vector<int>& prices) {\n           vector buy(k+1, INT_MIN), sel(k+1, 0);\n           for (int i : prices) {\n               for (int j = 1; j < k+1; j++) {\n                   buy[j] = max(buy[j], sel[j - 1] - i);\n                   sel[j] = max(sel[j], buy[j] + i);\n               }\n           }\n           return sel[k];\n       }\n   };\n   ```\n\n5. 无限次交易，但带冷静期\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(vector<int>& prices) {\n           vector<vector<int>> dp(prices.size(), vector<int>(3));\n           dp[0][0] = - prices[0]; // 持有\n           dp[0][1] = 0; // 不持有且不在不在冷冻期\n           dp[0][2] = 0; // 冷冻期\n   \n           for(int i = 1; i < prices.size(); i++) {\n               dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]); // 持有只有两种：上一期持有，上次不持有-price[i]\n               dp[i][1] = max(dp[i-1][1], dp[i-1][2]); // 上一次在冷冻期，或者上一次不持有\n               dp[i][2] = dp[i-1][0] + prices[i]; // 上一期持有，本期抛售\n               // cout << dp[i][0] << \" \" << dp[i][1] << \" \" << dp[i][2] << endl;\n           }\n           return max(dp[prices.size() - 1][1], dp[prices.size() - 1][2]);\n   \n       }\n   };\n   ```\n\n6. 无限次交易，但含手续费\n\n   ```cpp\n   class Solution {\n   public:\n       int maxProfit(vector<int>& prices, int fee) {\n           vector<vector<int>> dp(prices.size(), vector<int> (2));\n           dp[0][0] = -prices[0];\n           dp[0][1] = 0;\n           for (int i = 1; i < prices.size(); i++) {\n               dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);\n               dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);\n           }\n           return dp[prices.size() - 1][1];\n       }\n   };\n   ```\n\n   \n\n\n\n\n\n### 公共子串\n\n\n\n### 回文子串\n\n动态规划\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        vector<vector<bool>> dp(s.length(), vector<bool>(s.length(), false));\n        int output = 0;\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = i; j < s.length(); j++) {\n                if (s[i] == s[j] && (j - i <= 1 || dp[i+1][j-1])) {\n                    output++;\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return output;\n    }\n```\n\n双指针\n\n```cpp\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int left, right;\n        int output = 1; // 0位置的\n\n        for (int center = 1; center < s.length(); center++)  {\n            output ++; // 独自的\n            // 区分奇偶，偶数往左找\n            if (s[center] == s[center - 1]) { // 偶\n                left = center - 1;\n                right = center;\n                while (left >= 0 && right < s.length() && s[left] == s[right]) {\n                    output++;\n                    left--;\n                    right++;                    \n                }\n            }\n            // 奇数是必然有的情况，不需要else\n            left = center - 1;\n            right = center + 1;\n            while (left >= 0 && right < s.length() && s[left] == s[right]) {\n                output++;\n                left--;\n                right++;                    \n            }\n        }\n        return output;\n    }\n};\n```\n\n\n\n### 括号匹配\n\n### 链表成环\n\n\n\n\n\n\n---\n\n<center>持续更新中</center>\n\n---","tags":["编程","秋招"],"categories":["杂七杂八"]},{"title":"LaTeX札记（六）：MATLAB与TikZ绘图","url":"/2024/01/01/latex-note-06/","content":"\n# $\\LaTeX$札记（六）——MATLAB与TikZ绘图\n\n在跨年前夜水一片博客，2023年没怎么写博客，因为没有什么可写的~ 祝大家新年快乐哦！\n\n\n\n这篇札记主要分为以下几个方面：\n\n1. 如何将MATLAB画的图导出为$\\LaTeX$中画图的Ti$k$Z代码\n2. 如何在$\\LaTeX$中画图代码进行一些修饰和改进\n3. 如何将论文中所有采用Ti$k$Z的绘图保存为PDF图片，方便后续交稿等操作\n\n\n\n首先回答一个问题——**“为什么想要把MATLAB画好的图多此一举地转为TikZ？”**\n\n+ TikZ是MATLAB比较原生的绘图方式，所以画图的字体什么的会比较贴近于正文，同时不同图片大小也方便统一。\n+ 如果我们需要增加/删减图片的某条线，修改图片某个图例等。\n  + 如果采用MATLAB导出的方式，工作流是“修改MATLAB画图代码=>导出PDF/EPS=>删减白边=>重新复制到LaTeX文档目录下”；\n  + 然而如果采用TikZ的方式，我们只需要在第一次复制到相应的文档目录，调整好尺寸大小，后续的几乎所有操作都可以在LaTeX编辑器中完成，而不需要再大费周折从MATLAB导出。\n\n\n\n## 导出MATLAB绘图至TikZ\n\n这里要使用一个MATLAB脚本`matlab2tikz`：下载链接🔗[GitHub - matlab2tikz/matlab2tikz: This program converts MATLAB®/Octave figures to TikZ/pgfplots figures for smooth integration into LaTeX.](https://github.com/matlab2tikz/matlab2tikz)\n\n+ 首先按照网站Installation部分的安装`matlab2tikz`\n\n  + 把它完整下载到本地。\n  + 下载完成后，将下载获得的文件夹中的`\\src`文件夹添加到`matlab`路径中。如`addpath('你的目录\\src')`\n\n+ 在你所需绘图的图片下方输入该命令\n  ```matlab\n  matlab2tikz('ABCDE.tex');\n  ```\n\n  或者（不显示一长串的说明）\n  ```matlab\n  matlab2tikz('plot_rebuttal/ABCDE.tex','showInfo',false)\n  ```\n\n+ 于是你会在你的当前目录下，或者对应文件夹下找到生成的`ABCDE.tex`文件，这个文件就是tikz的画图函数。主要包含以下一些\n\n  + 颜色的定义`\\definecolor`\n  + `\\begin{tikzpicture}` tikz画图环境\n  + `\\begin{axis}` axis坐标环境：在axis环境中主要包括坐标区域和legend的定义，以及各个线条的坐标数值。\n\n+ 将这个放置到latex项目的对应路径下，即可在论文中引用它。\n  \n  + 注意在最开始的导言区需要引用以下宏包和指令，大家也可以直接粘贴上述生成`.tex`文档时matlab中的输出：\n    ```tex\n      \\usepackage{pgfplots}\n      \\pgfplotsset{compat=newest}\n      %% the following commands are needed for some MATLAB2tikz features\n      \\usetikzlibrary{plotmarks}\n      \\usetikzlibrary{arrows.meta}\n      \\usepgfplotslibrary{patchplots}\n    ```\n  + 与普通图片相同的是——我们同样需要在`figure`环境中引用他\n  + 与普通图片不同的是——我们不再采用类似`\\includegraphics[width=.9\\linewidth]{img/BCDEF.pdf}`的形式来引用图片，而利用类似文件嵌套的形式`\\input{img/ABCDE}`来引用图片，注意到这里我们不需要加入后缀`.tex`。注意到这里我们不能加入对于大小的控制，对于大小的控制我们会在第二节中阐述。\n  + 给出两个例子：\n    ①全图形式：和普通的图片类似，只是`\\includegraphics`变为`\\input`\n  \n    ```tex\n        \\begin{figure}[htbp]\n            \\centering\n            \\input{main/chapter4/figures/AAAA}\n            \\caption{OFDM-AAAA}\n            \\label{fig:postion}\n        \\end{figure}\n    ```\n    ②子图形式（`figure*`是IEEEtran格式定义的环境，大家用普通的figure环境即可，`\\subfloat`需要引用`subcaption`宏包；此外大家也可以直接把子图的注释直接写在`[]`中）\n    ```tex\n    \\begin{figure*}[t]\n        \\subfloat[]{\\input{img/3a_throughput}\\label{fig:aaa}}\\hfill\n        \\subfloat[]{\\input{img/3b}\\label{fig:bbb}}\\hfill\n        \\subfloat[]{\\input{img/3c}\\label{fig:ccc}}\\hfill\n        \\subfloat[]{\\input{img/3d_new}\\label{fig:ddd}}\n        \\caption{(a) xxxxxx. (b) xxxxxx. (c) xxxxxx. (d) xxxxxx. }\n        \\label{fig:xxxx}\n    \\end{figure*}\n    ```\n  \n+ 【附】如果我们自己用tikz画的图则直接包裹在`figure`和`tikzpicture`环境中即可，不需要另开一个文件也可以。将画图单独提取为一个文件主要为了论文中结构清晰。\n\n\n\n\n\n## 在LaTeX中修饰TikZ的绘图\n\n**本节中我们的操作均对于`matlab2tikz`生成的`.tex`操作！**\n\n### 常规操作\n\n#### 大小\n主要涉及两方面的调整：①对整个`\\begin{tikzpicture}`环境的大小调整；②对画幅尺寸的调整（即`axis`环境中`height`和`witdh`的调整）\n\n+ 首先建议将`axis`环境中的`at={(0.758in,0.481in)}, scale only axis,`两行注释，大家一会可以尝试一下不注释这两行的效果，选择自己想要的效果。\n\n1. 对整个`tikzpicture`环境的调整：加上`\\begin{tikzpicture}[scale=.65]`能够对整个图片的大小进行调整为原来的xx倍。\n     1. 同时可以使用`xscale`和`yscale`命令对横纵进行不同大小的缩放，达到拉伸的效果。\n     2. 注意这样的调整是对整体的调整，所有曲线、坐标、字符均进行等同的大小缩放。\n2. `axis`环境中`height`和`witdh`是调整的图片原始的比例。\n     1. 注意这样的调整实际上是调整了原始画幅的大小，相当于在matlab中对生成的figure窗口进行拉伸缩放操作。\n     2. 光调整这两个参数，虽然latex中图片大小变化了，可以注意到所有曲线、坐标、字符和原始大小不变。\n\n建议大家*综合考量两个调整方式*，以使得图片尺寸和字体、mark大小等均比较合适。\n\n给出一个例子：\n![scale_figure](/scale_figure.jpg)\n\n#### 坐标轴\n主要包括以下几个方面：\n\n+ 坐标轴的取值范围：调整`xmin`,`xmax`,`ymin`,`ymax`即可\n\n+ 四边坐标轴的黑边：如果想让四边均为黑色的可以把`axis x line*=bottom,axis y line*=left,`注释掉\n\n+ 增加tick：例如原来坐标轴只标注了`2,4,6,8`，想标注更多`1,2,3,4,5,6,7`，则增加一行(对y坐标轴同理)\n  ```tex\n  xtick={1,2,3,4,5,6,7},\n  ```\n\n+ 增加tick（光增加灰色线条，不增加标注坐标轴数字）：则增加以下三行（对y坐标轴同理）\n  ```tex\n  extra x ticks={1,2,3,4,5,6,7,8,9},\n  extra x tick style={grid=major},\n  extra x tick labels={},\n  ```\n\n+ 如果想要进一步挤压tick数字和label之间的距离可以加入这一行代码，但是会很紧（注意至少加在`y label`后面）\n  ```tex\n  every axis y label/.style={\n  at={(ticklabel cs:0.5)},rotate=90,anchor=center,\n  },\n  ```\n\n  \n\n#### 图例\n\n主要介绍：①位置，②字体大小，③透明度表现形式，④图例内容\n\n`matlab2tikz`生成的图例相关的指令通常类似于\n\n```tex\nlegend style={at={(0.97,0.74)}, anchor=east, legend cell align=left, align=left, draw=white!15!black}\n```\n\n1. 首先说明以下这里面关于位置的一些说明\n\n   + `at={(0.97,0.74)}`指定legend框的*端点*在整个图片横纵坐标的比例位置，即放置在横向97%位置，纵向74%位置。\n\n   + 上面所谓的*端点*又是什么呢？它由anchor决定，表示端点和legend的位置关系。\n     <img src=\"/image-20231231215100509.png\" alt=\"image-20231231215100509\" style=\"zoom:50%;\" />\n\n\n2. 调整图例的字体大小可以通过`font=\\scriptsize`来调整。\n\n3. 介绍一个比较好看的legend表现形式（我们可以观察到python的legend的底框是透明的，可以透出下面的线条），如何在tikz完成呢？\n\n   + 在`{}`中增加以下的代码即可，\n\n     ```\n     fill opacity=0.7,text opacity=1\n     ```\n\n\n   + 这表示legend框的填充透明度为0.7（越高越不透明），文字完全不透明，大家可以适度调整\n\n4. `matlab2tikz`的图例内容来源来源于跟在每条线条画图`\\addplot`后面的`\\addlegendentry{XXX}`，大家想要修改线条的图例名称直接在这里修改即可。这里支持latex的公式语法哦！\n\n\n\n#### 曲线相关\n\n曲线数值的来源`\\addplot`中的table的数值，如果想要修改/增减曲线的点，直接修改`table`数值即可。\n\n曲线相关的美化主要介绍：①线条类型、粗细；②mark大小；③颜色、透明度；④线条的增删\n\n1. 线条类型、粗细：\n   + 线宽由`line width=1.5pt`控制，一般我觉得`1.5pt`-`2.0pt`是比较明显清晰的粗细\n   + 实线类型没什么好说的\n   + 对于虚线由`matlab2tikz`生成的虚线比较奇怪，我们可以将`dashed`修改为`dash pattern=on 6pt off 3pt`，这是我尝试下来比较不错的pattern。\n   + 还有一些其他的pattern可以参考[TiKZ 线条绘制的控制 - LaTeX工作室 (latexstudio.net)](https://www.latexstudio.net/archives/51622.html)\n2. mark大小：这是我觉得`matlab2tikz`控制的比较不好的一点，由它生成的mark不知道为什么大大小小的，大家可以统一为`mark size=3.0pt`或者`4.0pt`左右。\n3. 颜色、透明度：\n   + 曲线和mark的颜色由`color=mycolor1`控制，大家可以自己在画图的顶上定义自己喜欢的颜色\n   + 如果想要让mark有填充，并且存在透明度。可以将\n     + ①原始的`mark`均加上`*`，如`mark=diamond*`、`mark=triangle*`等。注意原来代表mark形状为圆圈的`o`直接改为`*`即可。\n     + ②`mark options={solid, mycolor2}`增加`fill opacity=0.5`，变为`mark options={solid, mycolor2, fill opacity=0.5}`\n4. 线条的删除——直接将该线条对应的`\\addplot`直到`\\addlegendentry`删除\n5. 线条的增加——复制别的线条对应的`\\addplot`直到`\\addlegendentry`，修改对应的颜色、数值等\n\n\n\n\n\n### 一些别的操作实例\n\n#### 新增线条的标注——如水平线条、垂直线条\n\n下面直接通过一个实例来解释——实例内数值均无实际含义\n\n该实例主要包含以下几个操作\n\n+ 描边文字`\\contour{white}{$\\sim$Z.ZZx}`：这样主要可以使得文字可以更加明显的显示\n\n+ 绘制虚线并在线上标注：\n  ````tex\n  \\draw[gray, line width=1.5pt, dashed] (8.5, 200) node[ above] {\\contour{white}{XXXX@10\\%YYYY}}-- (18.2, 200) ;\n  ````\n\n+ 绘制双箭头线并多个标注：\n  ```tex\n  \\draw[red, line width=2pt, <->] (14, 120)node[right]{\\color{mycolor1} $\\sim$AAA~Mbps} -- (14, 200) node[midway, above right, red, font=\\bfseries\\sffamily\\large] {\\contour{white}{$\\sim$Z.ZZx}}\n  ```\n\n  \n\n```tex\n%% 以下代码会用到，请在导言区加入\n% \\usepackage{xcolor}\n% \\usepackage{contour} % 导入 contour 库，实现描边文字\n\n%% document环境内\n\\definecolor{mycolor1}{rgb}{0.00000,0.44700,0.74100}%\n\\definecolor{mycolor2}{rgb}{0.85000,0.32500,0.09800}%\n\\definecolor{mycolor3}{rgb}{0.92900,0.69400,0.12500}%\n\\definecolor{mycolor4}{rgb}{0.49400,0.18400,0.55600}%\n\\definecolor{mycolor5}{rgb}{0.46600,0.67400,0.18800}%\n\\definecolor{mycolor6}{rgb}{0.63529,0.07843,0.18431}%\n%\n\\begin{tikzpicture}[scale=.8]\n\n\\begin{axis}[%\nwidth=4.521in,\nheight=3.566in,\nat={(0.758in,0.481in)},\nscale only axis,\nxmin=7,\nxmax=18.3,\nxtick={ 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18},\nxlabel style={font=\\color{white!15!black}},\nxlabel={SNR (dB)},\nymin=0,\nymax=250,\nylabel style={font=\\color{white!15!black}},\nylabel={CCCCCCC},\naxis background/.style={fill=white},\nxmajorgrids,\nymajorgrids,\nlegend style={at={(0.97,0.03)}, anchor=south east, legend cell align=left, align=left, draw=white!15!black}\n]\n\n\\addplot [color=mycolor1, line width=1.5pt, mark size=3.0pt, mark=triangle*, mark options={solid, mycolor1, fill opacity=0.5}]\n  table[row sep=crcr]{%\n8\t13\\\\\n12\t70\\\\\n16\t160\\\\\n18  200\\\\\n};\n\\addlegendentry{XXX1}\n\\addplot [color=mycolor2, line width=1.5pt, mark size=3.0pt, mark=triangle*, mark options={solid, mycolor2, fill opacity=0.5}]\n  table[row sep=crcr]{%\n8\t40\\\\\n12\t95\\\\\n16\t200\\\\\n18  210\\\\\n};\n\\addlegendentry{XXX2}\n\n% 添加虚线\n\\draw[gray, line width=1.5pt, dashed] (8.5, 200) node[ above] {\\contour{white}{XXXX@10\\%YYYY}}-- (18.2, 200) ;\n\n\\draw[gray, line width=1.5pt, dashed] (16.5, 180) -- (18.2, 180) node[ above left] {\\contour{white}{XXXX@10\\%YYYY}};\n\n% 添加箭头线\n\\draw[red, line width=2pt, <->] (14, 120)node[right]{\\color{mycolor1} $\\sim$AAA~Mbps} -- (14, 200) node[midway, above right, red, font=\\bfseries\\sffamily\\large] {\\contour{white}{$\\sim$Z.ZZx}};\n\\end{axis}\n\\end{tikzpicture}%\n```\n\n<img src=\"/image-20231231224111626.png\" alt=\"image-20231231224111626\" style=\"zoom:50%;\" />\n\n\n\n#### `\\label`和`\\ref`来构造不一般的legend\n\n下面直接通过一个实例来解释——实例内数值均无实际含义\n\n该实例主要包含以下几个操作\n\n+ 使用`\\label`和`\\ref`来构造不一般的legend\n\n```tex\n\\definecolor{mycolor1}{rgb}{0.00000,0.44706,0.74118}%\n\\definecolor{mycolor3}{rgb}{0.85098,0.32549,0.09804}%\n%\n\\begin{tikzpicture}\n\n\\begin{axis}[%\nwidth=3.5in,\nheight=3.1in,\nxmin=1,\nxmax=9.8,\nxlabel style={font=\\color{white!15!black}},\nxlabel={SNR [dB]},\nymin=50,\nymax=130,\nylabel style={font=\\color{white!15!black}},\nylabel={CCCCCCCCCCC},\nevery axis y label/.style={\nat={(ticklabel cs:0.5)},rotate=90,anchor=center,\n},\naxis background/.style={fill=white},\nxmajorgrids,\nymajorgrids,\nxtick={1,2,3,4,5,6,7,8,9},\nextra y ticks={50,60,70,80,90,100,110,120,130},\nextra y tick style={grid=major},\nextra y tick labels={},\nlegend style={at={(0.99,0.01)}, anchor=south east, legend cell align=left, align=left, draw=white!15!black,fill opacity=0.6,text opacity=1,font=\\scriptsize}\n]\n\\addlegendimage{empty legend}\n\\addlegendentry[text depth=]{\\begin{tabular}{lcc}\n         & $EEE=1$  & $EEE=8$\\\\\n        BBB & \\protect\\ref{pgf:bbb_1} & \\ref{pgf:bbb_8}\\\\\n        VVV  & \\protect\\ref{pgf:vvv_1}&\\ref{pgf:vvv_8}\\\\ \n    \\end{tabular}}\n    \n\\addplot [color=mycolor1, dash pattern=on 6pt off 3pt, line width=1.5pt, mark size=3.0pt, mark=diamond*, mark options={solid, mycolor1, fill opacity=0.5}, opacity=0.6]\n  table[row sep=crcr]{%\n1.5\t65\\\\\n4.5\t95\\\\\n7.5\t110\\\\\n};\n\\label{pgf:bbb_1}\n% \\addlegendentry{BBB (1)}\n\n\\addplot [color=mycolor1, line width=1.5pt, mark size=3.0pt, mark=diamond*, mark options={solid, mycolor1, fill opacity=0.5}]\n  table[row sep=crcr]{%\n1.5\t80\\\\\n4.5\t100\\\\\n7.5\t110\\\\\n};\n\\label{pgf:bbb_8}\n% \\addlegendentry{BBB (8)}\n\n\\addplot [color=mycolor3, dash pattern=on 6pt off 3pt, line width=1.5pt, mark size=3.0pt, mark=triangle*, mark options={solid, rotate=180, mycolor3, fill opacity=0.5, fill opacity=0.5}, opacity=0.6]\n  table[row sep=crcr]{%\n3.5\t65\\\\\n6.5\t95\\\\\n9.5\t105\\\\\n};\n\\label{pgf:vvv_1}\n% \\addlegendentry{vvv (1)}\n\n\\addplot [color=mycolor3, line width=1.5pt, mark size=3.0pt, mark=triangle*, mark options={solid, rotate=180, mycolor3, fill opacity=0.5}]\n  table[row sep=crcr]{%\n3.5\t90\\\\\n6.5\t105\\\\\n9.5\t110\\\\\n};\n\\label{pgf:vvv_8}\n% \\addlegendentry{vvv (8)}\n\n\\end{axis}\n\\end{tikzpicture}%\n```\n\n<img src=\"/image-20231231225309545.png\" alt=\"image-20231231225309545\" style=\"zoom:50%;\" />\n\n## 将TikZ绘图保存为PDF\n\n### preview宏包\n\n可以使用`preview`宏包来创建只含有tikz画图的PDF文件\n\n```tex\n\\usepackage[active,pdftex,tightpage]{preview}\n\\PreviewEnvironment{tikzpicture}\n\\setlength{\\PreviewBorder}{0.5bp}\n```\n\n+ 注意`\\setlength{\\PreviewBorder}{0.5bp}`设置的是图片周围白边的宽度为`0.5bp`\n\n生成结果如下\n\n![image-20231231225824094](/image-20231231225824094.png)\n\n大家再采用Adobe Acrobat等工具分开每张图即可。\n\n### 【附】脚本删除所有PDF文件的白边\n\n**例如用于PowerPoint/MATLAB绘图导出的PDF文档**\n\n安装texlive的时候会安装一个脚本`pdfcrop`，定位到需要删除白边的文件夹下在命令行中输入该代码能够将所有的PDF结尾的图片的白边全都去除。\n```\nfor %i in (*.pdf) do pdfcrop %i %i\n```\n\n\n\n---\n\n该博客都是一些自己的探索和方法，如果有错误、缺漏、不足，欢迎在评论区指出！\n\n*［暴论］ChatGPT就是最好的老师！*\n","tags":["论文","MATLAB"],"categories":["LaTeX and ..."]},{"title":"【科研札记】Python和MATLAB的协同使用","url":"/2023/04/05/python-matlab/","content":"\n# Python和MATLAB的协同使用\n\n最近科研中需要联合使用Python和MATLAB，所以写下这篇博客记录一下中间踩坑的历程，也希望能对后续的有相同疑惑的同学有所帮助吧\\~\n\n## 缘起\n\n目前的项目需要搭建一个搭建一个多用户MIMO-OFDM上行链路的系统（当然不只是基本的系统，多的和这个问题没多大关系，就不说了），并且在其中应用AI对其中的部分模块进行深度学习训练，或者对多模块进行联合优化。\n\n我们知道MATLAB中有[5g对应的toolbox](https://ww2.mathworks.cn/products/5g.html)，安装后拥有丰富的库函数实现5gnr链路级仿真的各个功能。（当然我们也尝试过[sionna](https://github.com/NVlabs/sionna)，但是部分模块感觉总有点问题，而且他是用tensorflow写的，有点反人类。）因此，我们非AI的基线使用MATLAB写成。\n\n但我们的项目中需要“深度学习”的加入，而MATLAB对深度学习的支持还不是非常的完善。所以我们选用Pytorch进行部分“黑盒/半黑盒”网络的训练。\n\n**于是，如何将Pytorch中训练好的网络同MATLAB搭建好的系统就是一个大问题！**\n\n下面首先介绍一下“Python和MATLAB协同操作的方式”，接着叙述一下目前采取的方式和其中的坑。\n\n\n\n## 协同方式\n\n首先介绍一下，Python和MATLAB协同操作的方式，主要包含两大类：\n\n+ Matlab应用于Python——即在Python函数中调用MATLAB代码\n+ Python应用于Matlab——即在MATLAB中调用已经训练好的tensorflow/pytorch/onnx\n\n### Matlab应用于Python\n\n#### 两种思路\n\n1. 在python中使用`matlab.engine`，即使用MATLAB Engine API for Python，实际上调用matlab本身。\n2. 将matlab函数单独打包为python库进行安装，即使用MATLAB Compiler SDK，实际上调用matlab runtime。\n\n但是两者存在至关重要的区别\n\n+ MATLAB Engine API for Python 允许使用工作区(workspace)，而 MATLAB Compiler SDK for Python 没有。因此，不能使用 MATLAB  Compiler SDK for Python 调用 MATLAB 类（句柄）\n+ 而我们的代码中存在大量的matlab类，如解码等\n\n因此目前主要考虑使用MATLAB Engine API，其基本使用方法如[文档](https://ww2.mathworks.cn/help/matlab/matlab-engine-for-python.html?s_tid=CRUX_lftnav)所示，matlab R2022a只支持Python 2.7/3.8/3.9。目前已基本测试能够在python中完成目前SIP的非AI系统matlab代码中的模块，且结果正确。后续迁移过程中，只是需要一定的[数据类型转换](https://ww2.mathworks.cn/help/matlab/matlab_external/matlab-arrays-as-python-variables.html)。\n\n目前主要存在的问题是，不论是调用`matlab.engine`还是使用Compiler SDK，在python看来，matlab代码部分类似于一个黑盒，无法实施反向传播，还没有找到很好的解决方式。\n\n#### 两个例子\n\n##### `nrULSCHDecoder_llr`——MATLAB句柄（类）\n\n1. engine API（类里面的function带点的不能用，需要在method中定义新函数以改变内部的property，.m文件需在同一文件夹下）\n\n   ```python\n   import matlab.engine\n   import scipy.io as sio\n   L_emap111 = sio.loadmat('D:/MATLAB_drive/5g_local/Baseline/sip_qpsk_449/nrULSCHDecoder_llr/for_redistribution_files_only/L_Emap.mat')['L_emap111']\n   L_emap111=matlab.double(L_emap111.tolist())\n   \n   eng = matlab.engine.start_matlab()\n   decodeULSCH = eng.nrULSCHDecoder_llr()\n   eng.setTargetCodeRate(decodeULSCH,0.587890625,nargout=0)\n   eng.setLDPCDecodingAlgorithm(decodeULSCH,'Belief propagation',nargout=0)\n   eng.setMaximumLDPCIterationCount(decodeULSCH,40,nargout=0)\n   eng.setTransportBlockLength(decodeULSCH,2976,nargout=0)\n   a = eng.step(decodeULSCH,L_emap111,'QPSK',1,0,nargout=4)\n   print(a[0].size)\n   ```\n\n2. Compiler SDK——不支持\n\n##### `nrEqualizeMMSE_iter`——MATLAB函数\n\n1. engine API\n\n```python\nimport scipy.io as sio\n\nimport matlab.engine\neng = matlab.engine.start_matlab()\n\nh = sio.loadmat('D:/MATLAB_drive/5g_local/Baseline/sip_qpsk_449/puschHest.mat')['h']\nrx4Eq_iter = sio.loadmat('D:/MATLAB_drive/5g_local/Baseline/sip_qpsk_449/rx4Eq_iter.mat')['rx4Eq_iter']\n\nh=matlab.double(h.tolist(), is_complex=True)\nrx4Eq_iter=matlab.double(rx4Eq_iter.tolist(), is_complex=True)\nt =eng.nrEqualizeMMSE_iter(rx4Eq_iter,h,0.0355,nargout=2)\nprint(t[0].size)\nprint(eng.mean(t[0]))\n```\n\n2. Compiler SDK\n\n```python\nimport nrEqualizeMMSE_iter\nimport matlab\nimport scipy.io as sio\n\na = nrEqualizeMMSE_iter.initialize()\nh = sio.loadmat('D:/MATLAB_drive/5g_local/Baseline/sip_qpsk_449/puschHest.mat')['h']\nrx4Eq_iter = sio.loadmat('D:/MATLAB_drive/5g_local/Baseline/sip_qpsk_449/rx4Eq_iter.mat')['rx4Eq_iter']\n\nh=matlab.double(h.tolist(), is_complex=True)\nrx4Eq_iter=matlab.double(rx4Eq_iter.tolist(), is_complex=True)\nt =a.nrEqualizeMMSE_iter(rx4Eq_iter,h,0.0355,nargout=2)\nprint(t[0].size)\n\na.terminate()\n```\n\n### Python应用于Matlab\n\n基本的思路有三种，但各有利弊：\n\n+ Using models created in MATLAB using [Deep Learning Toolbox™](https://www.mathworks.com/products/deep-learning.html)\n+ [Converting](https://www.mathworks.com/help/deeplearning/deep-learning-import-and-export.html) models from other frameworks into MATLAB\n+ Co-executing models from other frameworks with MATLAB\n\n例如matlab也提供了通信中的[CSINet](https://github.com/matlab-deep-learning/CSINet-Channel-Compression-in-MATLAB-Using-Keras)将Tensorflow框架和Matlab框架协同处理的方式，但matlab在其中的功能也仅是生成信道和仿真，matlab并未牵涉到反向传播的问题。\n\n![灰色为keras处理，蓝色为matlab处理](image-20230404204724747.png)\n\n所以将python应用于matlab的方法，实际上和matlab应用于python存在类似的问题。\n\n我也尝试将Pytorch训练好的网络，利用MATLAB r2023a中的库进行迁移，但是中途报错了，那个错误我也看不太懂，5555，所以这条路我们也弃用了！\n\n\n\n## 目前采取的方式和其中的坑\n\n目前采用的方式是利用Python，采用engine api的方式*重写*之前MATLAB整体的系统，并将Pytorch训练好的网络嵌入进该系统中。\n\n——是的，我们还是没法对matlab函数进行反向传播。\n\n——但是不要慌，*重写*不是从头开始，我们只是把大体框架用Python来写，其中复杂的打个包作为matlab函数调用就好了。\n\n\n\n### 安装matlab engine api\n\n1. 按照matlab的要求在你的本地电脑或是服务器上安装“MATLAB”本体，如何在服务器上安装matlab，建议找学长（逃，我也不会，学长搞了好久）。\n\n2. 在对应的python环境中安装matlabengineforpython，具体可以参考[这个](https://ww2.mathworks.cn/help/matlab/matlab_external/python-setup-script-to-install-matlab-engine-api.html)。（其实就相当于给Python安装了一个库），`conda list`后出现这个基本上就是安装好了\n\n   ```shel\n   matlabengineforpython     R2022a                   pypi_0    pypi\n   ```\n\n### 利用engine api方式将matlab主函数改写为python主函数\n\n+ 使用engine api最基础的几个步骤就是：调用库、开启引擎、退出引擎\n  ```python\n  import matlab.engine\n  eng = matlab.engine.start_matlab()\n  eng.quit()\n  ```\n\n+ 那么，我们需要把我们所有调用到的自己写的函数统统都放在主函数同一文件夹下吗？我之前是这么做的，但我问了问全知全能的new bing，他告诉我这样做就可以把函数目录添加到matlab路径中了，果然很好用！\n  ```Python\n  import os\n  folder_path = os.path.join(os.getcwd(), '../matlab_test')\n  eng.addpath(folder_path)\n  eng.rmpath(folder_path)\n  ```\n\n+ 【matlab句柄的改写】建议直接建一个Python类与之相对应\n\n+ 【matlab结构体数组的改写】直接给一个实例吧，*我也忘了当时怎么想的了，反正成功了！*没记错的话，是利用matlab输出数量不确定的函数的方式化解了结构体数组无法从matlab传播给Python的问题。\n\n  + 原始的函数\n    ```matlab\n    function channels = hMultiUserChannels(delayProfile,delaySpread,maximumDopplerShift,bsAntSize,ueAntSizes)\n    \n        % Create empty output structures\n        numUEs = size(ueAntSizes,1);\n        channels = repmat(struct('channel',[],'chInfo',[],'pathFilters',[]),1,numUEs);\n    \n        % Create a CDL channel model object configured with the desired delay\n        % profile, delay spread and Doppler frequency\n        channel = nrCDLChannel;\n        channel.DelayProfile = delayProfile;\n        channel.DelaySpread = delaySpread;\n        channel.MaximumDopplerShift = maximumDopplerShift;\n        channel.CarrierFrequency = 2.6e9;\n        channel.SampleRate = 7680000;\n    \n        % Set the base station antenna array size. Initially, the channel\n        % operates in the UL direction, therefore the transmit antenna array\n        % corresponds to the base station, while the receive antenna array\n        % corresponds to the UE\n        channel.ReceiveAntennaArray.Size = [bsAntSize 1 1];\n    \n        % Configure channel filtering:\n        % * For ChannelFiltering = true, the transmit resource grid will be\n        %   OFDM modulated, filtered by the channel impulse repsonse, and\n        %   OFDM demodulated to produce the receive resource grid\n        % * For ChannelFiltering = false, the channel will be applied to the\n        %   transmit resource grid in the frequency domain to produce the\n        %   receive resource grid\n        % ChannelFiltering = false is faster, at the expense of not modelling\n        % channel variation (and loss of orthogonality) due to Doppler across\n        % the duration of each OFDM symbol\n        channel.ChannelFiltering = false;\n    \n        % Configure a set of azimuth and zenith angle offsets, used to adjust\n        % the angles of departure of the channel for each UE. This simulates\n        % the effect of different UEs being in different locations in the\n        % environment around the base station\n        \n        % Azimuth offsets: assume a 120 degree wide sector, offset values\n        % are spread between (-60,60)\n        offsetsAoD = (rand([1 numUEs])-0.5) * 120;\n    \n        % Elevation offsets: assume a tower height of 30m above the UE and\n        % cell radius of 600m, with UEs between 150m and 600m from the cell\n        % centre\n        range = 150 + (rand([1 numUEs]) * 450);\n        offsetsZoD = atand(30 ./ range);\n    \n        % For each UE\n        for ue = 1:numUEs\n    \n            % Create a copy of the original channel\n            cdl = copyCDL(channel);\n    \n            % Set the UE antenna array size\n            cdl.TransmitAntennaArray.Size = [ueAntSizes(ue,:) 1 1];\n    \n            % Configure the channel seed based on the UE number\n            % (results in independent fading for each UE)\n            cdl.Seed = 73 + (ue - 1);\n    \n            % Configure the azimuth and zenith angle offsets for this UE\n            cdl.AnglesAoD(:) = cdl.AnglesAoD(:) + offsetsAoD(ue);\n            cdl.AnglesZoD(:) = cdl.AnglesZoD(:) + offsetsZoD(ue);\n    \n            % Record the channel object and channel information in the output\n            channels(ue).channel = cdl;\n            channels(ue).chInfo = info(cdl);\n    \n        end\n    \n    end\n    ```\n\n  + 改写后的函数\n\n    matlab中函数改写：\n\n    ```matlab\n    function varargout = hMultiUserChannels_py(delayProfile,delaySpread,maximumDopplerShift,bsAntSize,ueAntSizes,numUEs)\n    \n        % Create empty output structures\n        numUEs = numUEs;\n        channels = repmat(struct('channel',[],'chInfo',[],'pathFilters',[]),1,numUEs);\n        varargout = cell(1, numUEs);\n    \n        % Create a CDL channel model object configured with the desired delay\n        % profile, delay spread and Doppler frequency\n        channel = nrCDLChannel;\n        channel.DelayProfile = delayProfile;\n        channel.DelaySpread = delaySpread;\n        channel.MaximumDopplerShift = maximumDopplerShift;\n        channel.CarrierFrequency = 2.6e9;\n        channel.SampleRate = 7680000;\n    \n        % Set the base station antenna array size. Initially, the channel\n        % operates in the UL direction, therefore the transmit antenna array\n        % corresponds to the base station, while the receive antenna array\n        % corresponds to the UE\n        channel.ReceiveAntennaArray.Size = [bsAntSize 1 1];\n    \n        % Configure channel filtering:\n        % * For ChannelFiltering = true, the transmit resource grid will be\n        %   OFDM modulated, filtered by the channel impulse repsonse, and\n        %   OFDM demodulated to produce the receive resource grid\n        % * For ChannelFiltering = false, the channel will be applied to the\n        %   transmit resource grid in the frequency domain to produce the\n        %   receive resource grid\n        % ChannelFiltering = false is faster, at the expense of not modelling\n        % channel variation (and loss of orthogonality) due to Doppler across\n        % the duration of each OFDM symbol\n        channel.ChannelFiltering = false;\n    \n        % Configure a set of azimuth and zenith angle offsets, used to adjust\n        % the angles of departure of the channel for each UE. This simulates\n        % the effect of different UEs being in different locations in the\n        % environment around the base station\n        \n        % Azimuth offsets: assume a 120 degree wide sector, offset values\n        % are spread between (-60,60)\n        offsetsAoD = (rand([1 numUEs])-0.5) * 120;\n    \n        % Elevation offsets: assume a tower height of 30m above the UE and\n        % cell radius of 600m, with UEs between 150m and 600m from the cell\n        % centre\n        range = 150 + (rand([1 numUEs]) * 450);\n        offsetsZoD = atand(30 ./ range);\n    \n        % For each UE\n        for ue = 1:numUEs\n            varargout{ue} = struct('channel',[],'chInfo',[],'pathFilters',[]);\n    \n            % Create a copy of the original channel\n            cdl = copyCDL(channel);\n    \n            % Set the UE antenna array size\n            cdl.TransmitAntennaArray.Size = [ueAntSizes(ue,:) 1 1];\n    \n            % Configure the channel seed based on the UE number\n            % (results in independent fading for each UE)\n            cdl.Seed = 73 + (ue - 1);\n    \n            % Configure the azimuth and zenith angle offsets for this UE\n            cdl.AnglesAoD(:) = cdl.AnglesAoD(:) + offsetsAoD(ue);\n            cdl.AnglesZoD(:) = cdl.AnglesZoD(:) + offsetsZoD(ue);\n    \n            % Record the channel object and channel information in the output\n            channels(ue).channel = cdl;\n            varargout{ue}.channel = channels(ue).channel;\n            channels(ue).chInfo = info(cdl);\n            varargout{ue}.chInfo = channels(ue).chInfo;\n        end\n    \n    end\n    ```\n\n    Python中调用：\n    ```python\n    simParaChannels = []\n    temp = eng.hMultiUserChannels_py(simPara.delayProfile, simPara.delaySpread, simPara.maximumDopplerShift, matlab.double(simPara.bsAntSize), matlab.double(simPara.ueAntSize),matlab.double(simPara.numUe),nargout=simPara.numUe)\n    for ue in range(simPara.numUe):\n            simParaChannels.append(temp[ue])\n    ```\n\n+ 【函数和句柄类的改写】参考第二部分\n\n+ 【数据的转换】[从 Python 中调用 MATLAB - MATLAB & Simulink - MathWorks 中国](https://ww2.mathworks.cn/help/matlab/matlab-engine-for-python.html)，可以参考下面这几个文档，其实最常用的就是把list转换为matlab数组格式`matlab.double(XXX)`，复数的话记得变成`matlab.double(XXX, is_complex=True)`，如果你之前是numpy格式，那么需要先变成list（r2023a貌似不需要这一步了），即`matlab.double(XXX.tolist(), is_complex=True)`，如果是cuda上torch的tensor的话那就再加一步`XXX.cpu().detach().numpy()`。\n  ![image-20230404212334542](/image-20230404212334542.png)\n\n\n\n### 技巧和坑\n\n+ 【大坑】matlab和Python的行列排列顺序不同，**reshape格外注意！！！**\n+ 【小坑】注意matlab有多个输出时，需要加上l类似`nargout=3`这样的选项。\n+ 【小坑】如果想把python类传给matlab作为matlab句柄类，里面的数据中不能出现numpy格式（r2023a可能没有这个问题了），请在需要回传给matlab的类中使用list存储数据。\n+ 【技巧】一些懒得改写的matlab代码（如自己也搞不清维度的reshape，各种matlab库函数的操作），其实可以自行封装成一个函数，直接调用你封装的函数即可\n+ 【技巧】matlab.double类型数组转化成numpy格式，直接` np.array(XXX, dtype=np.complex64)`\n+ 【技巧】numpy官方提供了matlab入门numpy用法的指南，改写可以参考[NumPy for MATLAB users — NumPy v1.23 Manual](https://numpy.org/doc/1.23/user/numpy-for-matlab-users.html)\n+ 【最大的技巧】**勤问new bing！** 真的很强，甚至可以帮你改写代码！\n\n\n\n> 最后，感谢new bing给我这篇文章的各种帮助！！！\n","tags":["MATLAB"],"categories":["科研向"]},{"title":"【完结】研究生期间笔记整理","url":"/2022/12/05/SEU-note/","content":"\n# 研究生期间笔记整理\n\n研究生的考试也结束啦，完结撒花~~~\n\n> **说明：**\n>\n> 🆕最近更新：**完结**。\n>\n> 1. 戳👉**标题**就好了，这套CSS好像标题有超链接不会变蓝，带有👉标记的都能点。\n> 2. **请勿二改二传！！！**\n> 3. 点击👉右边或者👇下面的菜单栏🗂，可以调出目录，查找你需要的笔记！\n> 4. 如果有链接失效，我也不知道我会不会补链了~也许吧 **注意关注页面顶端📌说明（会给出蓝奏云最新链接）**\n> 5. 有部分记得比较烂的就不放上来了。这个帖子里面的其实都不是笔记，真正的笔记太乱了，我大部分都记在slides上了，这里的大多都是平时或者期末时候的整理，所以还是比较清晰的。\n> 6. 如果有错误欢迎在**评论区**指出，但是我应该不会改了吧。**部分更改见每门课程下的勘误说明。**\n> 7. 笔记链接密码均为 `levitate` 。\n> 8. 本科期间笔记链接：[【完结】大学本科期间笔记整理 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/05/01/XDU-note/)\n\n\n\n\n\n---\n\n### 👉[部分东南信息学院电子课本及习题解答](https://levitate.lanzoub.com/b0dghisqj)\n\n密码: `c7ob`\n\n> 此电子教材仅供学习使用，侵删。\n\n---\n\n## 📡专业课\n\n### [👉现代数字信号处理(1) （秋学期，C类）](https://levitate.lanzoub.com/b0dgv8t0d)\n\n（密码往顶上看）\n\n3学分（C类专业必修课）\n\n任课老师：赵嘉宁\n\n+ 01 经典数字信号处理（一）（离散时间信号与离散时间系统、Z变换及离散时间系统分析、离散时间信号的傅里叶变换）\n+ 02 经典数字信号处理（二）（离散时间系统的相位和结构、正交变换、多速率信号处理）\n+ 03 统计数字信号处理（一）（平稳随机信号、经典功率谱估计、参数模型功率谱估计）\n+ 04 统计数字信号处理（二）（维纳滤波与卡尔曼滤波、自适应滤波器\n\n> 正在更新中…… ~~12月底考试~~ 下学期初考试啦，年后再更新\n>\n> 老版本（无备注）为直接对课件内容结合自己理解整理，新版本（v2或后续版本）根据“复习内容提纲”和课件内容，酌情整理，前半部分内容多于课程内容，包含本科《数字信号处理》等课程内容。\n>\n> 可以参考“本科部分”：\n>\n> + [👉信号与系统](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E5%AD%A6%E6%9C%9F)、[👉数字信号处理](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E7%AC%AC6%E5%AD%A6%E6%9C%9F)：离散时间信号与离散时间系统、Z变换及离散时间系统分析、离散时间信号的傅里叶变换、离散时间系统的相位和结构、多速率信号处理\n> + [👉随机信号分析](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E9%9A%8F%E6%9C%BA%E4%BF%A1%E5%8F%B7%E5%88%86%E6%9E%90%E7%AC%AC5%E5%AD%A6%E6%9C%9F)：平稳随机信号、离散时间信号与离散时间系统\n> + [👉现代图像分析](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E7%8E%B0%E4%BB%A3%E5%9B%BE%E5%83%8F%E5%88%86%E6%9E%90%E7%AC%AC6%E5%AD%A6%E6%9C%9F)：正交变换\n> + [👉保研复习](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0-2)中相关内容。\n\n\n\n### [👉工程矩阵理论（春学期，C类）](https://levitate.lanzoub.com/b0dhkewtg)\n\n（密码往顶上看）\n\n3学分（C类专业必修课）\n\n任课老师：何薇\n\n+ 01 工程矩阵理论笔记\n+ 02 工程矩阵理论（从“定义”出发）的整理\n+ 03 工程矩阵理论（从“题目”出发）的整理\n+ 04 工程矩阵往年题整理\n\n> 正在更新中...\n>\n> 03预计6月17日更新。\n>\n> 均分高的离谱。。。\n\n\n\n### [👉数字通信原理与系统（春学期，C类）](https://levitate.lanzoub.com/b0dhkewvi)\n\n（密码往顶上看）\n\n3学分（C类专业必修课）\n\n任课老师：曾勇(1-4),徐晓莉(5-7),张源(9、11、13-16)\n\n+ 01 《数字通信原理与系统》习题集（有部分小错，修正见02）\n+ 02 数字通信A4纸（第一部分：知识点整理，第二部分：绝大部分布置的习题）\n\n> 正在更新中...\n>\n> 01预计6月9日更新，02预计6月19日更新。\n>\n> **2023春【专硕C类4面A4纸半开卷】期末试题（一定要快点做题，题量很大，结果只需要保留Q函数）：**\n>\n> 一、填空（3分×10）\n>\n> + 写$s(t)=A(t)\\cos(2\\pi f_ct+\\phi(t))$的等效低通\n> + 算Laplace分布(?) $p(x)=\\frac12 e^{-|x|}$的$\\mathrm{Pr}[X>\\delta]$，$\\delta>0$\n> + $\\{-3,-1,1,3\\}$问平均能量？……（还有半问）\n> + 平方环是否需要符号判决结果？低信噪比情况，面向判决的环____（优于/劣于）非面向判决的环\n> + 语音信号采样率8kHz，要用8bit……，用16-PAM，问符号传输速率\n> + 由带通带宽，问Nyquist传输速率\n> + OFDM求传输速率\n> + $E(X_i)=m_i,Var(X_i)=s_i$，$U=X_1+X_2$，问$(E[U])^2/Var[U]=$____\n> + 多径衰落信道散射函数$S(\\tau ; \\lambda)$ 在 $0 \\le \\tau \\le 1$ms和$-100~\\text{Hz} \\le \\lambda \\le 100~\\text{Hz}$非零。 假设散射函数两变量近似均匀. 问慢衰落的条件\n> + $N$发$M$收的MIMO的分集自由度为____\n>\n> 二、简答（3分×10）\n>\n> 1. 随机变量$X$的概率密度函数$p(x)$，定义随机变量$Y=aX+b$，其中$a<1$，则随机变量$Y$的概率密度函数\n> 2. 计算星座图平均传输功率，并说明功率效率哪个高\n>    ![image-20230625163948674](/image-20230625163948674.png)\n> 3. 推导未调制载波$A\\cos(2\\pi f_ct)$的载波相位估计\n> 4. 推导BSC信道容量\n> 5. 给定校验矩阵$\\mathbf H$，求码率、最小码距。给$\\mathbf r$，判断是否为合法码字\n> 6. ISI的成因和消除方法\n> 7. OFDM中IFFT和FFT的作用\n> 8. 如何判断是否是频率选择性、快衰落信道\n> 9. CSI对衰落信道容量的影响\n> 10. 多用户检测的方法和原理\n>\n> 三、计算证明（10分×4）\n>\n> 1. 给定符号$S=\\{-1,1,4\\}$，概率分别为0.2，0.2，0.6，高斯噪声信道$n\\sim\\mathcal N(0,2)$\n>    1. ML判决，求各个判决域，求$S=-1$的差错概率\n>    2. MAP判决，求$S=1$的判决域，求$S=1$的差错概率\n> 2. A discrete memoryless source has an alphabet of size 7, $\\mathscr{X} = \\{x_1, x_2, x_3, x_4, x_5, x_6, x_7\\},$ with corresponding probabilities \\{0.02, 0.11, 0.07, 0.21, 0.15, 0.19, 0.25\\}.\n>    1. 求$\\mathscr X$的熵\n>    2. 构造Huffman code\n>    3. A new source $\\mathscr{Y} = \\{y_1, y_2, y_3\\}$ is obtained by grouping the outputs of the source $\\mathscr{X}$ as $y_1=\\{x_1, x_2, x_3\\}, y_2=\\{x_4, x_5\\}, y_3=\\{x_6, x_7\\}$. 确定 $I(X;Y)$\n>    4. 带宽$W=1$，$SNR=3$，*可以使用信道编码、信源编码，判断每个信道使用能否传输信源至少1 bit？*（记不太清楚了）\n> 3. BPSK信号在衰落信道中传输$r_l(t)=as_l(t)+z(t)$，有$p(a)=0.5\\delta(a-0.1)+0.5\\delta(a-1)$\n>    1. 画匹配滤波器构成的接收机\n>    2. 算$\\mathcal E_b/N_0=10\\text{dB}$的平均比特差错概率。\n> 4. 推导$M\\times M$ 的MIMO信道容量。\n> \n> \n\n---\n\n\n\n## 🔠英语\n\n### [👉学位英语（秋/春学期，A类）](https://levitate.lanzoub.com/b0dgv8tcf)\n\n（密码往顶上看）\n\n4学分2学期（A类公共必修课）\n\n任课老师：姚羚羚（秋+春2-9）、刘东虹（春10-17）\n\n+ 01 ＴＣ（Technical Communication）\n+ 02 ＩＣ（International Conference）\n+ 03 学位英语（秋）课堂题目整理\n+ 04 Academic Writing\n\n> **秋学期说明：**\n>\n> 待整理……~~12月底考试~~ 下学期初考试啦，年后陆续更新\n>\n> 根据“要点说明”整理，2月19-20日发。\n>\n> + 学位英语1期末试题是目前能找到的一部分秋学期期末试题，每年都变化很大\n> + 英语85题中有部分往年题\n>\n> 秋学期（TC+IC）期末试题（具体分值什么的记不清了）\n>\n> + IC（50）：选择(2x10)、判断(1x10)、匹配(5)、翻译(2x5)、排序(5)\n>\n> + TC（50）：选择、判断、写作（20）（好像还有一个题型不记得了）\n>\n> **春学期说明：**\n>\n> 待更新... （预计6月15日初版）\n>\n> 春学期期末试题\n>\n> + 50分基础知识（选择、匹配、填段落（段落是文献综述的介绍）等）\n> + 20分改写（10句句子改写）\n> + 30分写作（给了一张4个国家、4种类型电影的观影人数表，让你用三段式描述结果等）\n\n\n\n---\n\n\n\n## 📰思政类\n\n###  [👉思政类](https://levitate.lanzoub.com/b0dgv8u0j)\n\n（密码往顶上看）\n\n任课老师：黄婷（中特）、顾秋实（自辩）\n\n+ 01 新中特（秋学期，A类，2学分） \n+ 02 自辩（秋学期，B类，1学分）\n\n> 待整理……~~12月底考试~~ 下学期初考试啦，年后陆续更新\n>\n> 根据“复习提纲”整理，但有很多书上找不到的，就根据自己理解整理了。\n>\n> + **自辩2022秋期末试题（每题25分）**\n>\n>   1. 系统自然观、人工自然观、生态自然观地辩证关系\n>   2. 技术发展的动力\n>   3. 多学科交叉和融贯的方法论意义\n>   4. 科学技术的风险有哪些？如何恰当地进行科学技术风险评价与决策？\n>\n> + **新中特2022秋期末试题**\n>\n>   一、简答(2×10)\n>\n>   1. 新发展格局的内涵与意义\n>   2. 如何理解社会主义文化强国建设\n>\n>   二、论述（2×20）\n>\n>   1. 谈谈对“中国特色社会主义是实现中华民族伟大复兴的必由之路”这句话的理解\n>   2. 党的自我革命是中国共产党最鲜明的品格，谈谈理解\n>\n>   三、材料(40)\n>\n>   1. 结合材料，运用习生态文明思想谈谈对双碳战略的重大意义。\n","categories":["课程向"]},{"title":"git基本操作整理与VScode ssh配置远程服务器","url":"/2022/09/17/git-ssh/","content":"\n# git基本操作整理与VScode ssh配置远程服务器\n\n\n\n## git学习\n\n摘自[Git教程 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/896043488029600)\n\n1. 创建版本库\n\n   1. 初始化一个Git仓库，使用`git init`命令。\n   2. 添加文件到Git仓库，分两步：\n      1. 使用命令`git add <file>`，注意，可反复多次使用，添加多个文件；\n      2. 使用命令`git commit -m <message>`，完成。\n\n2. 时光机穿梭\n\n   - 要随时掌握工作区的状态，使用`git status`命令。\n   - 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。\n\n3. 版本回退\n\n   1. `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。\n   2. 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。`git log --pretty=oneline`可以不显示很多行\n   3. 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本。\n\n4. `git add`命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行`git commit`就可以一次性把暂存区的所有修改提交到分支。\n\n5. 每次修改，如果不用`git add`到暂存区，那就不会加入到`commit`中。\n\n6. 撤销修改\n\n   1. 想直接丢弃工作区的修改时：`git restore `让这个文件回到最近一次`git commit`或`git add`时的状态。\n   2. 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，`git restore --staged`可以把暂存区的修改回退到工作区，回到(a)\n   3. 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退](https://www.liaoxuefeng.com/wiki/896043488029600/897013573512192)一节，不过前提是没有推送到远程库。\n\n7. 删除文件\n\n   1. 工作区：直接在文件管理器中把没用的文件删了，或者用`rm`命令删了\n   2. 从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`\n   3. 用版本库里的版本替换工作区的版本，把误删的文件恢复到最新版本，`git restore --staged file`恢复到暂存区，`git restore file`恢复到工作区。\n\n8. 远程仓库——生成SSH\n\n   ```bash\n   $ ssh-keygen -t rsa -C \"youremail@example.com\"\n   ```\n\n   `id_rsa`是私钥，不能泄露出去，`id_rsa.pub`是公钥，可以放心地告诉任何人。\n\n9. 添加远程库\n\n   + 要关联一个远程库，使用命令`git remote add origin git@server-name:path/repo-name.git`；\n   + 关联一个远程库时必须给远程库指定一个名字，`origin`是默认习惯命名；\n   + 关联后，使用命令`git push -u origin master`第一次推送master分支的所有内容；\n   + 此后，每次本地提交后，只要有必要，就可以使用命令`git push origin master`推送最新修改；\n   + 删除远程库（解除了本地和远程的绑定关系），`git remote rm origin`\n\n10. 从远程克隆\n\n    + 要克隆一个仓库，首先必须知道仓库的地址，然后使用`git clone`命令克隆。\n    + Git支持多种协议，包括`https`，但`ssh`协议速度最快。\n\n11. Git鼓励大量使用分支：\n\n    + `HEAD`严格来说不是指向提交，而是指向`master`，`master`才是指向提交的，所以，`HEAD`指向的就是当前分支。\n    + 查看分支：`git branch`\n    + 创建分支：`git branch <name>`\n    + 切换分支：`git checkout <name>`或者`git switch <name>`\n    + 创建+切换分支：`git checkout -b <name>`或者`git switch -c <name>`\n    + 合并某分支到当前分支：`git merge <name>`\n    + 删除分支：`git branch -d <name>`\n\n12. 解决冲突\n\n    + 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。\n    + 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。\n    + 用`git log --graph`命令可以看到分支合并图。（`git log --graph --pretty=oneline --abbrev-commit`）\n    + [git log 后一直出现:(冒号)的原因以及处理方法_mukes的博客-CSDN博客_git 冒号](https://blog.csdn.net/mukes/article/details/116704220)\n\n13. 分支管理策略\n\n    + 合并分支时，加上`--no-ff`参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而`fast forward`合并就看不出来曾经做过合并。\n\n    + 在实际开发中，我们应该按照几个基本原则进行分支管理：\n\n      `master`分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；\n\n      干活都在`dev`分支上，也就是说，`dev`分支是不稳定的，到某个时候，比如1.0版本发布时，再把`dev`分支合并到`master`上，在`master`分支发布1.0版本；\n\n      你和你的小伙伴们每个人都在`dev`分支上干活，每个人都有自己的分支，时不时地往`dev`分支上合并就可以了。\n\n      所以，团队合作的分支看起来就像这样：\n      ![git-br-policy](https://www.liaoxuefeng.com/files/attachments/919023260793600/0)\n\n14. Bug分支——修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；\n\n    + 当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，\n    + 修复后，恢复工作现场\n      + 用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；\n      + 用`git stash pop`，恢复的同时把stash内容也删了\n      + 多次stash，恢复的时候，先用`git stash list`查看，然后恢复指定的stash`git stash apply stash@{0}`\n    + 在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。(先`cherry-pick` 后`stash pop`)\n\n15. Feature分支——开发一个新feature，最好新建一个分支；\n\n    如果要丢弃一个没有被合并过的分支，可以通过`git branch -D <name>`强行删除。\n\n16. 多人协作\n\n    + 查看远程库信息，使用`git remote -v`；\n    + 本地新建的分支如果不推送到远程，对其他人就是不可见的；\n    + 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；\n      1. 首先，可以试图用`git push origin <branch-name>`推送自己的修改；\n      2. 如果推送失败，则因为远程分支比你的本地更新，需要先用`git pull`试图合并；\n      3. 如果合并有冲突，则解决冲突，并在本地提交；\n      4. 没有冲突或者解决掉冲突后，再用`git push origin <branch-name>`推送就能成功！\n    + 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；\n    + 如果`git pull`提示`no tracking information`，建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；\n    + 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。\n\n17. Rebase：[Rebase - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/wiki/896043488029600/1216289527823648)\n\n18. 标签\n\n    - 命令`git tag <tagname>`用于新建一个标签，默认为`HEAD`，也可以指定一个commit id；\n    - 命令`git tag -a <tagname> -m \"blablabla...\"`可以指定标签信息；\n    - 命令`git tag`可以查看所有标签\n    - `git show <tagname>`可以查看标签信息，看到说明文字\n    - 命令`git push origin <tagname>`可以推送一个本地标签；\n    - 命令`git push origin --tags`可以推送全部未推送过的本地标签；\n    - 命令`git tag -d <tagname>`可以删除一个本地标签；\n    - 命令`git push origin :refs/tags/<tagname>`可以删除一个远程标签。\n\n19. github使用\n\n    + 在GitHub上，可以任意Fork开源仓库；\n    + 自己拥有Fork后的仓库的读写权限；\n    + 可以推送pull request给官方仓库来贡献代码。\n\n20. gitee的使用——多个远程库，不同的名字\n\n\n\n## VScode ssh远程配置\n\n摘自renjie_xie学长的教程\n\n准备工作：用**A**表示个人PC或者笔记本电脑，**host**表示服务器，配置过程如下：\n\n1. 在A上安装VScode；\n\n2. 在A上生成SSH keys， 详情见：[SSH生成教程](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/connecting-to-github-with-ssh)；\n\n3. 在A浏览器上登陆*服务器的jupyter lab页面*，输入密码连接上服务器，打开terminal打开ssh配置文件：\n\n   ```bash\n        vi ~/.ssh/authorized_keys\n   ```\n   将个人公钥id_ed25519.pub的内容复制进去，保存退出，这一步骤保证A拥有B的访问权限；[vi/vim的用法(必学)](https://www.runoob.com/linux/linux-vim.html)\n\n4. 在VScode上的remote explorer上新建配置, 主要包括host的ip，对应的端口号，以及私钥文件路径。样例如下，按照自己的情况进行修改：\n\n   ```bash\n   Host lab\n       HostName 10.129.XXX.XXX # host的ip\n       User root\n       Port XXXX # 分配的端口号\n       IdentityFile C:\\Users\\10638\\.ssh\\id_ed25519\n   ```\n   完成这一步后A上的VScode就可以远程访问host的workspace，可以跑代码+运行jupyter notebook。\n\n5. 更近一步地，为了使得host上可以使用代码托管。同意我们需要在host上生成SSH keys，同理将公钥复制到实验室代码托管平台账户设置的ssh相关配置下。\n6. 同理若要在主机A进行开发，则需要把A上的公钥复制到实验室代码托管平台的相关配置下。\n\n","tags":["git","ssh"],"categories":["科研向"]},{"title":"本科期间推文、视频等汇总","url":"/2022/08/24/undergraduate-media-achievements/","content":"\n# 本科期间推文、视频汇总\n\n\n\n## 海棠9号书院（微信公众号）\n\n[![vcUcWR.png](https://s1.ax1x.com/2022/08/23/vcUcWR.png)](https://imgse.com/i/vcUcWR)\n\n+  *2021-07-09*排版：[海棠九号书院提质增效抓牢抓实党史学习教育 (qq.com)](https://mp.weixin.qq.com/s/9K9JhDvnzPqyKerTiZ4PrA)\n+  *2021-06-09*排版：[研究生招考面对面咨询系列活动（一）丨一起筑梦航天，让青春不悔 (qq.com)](https://mp.weixin.qq.com/s/LZoTZmeXWm29mb-P-ZPE0Q)\n+  *2021-05-23*排版：[劳动实践（九）丨小满小满，梳枝理蔓 (qq.com)](https://mp.weixin.qq.com/s/H_4_J9-FTQloJ9cIcqlPBw)\n+  *2021-05-13*排版：[“德显”科创菁英计划丨科研很苦，但坚持很酷 (qq.com)](https://mp.weixin.qq.com/s/iVOTu8thpN4f-424j_ygTA)\n+  *2021-05-04*排版：[学生说·五四特辑丨我的青年偶像 (qq.com)](https://mp.weixin.qq.com/s/fwGa_zgBNLlnVSVVU7CULg)\n+  *2021-05-02*排版：[百日重读百年史丨1961【倒计时60天】 (qq.com)](https://mp.weixin.qq.com/s/Q-SSU8piLzWrPJfjH-6mqA)\n+  *2021-04-25*排版：[历史学者进书院丨党史讲述与影片赏析 (qq.com)](https://mp.weixin.qq.com/s/BSqC9-1y10cqbSr0EcCDcA)\n+ *2021-04-17*排版：[劳动实践（八）丨春意融融巧筑篱，劳动青春正当时 (qq.com)](https://mp.weixin.qq.com/s/-PbvwEqFKgbFIKRXxA8tvA)\n+  *2021-04-08*排版：[简历设计制作大赛，助力职业发展第一步 (qq.com)](https://mp.weixin.qq.com/s/zXBoVeZi11R9ACYRVlcPAg)\n+  *2021-04-04*排版：[致敬英雄 | 为了我们的春天， 他们作别了这个繁丽的世界 (qq.com)](https://mp.weixin.qq.com/s/1UXVdxJxHbKTr2s65SvQ4Q)\n+  *2021-01-12*排版：[以往不谏，来者可追 | 致敬这奋斗的一年 (qq.com)](https://mp.weixin.qq.com/s/vALwa-3eakCeOYkkLC4stw)\n+ *2021-01-02*排版：[陕西省十佳辅导员｜王朱丹：助浪奔涌 聚光成芒 (qq.com)](https://mp.weixin.qq.com/s/s6djNPEg-WNRMuEAsFRuBg)\n+ 【转载于[西电导航](https://mp.weixin.qq.com/s/W4Ii6qusxy-nX69T412hqQ)】*2020-12-16*排版：[海棠9号书院2019-2020学年总评表彰仪式暨“我与书院共成长”青春楷模分享会顺利举行 (qq.com)](https://mp.weixin.qq.com/s/ECxBe9u7cEhiZo5573UR7Q)\n+ *2020-12-05*排版：[德显讲坛|开坛之讲—梁昌洪教授《二十一世纪的太阳》 (qq.com)](https://mp.weixin.qq.com/s/1jOnT90MX57MtaQPvK7fjQ)\n+  *2020-11-25*排版+插图：[“德显”科创菁英计划|海棠9号书院开展导师课题立项答辩 (qq.com)](https://mp.weixin.qq.com/s/WaYSapqqvoP-j5IW-JxF2w)\n+ *2020-11-22*排版：[德显筑芯程——“漫道”讲堂（十七）丨可触及的模拟集成电路 (qq.com)](https://mp.weixin.qq.com/s/SXq877W6TwLmLD8Havmd0g)\n+ *2020-11-14*排版：[赛事速递|“书院杯”篮球赛9号书院拿下首场比赛胜利！ (qq.com)](https://mp.weixin.qq.com/s/d6rnXHqNTS9JB3CDuBwWaQ)\n+  *2020-11-09*排版+插图：[四肢发达的同学，头脑也不简单！ | 新鲜出炉的海棠9号书院体测分析报告 (qq.com)](https://mp.weixin.qq.com/s/0uW782h9R2xsgtrXQp-AHQ)\n+ *2020-10-31*排版：[德显筑芯程—“漫道”讲堂(十二)|柔性电子材料、器件及应用 (qq.com)](https://mp.weixin.qq.com/s/4aVuzLVD1S1iN3HKH6HBKw)\n+ *2020-10-18*排版：[“书香润心灵，阅读促德行”|书院阅读打卡活动 (qq.com)](https://mp.weixin.qq.com/s/3twQ2sRs5yqRDgK5_CmVxw)\n+  *2020-09-07*插图+排版：[9号书院运动队第四学期作业奉上 (qq.com)](https://mp.weixin.qq.com/s/bKTFcn_Fqte5uk4kOXb2Ww)\n+ 【转载于[西电导航](https://mp.weixin.qq.com/s/dze9TWFoImP0EmCybNS8sg)】*2020-04-30*文案+排版：[从“草台班子”到美赛O奖—这支数模队有、东西！ (qq.com)](https://mp.weixin.qq.com/s/1kONvLjsYw_n9RBe0uU8Cg)\n+  *2020-04-29*排版：[求真路上再出发，青春奋斗正当时｜海棠9号书院团工委2019-2020共青团年度工作总结 (qq.com)](https://mp.weixin.qq.com/s/X1vL0o2rOp6T4e5sjw6oqQ)\n+ *2020-04-21*文案+排版：[重磅福利|你的下一个电子学习工具，应该选谁？ (qq.com)](https://mp.weixin.qq.com/s/VnjBRY24mZVvfILT8OQH4A)\n+ *2020-04-10*排版（公众号公式排版）：[书院小课堂 | 电磁场与电磁波例题 (qq.com)](https://mp.weixin.qq.com/s/mAFWPFsGrWyElko3L4vfjA)\n+ *2020-04-09*排版（公众号公式排版）：[书院小课堂 | 模拟电子技术基础例题 (qq.com)](https://mp.weixin.qq.com/s/Huf5XjPxiea7rtQNShJWoA)\n+ 【转载于[西电导航](https://mp.weixin.qq.com/s/ypMbshAoi4lbv-yXXb4P2A)】*2020-03-25*排版：[“得遇良师，何其幸哉”——致敬疫情中的硬核导师们！ (qq.com)](https://mp.weixin.qq.com/s/dDe5CpycvnVOGatrOSe8eQ)\n+ *2020-03-12*排版：[新学期福利 | 9号书院“小课堂”继续推进！ (qq.com)](https://mp.weixin.qq.com/s/jDOIxY7-G6HJO5sI8UPR1g)\n+ 【转载于[西安电子科技大学](https://mp.weixin.qq.com/s/s3OFD11WsuBt32aHokqHMw\n  )】 *2020-03-03*排版：[请母校放心！在鄂学子回信母校：我会平安，期待与您重逢！ (qq.com)](https://mp.weixin.qq.com/s/SNTEG59DbsdV2GIIs0u6Mw)\n+ *2020-02-12*文案+排版+插图：[暖心巨制|9号书院学生版《武汉加油！》.mp4 (qq.com)](https://mp.weixin.qq.com/s/RK5ta_6zYrcO5RM9rKqQyw)\n+ *2020-02-09*排版：[战“疫”锐文|李文亮医生事件群体情绪爆发后的思考 (qq.com)](https://mp.weixin.qq.com/s/3_1JH2F06YNA2NtuynzwcA)\n+ *2020-01-26*排版：[今年春节，“罩young”幸福 (qq.com)](https://mp.weixin.qq.com/s/FkAYvj-H32rthK2nVXM5iw)\n+  *2019-12-11*排版：[当世上的水仍是氢二氧一，你该认识她~ 游霏(qq.com)](https://mp.weixin.qq.com/s/U-3eqQ93kdcC-DCb0N-4bw)\n+  *2019-11-30*排版：[年度盛典|“我与书院共成长”故事分享会暨表彰仪式 (qq.com)](https://mp.weixin.qq.com/s/xNCpNFcnfk-I5UW9zBFV4Q)\n+ *2019-11-11*排版：[西电潇洒的人是这样生活的…… (qq.com)](https://mp.weixin.qq.com/s/DjjKiEmT1d116GKStp9wjA)\n+ *2019-10-09*排版：[书院集结号 | 海棠9号书院举办第四期教授午餐会 (qq.com)](https://mp.weixin.qq.com/s/PGhCpMp-d0a_UYw3VJYNXA)\n+ *2019-05-13*文案+排版：[“飞翔的海豚”背后的西电故事 (qq.com)](https://mp.weixin.qq.com/s/CQSN4ZcVnTSp7Qx3aDJ19w)\n+ *2019-04-24*排版：[海棠9号书院组织“专业+思政”主题周点名活动 (qq.com)](https://mp.weixin.qq.com/s/kjDeJJ7Qft2kS0YP9t5lEg)\n+ *2019-04-12*排版：[学习发展 | 海棠9号书院小课堂正式成立啦！ (qq.com)](https://mp.weixin.qq.com/s/jPjFpqTtHe67f4jcW1iWPA)\n+ *2018-11-20*排版：[石光明教授做客“教授午餐会” 与学生畅谈大学生活 (qq.com)](https://mp.weixin.qq.com/s/4-K847k1xG64NpBom8pCOg)\n+ *2018-11-13*排版：[升旗仪式 | 海棠9号书院向全体同学发出倡议 (qq.com)](https://mp.weixin.qq.com/s/DziQF4XI8lyPODnGXYSg8g)\n+ *2018-10-31*排版：[心理健康 | 海棠9号书院开展 “心手相牵”心理健康知识培训会 (qq.com)](https://mp.weixin.qq.com/s/e-UlwplSOE3eW1TQFQC23g)\n+ *2018-10-25*排版：[有“9”有故事 | 范益钰：青春正当时，不予负流年 (qq.com)](https://mp.weixin.qq.com/s/gAiMJON3PP83pxRo8Hhtvw)\n\n\n\n## 西电MSC（微信公众号）\n\n+ *2020-04-15*排版：[西电MSC | 数学建模竞赛答疑交流会 (qq.com)](https://mp.weixin.qq.com/s/yyeoMW7KrNUn5isvMKrRfA)\n+ *2019-11-15*排版：[西电MSC | 微软“创新杯”外场&宣讲 (qq.com)](https://mp.weixin.qq.com/s/9mVjlH15UQS56vsBD-MOow)\n+ *2019-11-04*排版：[西电MSC | 美食城，12周岁快乐！ (qq.com)](https://mp.weixin.qq.com/s/6nltl1zpYLh7d_oUaoZvFQ)\n+ *2019-08-08*排版：[西电 MSC | 招新第二弹 ~ 技术部 (qq.com)](https://mp.weixin.qq.com/s/NpHma855MhrthJW8uKHOug)\n+ *2019-07-31*排版：[西电 MSC | 招新第一弹 ~ 总体介绍 (qq.com)](https://mp.weixin.qq.com/s/3IBmSUouDLw4OJ3TwVgJLw)\n+ *2019-07-25*文案+排版：[西电MSC的上海微软之旅 (qq.com)](https://mp.weixin.qq.com/s/1IqufIrb4rPXylYLmu8bEQ)\n+ *2019-07-24*文案+摄影+排版：[Day 3：商汤科技 (qq.com)](https://mp.weixin.qq.com/s/BGnSkLNScrYKARZM8ddtsA)\n+ *2019-07-02*排版：[西电MSC | 换届大会预告 (qq.com)](https://mp.weixin.qq.com/s/P5mBr0S-ZnYsH-SAFZKugg)\n+ *2019-05-21*文案+排版：[2019青华园烧烤之旅 (qq.com)](https://mp.weixin.qq.com/s/Dd_ewOjAqazxqZrfpACWrg)\n+ *2019-04-22*文案：[Hackathon实况第二弹！获奖名单公布！ (qq.com)](https://mp.weixin.qq.com/s/hWIaZzLNXGNSch1RbYYJjA)\n+ *2019-04-20*文案：[Hackathon实况第一弹！！！ (qq.com)](https://mp.weixin.qq.com/s/UyNFYKfmGjr-TSCkNF9PpA)\n+  *2018-12-23*文案：[2018 | MSC 第五次技术沙龙回顾 (qq.com)](https://mp.weixin.qq.com/s/pS8v9LyI21QdzWuqmnmvzw)\n+  *2018-11-27*排版：[西电MSC | 第三次技术沙龙回顾 (qq.com)](https://mp.weixin.qq.com/s/GknN3OJnwXLxCFc1ds3myQ)\n+  *2018-10-18*文案：[西电MSC | 第一次技术沙龙回顾 (qq.com)](https://mp.weixin.qq.com/s/xtPlfOiTj9nf15JQ2BedbA)\n+ *2018-09-29*排版：[西电MSC | 见面会回顾 (qq.com)](https://mp.weixin.qq.com/s/J-Z89EoeVeC5xUdQIylOsA)\n\n> 可能不全，有的当时没署名\n\n\n\n## 对策府库（微信公众号）\n\n+ *2022-07-27*文案+排版+视频：[Levitate_的电子信息工程路径与笔记整理 (qq.com)](https://mp.weixin.qq.com/s/EoiI6ovyxPvDLz5GSllyCw)\n\n\n\n## 西电微软学生俱乐部（bilibili）\n\n[![vcU6Y9.png](https://s1.ax1x.com/2022/08/23/vcU6Y9.png)](https://imgse.com/i/vcU6Y9)\n\n### 2020-06-07 【西电MSC】数模美赛论文插图制作\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe  src=\"//player.bilibili.com/player.html?aid=455962029&bvid=BV1c5411W7U9&cid=199388439&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n<style>\n/* 这个规则规定了iframe父元素容器的尺寸，我们要去它的宽高比应该是 25:14 */\n.aspect-ratio {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56%; /* 高度应该是宽度的56% */\n}/* 设定iframe的宽度和高度，让iframe占满整个父元素容器 */\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n</style>\n\n\n### 2020-08-04 【西电MSC】2020年西电微软学生俱乐部招新宣传介绍\n<div class=\"aspect-ratio\">\n<iframe src=\"//player.bilibili.com/player.html?aid=414015342&bvid=BV1cV411z7Mc&cid=220302367&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n### 2020-11-28 【西电MSC】2020第三次技术沙龙（后半段）\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe src=\"//player.bilibili.com/player.html?aid=287888519&bvid=BV1Ef4y1v78w&cid=260505635&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n### 2021-01-19 【西电数模】2021年数模美赛分享讲座-学生团队专场\n<div class=\"aspect-ratio\">\n    \t\t<iframe src=\"//player.bilibili.com/player.html?aid=586180905&bvid=BV1Xz4y1U78b&cid=284684020&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n\n## 聊聊西电“电子信息工程”（bilibili）\n\n\n### （一）总体路径、数理基础、计算机基础\n\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe  src=\"//player.bilibili.com/player.html?aid=770736853&bvid=BV1Nr4y1E7eS&cid=767637565&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n\n### （二）电路与电子学、电磁场与微波\n\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe src=\"//player.bilibili.com/player.html?aid=728355633&bvid=BV15S4y1J7wz&cid=768510868&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n\n### （三）信号、综合系统\n\n<div class=\"aspect-ratio\">\n<iframe src=\"//player.bilibili.com/player.html?aid=600865274&bvid=BV1zB4y1h72o&cid=769494719&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n<style>\n/* 这个规则规定了iframe父元素容器的尺寸，我们要去它的宽高比应该是 25:14 */\n.aspect-ratio {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56%; /* 高度应该是宽度的56% */\n}/* 设定iframe的宽度和高度，让iframe占满整个父元素容器 */\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n</style>\n","categories":["总结"]},{"title":"【讲座笔记】Massive MIMO无线通信理论与应用","url":"/2022/07/28/mimo-lecture-01/","content":"\n# 【讲座笔记】Massive MIMO无线通信理论与应用\n\n> MIMO无线通信理论与应用暑期学校\n> \n> 2022年7月27日　清华大学电子工程系　戴凌龙\n\n移动通信的核心指标：**通信速率**每一代提高10倍\n\n\n\n## MIMO基础\n\n### 信道容量\n\n$$\nC=B\\log_2(1+SNR)\n$$\n\n+ 低信噪比时，$1$起主要作用，$C\\approx SNR/\\ln 2$，信道容量随信噪比线性增长\n\n+ 高信噪比时，$SNR$起主要作用，$C\\approx\\log_2(SNR)$，信噪比每增加3dB，$C$增加1 bit。\n\n+ 信噪比要求过高，单入单出难以进一步提高系统容量。\n\n### 多天线技术（MIMO）\n\n+ 代：\n  \n  + 4G：6\\~8天线\n  \n  + 5G：大规模MIMO\n  \n  + 6G：超大规模MIMO\n\n+ 信息论角度：**对称**增加基站天线数、用户数，可成倍增加通信速率\n  \n  $$\n  C=\\min(M,K)B\\log_2(1+SNR)\n  $$\n  \n  其中，$M$为基站天线数，$K$为用户数\n\n+ 主要特征：\n  \n  + 提供**空间分集**：增加天线数量，降低错误概率（SIMO：接收分集，MISO：发射分集）\n  \n  + 提供**空间复用**：提供自由度，提供了$\\min(M,K)$个并行信道，在高信噪比下有效。\n\n### MIMO信道描述与容量\n\n$$\n\\mathbf{y}_{N_r}(k)=\\mathbf{H}_{N_r\\times N_t}(k) \\mathbf{x}_{N_t}(k)+\\mathbf{n}_{N_r}(k)\n$$\n\n其中，$\\mathbf{n}$是接收机噪声，非信道噪声。$N_0=nB=噪声功率谱密度\\times 带宽$。\n\n+ 奇异值分解：\n  \n  $$\n  \\mathbf{H}_{N_r\\times N_t}=\\mathbf{U}_{N_r\\times N_r}\\mathbf{\\Lambda}_{N_r\\times N_t} \\mathbf{V}_{N_t\\times N_t}\n  $$\n\n  + 预编码（Precoding）：$\\tilde{\\mathbf{x}}_{N_t}(k) =\\mathbf{V}_{N_t\\times N_t}^H\\mathbf{x}_{N_t}(k)$。\n  \n  + Combining：$\\tilde{\\mathbf{y}}_{N_r}(k) =\\mathbf{U}_{N_r\\times N_r}^H\\mathbf{y}_{N_r}(k)$.\n  \n  + $N$ 个独立信道：$\\tilde{y}_i(k)=\\lambda_i \\tilde{x}_i(k) + \\tilde{n}_i(k)$，并行信道数量 $N$ 不大于 $\\min(N_t,N_r)$.\n  \n+ 不考虑公平性的信道容量——总发射功率一定约束下，分配$P_i$使下式最大：\n  \n  $$\n  C=\\sum_{i=1}^{N}\\log_2\\left(1+\\frac{P_i\\lambda_i^2}{N_0}\\right)\n  $$\n  \n  注水法（信噪比越低分配愈多的功率）：$P_i=\\left(\\mu-\\frac{N_0}{\\lambda_i^2}\\right)^+$ ， $\\lambda_i$是第i个独立信道的奇异值\n\n### MIMO信道检测\n\n+ ZF接收机：$\\mathbf{y}$乘上$\\mathbf{H}^{\\dagger}$，$\\hat{\\mathbf{x}}=\\mathbf{H}^\\dagger\\mathbf{y}$\n  \n  + 低信噪比，噪声放大\n  \n  + 无偏估计\n\n+ MMSE接收机：考虑噪声影响，$\\hat{\\mathbf{x}}_{MMSE}=\\mathbf{Ay}=\\mathbf{H}^H(\\mathbf{HH}^H+\\sigma^2\\mathbf{I})^{-1}\\mathbf{y}$\n  \n  + 更好的信噪比性能\n  \n  + 有偏估计\n\n+ 高信噪比下$\\sigma^2\\to 0$，ZF和MMSE性能差不多\n\n+ 线性检测 劣于 非线性检测（最大似然）\n\n### Alamouti空时编码\n\n+ 发射端多天线，提供空间分集增益\n\n+ 原理：连续两个时间周期里分别从两个发射天线发射\n  \n  $$\n  \t\\begin{array}{lllll}\n\t\t[T_1] & Tx1: & x_1  & Tx2: & x_2\\\\ \n\t\t[T_2] & Tx1: & -x_2^* & Tx2: & x_1^*\n  \t\\end{array}\n  $$\n\n+ 编码矩阵： $X=\\begin{bmatrix}x_1 & -x_2^*\\\\ x_2 & x_1^*\\end{bmatrix}$ ，具有**正交性**\n\n+ 译码：\n  \n  $$\n    \\left\\{\n    \t\\begin{array}{l} \n    \t\ty_1= h_1x_1+h_2x_2+\\eta_1\\\\ \n\t\t\ty_2=-h_1x_2^*+h_2x_1^*+\\eta_2\n    \\end{array}\\right.\n    \\Rightarrow \n\t  \\left\\{ \n    \t\\begin{array}{l} \n    \t\t\\hat{x}_1 只含 x_1 \\\\ \n\t\t\t\\hat{x}_2 只含 x_2\n    \t\\end{array}\n    \\right.\n  $$\n\n+ 分集增益（ $|h_1|^2+|h_2|^2$ ）\n\n+ 接收端SNR：降低一半噪声，噪声方差减小。\n  \n  $$\n  SNR_d=\\frac{|h_1|^2+|h_2|^2}{2}\\frac{E_s}{N_0}\n  $$\n\n## 4G技术——MIMO\n\n+ LTE：R.11前4G，R.12后B4G\n  \n  + R.8/9：下行OFDMA、多天线技术\n  \n  + R.10/11：最多8路复用数据，增强多用户MIMO\n\n+ 开环/闭环MIMO：\n  \n  + 开环MIMO：预编码矩阵**确定**，与信道状态无关\n  \n  + 闭环MIMO：预编码矩阵与信道状态有关（LTE/LTE-A）\n    \n    + 显式反馈——大量反馈开销\n    \n    + 隐式反馈——码本-（码本集合索引PMI）>性能损失（LTE/LTE-A）\n\n+ 接收机：\n  \n  + MMSE接收机\n  \n  + 联合最大似然接收机（复杂度指数上升）\n\n+ 多用户MIMO：R.9 最多4路数据流，4个用户\n\n## 5G技术——大规模MIMO\n\n+ 增加$M,K$可以提高频谱效率\n  \n  + 分集增益$MK$：误码率（可靠性指标）$p_e\\sim SNR^{-MK}$\n  \n  + 复用增益$\\min(M,K)$：可达和速率（空分复用）$C=\\min(M,K)B\\log_2(1+SNR)$\n\n### 大规模MIMO模型\n\n$$\n\\mathbf{y}=\\sqrt{p}\\mathbf{H}\\mathbf{x}+\\mathbf{n}\n$$\n\n+ 信道模型：大尺度衰落、小尺度衰落\n\n+ ”大规模“：量变->质变——随机矩阵理论\n  \n  $$\n  \\left\\{\n    \\begin{array}{l} \n      \\displaystyle \\lim_{M\\to\\infty,\\ i\\neq j} \\frac1M h_i^Hh_j=0\\\\ \n        \\displaystyle \\lim_{M\\to \\infty} \\frac1Mh_i^Hh_i=\\sigma^2\n    \\end{array}\\right.\n  $$\n  \n  + 多用户信道渐近正交\n  \n  + 随机信道硬化（特征值逐渐固定）\n\n\n\n### 理想传输条件\n\n大规模MIMO中，信道小尺度衰落因随机信道硬化消失，有$\\frac{\\mathbf{G}^H\\mathbf{G}}{M}=\\mathbf{D}$(对角阵)。\n$$\nR=\\sum_{k=1}^K\\log_2(1+P\\lambda_k^2)\n$$\n其中，总能量固定($\\sum_{k=1}^K\\lambda_k^2=MK$)，理想传输条件$\\mathbf{H}^H\\mathbf{H}=M\\mathbf{I}$。\n\n速率上限：\n$$\nR=K\\log_2(1+MP)\n$$\n\n\n### 技术挑战Ⅰ：信号检测\n\n信号检测：已知$\\mathbf{H}$，由$\\mathbf{y}$求$\\mathbf{x}$。\n\n多用户信号检测模型：多用户叠加、干扰，需要区分\n$$\n\\mathbf{y}_{N\\times 1}=h_1x_1+h_2x_2+\\cdots+h_kx_k+\\mathbf{n}=\\mathbf{H}_{N\\times K}\\mathbf{x}_{K\\times 1}+\\mathbf{n}_{N\\times 1}\n$$\n经典算法：\n\n+ 最大似然检测\n  + 方法：穷搜全部可行解（星座点），找最相似的，即为最优\n  + 代价：指数复杂度，支持的$K$很小，存在瓶颈\n+ 迫零检测（立方复杂度，比最大似然检测好）\n  + 方法：$\\hat{\\mathbf{x}}=\\mathbf{H}^\\dagger\\mathbf{y}=\\mathbf{x}+(\\mathbf{H}^H\\mathbf{H})^{-1}\\mathbf{H}^H\\mathbf{n}$，$(\\mathbf{H}^H\\mathbf{H})^{-1}\\mathbf{H}^H\\mathbf{n}$为等效噪声\n  + 代价：低信噪比，放大噪声性能损失严重\n+ 最大似然检测的性能+迫零检测的速度——**非对称**增加$M,K$\n  + 大幅度提升**基站天线数**（$K$不变，只增大$M$）\n  + 超定方程容易求解=>观测越多，越容易区分不同用户的信号（$\\mathbf{H}$各列干扰小）=>只大幅增加$M$，信道干扰$\\to 0$\n  + 此时，迫零检测具有准最优性能（噪声放大=>噪声不变）\n  + ![image-20220728150713391](/image-20220728150713391.png)\n+ 只增大$M$（非对称思想）=>低复杂度ZF可用=>用户数增大（$M,K$同比例增大）\n\n\n\n### 技术挑战Ⅱ：信道估计\n\n导频开销过高\n$$\n\\mathbf{y}_{P\\times 1}=\\mathbf{C}_{P\\times M}\\mathbf{h}_{M\\times 1}+\\mathbf{n}_{P\\times 1}\n$$\n\n+ 最小二乘法：已知$\\mathbf{y}_{P\\times 1},\\mathbf{C}_{P\\times M}$估计$\\mathbf{h}_{M\\times 1}$，要求方程个数/导频组数$P\\geq$未知数个数/天线数$M$\n\n+ 压缩感知：\n  $$\n  \\mathbf{y}_{P\\times 1}=\\mathbf{A}_{P\\times M}\\mathbf{s}_{M\\times 1}\n  $$\n  天线域信道非稀疏=($\\mathcal{F}$)=>空间域系统稀疏，令$\\mathbf{A}_{P\\times M}=\\mathbf{C}_{P\\times M}\\mathbf{F}_{M\\times M}$，$\\mathbf{s}$稀疏，使得$P<M$可行。\n\n  信道估计问题=>压缩感知问题\n\n  \n\n\n\n### 技术挑战Ⅲ：上行信道反馈\n\n采用隐式反馈，利用”码本“的方式。\n\n+ 反馈位数$B$与发射天线数$M$成正比，反馈码本尺寸随$M$指数增加，存不下！\n+ 基于角度域稀疏性的信道反馈方式$\\mathbf{H}_b=\\mathbf{U}_R^H\\mathbf{H}\\mathbf{U}_T$\n  + 用户反馈低维观测向量$\\mathbf{y}$到基站\n  + 基站利用压缩感知恢复高维信道矩阵$\\hat{\\mathbf{s}}$\n\n\n\n\n\n### 毫米波大规模MIMO\n\n+ 全数字预编码（大量射频链路）\n+ 模数混合预编码（RF chains 不低于自由度）\n\n\n\n\n\n## 6G技术——超大规模MIMO\n\n+ 代\n\n  + 4G：2-8天线\n  + 5G：128天线\n  + 6G：1024+天线（有源天线阵列、智能超表面RIS）\n\n+ 超大规模MIMO的“质变”——近场宽带效应\n\n  + **远场**假设（平面波）可能不成立，用户可能分布在**近场**（球面波），区分点瑞利距离$\\frac{2D^2}{\\lambda}$\n  + 严重的波束分裂，**窄带**假设可能不成立，变为**宽带**\n\n+ 近场宽带效应的解决\n\n  + 近场信道的分区远场近似（解耦）\n\n  + 相移产生窄带平面波，匹配远场相位\n\n    时延逼近宽带球面波，补偿近场相位\n\n  + 有效Rayleigh条件——波束赋形分集增益定义\n\n    经典Rayleigh条件——最大相位误差定义\n\n\n\n\n\n![image-20220728153313927](/image-20220728153313927.png)\n","tags":["无线通信","MIMO"],"categories":["课程向"]},{"title":"【总结】聊聊“电子信息工程”","url":"/2022/07/08/EE-map/","content":"\n# 聊聊“电子信息工程”\n\n本科毕业啦，有一件一直想做但没能做的事情——梳理一下本科课程的路径图。想想毕业了就更不可能做了，再不做就来不及了，所以就有了这篇博客。\n\n![map](https://s1.ax1x.com/2022/07/03/jGmYV0.png)\n\n\n\n## 正经视频——专业方向介绍、课程介绍\n\n视频内容slides链接：https://levitate-qian.github.io/2022/07/08/EE-map/ee_map_slides.pdf （思源字体的转换有问题，所以现在转出来的不是矢量字体，凑合看吧。）\n\nPDF版本：\n<object data=\"ee_map_slides.pdf\" type=\"application/pdf\" width=\"100%\" height=\"500px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"ee_map_slides.pdf\">Download PDF</a>.</p></object>\n\nSlides版本（可能需要一些科学手段）：\n<div class=\"aspect-ratio\">\n<iframe src=\"https://onedrive.live.com/embed?cid=A34AA48C6847224D&amp;resid=A34AA48C6847224D%2161771&amp;authkey=AD_7cRm_bLH3OiE&amp;em=2&amp;wdAr=1.7777777777777777\"  frameborder=\"0\">\n这是嵌入 <a target=\"_blank\" href=\"https://office.com\">Microsoft Office</a> 演示文稿，由 <a target=\"_blank\" href=\"https://office.com/webapps\">Office</a> 提供支持。</iframe>\n</div>\n\n### （一）总体路径、数理基础、计算机基础\n\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe  src=\"//player.bilibili.com/player.html?aid=770736853&bvid=BV1Nr4y1E7eS&cid=767637565&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n### （二）电路与电子学、电磁场与微波\n\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe src=\"//player.bilibili.com/player.html?aid=728355633&bvid=BV15S4y1J7wz&cid=768510868&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n### （三）信号、综合系统\n\n<div class=\"aspect-ratio\">\n<iframe src=\"//player.bilibili.com/player.html?aid=600865274&bvid=BV1zB4y1h72o&cid=769494719&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n<style>\n/* 这个规则规定了iframe父元素容器的尺寸，我们要去它的宽高比应该是 25:14 */\n.aspect-ratio {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56%; /* 高度应该是宽度的56% */\n}/* 设定iframe的宽度和高度，让iframe占满整个父元素容器 */\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n</style>\n\n## 笔记整理\n\n[【完结】大学期间笔记整理 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/05/01/XDU-note/)\n\n[【对策府库版本】Levitate_的电子信息工程路径与笔记整理（微信公众号：对策府库）](https://mp.weixin.qq.com/s/EoiI6ovyxPvDLz5GSllyCw)\n\n\n\n## 整活部分——普通电子带专毕业生综合能力考试\n\n> 7月10日晚发“参考答案与解析”\n>\n> 试题及答案有更新，请下载最新版本哦\n\n### 试题\n\n试题链接：https://levitate-qian.github.io/2022/07/08/EE-map/ee_exam_paper.pdf\n\n<object data=\"ee_exam_paper.pdf\" type=\"application/pdf\" width=\"100%\" height=\"900px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"ee_exam_paper.pdf\">Download PDF</a>.</p></object>\n\n\n### 答题卡\n\n答题卡链接：https://levitate-qian.github.io/2022/07/08/EE-map/ee_exam_card.pdf\n\n<object data=\"ee_exam_card.pdf\" type=\"application/pdf\" width=\"100%\" height=\"400px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"ee_exam_card.pdf\">Download PDF</a>.</p></object>\n\n\n### 简明参考答案\n\n简明参考答案链接：https://levitate-qian.github.io/2022/07/08/EE-map/ee_exam_ans_brief.pdf\n\n<object data=\"ee_exam_ans_brief.pdf\" type=\"application/pdf\" width=\"100%\" height=\"900px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"ee_exam_ans_brief.pdf\">Download PDF</a>.</p></object>\n\n\n### 参考答案与解析、评分标准\n\n参考答案与解析链接：https://levitate-qian.github.io/2022/07/08/EE-map/ee_exam_ans.pdf （7月10日**22点**发放）。\n\n<object data=\"ee_exam_ans.pdf\" type=\"application/pdf\" width=\"100%\" height=\"900px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"ee_exam_ans.pdf\">Download PDF</a>.</p></object>\n","tags":["大学"],"categories":["总结"]},{"title":"【MIMO通信学习笔记】Foundations of MIMO Communication","url":"/2022/05/26/mimo-communication/","content":"\n# 【MIMO通信学习笔记】Foundations of MIMO Communication\n\n>本文是*Foundations of MIMO Communication*(Robert W. Heath Jr. and Angel Lozano, 2018)笔记的总结帖。总算是在答辩完后三天看完了，没拖到研究生，\n>\n>之前想过看好几本无线通信、MIMO的书，但都没能看完。。\n>\n>+ *Wireless communications* (Andrea Goldsmith, 2005)\n>+ *Fundamentals of wireless communication* (David Tse and Pramod Viswanath)\n\n\n\n先甩出笔记的链接：https://levitate.lanzouq.com/b0dg6sdli\t密码:levitate\n\n> 看的不算特别仔细，错误肯定很多，欢迎批评指正。\n>\n> 一些材料可以在这边下：[Foundations of MIMO Communication (cambridge.org)](https://www.cambridge.org/core/books/foundations-of-mimo-communication/D1D999D61E48C62C44240EF2341A29A1)，[Foundations mimo communication | Wireless communications | Cambridge University Press](https://www.cambridge.org/us/academic/subjects/engineering/wireless-communications/foundations-mimo-communication?format=HB)\n\n\n\n目录：\n\n\n**Part I: Wireless Communication Theory（第一部分：无线通信原理）\t1**\n1 A primer on information theory and MMSE estimation（信息论与MMSE估计初步）\t3\n\t1.1 Introduction\t3\n\t1.2 Signal distributions\t4\n\t1.3 Information content\t6\n\t1.4 Information dependence\t11\n\t1.5 Reliable communication\t17\n\t1.6 MMSE estimation\t39\n\t1.7 LMMSE estimation\t47\n\t1.8 Summary\t51\n\tProblems\t51\n2 A signal processing perspective（信号处理的角度）\t57\n\t2.1 Introduction\t57\n\t2.2 Signal, channel, and noise representations\t58\n\t2.3 Signal, channel, and noise representations: extension to MIMO\t77\n\t2.4 Linear channel equalization\t87\n\t2.5 Single-carrier frequency-domain equalization\t98\n\t2.6 OFDM\t104\n\t2.7 Channel estimation\t110\n\t2.8 Summary and outlook\t122\n\tProblems\t124\n3 Channel modeling（信道建模）\t131\n\t3.1 Introduction\t131\n\t3.2 Preliminaries\t132\n\t3.3 Large-scale phenomena\t135\n\t3.4 Small-scale fading\t143\n\t3.5 Interlude: essential notions of antenna arrays\t170\n\t3.6 Modeling of MIMO channels\t175\n\t3.7 Channel estimation revisited\t192\n\t3.8 MIMO channel models in standards\t199\n\t3.9 Summary and outlook\t202\n\tProblems\t205\n4 Single-user SISO（单用户SISO）\t209\n\t4.1 Introduction\t209\n\t4.2 Interplay of bit rate, power, and bandwidth\t209\n\t4.3 AWGN channel\t220\n\t4.4 Frequency-selective channel\t228\n\t4.5 Frequency-flat fading channel\t244\n\t4.6 Frequency-selective fading channel\t267\n\t4.7 Which fading setting applies?\t268\n\t4.8 Pilot-assisted communication\t271\n\t4.9 Channels with interference\t279\n\t4.10 Summary and outlook\t284\n\tProblems\t287\n\n\n\n**Part II: Single-user MIMO（单用户MIMO系统）\t295**\n5 SU-MIMO with optimum receivers（最佳接收机的单用户MIMO系统）\t297\n\t5.1 Introduction\t297\n\t5.2 Initial considerations\t298\n\t5.3 CSIR and CSIT\t301\n\t5.4 No CSIT\t311\n\t5.5 No CSI\t338\n\t5.6 Pilot-assisted communication\t341\n\t5.7 Channels with interference\t345\n\t5.8 Optimum transmitter and receiver structures\t348\n\t5.9 Link adaptation\t358\n\t5.10 Reciprocity and CSI feedback\t361\n\t5.11 Summary and outlook\t374\n\tProblems\t378\n6 SU-MIMO with linear receivers（线性接收机的单用户MIMO系统）\t386\n\t6.1 Introduction\t386\n\t6.2 General characteristics of linear MIMO receivers\t387\n\t6.3 Linear ZF receiver\t388\n\t6.4 LMMSE receiver\t396\n\t6.5 Relationship between the LMMSE and the optimum receiver\t407\n\t6.6 Summary and outlook\t408\n\tProblems\t410\n\n\n\n**Part III: Multiuser MIMO（多用户MIMO系统）\t413**\n7 Multiuser communication prelude（多用户通信序曲）\t415\n\t7.1 Introduction\t415\n\t7.2 Spectral efficiency region\t416\n\t7.3 Orthogonal channel sharing\t418\n\t7.4 Non-orthogonal channel sharing\t420\n\t7.5 Scalar metrics\t422\n\t7.6 User selection and resource allocation\t426\n\t7.7 Low-SNR regime\t429\n\t7.8 Summary and outlook\t431\n\tProblems\t433\n8 MU-MIMO with optimum transceivers（最佳收发信机的多用户MIMO系统）\t436\n\t8.1 Introduction\t436\n\t8.2 The multiple-access channel\t437\n\t8.3 Multiple-access channel with CSIR and CSIT\t440\n\t8.4 Multiple-access channel with no CSIT\t457\n\t8.5 Multiple-access channel with no CSI\t460\n\t8.6 Pilot-assisted multiple-access channel\t461\n\t8.7 Duality between the multiple access and broadcast channels\t462\n\t8.8 The broadcast channel\t467\n\t8.9 Broadcast channel with CSIR and CSIT\t469\n\t8.10 Broadcast channel with no CSIT\t487\n\t8.11 Summary and outlook\t490\n\tProblems\t490\n9 MU-MIMO with linear transceivers（线性收发信机的多用户MIMO系统）\t497\n\t9.1 Introduction\t497\n\t9.2 Linear receivers for the multiple-access channel\t498\n\t9.3 Linear ZF receiver for the multiple-access channel\t500\n\t9.4 LMMSE receiver for the multiple-access channel\t507\n\t9.5 Duality with linear transceivers\t514\n\t9.6 Linear transmitters for the broadcast channel\t516\n\t9.7 Linear ZF transmitter for the MU-MISO broadcast channel\t517\n\t9.8 Block-diagonalization for the broadcast channel\t554\n\t9.9 Regularized ZF transmitter for the broadcast channel\t562\n\t9.10 Summary and outlook\t571\n\tProblems\t574\n10 Massive MIMO（大规模MIMO系统）\t578\n\t10.1 Introduction\t578\n\t10.2 Going massive\t579\n\t10.3 Reverse-link channel estimation\t582\n\t10.4 Reverse-link data transmission\t587\n\t10.5 Forward-link data transmission\t615\n\t10.6 Mitigation of pilot contamination\t623\n\t10.7 Practical considerations\t628\n\t10.8 Summary and outlook\t631\n\tProblems\t636\n11 Afterword\t643\n\t11.1 Beyond cellular\t643\n\t11.2 Beyond wireless\t644\n\n\n\n**Appendices\t647**\nAppendix A: Transforms\t649\nAppendix B: Matrix algebra\t653\nAppendix C: Random variables and processes\t661\nAppendix D: Gradient operator\t674\nAppendix E: Special functions\t676\nAppendix F: Landau symbols\t680\nAppendix G: Convex optimization\t681\nReferences\t685\nIndex\t752\n\n","tags":["无线通信","MIMO"],"categories":["课程向"]},{"title":"LaTeX札记（五）：毕设相关","url":"/2022/05/10/latex-note-05/","content":"\n# $\\LaTeX$札记（五）——毕设相关\n\n这里提供的解决方法仅针对Github上[StickCui/XDUthesis-personal: XDUthesis 西安电子科技大学学位论文模板 Xidian University thesis template (github.com)](https://github.com/StickCui/XDUthesis-personal)版本，新note286版本请在github自行提issue。\n\n## 模板中的字体问题\n\n*Github上StickCui版毕业设计模板中xelatex如何输出公式字体为Times风格*\n\n这个问题请见[LaTeX札记（四）：字体 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2022/04/14/latex-note-04/)问题2。\n\n> **问题：** Github上[StickCui/XDUthesis-personal: XDUthesis 西安电子科技大学学位论文模板 Xidian University thesis template (github.com)](https://github.com/StickCui/XDUthesis-personal)版本（该版本已不再维护）的毕设模板中，pdflatex可以编译出Times风格数学公式字体，而xelatex不可以。在“不改备注别进群”、“匿名毕设交流群”中的模板已经进行了替换，具体替换如下，这样的修改对于 $\\TeX Live$ 2020和 $\\TeX Live$ 2021早期版本，overleaf均是适用的：\n>\n> ```tex\n>     % \\setmainfont[NFSSFamily=entextrm]{Times New Roman}%\n>     % \\setsansfont[NFSSFamily=entextsf]{Times New Roman}%\n>     \\RequirePackage{newtxtext}\n>     \\RequirePackage[cmintegrals]{newtxmath}\n> ```\n>\n> 但如果对 $\\TeX Live$ 2021的宏包进行了更新或使用 $\\TeX Live$ 2022版本，则会出现找不到“SimHei”字体的错误，这主要是`newtxtext`宏包引起的，具体解决方案是回退`newtxtext`版本。\n>\n> **解决方案**：\n>\n> + 方法一：回退`newtxtext`版本，并加上`[nofontspec]`\n>\n> + 方法二：下载`newtxtext`早期版本（提供一个早期版本的🔗[链接](https://levitate.lanzouq.com/iLqd803623hc)，下载了记得解压，蓝奏云无法直接上传sty文件），并在XDUthesis.cls文件的`newtxtext`引用部分加上`[nofontspec]`（全局搜索`\\RequirePackage{newtxtext}`，都改成`\\RequirePackage[nofontspec]{newtxtext}`即可），\n>\n>     ```tex\n>     \\RequirePackage[nofontspec]{newtxtext}\n>     \\RequirePackage[cmintegrals]{newtxmath}\n>     ```\n>\n>     直接放置在毕设文件夹下，具体放在这个位置，记得重新编译前把之前生成的临时文件（Demo开头除了tex以外的文件）删掉\n>     ![image-20220414112658599](/image-20220414112658599.png)\n>\n> + 方法三：换用overleaf，使用overleaf中TeXLive2021+xelatex编译是没有问题的\n>\n> + 方法四：换用其他模板，如大佬最新推出的可能会持续的更新的模板\n>\n>     > 新的本科毕设latex模板发布了\n>     >\n>     > 睿思：https://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=1136781&extra=\n>     > GitHub：https://github.com/note286/xduts\n>\n> \n\n## 格式问题\n\n### 封面格式\n\n不推荐直接使用模板配套的封面作为毕设正式的封面。因为比例有一定的问题。这里提供一个我修改过的，但也和学校提供的封面不完全一样。\n\n请在模板cls文件中搜索`titlepage`，位置大致在427行附近，将`\\begin{titlepage}`至`\\end{titlepage}`区域的内容替换为以下内容，**可以比较好地接近学校封面，但仍然不保证会不会有别的问题。**\n\n```tex\n\\begin{titlepage}%%  封面右上角班级学号格式\n  \\newgeometry{left=3cm,right=2cm,top=2.5cm,bottom=2.5cm}\n  \\begin{table}\n    \\raggedleft\n    \\renewcommand{\\arraystretch}{1.3}\n    \\begin{tabular}{c c}\n      \\textbf{\\zihao{-4}\\XDU@classname}        & \\textbf{\\zihao{-4}\\XDU@class}          \\\\ \\cline{2-2}\n      \\textbf{\\zihao{-4}\\XDU@schoolnumbername} & \\textbf{\\zihao{-4}{\\XDU@schoolnumber}} \\\\ \\cline{2-2}\n    \\end{tabular}\n    \\hspace{1.48cm}\n  \\end{table}\n  \\if@WordOneHalf\n  \\if@nologo\n    \\vspace*{\\stretch{11}}\n  \\else\n  %   \\centering\\includegraphics[width=0.5\\textwidth]{./Figure/xidian.pdf}\n  \\vspace*{\\stretch{0.5}}\n  \\centering\\includegraphics[width=7.72cm]{./Figure/xidian.pdf}\n  \n    \\vspace*{\\stretch{3}}\n  \n    \\begin{center}\n    \\makebox[360pt][s]{\\heiti{\\zihao{0}本\\hspace{\\fill}科\\hspace{\\fill}毕\\hspace{\\fill}业\\hspace{\\fill}设\\hspace{\\fill}计\\hspace{\\fill}论\\hspace{\\fill}文\\hspace{\\fill}}} \n  %   {\\centering\\heiti{\\zihao{0}\\XDU@subject}}\n    \\end{center}\n  \n    \\vspace*{\\stretch{3}}\n  \n    \\begin{center}\n  %   \\includegraphics[width=0.27\\textwidth]{./Figure/logo.pdf}\n  \\includegraphics[width=4.42cm]{./Figure/logo.pdf}\n    \\end{center}\n  \\fi\n  \\else\n  \\if@nologo\n    \\vspace*{\\stretch{15}}\n  \\else\n    \\centering\\includegraphics[width=0.5\\textwidth]{./Figure/xidian.pdf}\n  \n    \\vspace*{\\stretch{5}}\n  \n    \\begin{center}\n    \\makebox[360pt][s]{\\heiti{\\zihao{0}本\\hspace{\\fill}科\\hspace{\\fill}毕\\hspace{\\fill}业\\hspace{\\fill}设\\hspace{\\fill}计\\hspace{\\fill}论\\hspace{\\fill}文}} \n  %   {\\centering\\heiti{\\zihao{0}\\XDU@subject}}\n    \\end{center}\n  \n    \\vspace*{\\stretch{5}}\n  \n    \\begin{center}\n    \\includegraphics[width=0.3\\textwidth]{./Figure/logo.pdf}\n    \\end{center}\n  \\fi\n  \\fi\n  \n  \\vspace*{\\stretch{3}}\n  \n  \\begin{center}\n  \\begin{tabular}{c C{8.5cm}}\n    \\makebox[84pt][s]{\\textbf{\\zihao{3}题\\hspace{\\fill}目}}& {\\heiti\\sffamily\\zihao{3}\\XDU@septitleA}\\\\\n  \\cline{2-2}\n   & \\\\\n   & {\\heiti\\sffamily\\zihao{3}\\XDU@septitleB}\\\\\n  \\cline{2-2}\n   & \\\\\n   \\makebox[84pt][s]{\\textbf{\\zihao{3}学\\hspace{\\fill}院}} & {\\zihao{-3}\\XDU@school}\\\\\n  \\cline{2-2}\n   & \\\\\n   \\makebox[84pt][s]{\\textbf{\\zihao{3}专\\hspace{\\fill}业}} & {\\zihao{-3}\\XDU@major}\\\\\n  \\cline{2-2}\n   &\\\\\n   \\makebox[84pt][s]{\\textbf{\\zihao{3}学\\hspace{\\fill}生\\hspace{\\fill}姓\\hspace{\\fill}名}} & {\\zihao{-3}\\XDU@author}\\\\\n  \\cline{2-2}\n   &\\\\\n   \\makebox[84pt][s]{\\textbf{\\zihao{3}导\\hspace{\\fill}师\\hspace{\\fill}姓\\hspace{\\fill}名}} & {\\zihao{-3}\\XDU@supervisor}\\\\\n  \\cline{2-2}\n  \\cline{2-2}\n  \\end{tabular}\n  \\end{center}\n  \\vspace*{\\stretch{7}}\n  \\end{titlepage}\n```\n\n并且由于调整封面页边距为学校模板，故需要将页边距恢复请在` \\pagestyle{empty}  \\cleardoublepage`两行后添加`\\restoregeometry`，大致如下：\n\n![image-20220528114550676](/image-20220528114550676.png)\n\n如果更改后出现Adobe系列字体报错的问题，请仔细核对107行附近的字体名是否和文件夹中的字体名一致，*之前黑体好像少打了一个r*，如果不使用adobe系列字体应该不会出现这方面的问题。\n\n![image-20220510095528231](/image-20220510095528231.png)\n\n\n\n### 章节标题格式\n\n该模板初始章标题，前后间距较大，前后间距方面毕设工作手册并未提出明确要求，如果需要修改可以找到cls文件中274行附近，将原始的`chapter/afterskip = {20pt}`替换为下列内容，两个数值分别表示章标题段前，章标题段后。\n\n```tex\n chapter/beforeskip = {-10pt},chapter/afterskip = {15pt},\n```\n\n![image-20220510095801568](/image-20220510095801568.png)\n\n\n\n### 表格格式\n\n部分老师指出表格字号应小于正文字号，显示为五号。修改方法仅需加上`\\small`\n\n![image-20220510100100138](/image-20220510100100138.png)\n\n如果感觉表格间距过紧，可加上上图所示`\\renewcommand\\arraystretch{1.5}`，即可将表格间距调整为1.5倍间距。\n\n\n\n### 摘要部分\n\n#### 摘要间距\n\n部分同学为了将英文摘要缩为一页，可能想要调整英文摘要的间距，但找不到摘要、abstract的修改位置。在cls文件400行附近开始即为修改摘要格式的地方。`cabstract`表示中文摘要，`enabstract`表示英文摘要。修改的内容可根据自己文章自行调整，但也不要太挤了。\n\n![image-20220510100426386](/image-20220510100426386.png)\n\n#### 关键词格式\n\n模板中中文关键字使用`\\keywords{...}`，英文关键词使用`\\enkeywords{...}`，书写方式不需要手动间隔两个关键词，仅需在两个关键词之间使用`西文逗号+西文空格`即可，模板会自动匹配为符合毕设工作手册的空格。\n\n\n\n\n\n## 外文文献翻译问题\n\n部分同学利用该模板翻译外文文献\n\n### 参考文献\n\n外文文献的参考文献可以直接粘贴原文献，不需要替换格式。\n\n如果原文献使用**顺序编号**，则\n\n![11](/11.JPG)\n\n![22](/22.JPG)\n\n![33](/33.JPG)\n\n![44](/44.JPG)\n\n```tex\n\\begin{thebibliography}{99}\n\\end{thebibliography}\n```\n\n引用时候直接`\\cite{bib1}`这样子，如果遇到`&`等符号需要转义\n\n如果你原来的是**作者年份制**的也可这么搞，只是把中间的替换[、]变成word里的编号，定义编号方式为\\bibitem{bib1}\n\n### 标题\n\n外文文献翻译最好在摘要上方显示外文文献标题。可以将cls文件407行内容，复制在407行上方，将`\\XDU@abstractname`替换为你的英文标题即可，如果一行写不下就多粘贴两遍。\n\n![image-20220510101354282](/image-20220510101354282.png)\n\n\n\n\n\n","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"LaTeX札记（四）：字体","url":"/2022/04/14/latex-note-04/","content":"\n# $\\LaTeX$ 札记（四）——字体\n\n今天讨论几个最近碰到的字体问题。后续碰到有新的字体问题的可能也会更新。\n\n❗ **首先注意，你的字体必须是为全体安装的！！！** 目前我这些问题出现在 $\\TeX Live$ 2022版本，部分问题在2020、2021就有出现。\n\n🌟推荐下载开源免费商用字体的网站：猫啃网（[猫啃网，最新最全的可免费商用中文字体下载网站！喵啃~ (maoken.com)](https://www.maoken.com/)），好多人来问题江城哪里下载，就在这上面！都是开源免费商用的字体，冲！真的是非常良心的网站！！\n\n\n\n## 简历模板中“思源黑体 Light”、“江城斜黑体 200W”无法识别\n\n这其实是两个问题：\n\n### “思源黑体 Light”无法识别\n\n请大家看清自己安装的是“思源黑体”（中日韩全字库版本，较大），还是“思源黑体 CN”（仅中文字库），如果安装的是CN版稍作修改即可。\n\n```tex\n\\setCJKsansfont{思源黑体 CN Light}\n```\n\n\n\n### “江城斜黑体 200W”无法识别，TeXLive2021以后版本无法识别中文文献名字体\n\n\n\n这个问题很早之前就有人来问我，但我一直也没碰到就没有解决，直到我自己从  $\\TeX Live$  2020更新到  $\\TeX Live$  2022后，我也遇到了这个问题🤔。根据网上的猜测应该是由 $\\TeX Live$ 2021大版本更新带来的。。。\n\n> 网络上有的一些解决办法：\n>\n> [(25条消息) window11 latex 解决找不到字体的问题_问题生产商的博客-CSDN博客_texlive 找不到字体](https://blog.csdn.net/github_39582118/article/details/120598547)\n>\n> [Win10+TeXLive2021无法识别新安装字体解决方法_zorchp的博客-CSDN博客_texlive 找不到字体](https://blog.csdn.net/qq_41437512/article/details/117306015)\n\n**原因**：由于“江城斜黑体”等字体名为中文，例如“江城斜黑体 200W.ttf”，这种中文文件名的字体在 $\\TeX Live$ 2021版以后就经常找不到了。\n\n```tex\n\\setCJKmainfont[ItalicFont={江城斜宋体 300W}]{思源宋体}\n\\setCJKmainfont[ItalicFont={江城斜黑体 200W}]{思源黑体 Light}\n```\n\n**解决方法**\n\n+ 方法一（可以尝试，但在我的TeXLive2022版本行不通）：将上述字体名直接加上文字名称的后缀名`.ttf`，也许可以缓解该问题，例如\n\n    ```tex\n    \\setCJKmainfont[ItalicFont={江城斜宋体 300W.ttf}]{思源宋体}\n    \\setCJKmainfont[ItalicFont={江城斜黑体 200W.ttf}]{思源黑体 Light}\n    ```\n\n+ 方法二（我就是这样解决的）：其实就是重装字体，同时重装之前先把文件名改成~~中文~~英文*（感谢郑同学指出原来的错误）*，例如江城斜黑体改成这样![image-20220414111433042](/image-20220414111433042.png)\n\n    然后重新为全体用户安装即可，中间如果说字体已经安装过了，这样选就可以啦！\n    ![image-20220414111610966](/image-20220414111610966.png)\n\n    这样安装完，直接原来的应该就可以用了\n\n    ```tex\n    \\setCJKmainfont[ItalicFont={江城斜宋体 300W}]{思源宋体}\n    \\setCJKmainfont[ItalicFont={江城斜黑体 200W}]{思源黑体 Light}\n    ```\n\n    \n\n\n\n## Github上StickCui版毕业设计模板中xelatex如何输出公式字体为Times风格\n\n**问题：** Github上[StickCui/XDUthesis-personal: XDUthesis 西安电子科技大学学位论文模板 Xidian University thesis template (github.com)](https://github.com/StickCui/XDUthesis-personal)版本（该版本已不再维护）的毕设模板中，pdflatex可以编译出Times风格数学公式字体，而xelatex不可以。在“不改备注别进群”、“匿名毕设交流群”中的模板已经进行了替换，具体替换如下，这样的修改对于 $\\TeX Live$ 2020和 $\\TeX Live$ 2021早期版本，overleaf均是适用的：\n\n```tex\n    % \\setmainfont[NFSSFamily=entextrm]{Times New Roman}%\n    % \\setsansfont[NFSSFamily=entextsf]{Times New Roman}%\n    \\RequirePackage{newtxtext}\n    \\RequirePackage[cmintegrals]{newtxmath}\n```\n\n但如果对 $\\TeX Live$ 2021的宏包进行了更新或使用 $\\TeX Live$ 2022版本，则会出现找不到“SimHei”字体的错误，这主要是`newtxtext`宏包引起的，具体解决方案是回退`newtxtext`版本。\n\n**解决方案**：\n\n+ 方法一：回退`newtxtext`版本，并加上`[nofontspec]`\n\n+ 方法二：下载`newtxtext`早期版本（提供一个早期版本的🔗[链接](https://levitate.lanzouq.com/iLqd803623hc)，下载了记得解压，蓝奏云无法直接上传sty文件），并在XDUthesis.cls文件的`newtxtext`引用部分加上`[nofontspec]`（全局搜索`\\RequirePackage{newtxtext}`，都改成`\\RequirePackage[nofontspec]{newtxtext}`即可），\n\n    ```tex\n    \\RequirePackage[nofontspec]{newtxtext}\n    \\RequirePackage[cmintegrals]{newtxmath}\n    ```\n\n    直接放置在毕设文件夹下，具体放在这个位置，记得重新编译前把之前生成的临时文件（Demo开头除了tex以外的文件）删掉\n    ![image-20220414112658599](/image-20220414112658599.png)\n\n+ 方法三：换用overleaf，使用overleaf中TeXLive2021+xelatex编译是没有问题的\n\n+ 方法四：换用其他模板，如大佬最新推出的可能会持续的更新的模板\n\n    > 新的本科毕设latex模板发布了\n    >\n    > 睿思：https://rs.xidian.edu.cn/forum.php?mod=viewthread&tid=1136781&extra=\n    > GitHub：https://github.com/note286/xduts\n\n\n\n## beamer中如何全篇使用CM风格非衬线体，即使用sansmathfonts宏包\n\n尝试了好多次，经常报NFSS异常的错。有几点注意事项：\n\n+ 请使用`ctexbemaer`文档类，而非`beamer`文档类+`ctex`宏包，会报NFSS错\n\n+ 不要使用`sansmathfonts`宏包的`onlymath`、`nottext`等命令，会报NFSS错\n\n+ 建议使用~~T1字体族~~ OT1字体族，不然会报错\n\n    ```tex\n    \\usepackage[OT1]{fontenc}\n    ```\n\n+ 使用`sansmathfonts`宏包后数字等字符会显示为衬线体，在引用该宏包前先引用CM宏包，即`cmbright`宏包，~~但是注意部分加粗字体采用的是sansmathfonts的加粗而非cmbright的加粗，看起来有点区别，我也不会调整~~ 改成OT1字体族就可以了\n\n    ```tex\n    \\usepackage[OT1]{fontenc}\n    \\usepackage{cmbright}\n    \\usepackage{sansmathfonts}\n    ```\n\n大家对beamer有什么别的疑惑的话可以去读文档，有[中文版](http://static.latexstudio.net/wp-content/uploads/2017/02/BeamerUserGuide_V3.24_zh-cn.pdf)的，比较通俗。提供一个自用的beamer导言区，见[LaTeX模板分享 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/12/01/latex-lecture/)\n\n","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"【预编码论文阅读（三）】深度学习(二)","url":"/2022/01/06/procoding-3/","content":"\n# 预编码论文阅读（三）——深度学习（二）\n\n> 由于没有非常系统地看完MIMO的相关内容，整理中必定有很多的问题，欢迎在评论区批评指正。\n>\n> 整理很乱。。。\n>\n> 由于网页公式渲染器KaTeX不支持公式交叉引用，我的前端水平就不足以把我这个模板加入mathjax。故将所有公式交叉引用均删除了，有的是在显示不出来的建议贴到markdown里面去吧\n\n\n\n---\n\n## Transfer learning/Meta Learning+online learning【迁移学习、元学习】——2021-TWC\n\n*Transfer Learning and Meta Learning-Based Fast Downlink Beamforming Adaptation*\n\n提出背景——传统深度学习方法无法很好处理训练集和测试集的mismatch\n\n+ Transfer learning is a promising technique to deal with the task mismatch issue experienced in the practical wireless communication systems due to its ability to transfer the useful prior knowledge to a new scenario [27].\n+ Another efficient way to deal with the task mismatch issue is meta-learning, which aims to improve the learning ability by leveraging\n    the different but related training and testing data [30].Meta Learning中希望把超参数，如网络结构，参数初始化，优化器等由机器自行设计（注：此处区别于AutoML，迁移学习（Transfer Learning）和终身学习（Life Long Learning） ），使网络有更强的学习能力和表现。\n\n解决的任务——SINR balancing problem under a total power constraint\n\n通过上行链路-下行链路对偶性，可以先求上行链路的功率分配矢量$\\mathbf q$\n\nLoss采用MSE\n$$\nLoss_{\\mathbb{D}}(\\theta)=\\frac 1N\\sum_{i=1}^N\\left\\|\\hat{\\mathbf q}^{(i)}(\\theta)-{\\mathbf q}^{(i)} \\right\\|_2^2\n$$\n\n### 离线训练算法\n\n+ joint training\n\n#### Transfer Learning\n\n先在分布不同的训练集下训练，再固定前$L-1$层，在有限样本的优化集下训练第$L$层\n    ![image-20211130154718588](image-20211130154718588.png)\n\n#### Meta learning\n\n[一文入门元学习（Meta-Learning）（附代码） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/136975128)\n\n+ 构建很多N-ways，K-shot的任务，每个任务中有训练集support set，验证集query set。\n\n+ MAML的目的是获取一组更好的模型初始化参数（即让模型自己学会初始化）。->使得模型学习到“先验知识”（初始化的参数）。这个“先验知识”在新的N-ways，K-shot任务上可以表现的更好。\n\n训练阶段\n\n+ ![image-20211130165712424](image-20211130165712424.png)\n\n+ inner-task——在每个任务中计算support set的Loss，并更新任务参数:\n    $$\n    \\phi_k^{(i)}=\\phi_k^{(i-1)}-\\beta\\nabla_{\\phi_k^{(i-1)}}Loss_{\\mathbb{D}_{mts}(k)}\\left(\\phi_k^{(i-1)}\\right)\n    $$\n    ​    第一轮为$\\theta$更新至$\\phi_k^{(0)}$\n\n+ cross-task——计算各任务query set的Loss的和，更新全局的参数：\n    $$\n    \\theta\\leftarrow\\theta- \\alpha\\nabla_\\theta \\sum_{k=1}^{N_b}Loss_{\\mathbb{D}_{mtq}(k)}\\left(\\phi_k\\right)\n    $$\n\n适应阶段\n\n+ 在adaptation set $\\mathbb{D}_{Ap}$上训练\n    $$\n    \\phi_{Ap}^{(j+1)}\\leftarrow\\phi_{Ap}^{(j)}-\\beta\\nabla_{\\phi_{Ap}^{(j)}}Loss_{\\mathbb{D}_{Ap}}\\left(\\phi_{Ap}^{(j)}\\right)\n    $$\n\n![image-20211130172502018](image-20211130172502018.png)\n\n*Comparison of Transfer Learning and Meta Leaning*: Transfer learning and meta learning both have the training and adaption stages. Although they have the same objective of achieving fast adaption, the strategies used in the training and adaption stages are different. Hence, transfer learning is not a special case of meta learning. Meta learning uses two iterative procedures to train the model, which means that it needs two backward passes in the training stage. However, transfer learning uses one backward pass to train the model in the training stage. In the adaption stage, meta learning re-trains all parameters on the new task whereas transfer learning only re-trains the parameter of the last layer while retaining the rest parameters.\n\n### 在线学习\n\n+ 在线学习——解决串行数据\n+ 在线meta learning：不重新学习了，从第一个时刻前开始就是通过前面的时间的数据来进行元学习，再通过每次更新的步长计算这一次的\n\n![image-20211201132759864](image-20211201132759864.png)\n\n+ inner-task：——task-specific(16)、(17)，第一次通过$\\theta_t$迭代\n    $$\n    \\phi_k^{(j)}=\\phi_k^{(j-1)}-\\beta\\nabla_{\\phi_k^{(j-1)}}Loss_{\\mathcal{D}_{k}^{train}}\\left(\\phi_k^{(j-1)}\\right)\n    $$\n\n+ cross-task：——shared network(18)\n    $$\n    \\theta_t\\leftarrow\\theta_t- \\alpha\\nabla_\\theta \\sum_{k=1}^{t-1}Z_kLoss_{\\mathcal{D}_{k}^{validation}}\\left(\\phi_k^{N_{in}}\\right)\n    $$\n    $Z_k$是task$\\mathcal{T}_k$发生的次数，$N_{in}$是迭代步数\n\n+ 通过线下学习到的网络参数作为线上学习的初始值\n\n> 既然要算监督学习的Loss，那么标签也就是真实的上行链路功率分配矢量$\\mathbf q$在哪里呢？莫非是到下一个time shot，上一次的标签就计算出来了？\n>\n> ————online learning是监督学习！！！是有标签的！\n\nthe offline algorithm heavily relies on the stationary environment.\n\n### Contributions\n\n1. DTL(先在分布不同的训练集下训练，再固定普遍特征的层在有限样本的优化集训练全连接层)\n2. MAML(①meta-learning，②fine-tuning)\n3. FTL(解决序列形式的实时系统)、meta-learning(快速自适应)\n4. 不需要大量数据和训练，达到near optimal\n\n\n\n## Meta Learning+Embedding model【元学习】——2021-TWC\n\n*Embedding Model Based Fast Meta Learning for Downlink Beamforming Adaptation*\n\ngeneral utility maximization problem under the total power constraint\n$$\n\\begin{aligned} \n\\max_\\mathbf W \\quad&U(\\gamma_1,\\cdots,\\gamma_K)\\\\ \ns.t.\\quad&\\sum_{k=1}^K\\left\\|\\mathbf w_k\\right\\|_2^2\\le P\n\\end{aligned}\n$$\n\n### fast meta learning with embedding model\n\n只关注提取特征，\n![image-20211202095207396](image-20211202095207396.png)\n\n+ 先将所有meta learning的support set和query set构成训练集$\\mathcal{D}_{fast}$，训练参数$\\theta$——embedding model training->$f_\\theta$\n    $$\n    \\theta=\\arg\\min_\\theta Loss_{\\mathcal{D}_{fast}}(\\theta)\n    $$\n\n+ 在$\\mathbb{D}_{adapt}$上训练参数$\\varphi$，拟合$\\mathbb{D}_{adapt}$的标签$\\mathbb{D}_{adapt}(y)$和embedding model输出值$y_{out}=f_\\theta(\\mathbb{D}_{adapt})$——adaptation->$f_{\\varphi^*}$\n    $$\n    \\varphi^*=\\arg\\min_\\varphi Loss_{\\mathbb{D}_{adapt}(y)}(Wy_{out}+b,\\mathbb{D}_{adapt}(y))\n    $$\n\n+ 再通过训练得到的$f_\\theta$和$f_{\\varphi^*}$进行测试\n\n![image-20211202094544360](image-20211202094544360.png)\n\n### Applications\n\n+ SINR balancing problem\n    $$\n    \\begin{aligned}\n    \\max_{\\mathbf W}\\min_{1\\le k\\le K}\\quad&\\gamma_k\\\\ \n    s.t.\\quad&\\sum_{k=1}^K\\left\\|\\mathbf w_k\\right\\|_2^2\\le P\n    \\end{aligned}\n    $$\n\n    + 由上行链路-下行链路对偶性，将上行链路的功率分配矢量$\\mathbf q$作为网络输出\n    + embedding model training阶段和adaptation、testing阶段的数据产生一致，（只是来源分布不同？）\n\n+ SR Maximization peoblem\n\n    + embedding model：由无监督学习产生，Loss为SR\n        $$\n        Loss=-\\frac{1}{2KL}\\sum_{l=1}^L\\sum_{k=1}^K\\log_2\\left(1+\\gamma_k^{(l)}\\right)\n        $$\n\n    + adaptation阶段：用WMMSE的作为标签\n        $$\n        Loss=\\frac{1}{2LK}\\sum_{l=1}^L\\left(\\left\\|\\underline{\\mathbf q}^{(l)}-\\hat{\\mathbf q}^{*(l)} \\right\\|_2^2\\right)\n        $$\n        $\\underline{\\mathbf q}^{(l)}$是WWMSE的功率分配矢量，$\\hat{\\mathbf q}^{*(l)}$是adaptation预测阶段的输出结果\n\n    + ![image-20211202111717068](image-20211202111717068.png)\n\n    \n\n### Online learning\n\nextracting features from adaptation data of the current time slot; $\\mathcal{B}_t$是缓冲区用来存放适应数据(adaptation data)\n\n在time shot $t$，提取的特征是：\n$$\n\\hat{\\mathbf q}_t^*=f_\\theta(\\mathcal{B}_t(\\mathbf h_t))\n$$\n将提取到的特征$\\hat{\\mathbf q}_t^*$和$\\mathcal{B}_t$中现有的输出$\\mathbf q_t$通过SVR计算loss：\n$$\n\\phi_t=\\arg\\min_{\\phi_t}Loss(\\mathbf W_t\\hat{\\mathbf q}_t^*+\\mathbf{b_t},\\mathcal{B}_t(\\mathbf q_t))\n$$\n\n> online learning是监督学习！\n\n## Knowledge Distillation【知识蒸馏】——2021-TVT\n\n*Knowledge Distillation-Aided End-to-End Learning for Linear Precoding in Multiuser MIMO Downlink Systems With Finite-Rate Feedback*——思路类似【ai5】\n\n在一般的方法中，类似【ai5】都采用了Straight-through estimator。但是伪梯度可能会导致不在正确的方向上更新参数。\n\n本文提出了一种与知识蒸馏(KD)相结合的训练方法，在辅助教师网络的帮助下，**通过使用附加的“无损梯度”来有效地训练接收方DNN**。随后，联合执行端到端学习以确定最大化下行链路和速率的预编码矩阵。提出的数据驱动方案优于传统的基于码本的线性预编码方法。\n\n优化问题：最大化速率(下面这个公式感觉有点问题)\n$$\nR_k\\triangleq \\mathbb{E}\\left[\\log_2\\left|\\mathbf{I}_N+\\frac PM\\sum_{l=1}^{K}\\mathbf H_k^H\\mathbf V_l\\mathbf V_l^H\\mathbf H_k \\right|\\right]-\\mathbb{E}\\left[\\log_2\\left|\\mathbf{I}_N+\\frac PM\\sum_{l=1,l\\neq k}^{K}\\mathbf H_k^H\\mathbf V_l\\mathbf V_l^H\\mathbf H_k \\right|\\right]\n$$\n\n\n导频估计：\n\n+ 训练导频$\\mathbf p_l\\in \\mathbb{C}^{M\\times 1}$\n\n+ 接收信号$\\mathbf y_{l,k}^{train}=\\sqrt{P_{train}}\\mathbf H_k^H\\mathbf p_l+\\mathbf n_k$来估计信道矩阵$\\bar{\\mathbf H}$\n\n+ 将信道矩阵进行紧凑形奇异值分解\n    $$\n    \\underbrace{\\bar{\\mathbf H}_k}_{M\\times N}=\\underbrace{\\tilde{\\mathbf H}_k}_{M\\times N}\\underbrace{\\boldsymbol{\\Sigma}^{\\frac12}_k}_{N\\times N}\\underbrace{\\mathbf{U}_k^H}_{N\\times N}\n    $$\n    $\\tilde{\\mathbf H}$中含有方向信息，需要量化反馈酉阵$\\tilde{\\mathbf H}$，但是注意到$\\tilde{\\mathbf H}_k$丢失了部分数量上的细节$\\boldsymbol{\\Sigma}_k$\n\n+ 第$k$用户侧利用$B$位的码本$\\mathcal{C}_k=\\{\\mathbf A_{k,1},\\cdots,\\mathbf A_{k,2^B}\\}$，通过一定的距离度量$d(\\bullet,\\bullet)$进行量化，将索引$q_k$反馈\n    $$\n    q_k=\\arg\\min_{j\\in\\{1,\\cdots,2^B\\}}d\\left(\\mathbf A_{k,j},\\tilde{\\mathbf H}_k\\right)\n    $$\n\n+ 基站侧通过码本$\\mathcal{C}_k$得到量化的信道矩阵$\\hat {\\mathbf H}_k=\\mathbf A_{k,q_k}$\n\n![image-20211208150213090](image-20211208150213090.png)\n\n### 网络结构\n\n![image-20211208150301854](image-20211208150301854.png)\n\n### 流程\n\n+ 接收机DNN：——全连接网络的激活函数采用ReLU\n    $$\n    \\begin{aligned}\n    \\hat{\\mathbf{q}}_{k} &=f_{k}^{\\mathrm{Rx}}\\left(\\mathbf{Y}_{k}^{\\mathrm{train}}, \\boldsymbol\\Theta_{k}^{\\mathrm{Rx}}\\right)=\\operatorname{sign}\\left(\\tanh \\left(\\mathrm{FC}_{k}^{\\mathrm{Rx}}\\left(\\mathbf{r}_{k}^{\\mathrm{Re}}, \\boldsymbol\\Theta_{k}^{\\mathrm{Rx}}\\right)\\right)\\right) \\\\\n    &=\\left[\\operatorname{sign}\\left(\\tanh \\left(\\left[\\mathbf{u}_{k}\\right]_{1}\\right)\\right), \\ldots, \\operatorname{sign}\\left(\\tanh \\left(\\left[\\mathbf{u}_{k}\\right]_{B}\\right)\\right)\\right]\n    \\end{aligned}\n    $$\n    其中，\n\n    + $\\mathbf r_k^{Re}$是将训练数据$\\mathbf Y_k^{train}$实部虚部组合而成的列向量；\n    + $\\boldsymbol{\\Theta}_k^{Rx}$是接收机DNN需要训练的所有参数；\n    + $\\mathbf u_k$是全连接网络输出的$B$维实值矢量后通过tanh压缩，sign量化\n\n+ 发射机DNN：\n    $$\n    \\begin{aligned}\n    \\mathbf V=[\\mathbf V_1,\\cdots,\\mathbf V_K]&=f^{Tx}(\\hat{\\mathbf q}_1,\\cdots,\\hat{\\mathbf q}_K,P;\\boldsymbol{\\Theta}^{Tx})\\\\ \n    &=h(FC^{Tx}(\\hat{\\mathbf q_1},\\cdots,\\hat{\\mathbf q_K},P;\\boldsymbol{\\Theta}^{Tx}))\n    \\end{aligned}\n    $$\n    其中，$h$是将$2MNK$维的实列向量重组为$M\\times NK$的波束成型矩阵\n\n+ Loss：\n    $$\n    \\begin{aligned}\n    \n    &L_{\\operatorname{main}}\\left(\\left\\{\\boldsymbol\\Theta_{k}^{\\mathrm{Rx}}\\right\\}_{k=1}^{K}, \\boldsymbol\\Theta^{\\mathrm{Tx}}\\right) \\\\\n    &\\quad=-\\sum_{k=1}^{K} R_{k}\\left(f^{\\mathrm{Tx}}\\left(\\left\\{f_{k}^{\\mathrm{Rx}}\\left(\\mathbf{Y}_{k}^{\\mathrm{train}} ; \\boldsymbol\\Theta_{k}^{\\mathrm{Rx}}\\right)\\right\\}_{k=1}^{K}, P ; \\boldsymbol\\Theta^{\\mathrm{Tx}}\\right)\\right) .\n    \\end{aligned}\n    $$\n    优化目标：\n    $$\n    \\min _{\\boldsymbol\\Theta^{\\mathrm{Tx}}, \\boldsymbol\\Theta_{1}^{\\mathrm{Rx}}, \\ldots, \\boldsymbol\\Theta_{K}^{\\mathrm{Rx}}} L_{\\operatorname{main}}\\left(\\left\\{\\boldsymbol\\Theta_{k}^{\\mathrm{Rx}}\\right\\}_{k=1}^{K}, \\boldsymbol\\Theta^{\\mathrm{Tx}}\\right)\n    $$\n\n    \n\n### KD\n\n**反向传播：注意到二值化无法反向传播，常见的方法是采用直通（STE）**，本文中类似【KD-14】考虑到双曲正切函数的性质\n$$\n    \\nabla_{\\Theta_k^R}\\ \\mathrm{sign}(\\tanh(z))\\approx\\nabla_{\\Theta_k^R}\\tanh(z)\n$$\n\n但是上述方法的噪声积累仍会导致DNN参数梯度下降方向不正确，表现变差，故**最好的方式是将“损失更小的梯度”反向传播给接收机DNN，于是就引出了KD**。The best solution to overcome the noisy gradient problems is to provide “lossless gradients” to receiver DNNs. To achieve this, we propose a novel joint training method using KD.\n\n因为有一个二值化，所以要用STE才能反向传播，但这样就会累计误差，所以把辅助发射机DNN在还没有二值化的地方，先训练“接收机DNN+辅助发射机DNN”再训练“接收机DNN+发射机DNN”\n\n![image-20211208170425951](image-20211208170425951.png)\n\n在接收机DNNs的末端只有一个瓶颈(二进制层)。换言之，浅层学生网络(原始发射机DNN)和深层教师网络(辅助发射机DNN)具有相同的结构，除了tanh函数和二值化层(tanh层和二值化层都不用于深层教师网络，因为它们导致梯度消失问题)。\n\n## Model-Driven Beamforming Neural Networks——2020-MWC\n\n可以看作是【ai2】【ai3】的介绍\n\n+ 两类BNN网络框架(architecture)：\n    + data-based：看称黑箱（black-box） *blind to any specialized signal structures*, does not have the same computational efficiency, and the performance is often *inferior to that of traditional SP methods*.\n    + model-based： Inside the SP module are the functional layers that are designed according to *prior expert knowledge of beamforming problems*, which is **problem-specific** and has no unified form. It is also possible to replace one or more layers in the ordinary NN module by the SP module to achieve better feature extraction ability.——【ai2】\n        ![image-20211209102042438](image-20211209102042438.png)\n+ 监督学习/无监督学习\n    + 监督学习：适应于存在最优解算法、易于获得标签的问题，常采用MSE/MAE Loss——【ai2】中的P1（功率约束下SINR balancing）、P2（Qos下功率最小）\n    + 无监督学习：不存在最优解算法，采用目标函数作为Loss——【ai2】中的P3（功率约束下SR最大）、【ai3】中的单天线约束下SINR balancing\n    + 混合(Hybrid)：类似【ai2】中对于P3的训练方式，两阶段，先监督逼近WMMSE，后无监督用SR作为Loss\n+ 复杂度\n    + 优化问题复杂度：【ai2】通过model-based的引入，不直接输出波束形成矩阵，而先输出一些关键特征，如上行/下行链路的功率分配矢量\n    + NN模块的复杂度：冗余的神经元——为了降低神经网络模块的复杂度，我们可以首先使用边缘检测来剪除所有权值在一定阈值以下的连接和那些具有零激活神经元的连接。然后，我们通过压缩技术减少用于表示每个权重的比特数，并在不同的连接之间实施权重分担以减少权重的数量。最后，可以采用霍夫曼编码来使用具有更少比特的符号来表示更多的公共权重[11]。\n+ 泛化能力——【ai3】中提及\n    + training-set augmentation：难以获取大量的数据\n    + transfer learning：fine-tuning\n        ![image-20211209110800360](image-20211209110800360.png)\n+ open issue\n    + 现实环境的数据集\n    + 对可能导致BNN训练不一致和失败的损坏数据具有鲁棒性\n\n## Deep Learning for SVD and Hybrid Beamforming——2020-TWC\n\nSU-MIMO\n\n+ unconstrained SVD\n    $$\n    \\mathbf y=\\mathbf R^H\\mathbf{HTs}+\\mathbf R^H\\mathbf n\n    $$\n    achieved rate:\n    $$\n    R=\\log_2\\left(\\left|\\mathbf I+\\frac PL\\mathbf C_n^{-1}\\mathbf R_{opt}^H\\mathbf {HT}_{opt}\\mathbf T_{opt}^H \\mathbf H^H\\mathbf R_{opt}\\right|\\right)\n    $$\n    其中，$\\mathbf T_{opt}=\\mathbf V_L\\in\\mathbb C^{N_T\\times L},\\mathbf R_{opt}=\\mathbf U_L\\in\\mathbb C^{N_R\\times L},$为右奇异值矩阵和左奇异值矩阵$\\mathbf C=\\mathbf R_{opt}^H\\mathbf R_{opt}$\n\n+ constrained SVD\n    $$\n    \\mathbf y=\\mathbf R_{BB}^H\\mathbf R_{RF}^H\\mathbf{HT}_{RF}\\mathbf T_{BB}\\mathbf{s}+\\mathbf R_{BB}^H\\mathbf R_{RF}^H\\mathbf n\n    $$\n    约束条件：\n\n    + 发射信号假设：$\\mathbb{E}[\\mathbf {ss}^H]=\\frac PL\\mathbf I_L$\n    + 恒模约束：$\\left|[\\mathbf T_{RF}]_{i,j}\\right|^2=N_T^{-1},\\left|[\\mathbf R_{RF}]_{i,j}\\right|^2=N_R^{-1},$\n    + 移相量化：第$n$根发射天线(第$m$根接收天线)用$N_q$位移相器$e^{\\frac{j2\\pi nk_q}{N_q}}(e^{\\frac{j2\\pi mk_q}{N_q}})$，其中$k_q=0,1,\\cdots,2^{N_q}-1$\n    + 功率约束：$\\left\\|\\mathbf{T}_{RF}\\mathbf{T}_{BB}\\right\\|^2_F=L,\\left\\|\\mathbf{R}_{RF}\\mathbf{R}_{BB}\\right\\|^2_F=L$\n\n### SVD近似\n\n$$\n\\mathbf H_k=\\mathbf U_k\\mathbf \\Sigma_k\\mathbf V_k^H\n$$\n\n写成秩1近似的和\n$$\n\\mathbf H_k=\\sum_{i=1}^k\\sigma_i\\mathbf u_i\\mathbf v_i\n$$\n\n\n#### for Rank-*k* Matrix Approximation\n\n![image-20211213110603767](image-20211213110603767.png)\n\nLoss函数：\n$$\n\\mathcal{L}(\\theta)=\\frac{\\left\\|\\mathbf{H}_{k}-\\tilde{\\mathbf{H}}_{k}\\right\\|_{F}}{\\left\\|\\mathbf{H}_{k}\\right\\|_{F}}+\\lambda_{1} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{u}}_{i}^{*} \\tilde{\\mathbf{u}}_{j}\\right\\|_{2}+\\lambda_{2} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{v}}_{i}^{*} \\tilde{\\mathbf{v}}_{j}\\right\\|_{2}\n$$\n（信道矩阵$\\mathbf H$尽可能接近，左右奇异矩阵为酉阵且列正交）\n\n#### 低复杂度——for Rank-*k* Matrix Approximation\n\n每次求当前最大的奇异值、奇异矩阵，下一次减掉它\n\n![image-20211214084539548](image-20211214084539548.png)\n\n+ trained jointly\n    $$\n    \\mathcal{L}(\\theta_1,\\theta_2,\\cdots,\\theta_k)=\\frac{\\left\\|\\mathbf{H}_{k}-\\tilde{\\mathbf{H}}_{k}\\right\\|_{F}}{\\left\\|\\mathbf{H}_{k}\\right\\|_{F}}+\\lambda_{1} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{u}}_{i}^{*} \\tilde{\\mathbf{u}}_{j}\\right\\|_{2}+\\lambda_{2} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{v}}_{i}^{*} \\tilde{\\mathbf{v}}_{j}\\right\\|_{2}\n    $$\n\n+ sequence（$\\theta_1$不需要考虑正交性）\n    $$\n    \\mathcal{L}\\left(\\theta_{i}\\right)=\\frac{\\left\\|\\sigma_{i} \\mathbf{u}_{i} \\mathbf{v}_{i}^{*}-\\tilde{\\sigma}_{i} \\tilde{\\mathbf{u}}_{i} \\tilde{\\mathbf{v}}_{i}^{*}\\right\\|_{F}}{\\left\\|\\sigma_{i} \\mathbf{u}_{i} \\mathbf{v}_{i}^{*}\\right\\|_{F}}+\\lambda_{1} \\sum_{i, j<i}\\left\\|\\tilde{\\mathbf{u}}_{i}^{*} \\tilde{\\mathbf{u}}_{j}\\right\\|_{2} +\\lambda_{2} \\sum_{i, j<i}\\left\\|\\tilde{\\mathbf{v}}_{i}^{*} \\tilde{\\mathbf{v}}_{j}\\right\\|_{2}\n    $$\n\n采用梯度下降更新参数\n\n#### Rank-1 Matrix Approximation\n\n将低复杂度Rank-*k*的$k$个神经网络变成1个。它使用单个DNN递归地估计$k$个奇异值和奇异向量。\n\n![image-20211214085038717](image-20211214085038717.png)\n\nLoss函数：\n$$\n\\mathcal{L}(\\theta)=\\frac{\\left\\|\\mathbf{H}_{k}-\\tilde{\\mathbf{H}}_{k}\\right\\|_{F}}{\\left\\|\\mathbf{H}_{k}\\right\\|_{F}}+\\lambda_{1} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{u}}_{i}^{*} \\tilde{\\mathbf{u}}_{j}\\right\\|_{2}+\\lambda_{2} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{v}}_{i}^{*} \\tilde{\\mathbf{v}}_{j}\\right\\|_{2}\n$$\n\n\n\n### 混合预编码\n\n![image-20211214103300159](image-20211214103300159.png)\n\n在该方法中，我们不是直接最大化速率，而是最小化无约束波束形成器和混合波束形成器获得的<u>秩-k近似</u>之间的Frobenius距离（？）。\n\n> 【理解】\n> $$\n> \\mathbf y=\\mathbf R_{BB}^H\\mathbf R_{RF}^H\\mathbf{HT}_{RF}\\mathbf T_{BB}\\mathbf{s}+\\mathbf R_{BB}^H\\mathbf R_{RF}^H\\mathbf n\\\\\n> $$\n> ![image-20211214104710646](image-20211214104710646.png)\n>\n> 对信道矩阵作SVD，\n> $$\n> \\mathbf H=\\mathbf{U\\Sigma V^H}\n> $$\n> 只要让\n> $$\n> \\mathbf R_{BB}^H\\mathbf R_{RF}^H=\\mathbf U^H,\n> \\mathbf{T}_{RF}\\mathbf T_{BB}=\\mathbf V\\label{eq:123}\n> $$\n> 因为$\\mathbf \\Sigma$是对角阵，就可以转化为并行信道\n> $$\n> \\mathbf y=\\mathbf \\Sigma \\mathbf s+\\mathbf U^H \\mathbf n\n> $$\n> 即上述网络想实现$\\eqref{eq:123}$的近似相等，以保证实现并行信道。同时接近的$\\mathbf{U,V}$不是实际值，而是上述三种SVD近似得到的结果\n\n**RF预编码恒模约束的四种方法**\n\n1. 训练阶段，使用分段线性函数的组合来近似均匀量化。\n    ![image-20211214135127640](image-20211214135127640.png)\n    测试阶段直接量化。\n    $$\n    \\tilde\\alpha_i=\\frac{2\\pi n}{2^{N_q}}\n    $$\n    $\\gamma=0$时，训练和测试阶段一致\n\n    ![image-20211214135323497](image-20211214135323497.png)\n\n2. 法一存在间断点，不平滑->利用sigmoid函数\n    $$\n    \\tilde\\alpha_i=\\frac{1}{1=\\exp(\\beta(\\alpha_i-b_n))}+o_n\n    $$\n    其中，$n=1,\\cdots,2^{N_q}$，$b_n$时第n个量化阶的bias（偏差），$o_n$是其offset（偏置）。\n\n    ![image-20211214135802275](image-20211214135802275.png)\n\n3. 在前向传播中，我们使用阶跃函数来应用均匀量化。在反向传播过程中，我们使用Sigmoid函数的线性组合。\n\n4. 在前向传播期间实现随机量化方法，\n    $$\n    \\tilde{\\alpha}_{i}=\\frac{\\left\\lfloor 2^{N_{q}} \\alpha_{i}\\right\\rfloor}{2^{N_{q}}}+\\frac{r_{i}}{2^{N_{q}}}\n    $$\n    而在反向传播期间用直通估计器替换。\n    $$\n    \\frac{\\partial Q(\\alpha)_i}{\\tilde\\alpha_j}=\\left\\{\\begin{array}{ll}1,&\\alpha_i\\text{被量化到$\\tilde \\alpha_j$}\\\\ \n    0,&otherwise\\end{array}\\right.\n    $$\n\n**功率约束**\n\n用未归一的$\\hat{\\mathbf T}_{BB},\\hat{\\mathbf R}_{BB}$和量化后的$\\tilde{\\mathbf T}_{RF},\\tilde{\\mathbf R}_{RF}$归一化\n$$\n\\begin{aligned}\n\\tilde{\\mathbf T}_{BB}=\\sqrt{L}\\frac{\\hat{\\mathbf T}_{BB}}{\\left\\|\\tilde{\\mathbf T}_{RF}\\hat{\\mathbf T}_{BB}\\right\\|_F}\\\\ \n\\tilde{\\mathbf R}_{BB}=\\sqrt{L}\\frac{\\hat{\\mathbf T}_{BB}}{\\left\\|\\tilde{\\mathbf R}_{RF}\\hat{\\mathbf R}_{BB}\\right\\|_F}\n\\end{aligned}\n$$\n**Loss函数：**——$L$ for rank-$L$\n$$\n\\mathcal{L}(\\theta)=\\frac{\\left\\|\\mathbf{H}_{L}-\\tilde{\\mathbf{H}}_{L}\\right\\|_{F}}{\\left\\|\\mathbf{H}_{L}\\right\\|_{F}}+\\lambda_{1} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{r}}_{i}^{*} \\tilde{\\mathbf{r}}_{j}\\right\\|_{2}+\\lambda_{2} \\sum_{i \\neq j}\\left\\|\\tilde{\\mathbf{t}}_{i}^{*} \\tilde{\\mathbf{t}}_{j}\\right\\|_{2}\n$$\n$\\tilde{\\mathbf r}_i$是$\\tilde{\\mathbf R}_{opt}$的列向量，$\\tilde{\\mathbf t}_i$是$\\tilde{\\mathbf T}_{opt}$的列向量\n\n### 仿真\n\n+ 对于不同规模的毫米波系统，基于DNN的混合BF方法用于秩-k矩阵近似的性能优于基于低复杂度DNN的混合BF方法(用于秩k近似)和基于DNN的混合BF方法(用于秩1近似)。——低复杂度秩-k和秩-1的方法在估计后续奇异值、奇异向量时用了之前预测的结果，会带来积累误差。由于在这些仿真中我们考虑满秩信道矩阵，发射和接收天线的数目等于信道的秩，这导致天线数目越多，性能差距越大。\n\n+ 图18-a显示了基于DNN的混合BF用于秩-k矩阵近似时的实现速率，我们观察到当使用DNN用于秩-k矩阵近似时，第一和第二量化方法获得了相似的速率并且优于其他量化方法。在18-b中表明，第三种量化方法以用于秩-k矩阵近似的低复杂度DNN获得了最高的数据速率。我们在18-c中观察到，当使用秩1矩阵的DNN近似时，第四量化方法优于其他方法。![image-20211214150104362](image-20211214150104362.png)\n\n  ​    \n\n### Contributions\n\n+ 三种DNN结构\n    + 第一种体系结构使用单个DNN的矩阵预测给定的k个最重要的奇异值和奇异向量。利用奇异值分解(SVD)的结构，提出了一种低复杂度的秩-k矩阵逼近DNN结构。\n    + 第二种结构由k个低复杂度DNN组成，每个DNN被训练来估计给定矩阵的最大奇异值和相应的右、左奇异向量。\n    + 为了进一步简化奇异值分解运算，我们提出了秩1矩阵逼近的第三种结构，它使用单个DNN递归地估计k个奇异值和奇异向量。\n    + 我们引入了定制的损失函数来训练三种DNN结构，原则上训练DNN的目的是最小化矩阵的真实值和估计秩-k近似之间的Frobenius距离，同时强制奇异向量正交。\n\n+ 四种量化方法\n    + 在第一种方法中，我们使用步长和分段线性函数的组合来近似相位量化操作，这在训练过程中提供了非零梯度。\n    + 在第二种方法中，我们考虑在前向和后向传播过程中使用几个具有不同参数的Sigmoid函数的组合来进行软量子化。\n    + 在第三种方法中，我们在前向传播中使用阶跃函数，而在后向传播中结合不同参数的Sigmoid函数。\n    + 在第四种方法中，我们在前向传播期间实现随机量化方法[37]，而在反向传播期间用直通估计器[38]替换。\n    + 最后，在所提出的DNN体系结构中，我们通过归一化层满足功率约束。\n\n\n\n\n\n","tags":["深度学习","无线通信","MIMO","预编码"],"categories":["科研向"]},{"title":"【预编码论文阅读（二）】深度学习(一)","url":"/2021/12/08/precoding-2/","content":"\n# 预编码论文阅读（二）——深度学习（一）\n\n> 由于没有非常系统地看完MIMO的相关内容，整理中必定有很多的问题，欢迎在评论区批评指正。\n>\n> 整理很乱。。。\n>\n> 由于网页公式渲染器KaTeX不支持公式交叉引用，我的前端水平就不足以把我这个模板加入mathjax。故将所有公式交叉引用均删除了，有的是在显示不出来的建议贴到markdown里面去吧\n\n\n\n---\n\n## Beamforming Design for Large-Scale Antenna Arrays Using Deep Learning——2020\n\nMISO-mmWave——maximizing the spectral efficiency (SE) with hardware limitation and imperfect CSI.\n\n![image-20211116102845778](image-20211116102845778.png)\n$$\nr=\\mathbf{h}^H\\mathbf{v}_{RF}s+n\n$$\n其中，$\\mathbf{v}_{RF}\\in\\mathbb{C}^{N_t\\times 1}$\n\n信道矩阵：\n$$\n\\mathbf{h}^{H}=\\sqrt{\\frac{N_{\\mathrm{t}}}{L}} \\sum_{l=1}^{L} \\alpha_{l} \\mathbf{a}_{\\mathrm{t}}^{H}\\left(\\phi_{\\mathrm{t}}^{l}\\right)\n$$\n其中，$L$条路径，$l=1$为LoS路径\n\n优化问题——sum-rate problem\n$$\n\\begin{aligned}\n\\underset{\\mathbf{v}_{\\mathrm{RF}}}{\\operatorname{max}} \\quad & \\log _{2}\\left(1+\\frac{\\gamma}{N_{\\mathrm{t}}}\\left\\|\\mathbf{h}^{H} \\mathbf{v}_{\\mathrm{RF}}\\right\\|^{2}\\right) \\\\\n\\text { s.t. } \\quad &\\left|\\left[\\mathbf{v}_{\\mathrm{RF}}\\right]_{i}\\right|^{2}=1, \\quad \\text { for } i=1, \\ldots, N_{\\mathrm{t}},\n\\end{aligned}\n$$\n$\\gamma=\\frac{P}{\\sigma^2}$是信噪比，最优的数字波束赋形$v_D=\\sqrt{\\frac{P}{N_t}}$。约束条件由恒模约束和功率约束。\n\n### 流程\n\n通过估计的$\\mathbf{h}_{est},\\gamma_{est}$优化RF预编码向量$\\mathbf{v}_{RF}$。相较于CSI，$\\gamma_{est}=\\gamma$\n\n![image-20211116141835446](image-20211116141835446.png)\n\n+ 离线训练：**随机生成信道**（可以获得perfect CSI），输入估计的$\\mathbf{h}_{est}$，在BFNN中优化$\\mathbf{v}_{RF}$。再通过$\\mathbf{v}_{RF}$和perfect CSI条件下的CSI和信噪比计算Loss函数。——学习在perfect CSI获得理想频谱效率的方法，同时增强信道估计误差的鲁棒性。\n+ 在线部署：实际环境信道(imperfect CSI)估计出$\\mathbf{h}_{est},\\gamma_{est}$，利用BFNN设计出$\\mathbf{v}_{RF}$。\n\n### 网络结构\n\n![image-20211116142810047](image-20211116142810047.png)\n\n+ 输入：$N_t=64$根发射天线，将$N_t=64$个信道$\\mathbf{h}_{est}$的实部、虚部和估计的信噪比$\\gamma_{est}$作为输入$(2N_t+1)\\times 1$\n\n+ 每层开始前先做Batch-Norm\n\n+ 最后输出前通过Lambda层将其变成符合恒模约束的复数矢量$\\mathbf{v}_{RF}$(由于sigmoid函数，$\\alpha_i\\in(0,1)$)\n    $$\n    \\mathbf{v}_{RF}=\\exp(j2\\pi\\boldsymbol{\\alpha})=\\cos(2\\pi\\boldsymbol{\\alpha})+j\\sin(2\\pi\\boldsymbol{\\alpha})\n    $$\n\n+ Loss函数：越小越好\n    $$\n    Loss=-\\frac 1N\\sum_{n=1}^N\\log_2\\left(1+\\frac{\\gamma_n}{N_t}\\left\\|\\mathbf{h}_n^H\\mathbf{v}_{RF,n} \\right\\|^2\\right)\n    $$\n\n### 算法复杂度\n\n每一层的浮点数运算次数是$(2N_I-1)N_O$ ， $N_I$是输入参数个数，$N_O$是输出参数个数。且可以使用并行运算。\n\n### 仿真\n\n见BFNN中ffbn_v2.py为pytorch的实数运算版本，ffbn_test.py为测试。ffbn_complex为复数运算版本。\n\n+ 注意：$\\log_2(A)$使用换底公式通过$\\frac{\\log(A)}{\\log(2)}$实现。\n\n### Contribution\n\n+ 新的设计方法：利用估计的CSI作为BFNN输入，直接输出最优beamforming权值。估计的信道矩阵$\\mathbf{h}_{\\mathrm{est}}$ ,估计的信噪比$\\gamma_{\\text {est }}$作为输入。\n\n+ 新颖的Loss函数：在作者的设计中不需要标签，创新性地提出了与SE十分相关的一个Loss函数\n    $$\n    \\text { Loss }=-\\frac{1}{N} \\sum_{n=1}^{N} \\log _{2}\\left(1+\\frac{\\gamma_{n}}{N_{\\mathrm{t}}}\\left\\|\\mathbf{h}_{n}^{H} \\mathbf{v}_{\\mathrm{RF}, n}\\right\\|^{2}\\right)\n    $$\n    Loss函数的减少正好对应着平均SE的增加\n\n+ 对于非理性CSI的鲁棒性：提出了一种两阶段设计方法，利用估计的CSI作为输入，让BFNN学会接近理想CSI下的SE。在线部署阶段，BFNN能够适应非理性CS实现对信道估计误差的鲁棒性。\n\n+ Lamda层满足恒模约束：经典的、完美的欧拉公式\n    $$\n    \\mathbf{v}_{\\mathrm{RF}}=\\exp (\\mathrm{j} \\cdot \\boldsymbol{\\theta})=\\cos (\\boldsymbol{\\theta})+{j} \\cdot \\sin (\\boldsymbol{\\theta})\n    $$\n    将相位$\\boldsymbol{\\theta}$作为在最后一个Dense层的输出，然后添加一个基于欧拉公式的Lamda层满足恒模约束。\n\n### 改进思路\n\n略\n\n\n\n---\n\n## A Deep Learning Framework for Optimization of MISO Downlink Beamforming——2020【是否可以改成transfer？共用前面网络层的参数】-TCOMM\n\n有约束！\n\nMU-MISO\n$$\ny_k=\\mathbf{h}_k^H\\sum_{i=1}^K\\mathbf{w}_ix_i+n_k\n$$\n其中，$\\mathbf{h}_k\\in \\mathbb{C}^{N\\times 1}$ ， $x_i\\sim\\mathcal{CN}(0,1),n_i\\sim\\mathcal{CN}(0,\\sigma^2)$\n\n本文解决的问题：(P1、P2可以解得最优解，可采用监督学习；P3非凸，无最优解)\n\n+ SINR balancing problem under a total power constraint, \n    $$\n    \\begin{aligned}\n    \\mathbf{P1:}\\underset{\\mathbf{W}}{\\operatorname{maximize}} \\quad & \\min_{1 \\leq k \\leq K}\\left\\{ \\frac{\\gamma_{k}^{d l}}{\\rho_{k}}\\right\\}, \\\\ \n    \\text { s.t. } \\quad&\\sum_{k=1}^{K}\\left\\|\\mathbf{w}_{k}\\right\\|^{2} \\leq P_{\\max }\n    \\end{aligned}\n    $$\n    $\\rho_k$是importance of the sub-streams，$\\mathbf{W}=[\\mathbf{w_1,w_2,\\cdots,w_K}]$ ， $P_{\\max}$是power budget\n\n+ power minimization problem under QoS(Quality of Service) constraints, \n    $$\n    \\begin{aligned}\n    \\mathbf{P2:}\\min_{\\mathbf{W}} \\quad& \\sum_{k=1}^K||\\mathbf{w}_k||^2\\\\ \n    \\mathrm{s.t.}\\quad&\\gamma_k^{dl}\\ge \\Gamma_k,\\forall k.\n    \\end{aligned}\n    $$\n    $\\boldsymbol{\\Gamma}=[\\Gamma_1,\\cdots,\\Gamma_K]^T$是SINR constraint\n\n+ sum rate maximization problem under a total power constraint.\n    $$\n    \\begin{aligned}\n    \\mathbf{P3:}\\max_{\\mathbf{W}}\\quad&\\sum_{k=1}^K\\alpha_k\\log_2(1+\\gamma_k^{dl})\\\\ \n    \\mathrm{s.t.}\\quad&\\sum_{k=1}^{K}\\left\\|\\mathbf{w}_{k}\\right\\|^{2} \\leq P_{\\max }\n    \\end{aligned}\n    $$\n\n### 网络框架\n\n![image-20211118151957384](image-20211118151957384.png)\n\nA DL-based framework for the beamforming optimization in MISO downlink, which includes two main modules: **the neural network module and the beamforming recovery module**. The neural network module is composed of an input layer, convolutional (CL) layers, batch normalization (BN) layers, activation (AC) layers, a flatten layer, a fully-connected (FC) layer, and an output layer, whereas the key features and the functional layers in the beamforming recovery module are specified by the expert knowledge.\n\n+ 输入层：$\\mathbf{h}=[\\mathbf{h}_1^H,\\cdots,\\mathbf{h}_K^H]^H\\in\\mathbb{C}^{NK\\times1}$-->I/Q transformation-->$[\\mathfrak{R}(\\mathbf{h}),\\mathfrak{I}(\\mathbf{h})]^T\\in\\mathbb{R}^{2\\times NK}$\n\n+ 本文，BN在CONV前进行\n+ MSE loss对异常值敏感，但数据集由仿真产生，故仍采用MSE\n+ 比起完全预测整个BF矩阵，专家知识可以有效减小需要预测的变量\n\n### P1（功率约束下SINR平衡）的网络——supervised\n\n通过$\\mathbf{h}$预测上行链路power allocation矢量$\\mathbf{\\hat q}$（最优值通过迭代获得【ai2-12】），再通过上行链路-下行链路二元性，得到下行链路的最优功率分配矢量$\\mathbf{p}^*$和BF矢量$\\mathbf{\\tilde W}^*$，有$\\mathbf{W}^*=\\mathbf{\\tilde W}^*\\mathbf{P}^*$\n\n![image-20211118171020326](image-20211118171020326.png)\n\n+ 除了最后一个激活函数为Sigmoid，其它均为ReLU\n\n+ Scaling——满足功率限制\n    $$\n    \\mathbf{\\hat q}^*=\\frac{P_{\\max}}{||\\mathbf{\\hat q}||_1}\\mathbf{\\hat q}\n    $$\n\n+ conversion——由$\\mathbf{\\hat q}^*$求$\\mathbf{\\hat W}^*$\n    ![image-20211119104539898](image-20211119104539898.png)\n\n+ Loss函数采用MSE度量\n\n### P2（服务质量约束下功率最小）的网络\n\n同样，通过$\\mathbf{h}$预测上行链路power allocation矢量$\\mathbf{\\hat q}$（最优值通过迭代获得【ai2-5】），再通过上行链路-下行链路二元性，得到下行链路的最优功率分配矢量$\\mathbf{p}^*$和BF矢量$\\mathbf{\\tilde W}^*$，有$\\mathbf{W}^*=\\mathbf{\\tilde W}^*\\mathbf{P}^*$。**但无功率约束，不需要上行链路power allocation矢量归一化。**\n\n+ conversion\n    ![image-20211119111841965](image-20211119111841965.png)![image-20211119111852718](image-20211119111852718.png)\n+ 与P1不同，当$\\mathbf{\\hat q}^*$与实际优化值$\\mathbf{q}^*$相差过大时，会导致$\\mathbf{\\hat p}^*$不符合物理规律从而导致波束成型不可行\n\n### P3（功率约束下SR最高）的网络\n\n![image-20211119150331158](image-20211119150331158.png)\n\nSum-rate优化问题没有最优解。\n\n+ **第一阶段**先通过监督学习逼近传统WMMSE算法的局部最优解，称为“预训练”\n    $$\n    Loss=\\frac{1}{2LK}\\sum_{l=1}^L\\left(\\left\\|\\mathbf{\\underline p}^{(l)}-\\mathbf{\\hat p}^{(l)}\\right\\|_2^2+\\left\\|\\boldsymbol{\\underline \\lambda}^{(l)}-\\boldsymbol{\\hat \\lambda}^{(l)}\\right\\|_2^2\\right)\n    $$\n    其中，$\\mathbf{p}$是BF的功率分配矢量，$\\boldsymbol{\\lambda}$是lagrange乘子，可以看作虚拟的功率分配矢量。\n\n+ **第二阶段**直接计算这个算法的优化目标函数作为loss，进行无监督学习。\n    $$\n    \\text { Loss }=-\\frac{1}{2 K L} \\sum_{l=1}^{L} \\underbrace{\\sum_{k=1}^{K} \\alpha_{k}^{(l)} \\log _{2}\\left(1+\\gamma_{k}^{u l,(l)}\\right)}_{sum-rate}\n    $$\n\n+ 分两个阶段的作用：显著增强学习效果，加快收敛。（杨神：？）\n\n+ scaling——满足功率约束，$2K$个参数\n    $$\n    \\mathbf{\\hat p}^*=\\frac{P_{\\max}}{||\\mathbf{\\hat p}||_1}\\mathbf{\\hat p}\\quad\\text{and}\\quad\\boldsymbol{\\hat \\lambda}^*=\\frac{P_{\\max}}{||\\boldsymbol{\\hat \\lambda}||_1}\\boldsymbol{\\hat \\lambda}\n    $$\n\n+ construction——$P_{\\max}$和$\\sum_{k=1}^K\\lambda_i=P_{\\max}$是lagrange对偶问题【ai2-2】\n    $$\n    \\hat{\\mathbf{w}}_{k}^{*}=\\sqrt{\\hat{p}_{k}^{*}} \\frac{\\left(\\mathbf{I}_{N}+\\sum_{k=1}^{K} \\frac{\\hat{\\lambda}_{k}^{*}}{\\sigma^{2}} \\mathbf{h}_{k} \\mathbf{h}_{k}^{H}\\right)^{-1} \\mathbf{h}_{k}}{\\left\\|\\left(\\mathbf{I}_{N}+\\sum_{k=1}^{K} \\frac{\\hat{\\lambda}_{k}^{*}}{\\sigma^{2}} \\mathbf{h}_{k} \\mathbf{h}_{k}^{H}\\right)^{-1} \\mathbf{h}_{k}\\right\\|_{2}}, \\quad \\forall k\n    $$\n\n### 仿真\n\n![image-20211120104337880](image-20211120104337880.png)\n\n### contributions\n\n+ 所提出的框架利用了专家知识，如上行链路和下行链路的二元性以及已知的最佳解决方案的结构。这种知识通过允许人们指定要学习的最佳参数来提高精简效率；这些参数通常不是波束成形矩阵条目。\n\n### 改进思路——针对SR的思考\n\n略\n\n---\n\n## Deep Learning Enabled Optimization of Downlink Beamforming Under Per-Antenna Power Constraints: Algorithms and Experimental Demonstration——2020-TWC\n\n三类DL处理的问题：\n\n+ One of the areas of interest is to deal with scenarios in which the channel\n    model does not exist, 传统信道模型不存在\n+ Another area of interest is to optimize the end-to-end system performance，对端到端系统的优化\n+ The third area of interest is to overcome the complexity of wireless networks，无线网络的复杂度问题\n\n\n\n在上一篇文章的基础上增加了单天线约束（过去大部分文章讨论MU-MISO，即基站多天线用户单天线问题）\n\n在基站侧单天线功率约束下，最大化最小接收信干噪比或平衡信干噪比\n\n——独立的非频选瑞利快衰落\n\n波束赋形矩阵：$\\mathbf{W}=[\\mathbf{w_1,w_2,\\cdots,w_K}]\\in\\mathbb{C}^{N_t\\times K}$。单天线约束为\n$$\np_n=\\left\\|\\mathbf{W}(n,:) \\right\\|^2=\\left\\|\\mathbf{e}_n\\mathbf{W} \\right\\|^2\n$$\n其中，$\\mathbf{e}_n$是除了第$n$个元素为1外的零矢量。\n\n### 单天线约束下的SINR balancing问题：\n\n$$\n\\begin{aligned}\n\\textbf { P1: } \\max _{\\mathbf{W}, \\Gamma} \\quad &\\Gamma  \\\\\n\\text { s.t. }\\quad&  \\gamma_{k} =\\frac{\\left|\\mathbf{h}_{k}^{T} \\mathbf{w}_{k}\\right|^{2}}{\\sum_{i=1, i \\neq k}^{K}\\left|\\mathbf{h}_{k}^{T} \\mathbf{w}_{i}\\right|^{2}+N_{0}} \\geq \\Gamma, \\quad \\forall k, \\\\\n& p_{n} =\\left\\|\\mathbf{e}_{n}^{T} \\mathbf{W}\\right\\|^{2} \\leq P_{n}, \\quad \\forall n .\n\\end{aligned}\n$$\n\n通过广义特征值算法，可以转化为问题P2\n$$\n\\begin{aligned}\n\\mathbf{P 2}:  \\max _{\\beta, \\boldsymbol{\\lambda}, \\boldsymbol{\\mu}}\\quad & \\beta \\\\\n \\text { s.t. } \\quad&\\beta \\lambda_{k} \\mathbf{h}_{k}^{T} \\mathbf{G}(\\boldsymbol{\\lambda}, \\boldsymbol{\\mu})^{-1} \\mathbf{h}_{k}^{*} \\leq 1, \\quad \\forall k, \\\\\n& \\sum_{k=1}^{K} \\lambda_{k} N_{0}=1, \\\\\n& \\sum_{n=1}^{N_{t}} \\mu_{n} P_{n}=1, \\\\\n& \\boldsymbol{\\lambda}, \\boldsymbol{\\mu}, \\beta \\geq \\mathbf{0} .\n\\end{aligned}\n$$\n其中，$\\mathbf{G}(\\boldsymbol{\\lambda}, \\boldsymbol{\\mu})\\triangleq\\sum_{i=1}^K\\lambda_i\\mathbf{h}_i^*\\mathbf{h}_i^T+diag(\\boldsymbol{\\mu})$，\n\n+ $\\boldsymbol{\\lambda}\\in\\mathbb{Z}^K$与SINR约束相关,\n+ $\\boldsymbol{\\mu}\\in\\mathbb{Z}^{N_t}$与单天线约束相关，\n\n$\\beta=1+\\frac{1}{\\Gamma}$。\n\nThe optimal downlink beamforming problem **P2** with per-antenna power constraints can be solved via a dual uplink channel in which the SINR constraints remain the same and the noise is uncertain. 通过对偶性转化成上行链路问题P3$\\max_{\\boldsymbol{\\mu}}\\max_{\\Gamma,\\boldsymbol{\\lambda}} \\Gamma$ ，P3是两个max嵌套，内层的max是$\\mathbf{u}$的函数，先求解内层问题P4$f(\\mathbf{u})=\\max_{\\Gamma,\\boldsymbol{\\lambda}} \\Gamma$，再通过subgradient算法，求解外层关于$\\boldsymbol{\\mu}$的问题。\n\n![image-20211121155315628](image-20211121155315628.png)\n\n\n\n### 流程\n\ntwo strategies：\n\n+ one is to learn the dual variables ***μ*** and ***λ*** with fast recovery of the original beamforming solution,——算法类似A2，但不需要更新\n+ the other is to learn only the dual variable ***μ*** with improved learning accuracy, to achieve various tradeoffs.——只通过神经网络估计$\\boldsymbol{\\mu}$，而$\\boldsymbol{\\lambda}$通过算法1求解，可以更精确\n\nDL结构的一般性：由于用户数量$K$和发射天线数量$N_t$会发生变化，所以要采取相应措施保证其泛化能力。\n\n+ Transfer learning——【ai3-52】\n+ training set augmentation（训练集扩大）——训练集中样本的$N_t,K$不固定，但是输入输出固定为$2\\times N_t'K'$和$K'$ ， $N_t'>N_t,K'>K$，多的补零。（杨神：？）\n\n### 仿真\n\n本文提出的和优化算法针对信道估计误差是鲁棒的。\n\n当$N_t\\geq K$则ZF需要解决复杂度更高的SOCP问题。\n\n### Contributions\n\n+ 提出了subgradient算法，收敛更快\n+ 提出了学习双变量的DL框架\n+ 开发了一种启发式算法，通过数据augmentation适应不同的用户数和天线数，提高泛化能力（？）\n+ testbed实验\n\n---\n\n## IAIDNN——2021-TWC\n\n*Iterative Algorithm Induced Deep-Unfolding Neural Networks: Precoding Design for Multiuser MIMO Systems*\n\n> 本文部分链接和引用没法用，链接的是预编码论文阅读（一）中迭代的那篇文章“*An Iteratively Weighted MMSE Approach to Distributed Sum-Utility Maximization for a MIMO Interfering Broadcast Channel*”\n\n建模同文章“*An Iteratively Weighted MMSE Approach to Distributed Sum-Utility Maximization for a MIMO Interfering Broadcast Channel*”\n\n![image-20211104143313382](https://z3.ax1x.com/2021/11/08/I8Sr9A.png)\n\n### 深度展开网络的搭建\n\n+ 优化问题（目标函数）：\n    $$\n    \\min_\\mathbf{X}\\quad \\mathbb{E}_\\mathbf{Z}\\{f(\\mathbf{X};\\boldsymbol{\\theta},\\mathbf{Z})\\},\\quad\\text{s.t.}\\ \\mathbf{X}\\in\\mathcal{X}\n    $$\n    其中，$\\boldsymbol{\\theta}$是可以训练的参数，$\\mathbf{X}$是变量，$\\mathbf{Z}$是随机参数\n\n+ 前向传播：\n    $$\n    \\mathbf{X}^l=\\mathcal{F}_l(\\mathbf{X}^{l-1};\\boldsymbol{\\theta},\\mathbf{Z})\n    $$\n    在本文中，前向传播的模型为\n    $$\n    \\mathbf{X}^l=\\bar{\\mathbf{A}}\\mathbf{X}^{l-1}\\bar{\\mathbf{B}}\\mathbf{X}^{l-1}\\bar{\\mathbf{C}}+\\varphi(\\bar{\\mathbf{A}}\\mathbf{X}^{l-1}\\bar{\\mathbf{B}}\\mathbf{X}^{l-1}\\bar{\\mathbf{C}})\\bar{\\mathbf{D}}\n    $$\n\n+ 反向传播：GCR in Matrix Form（更一般的链式法则）\n    $$\n    \\begin{aligned}\n    &\\operatorname{Tr}\\left\\{\\mathbf{G}^{l} d \\mathbf{X}^{l}\\right\\} \\\\\n    &\\stackrel{(5)}{=} \\operatorname{Tr}\\left\\{\\left(\\overline{\\mathbf{B}} \\mathbf{X}^{l-1} \\overline{\\mathbf{C}} \\mathbf{G}^{l}\\left(\\overline{\\mathbf{D}} \\circ \\varphi^{\\prime}\\left(\\overline{\\mathbf{A}} \\mathbf{X}^{l-1} \\overline{\\mathbf{B}} \\mathbf{X}^{l-1} \\overline{\\mathbf{C}}\\right)^{T}+\\mathbf{I}\\right) \\overline{\\mathbf{A}}\\right.\\right. \\\\\n    &\\left.\\left.\\quad+\\overline{\\mathbf{C}} \\mathbf{G}^{l}\\left(\\overline{\\mathbf{D}} \\circ \\varphi^{\\prime}\\left(\\overline{\\mathbf{A}} \\mathbf{X}^{l-1} \\overline{\\mathbf{B}} \\mathbf{X}^{l-1} \\overline{\\mathbf{C}}\\right)^{T}+\\mathbf{I}\\right) \\overline{\\mathbf{A}} \\mathbf{X}^{l-1} \\overline{\\mathbf{B}}\\right) d \\mathbf{X}^{l-1}\\right\\}\n    \\end{aligned}\n    $$\n    $\\mathbf{G}^l$是$\\mathbf{X}^l$的梯度，$\\circ$是element-wise。\n\n+ **该网络的创新点：**In comparison with applying the platforms such as “Pytorch” and “Tensorflow” to do the BP, the GCR has three advantages\n\n    + The platforms cannot do BP for the complex trainable parameters;\n    + There are some operations these platforms cannot do, such as the inversion and the determinant of a complex matrix; \n    + Based on the GCR, the closed-form gradients are obtained, which is more accurate and provides faster convergence speed compared with the automatic differential of the platforms.\n    + **Then, based on the GCR presented in Theorem 1, the gradient in each layer, i.e., $\\{\\mathbf{G}^l,l\\in\\mathcal{L}\\}$ is obtained. Finally, the gradient of trainable parameter $\\boldsymbol{\\theta}^l$ is calculated based on $\\mathbf{G}^l$.**\n\n\n### IWMMSE算法的转换\n\n将功率限制，考虑到$\\eqref{eq:2-1}$的目标函数中，考虑无约束的SR问题(13)\n$$\n\\begin{aligned}\n\\max _{\\left\\{\\mathbf{V}_{k}\\right\\}} \\quad& \\sum_{k=1}^{K} \\omega_{k} \\log \\operatorname{det}\\left(\\mathbf{I}+\\mathbf{H}_{k} \\mathbf{V}_{k} \\mathbf{V}_{k}^{H} \\mathbf{H}_{k}^{H}\\right.\\\\\n&\\left.\\left(\\sum_{m \\neq k} \\mathbf{H}_{k} \\mathbf{V}_{m} \\mathbf{V}_{m}^{H} \\mathbf{H}_{k}^{H}+\\frac{\\sigma_{k}^{2}}{P_{T}} \\sum_{n=1}^{K} \\operatorname{Tr}\\left(\\mathbf{V}_{n} \\mathbf{V}_{n}^{H}\\right) \\mathbf{I}\\right)^{-1}\\right)\n\\end{aligned}\n$$\n式$\\eqref{eq:ai4-13}$的最优解$\\mathbf{V}^{\\star\\star}$和式$\\eqref{eq:2-1}$的最优解$\\mathbf{V}^{\\star}$存在关系:\n$$\n\\mathbf{V}_k^{\\star}=\\alpha\\mathbf{V}_k^{\\star\\star},\\quad\\alpha=\\frac{\\sqrt{P_T}}{\\left(\\sum_{k=1}^K Tr(\\mathbf{V}_k^{\\star\\star}(\\mathbf{V}_k^{\\star\\star})^H) \\right)^{\\frac12}}\n$$\n进一步考虑，MMSE问题和WSR问题的同一性，将问题就转换成了无约束的MMSE问题\n$$\n\\min _{\\left\\{\\mathbf{W}_{k}, \\mathbf{U}_{k}, \\mathbf{V}_{k}\\right\\}} \\sum_{k=1}^{K} \\omega_{k}\\left(\\operatorname{Tr}\\left(\\mathbf{W}_{k} \\mathbf{E}_{2, k}\\right)-\\log \\operatorname{det}\\left(\\mathbf{W}_{k}\\right)\\right)\n$$\n其中，\n$$\n\\begin{aligned}\n&\\mathbf{E}_{2, k} \\triangleq\\left(\\mathbf{I}-\\mathbf{U}_{k}^{H} \\mathbf{H}_{k} \\mathbf{V}_{k}\\right)\\left(\\mathbf{I}-\\mathbf{U}_{k}^{H} \\mathbf{H}_{k} \\mathbf{V}_{k}\\right)^{H} \\\\\n&+\\sum_{m \\neq k} \\mathbf{U}_{k}^{H} \\mathbf{H}_{k} \\mathbf{V}_{m} \\mathbf{V}_{m}^{H} \\mathbf{H}_{k}^{H} \\mathbf{U}_{k}+\\frac{\\sum_{n=1}^{K} \\operatorname{Tr}\\left(\\mathbf{V}_{n} \\mathbf{V}_{n}^{H}\\right)}{P_{T}} \\sigma_{k}^{2} \\mathbf{U}_{k}^{H} \\mathbf{U}_{k}\n\\end{aligned}\n$$\n算法流程图：\n\n![image-20211123150620802](image-20211123150620802.png)\n\n![image-20211123150646333](image-20211123150646333.png)\n\n与上述分析的深度展开网络中参数的对照：\n$$\n\\begin{aligned}\n\\mathbf{X}\\equiv&\\left\\{\\mathbf{W}_k,\\mathbf{U}_k,\\mathbf{V}_k,\\forall k\\in\\mathcal{K} \\right\\}\\\\ \n\\mathbf{Z}\\equiv&\\left\\{\\mathbf{H}_k,\\omega_k,\\sigma_k,P_T,\\forall k\\in\\mathcal{K} \\right\\}\n\\end{aligned}\n$$\n迭代过程：\n$$\n\\begin{aligned}\n\\mathbf{U}^t=&F_t(\\mathbf{V}^{t-1})\\\\\n\\mathbf{W}^t=&G_t(\\mathbf{U}^t,\\mathbf{V}^{t-1})\\\\ \n\\mathbf{V}^t=&J_t(\\mathbf{U}^t,\\mathbf{W}^t)\n\\end{aligned}\n$$\n\n### IAIDNN(iterative algorithm induced Deep-Unfolding Neural Network)\n\n#### 前向传播\n\n+ 减小矩阵求逆的计算量的两种途径\n    + 用$\\mathbf{A}^+=(\\mathbf{A}\\circ\\mathbf{I})^{-1}$逼近$\\mathbf{A}^{-1}$，因为对角元比非对角元大得多=>训练$\\mathbf{A^+X}$中的$\\mathbf{X}$\n    + 用$\\mathbf{A}^{-1}$的一阶taylor展开$2\\mathbf{A}_0^{-1}-\\mathbf{A}_0^{-1}\\mathbf{AA}_0^{-1}$逼近=>训练$\\mathbf{AY+Z}$中的$\\mathbf{Y,Z}$\n    + 【？】用$\\mathbf{A^+X+AY+Z}$来逼近$\\mathbf{A}^{-1}$\n+ 迭代算法中$\\mathbf{U,W,V}$的估计均用此法估计，同时$\\mathbf{U,V}$的估计还有训练补偿(offset)$\\left\\{\\mathbf{O}_k^{u,l+1},\\mathbf{O}_k^{v,l+1} \\right\\}$\n+ $\\mathbf{V}$的维数比$\\mathbf{U,W}$的维数大得多，将$\\mathbf{U,W}$作为网络的输出，将$\\mathbf{V}$对$\\mathbf{U,W}$的表达式作为网络的Loss\n    ![image-20211124123855835](image-20211124123855835.png)\n+ Loss函数：\n\n$$\n\\max _{\\left\\{\\mathbf{V}_{k}\\right\\}} \\sum_{k=1}^{K} \\mathbb{E}_{\\mathbf{H}_{k}}\\left\\{\\omega_{k} \\log \\operatorname{det}\\left(\\mathbf{I}+\\mathbf{H}_{k} \\mathbf{V}_{k} \\mathbf{V}_{k}^{H} \\mathbf{H}_{k}^{H}\\left(\\sum_{m \\neq k} \\mathbf{H}_{k} \\mathbf{V}_{m} \\mathbf{V}_{m}^{H} \\mathbf{H}_{k}^{H}+\\frac{\\sigma_{k}^{2}}{P_{T}} \\sum_{k} \\operatorname{Tr}\\left(\\mathbf{V}_{k} \\mathbf{V}_{k}^{H}\\right) \\mathbf{I}\\right)^{-1}\\right)\\right\\}\n$$\n\n#### 反向传播\n\n**反向传播不直接对训练参数进行计算，而先对中间的迭代变量进行计算！**\n\n+ 对迭代变量$\\mathbf{U,W,V}$的梯度：\n    + 最后一层由目标函数代入$\\mathbf{V}_k^L$的表达式，对$\\mathbf{U_k^L,W_k^L}$求梯度$\\mathbf{G_k^{u,L}},\\mathbf{G_k^{v,L}}$\n    + 中间层由GCR算法，从$l+1$层的对$\\mathbf{U,W,V}$的梯度计算得到$l$层的梯度\n+ 进一步通过链式法则求解出训练参数的梯度\n    ![image-20211124164004293](image-20211124164004293.png)\n+ 采取梯度下降方法训练网络\n+ 初始值的选定：训练参数随机初始化；$\\mathbf{V}^0_k$用ZF初始化\n\n#### 算法流程\n\n![image-20211124131151072](image-20211124131151072.png)\n\n![image-20211124131216620](image-20211124131216620.png)\n\n### benchmark——CNN\n\n类似【ai2】，\n\n+ 输入：$\\mathbf{H}\\triangleq [\\mathbf H_1^T,\\mathbf H_2^T,\\cdots,\\mathbf H_k^T]^T$\n+ 输出：$\\mathbf{U_k,W_k}$\n+ 流程：\n    + 监督：先逼近传统的WMMSE，用求$\\mathbf{U,W}$的MSE作为loss\n    + 无监督：再用代入$\\mathbf V_k$的SR作为loss\n\n### 分析\n\n+ 参数\n\n    + IAIDNN的参数维度取决于需要训练的参数$\\left\\{\\mathbf X_k^{u,l},\\mathbf Y_k^{u,l},\\mathbf Z_k^{u,l},\\mathbf O_k^{u,l}\\right\\}$,$\\left\\{\\mathbf X_k^{w,l},\\mathbf Y_k^{w,l},\\mathbf Z_k^{w,l}\\right\\}$,$\\left\\{\\mathbf X_k^{v,l},\\mathbf Y_k^{v,l},\\mathbf Z_k^{v,l},\\mathbf O_k^{v,l}\\right\\}$，最后一层无$\\mathbf V$相关的参数\n        $$\n        \\begin{aligned}\n        \\text{普通中间层：}&\\left(3 N_{r}^{2}+3 d^{2}+3 N_{t}^{2}+d N_{r}+d N_{t}\\right) K\\\\\n        \\text{最后一层：}&L K\\left(3 N_{r}^{2}+3 d^{2}+d N_{r}\\right)+(L-1) K\\left(3 N_{t}^{2}+d N_{t}\\right)\n        \\end{aligned}\n        $$\n\n    + CNN\n        $$\n        \\sum_{l=1}^{L-2} S_{l}^{2} C_{l-1} C_{l}+K N_{r} N_{t} C_{L-2} C_{\\text {out }}\n        $$\n        卷积核$S_l=5$，通道数$C_l=32$，全连接层输出$C_{out}=1024$\n\n+ 复杂度\n\n    + 传统WMMSE需要迭代$L_W$次，但IAIDNN只有$L_a$层，$L_a\\ll L_w$\n    + 相比传统的矩阵求逆需要$\\mathcal{O}(n^3)$，本文中的近似只需要$\\mathcal{O}(n^{2.37})$\n    + IAIDNN的闭式梯度比传统黑箱CNN训练时间更短、效果更好\n\n+ 泛化能力\n\n    + 同【ai3】可以训练$(N_{t0},N_{r0},K_0)$的网络，但实际情景$(N_{t1},N_{r1},K_1)$时，$(N_{t1}<N_{t0},N_{r1}<N_{t0},K_1<K_{0})$也是可行的（这篇文章我觉得时可行的，因为都是矩阵运算）\n    + 同【ai1】可以训练在不同$P_T,\\sigma_k$环境下的$\\mathbf V$，以增强鲁棒性\n\n\n\n### Contributions\n\n+ We propose a framework for deep-unfolding, where the general form of IAIDNN is developed in matrix form to better solve the problems in communication systems. To train the IAIDNN, **the GCR is proposed to calculate the gradients of the trainable parameters.**\n+ We implement the proposed deep-unfolding framework to solve the sum-rate maximization problem for precoding design in MU-MIMO systems. Based on the structure of the iterative WMMSE algorithm, an efficient IAIDNN is developed, where **the iterative WMMSE algorithm is unfolded into a layer-wise structure.**\n+ We analyze the computational complexity and generalization ability of the proposed schemes. Simulation results show that the proposed IAIDNN efficiently achieves the performance of the iterative WMMSE algorithm with reduced computational complexity. The contribution becomes more significant in a massive MU-MIMO system.\n\n> 1. model-driven\n> 2. 反向传播——矩阵形式的广义链式法则\n\n---\n\n## DL-DSC-FDD-Massive-MIMO——2021-TWC\n\n*Deep Learning for Distributed Channel Feedback and Multiuser Precoding in FDD Massive MIMO*——imperfect CSI\n\nMU-MISO\n$$\n\\begin{aligned}\n\\underset{\\tilde{\\mathbf{X}},\\left\\{\\mathcal{F}_{k}(\\cdot)\\right\\}_{\\forall k}, \\mathcal{P}(\\cdot)}{\\operatorname{maximize}} \\quad & \\sum_{k=1}^{K} \\log _{2}\\left(1+\\frac{\\left|\\mathbf{h}_{k}^{H} \\mathbf{v}_{k}\\right|^{2}}{\\sum_{j \\neq k}\\left|\\mathbf{h}_{k}^{H} \\mathbf{v}_{j}\\right|^{2}+\\sigma^{2}}\\right) \\\\\n\\text { subject to } \\quad & \\mathbf{V}=\\mathcal{P}\\left(\\left[\\mathbf{q}_{1}^{T}, \\ldots, \\mathbf{q}_{K}^{T}\\right]^{T}\\right) \\\\\n& \\mathbf{q}_{k}=\\mathcal{F}_{k}\\left(\\mathbf{h}_{k}^{H} \\widetilde{\\mathbf{X}}+\\widetilde{\\mathbf{z}}_{k}\\right), \\quad \\forall k \\\\\n& \\operatorname{Tr}\\left(\\mathbf{V} \\mathbf{V}^{H}\\right) \\leq P \\\\\n&\\left\\|\\widetilde{\\mathbf{x}}_{\\ell}\\right\\|_{2}^{2} \\leq P, \\quad \\forall \\ell\n\\end{aligned}\n$$\n其中，$\\tilde{\\mathbf{X}}$是下行链路训练导频，$\\mathcal{F}_k:\\mathbb{C}^{1\\times L}\\to \\{\\pm 1\\}^B$表示第$k$个用户的反馈策略，$\\mathbf{q}_k$是$B$位反馈比特用于帮助设计预编码矩阵。$\\mathcal{P}:\\{\\pm 1\\}^{KB}\\to \\mathbb{C}^{M\\times K}$表示下行链路预编码策略。\n\n分布式信源编码\n\n![image-20211125143320423](image-20211125143320423.png)\n\n### 网络结构\n\n![image-20211125143541320](image-20211125143541320.png)\n\n1. downlink training and uplink feedback phase\n2. downlink data transmission phase\n\n### 流程\n\n#### 前向传播\n\n+ Downlink Pilot Training：训练参数$\\widetilde{\\mathbf X}$\n\n    + 作为全连接层，训练导频$\\tilde{\\mathbf{X}}$看成权重矩阵，bias看作0，加上一个$\\sigma^2$的加性噪声\n\n+ Uplink Feedback：（用户侧）参数$\\Theta_\\text{R}^{(k)}=\\left\\{\\mathbf W_r^{(k)},\\mathbf b_r^{(k)} \\right\\}_{r=1}^R$\n\n    + 输入：\n        $$\n        \\bar{\\mathbf y}_k\\triangleq[\\Re{(\\tilde{\\mathbf y}_k)},\\mathcal{I} (\\tilde{\\mathbf y}_k)]\n        $$\n\n    + 中间层采用ReLU，最后一层用符号函数\n        $$\n        \\mathbf{q}_k=sgn\\left(\\mathbf W_R^{(k)}\\sigma_{R-1}\\left(\\cdots\\sigma_1\\left(\\mathbf W_1\\bar{\\mathbf y}_k+\\mathbf b_1^{(k)}\\right)\\cdots\\right)+\\mathbf b_R^{(k)}\\right)\n        $$\n\n+ Downlink Precoding Design:    （BS侧）参数$\\Theta_\\text{T}=\\left\\{\\mathbf W_t,\\mathbf b_t \\right\\}_{t=1}^T$\n\n    + 输出：\n        $$\n        \\mathbf v=\\left[vec(\\Re{(\\mathbf V)})^T,vec(\\mathcal{I} (\\mathbf V))^T\\right]T\n        $$\n\n    + 中间层采用ReLU，最后一层则需要功率约束，对功率进行归一化$\\tilde\\sigma_T(\\bullet)=\\sqrt{P}\\frac{\\bullet}{\\left\\|\\bullet\\right\\|_2}$\n        $$\n        \\mathbf v=\\tilde \\sigma_{T}\\left(\\tilde{\\mathbf W}_T^{(k)}\\tilde \\sigma_{T-1}\\left(\\cdots\\tilde \\sigma_1\\left(\\tilde {\\mathbf W}_1\\bar{\\mathbf y}_k+\\tilde{\\mathbf b}_1^{(k)}\\right)\\cdots\\right)+\\tilde{\\mathbf b}_T^{(k)}\\right)\n        $$\n\n+ Loss函数：对信道矩阵$\\mathbf H$和下行链路训练阶段的噪声$\\tilde{\\mathbf z}$做期望\n    $$\n    \\max _{\\tilde{\\mathbf{x}},\\{\\Theta_{\\mathrm{R}}^{(k)}\\}_{k=1}^{K}, \\Theta_{\\mathrm{T}}} \\mathbb{E}_{\\mathbf{H}, \\tilde{\\mathbf z}}\\left[\\sum_{k} \\log _{2}\\left(1+\\frac{\\left|\\mathbf{h}_{k}^{H} \\mathbf{v}_{k}\\right|^{2}}{\\sum_{j \\neq k}\\left|\\mathbf{h}_{k}^{H} \\mathbf{v}_{j}\\right|^{2}+\\sigma^{2}}\\right)\\right]\n    $$\n\n#### 反向传播\n\n+ 随机梯度下降SGD\n\n+ 针对用户侧最后一步二值化，采用slope annealing(斜率退火)的sigmoid-adjusted straight-through(sigmoid调节直通)——用sigmoid函数去表示二值函数，从而使其可微\n    $$\n    sgn(u)\\to 2\\,\\mathrm{sigmoid}(\\alpha^{(i)}u)-1=\\frac{2}{1+\\exp(-\\alpha^{i}u)}-1\n    $$\n    其中，$\\alpha^{(i)}$是第$i$个epoch中的退火因子，$\\alpha^{(i)}\\geq\\alpha^{(i-1)}$\n\n####  算法流程\n\n![image-20211126103118589](image-20211126103118589.png)\n\n+ 用户侧和BS侧均为$R=T=4$层网络，用户侧$[1024,512,256,B]$，BS侧$[1024,512,512,2MK]$\n\n### 泛化能力（🌟）\n\n+ B（反馈的编码位数）\n    + 用户侧通过tanh输出$S$个$[-1,1]$间的软二进制值，通过一定的$Q-bit$量化方式，传送到BS侧（$B=S\\times Q$，原来是传递B位二进制值，现在改为S位Q进制值）——相当于在用户侧DNN输出后加了个量化器\n    + BS侧根据$KS$个Q进制量化的值，映射到$M\\times K$的预编码矩阵（原来是通过$KB$个二进制$\\{\\pm1\\}$量化值映射到$M\\times K$的预编码矩阵）\n+ K（用户数量）\n    + 每个用户信道分布i.i.d.，则只需要训练一个用户侧的DNN\n    + 分两个阶段：先利用单用户系统，训练导频$\\tilde{\\mathbf X}$和用户侧的网络；再针对多用户系统（训练导频和用户侧网络复制）训练BS侧网络。\n\n### 仿真\n\n#### 基准算法\n\n![image-20211126131819631](image-20211126131819631.png)\n\n+ 训练的DNN具备减小频分双工多用户系统用户间干扰的能力\n+ 先估计后量化信道参数是有限导频长度下的次优解\n+ 导频长度长，能逼近最优解，且本文方法的SR一般更高\n\n#### $L_p$的泛化能力\n\n+ 训练集和测试集的不匹配，会导致表现恶化\n+ 在更大范围的信道参数上训练DNN，能在无关于信道参数的先验条件时帮助我们设计更鲁棒的网络。\n\n#### $B$的泛化能力\n\n通过上面的设计，只有微不足道的损失。但同时能帮助神经网络提升在反馈容量方面的泛化能力。\n\n#### $K$的泛化能力\n\n+ DNN远好于其它有限下行链路训练资源\n+ 两步实现和end-to-end差异不大\n\n","tags":["深度学习","无线通信","MIMO","预编码"],"categories":["科研向"]},{"title":"【预编码论文阅读（一）】传统方法","url":"/2021/12/08/precoding-1/","content":"\n# 预编码论文阅读（一）——传统方法\n\n> 由于没有非常系统地看完MIMO的相关内容，整理中必定有很多的问题，欢迎在评论区批评指正。\n>\n> 整理很乱。。。\n>\n> 由于网页公式渲染器KaTeX不支持公式交叉引用，我的前端水平就不足以把我这个模板加入mathjax。故将所有公式交叉引用均删除了，有的是在显示不出来的建议贴到markdown里面去吧\n\n\n\n## 线性预编码\n\n[大规模MIMO下行链路预编码（1）_月半 月半的博客-CSDN博客](https://blog.csdn.net/weixin_43871127/article/details/104593325)\n\n[大规模MIMO下行链路预编码（2）_月半 月半的博客-CSDN博客](https://blog.csdn.net/weixin_43871127/article/details/104722688)\n\n### MRT预编码\n\n由于可以平衡系统性能和计算复杂度，最大比传输（MRT）预编码【又称作匹配滤波器（MF）预编码】是最简单易实现的预编码算法，通过最大化接收信噪比（SNR）实现。在大规模MIMO系统中，当基站天线数M MM足够大时，最简单的MRT线性预编码方案便可以得到最优的系统性能。\n\n在发射端已知完美信道状态信息的前提下，MRT线性预编码矩阵为：\n$$\n\\mathbf V=\\beta_{MRT}\\mathbf H^H\n$$\n(注：以上编码矩阵后可以加上功率分配矩阵组成整个预编码矩阵)\n\n式中，  $\\beta_{MRT}=\\sqrt{\\frac{1}{tr(HH^H )}}$  为约束基站发送功率的约束因子。大规模MIMO系统中基站天线数的不断增加使得信道矩阵列向量之间逐渐呈现正交性，即不同终端间的干扰逐渐降低甚至被完全消除，因此最简单的 MRT 预编码下便可以获得最优的频谱效率和最好的信号传输质量，且复杂度最低。\n\n传统MIMO系统中，匹配滤波预编码方案的侧重点在于接收端用户的信号增益最大化，**但在多用户系统的场景下，随着传输信道相关性的提升，此方案由于没有考虑如何对用户间的干扰进行处理，将会导致整个系统性能快速下降**。\n\n### Zero-forcing precoding\n\n转化为互相独立的并行信道，不考虑其它信道的干扰。${\\bf h}_i^H\\tilde{\\bf w}_j=0,i\\neq j$(5)——achieve virtually optimal\n$$\n\\mathbf{W}_{\\mathrm{ZF}}=\\mathbf{H}^{H}\\left(\\mathbf{H} \\mathbf{H}^{H}\\right)^{-1}\n$$\n\n#### Equal power scaling allocation(ZF-EPS)\n\n平均分配能量——normalized=power allocate\n$$\n\\begin{gathered}\n\t\\tilde{\\bf w}_i=\\eta{\\bf w}_i\\\\\n    \\eta=\\sqrt{\\frac{P}{tr\\{\\mathbf{W}_{\\mathrm{ZF}}\\mathbf{W}_{\\mathrm{ZF}}^H\\}}}\n\\end{gathered}\n$$\n\n#### Optimal power allocation - water-filling solution(ZF-WF)\n\n信噪比高的多分配能量\n$$\n\\begin{aligned}\n&\\operatorname{maximize}_{p_{1}, \\ldots, p_{K}} &\\sum_{i=1}^{K} \\log \\left(1+\\rho_{i} p_{i}\\right) \\\\\n&\\text { subject to } & \\sum_{i=1}^{K} \\gamma_{i} p_{i} \\leq P , p_{i} \\geq 0\n\\end{aligned}\n$$\n其中，$\\gamma_i=[({\\bf HH}^H)^{-1}]$。注水法功率控制(6)——$\\eta_i=\\sqrt{p_i}$\n$$\np_i=\\left[\\frac{\\mu}{\\gamma_i}-\\frac{1}{\\rho_i}\\right]^+,\\forall i\n$$\n其中， $[x]^+=max(x,0)$ ， 总功率限制\n$$\n\\sum_{i=1}^K=\\left[\\mu-\\gamma_i\\rho_i^{-1}\\right]^+=P\n$$\n\n### Regularized zero-forcing precoding(RZF)\n\n$(\\mathbf{H} \\mathbf{H}^{H})^{-1}$最大奇异值的不良性质，即使增加天线，也无法增加最大速率。加入正则项，(7)\n$$\n\\mathbf{W}_{\\mathrm{RZF}}=\\mathbf{H}^{H}\\left(\\mathbf{H} \\mathbf{H}^{H}+\\alpha \\mathbf{I}\\right)^{-1}\n$$\n\n$$\n\\begin{gathered}\n\t\\tilde{\\bf W}=\\eta{\\bf W}_\\text{RZF}\\\\\n    \\eta=\\sqrt{\\frac{P}{tr\\{\\mathbf{W}_{\\mathrm{RZF}}\\mathbf{W}_{\\mathrm{RZF}}^H\\}}}\n\\end{gathered}\n$$\n\n1. homogeneous SNR conditions（$\\rho_i=1$）\n\n$$\n    \\alpha^{\\star}=\\frac KP\n$$\n\n2. non-homogeneous SNR conditions——non-weighted sum-MSE minimization(9)\n    $$\n    \\mathbf{W}_{\\mathrm{RZF}}=\\mathbf{H}^{H}\\left(\\mathbf{HH}^{H}+\\frac{\\sum_{i=1}^{K}\\left(1 / \\rho_{i}\\right)}{P} \\mathbf{I}\\right)^{-1}\n    $$\n\n### Iterative weighted minimization ofmean squared error algorithm(IWMMSE)\n\n解决非凸问题的数值算法。weighted MSE problem(10)\n$$\n\\begin{aligned}\n&\\underset{\\Lambda, \\Omega, \\tilde{\\mathbf{W}}}{\\operatorname{minimize}} \\mathbb{E}\\left\\{\\left\\|\\Omega^{\\frac{1}{2}}(\\mathbf{u}-\\Lambda \\mathbf{y})\\right\\|^{2}\\right\\}-\\log \\operatorname{det} \\Omega \\\\\n&\\text { subject to } \\operatorname{Tr}\\left\\{\\tilde{\\mathbf{W}} \\tilde{\\mathbf{W}}^{H}\\right\\} \\leq P\n\\end{aligned}\n$$\n其中，$\\mathbf{\\Omega},\\mathbf{\\Lambda}$均为对角阵，$\\mathbf{\\Omega}$表示K个UE的权重(weights)，$\\mathbf{\\Lambda}$表示接收因子(receive coefficients)。$\\tilde{\\mathbf{W}},\\mathbf{\\Omega},\\mathbf{\\Lambda}$是优化变量。\n\nS1：随机初始化变量\n$$\n||\\tilde{\\mathbf{w}}_i||^2=\\frac PK\n$$\nS2：迭代直到convergence\n\n+ 确定$\\tilde{\\mathbf{W}},\\mathbf{\\Omega}$，优化$\\mathbf{\\Lambda}$(11)\n    $$\n    \\begin{aligned}\n    \\lambda_{i} &=\\arg \\min _{\\lambda_{i}} \\mathbb{E}\\left\\{\\left|u_{i}-\\lambda_{i} y_{i}\\right|^{2}\\right\\} \\\\\n    &=\\left(\\sum_{j=1}^{K} \\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{j}\\right|^{2}+1\\right)^{-1} \\sqrt{\\rho_{i}} \\tilde{\\mathbf{w}}_{i}^{H} \\mathbf{h}_{i} .\n    \\end{aligned}\n    $$\n\n+ 确定$\\tilde{\\mathbf{W}},\\mathbf{\\Lambda}$，优化$\\mathbf{\\Omega}$(12)\n    $$\n    \\begin{aligned}\n    \\omega_{i} &=\\arg \\min _{\\omega_{i}} \\omega_{i} e_{i}-\\log \\omega_{i} \\\\\n    &=e_{i}^{-1}=1+\\operatorname{SINR}_{i}=\\frac{\\sum_{j=1}^{K} \\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{j}\\right|^{2}+1}{\\sum_{j \\neq i}^{K} \\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{j}\\right|^{2}+1}\n    \\end{aligned}\n    $$\n\n+ 确定$\\mathbf{\\Omega},\\mathbf{\\Lambda}$，优化$\\tilde{\\mathbf{W}}$(14)\n    $$\n    \\begin{aligned}\n    \\tilde{\\mathbf{W}} &=\\left(\\mathbf{H}^{H} \\Lambda^{H} \\Omega \\Sigma \\Lambda \\mathbf{H}+\\mu \\mathbf{I}\\right)^{-1} \\mathbf{H}^{H} \\Lambda^{H} \\Omega \\Sigma^{\\frac{1}{2}} \\\\\n    &=\\mathbf{H}^{H}\\left[\\mathbf{H} \\mathbf{H}^{H}+\\mu\\left(\\Lambda^{H} \\Omega \\Sigma \\Lambda\\right)^{-1}\\right]^{-1} \\Lambda^{-1} \\Sigma^{-\\frac{1}{2}}\n    \\end{aligned}\n    $$\n\n## WMMSE【数字预编码】——2014\n\n*MMSE precoding for multiuser MISO downlink transmission with non-homogeneous user SNR conditions*\n\nMU-MISO模型（M天线、K用户）\n\n$\\bf u$是向量，每次给$UE_i$发送的是单个字符$u_i$——多用户\n$$\n\\begin{gathered}\n\\mathbf{y}=\\mathbf{\\Sigma}^{\\frac 12}\\mathbf{H\\tilde Wu}+\\mathbf{n}\\\\\n\\mathbf{x}=\\sum_{i=1}^K\\tilde{\\mathbf{w}}_iu_i=\\mathbf{u\\tilde W}\n\\end{gathered}\n$$\n其中，$\\mathbf{\\Sigma}=\\mathrm{diag}(\\rho_1,\\cdots,\\rho_K)$是对角阵，表示非同质信噪比条件的差异；$\\mathbf{H}=[\\mathbf{h}_1,\\cdots,\\mathbf{h}_K]^H$；$\\tilde{\\mathbf{W}}=[\\tilde{\\mathbf{w}}_1,\\cdots,\\tilde{\\mathbf{w}}_K]$ ， $u=[u_1,\\cdots,u_K]^T$\n\nSINR（信干噪比）\n$$\n\\mathrm{SINR}_i=\\frac{\\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{i}\\right|^{2}}{\\sum_{j \\neq i}^{K} \\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{j}\\right|^{2}+1} \n$$\nsum-rate的优化问题——非凸问题\n$$\n\\begin{aligned}\n&\\underset{\\tilde{\\mathbf{w}}_{1}, \\ldots, \\tilde{\\mathbf{w}}_{K}}{\\operatorname{maximize}} \\sum_{i=1}^{K} \\log \\left(1+\\frac{\\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{i}\\right|^{2}}{\\sum_{j \\neq i}^{K} \\rho_{i}\\left|\\mathbf{h}_{i}^{H} \\tilde{\\mathbf{w}}_{j}\\right|^{2}+1}\\right) \\\\\n&\\text { subject to } \\sum_{i=1}^{K}\\left\\|\\tilde{\\mathbf{w}}_{i}\\right\\|^{2} \\leq P\n\\end{aligned}\n$$\n\n### perfect CSI and average SNR knowledge\n\n#### 方法\n\ntake advantage of the non-homogeneous SNR conditions at the UE to predetermine the weights and receive coefficients and thus remove the iterative procedure of the IWMMSE algorithm.（利用UE的信噪比非同质这一特点，事先确定IWMMSE中的两个迭代参数$\\mathbf{\\Omega},\\mathbf{\\Lambda}$）\n\n#### 思路\n\n用effective small-scale channel gain $\\mathbf{G}(g_i=\\frac{||\\mathbf{h}_i||}{\\sigma_{n_i}})$表示两个迭代参数(16)\n$$\n\\mathrm{MSE}=\\mathbb{E}\\left\\{\\left\\|\\underbrace{\\mathbf{G} \\boldsymbol{\\Sigma}^{\\frac{1}{2}}}_{\\mathbf{\\Omega}^{\\frac12}}\\left(\\mathbf{u}-\\underbrace{\\eta^{-1} \\mathbf{G}^{-1} \\boldsymbol{\\Sigma}^{-\\frac{1}{2}}}_{\\Lambda} \\mathbf{y}\\right)\\right\\|^{2}\\right\\}\n$$\n使用lagrange乘数法求lagrange因子$\\mu^{\\star}$和波束成形矩阵$\\mathbf{W}^{\\star}$\n\n#### 结果\n\n$$\n\\begin{gathered}\\mu^\\star=\\frac KP\\\\\n\\mathbf{W}^\\star=\\mathbf{H}^H\\left(\\mathbf{HH}^H+\\frac KP\\mathbf{\\Sigma}^{-1}\\right)^{-1}\\mathbf{G}\n\\end{gathered}\n$$\n\n结果与IWMMSE形式类似，与RZF相比采用non-identity regularizer matrix（非同一正则矩阵）\n\n### quantized CDI and CQI feedbacks\n\n对平均SNR无knowledge。\n\n+ CDI（channel direction indicator）：量化方向矢量$\\mathbf{\\hat h}_i$的编号。用量化矢量$\\mathbf{\\hat h}_i$代替SINR表达式中的$\\mathbf{h}_i$\n+ CQI（channel quality indicator）：用有效信道增益表示瞬时信噪比$\\hat g_i \\hat \\rho_i=\\frac MP\\widehat{SNR_i}$代替SINR中平均信噪比$\\rho_i$\n+ CDI和CQI综合即可改写式$\\eqref{eq:16}$ ，但量化误差会带来non-robust。\n\n#### 方法——Robust\n\n分解归一化信道$\\mathbf{\\tilde h}_i=\\frac{\\mathbf{h}_i}{||\\mathbf{h}_i||}$,\n$$\n\\begin{gathered}\n\\mathbf{\\tilde h}_i=\\sqrt{1-z_i}\\,\\mathbf{\\hat h}_i+\\sqrt{z_i}\\,\\mathbf{s}\\\\ \nz_i=1-|\\mathbf{\\tilde h}_i^H\\mathbf{\\hat h}_i|^2\n\\end{gathered}\n$$\n其中，$z_i$是量化误差，$\\mathbf{\\tilde h}_i$是实际方向，$\\mathbf{\\hat h}_i$是量化方向的投影，$\\mathbf{s}$是量化矢量$\\mathbf{\\hat h}_i$的核空间上的各向同性的单位矢量。【1-[16]】\n\n#### 思路\n\n和perfect CSI and average SNR knowledge的MSE一致，但是其中$\\mathbf{\\tilde H}$有所变化：\n$$\n\\mathbf{H}=\\mathbf{G} \\tilde{\\mathbf{H}}=\\mathbf{G}(\\mathbf{I}-\\mathbf{Z})^{\\frac{1}{2}} \\hat{\\mathbf{H}}+\\mathbf{G} \\mathbf{Z}^{\\frac{1}{2}} \\mathbf{S}\n$$\n化开，同样使用lagrange乘数法求lagrange因子$\\mu^{\\star}$和波束成形矩阵$\\mathbf{W}^{\\star}$\n\n#### 结果\n\n$\\mu^\\star$不变\n$$\n\\mathbf{W}=\\frac{\\zeta}{1-\\delta} \\hat{\\mathbf{H}}^{H}\\left(\\hat{\\mathbf{H}} \\hat{\\mathbf{H}}^{H}+\\frac{\\delta P \\operatorname{Tr}\\left\\{\\mathbf{\\Sigma G}^{2}\\right\\}+K M}{P M(1-\\delta)} \\mathbf{\\Sigma}^{-1} \\mathbf{G}^{-2}\\right)^{-1}\n$$\n系数不影响归一化的波束成形矩阵$\\mathbf{\\tilde W}$，信噪比$\\mathbf{SNR}=\\frac PM\\mathbf{G}^2\\mathbf{\\Sigma}$（37）\n$$\n\\mathbf{W}^\\star=\\hat{\\mathbf{H}}^{H}\\left(\\hat{\\mathbf{H}} \\hat{\\mathbf{H}}^{H}+\\frac{\\delta  \\operatorname{Tr}\\left\\{\\mathbf{SNR}\\right\\}+K }{M(1-\\delta)} \\mathbf{SNR}^{-1}\\right)^{-1}\n$$\n\n+ 由quantized CDI and CQI feedbacks可以推perfect CSI and average SNR knowledge\n+ CQI量化可能无法很好估计SNR\n+ 可以通过WMMSE推出non-weighted MMSE【1-[11]】\n\n\n\n### Contribution\n\n用计算的effective small-scale channel gain却代替迭代的过程。\n\n---\n\n## Iteratively Weighted MMSE【数字预编码，迭代】——2011-TSP\n\n*An Iteratively Weighted MMSE Approach to Distributed Sum-Utility Maximization for a MIMO Interfering Broadcast Channel*\n\nMIMO\n\n每次给UE$i_k$发送的是$\\bf s$，而非单个字符——讨论单用户\n\n![image-20211104143313382](https://z3.ax1x.com/2021/11/08/I8Sr9A.png)\n$$\n\\mathbf{\\hat s}_{i_k}=\\mathbf{U}_{i_k}^H\\mathbf{y}_{i_k}\n$$\n\n### 优化问题\n\n> **Sum-rate problem**\n>\n> 在点对点单用户信道中，如果我们已知发送信号的协方差矩阵$\\mathbf{Q}=\\mathbb{E}\\{\\mathbf{x}_k\\mathbf{x}_k^H\\}$ ，假设干扰加噪声协方差矩阵是单位矩阵，那么单用户的信道容量就是\n> $$\n> \\log |\\mathbf{I}+\\mathbf{H}\\mathbf{Q}\\mathbf{H}^H|.\n> $$\n> 扩展到多用户IC信道，此时干扰加噪声协方差矩阵（interference-plus-noise covariance matrix）就不会再成为单位矩阵，它是$\\mathbf{R}_i = \\sum_{i \\neq j} \\mathbf{H}_{ji}\\mathbf{Q}_j \\mathbf{H}_{ji}^H+\\mathbf{I}，$多用户信道容量就变成了：\n> $$\n> \\sum_{i=1}^K \\log |\\mathbf{I}+\\mathbf{R}^{-1}_i\\mathbf{H}_{ii}\\mathbf{Q}_i\\mathbf{H}^H_{ii}|.\n> $$\n> 考虑它更广义的形式$i$个用户，加入效用因子$\\lambda_i$（文章1的$\\rho_i$）。当效用因子都是1时，就和上式等价，问题就变成了：\n> $$\n> \\sum_{i=1}^K \\lambda_i\\log |\\mathbf{I}+\\mathbf{R}^{-1}_i\\mathbf{H}_{ii}\\mathbf{Q}_i\\mathbf{H}^H_{ii}|\n> $$\n> [【优质信源】计划02--多用户通信中总速率优化问题的一些凸优化模式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/137952433)\n\n+ sum-rate problem(1)\n    $$\n    \\begin{aligned}\n    \\max_{\\mathbf{V}} & \\sum_{k=1}^{K} \\sum_{i_{k}=1}^{I_{k}} \\alpha_{i_{k}} R_{i_{k}} \\\\\n    \\text { s.t. } & \\sum_{i=1}^{I_{k}} \\operatorname{Tr}\\left(\\mathbf{V}_{i_{k}} \\mathbf{V}_{i_{k}}^{H}\\right) \\leq P_{k}, \\forall k=1,2, \\ldots, K\n    \\end{aligned}\n    $$\n    其中，$\\alpha_{i_k}$是优先级\n\n+ sum-MSE minimization(4)\n    $$\n    \\begin{aligned}\n    \\min _{\\mathbf{U}, \\mathbf{V}} & \\sum_{k=1}^{K} \\sum_{i=1}^{I_{k}} \\operatorname{Tr}\\left(\\mathbf{E}_{i_{k}}\\right) =\\sum_{k=1}^{K} \\sum_{i=1}^{I_{k}} ||\\mathbf{\\hat s }_{i_k}-\\mathbf{s}_{i_k}||\\\\\n    \\text { s.t. } & \\sum_{i=1}^{I_{k}} \\operatorname{Tr}\\left(\\mathbf{V}_{i_{k}} \\mathbf{V}_{i_{k}}^{H}\\right) \\leq P_{k}, \\quad k=1,2, \\ldots, K .\n    \\end{aligned}\n    $$\n\n    $$\n    \\begin{aligned}\n    \\mathbf{U}_{i_{k}}^{\\mathrm{mmse}}=&\\mathbf{J}_{i_{k}}^{-1} \\mathbf{H}_{i_{k} k} \\mathbf{V}_{i_{k}}\\\\\n    \\mathbf{E}_{i_{k}}^{\\mathrm{mmse}}=&\\mathbf{I}-\\mathbf{V}_{i_{k}}^{H} \\mathbf{H}_{i_{k} k}^{H} \\mathbf{J}_{i_{k}}^{-1} \\mathbf{H}_{i_{k} k} \\mathbf{V}_{i_{k}}\n    \\end{aligned}\n    $$\n\n    其中，$\\mathbf{J}_{i_{k}} \\triangleq \\sum_{j=1}^{K} \\sum_{\\ell=1}^{I_{j}} \\mathbf{H}_{i_{k} j} \\mathbf{V}_{\\ell_{j}} \\mathbf{V}_{\\ell_{j}}^{H} \\mathbf{H}_{i_{k}}^{H}+\\sigma_{i_{k}}^{2} \\mathbf{I}$。\n\n+ 两个问题的统一性（7）——【1-[5]、2-[13]】梯度、KKT条件引出\n    $$\n    \\begin{aligned}\n    \\min _{\\mathbf{W}, \\mathbf{U}, \\mathbf{V}} & \\sum_{k=1}^{K} \\sum_{i=1}^{I_{k}} \\alpha_{i_{k}}\\left(\\operatorname{Tr}\\left(\\mathbf{W}_{i_{k}} \\mathbf{E}_{i_{k}}\\right)-\\log \\operatorname{det}\\left(\\mathbf{W}_{i_{k}}\\right)\\right) \\\\\n    \\text { s.t. } & \\sum_{i=1}^{I_{k}} \\operatorname{Tr}\\left(\\mathbf{V}_{i_{k}} \\mathbf{V}_{i_{k}}^{H}\\right) \\leq P_{k}, k=1,2, \\ldots, K\n    \\end{aligned}\n    $$\n    （7） is in the space of $(u,v,w)$ and is easier to handle since optimizing each variable while holding others fixed is convex and easy (e.g., closed form).\n\n$$\nR_{i_k}=\\log\\det\\left(\\left(\\mathbf{E}_{i_k}^{mmse}\\right)^{-1}\\right)\n$$\n\n\n\n### 迭代优化的方法\n\n要解决sum-rate问题，即解决式$\\eqref{eq:2-7}$的优化问题，需要优化$\\mathbf{U,V,W}$。\n\n> 1 Initialize $\\mathbf{V}_{i_{k}}$ 's such that $\\operatorname{Tr}\\left(\\mathbf{V}_{i_{k}} \\mathbf{V}_{i_{k}}^{H}\\right)=\\frac{p_{k}}{I_{k}}$\n> 2 **repeat**\n> $3 \\quad \\mathbf{W}_{i_{k}}^{\\prime} \\leftarrow \\mathbf{W}_{i_{k}}, \\quad \\forall i_{k} \\in \\mathcal{I}$\n> $4 \\quad \\mathbf{U}_{i_{k}} \\leftarrow\\left(\\sum_{(j, \\ell)} \\mathbf{H}_{i_{k} j} \\mathbf{V}_{\\ell_{j}} \\mathbf{V}_{\\ell_{j}}^{H} \\mathbf{H}_{i_{k} j}^{H}+\\sigma_{i_{k}}^{2} \\mathbf{I}\\right)^{-1} \\mathbf{H}_{i_{k} k} \\mathbf{V}_{k}, \\forall i_{k} \\in \\mathcal{I}$\n> $5\\quad\\mathbf{W}_{i_{k}} \\leftarrow\\left(\\mathbf{I}-\\mathbf{U}_{i_{k}}^{H} \\mathbf{H}_{i_{k} k} \\mathbf{V}_{i_{k}}\\right)^{-1}, \\forall i_{k} \\in \\mathcal{I}$\n> $6 \\quad \\mathbf{V}_{i_{k}} \\leftarrow \\alpha_{i_{k}}\\left(\\sum_{(j, \\ell)} \\alpha_{\\ell_{j}} \\mathbf{H}_{\\ell_{j} k}^{H} \\mathbf{U}_{\\ell_{j}} \\mathbf{W}_{\\ell_{j}} \\mathbf{U}_{\\ell_{j}}^{H} \\mathbf{H}_{\\ell_{j} k}+\\mu_{k}^{*} \\mathbf{I}\\right)^{-1} \\mathbf{H}_{i_{k} k}^{H} \\mathbf{U}_{i_{k}} \\mathbf{W}_{i_{k}}, \\forall i_{k}$\n> 7 **until** $\\left|\\sum_{(j, \\ell)} \\log \\operatorname{det}\\left(\\mathbf{W}_{\\ell_{j}}\\right)-\\sum_{(j, \\ell)} \\log \\operatorname{det}\\left(\\mathbf{W}_{\\ell_{j}}^{\\prime}\\right)\\right| \\leq \\epsilon$\n\n+ $\\mathbf{W}$的优化来自对$\\eqref{eq:2-7}$的求解——对$\\mathbf{W}$求一阶导数得到$\\mathbf{W}^\\star=(\\mathbf{E}_{i_k}^{MMSE})^{-1}$ ， $\\mathbf{E}_{i_k}^{MMSE}$来自MMSE问题的求解，可由$\\mathbf{U}$表示\n+ $\\mathbf{U}$的优化来自MMSE的求解——对MSE表达式对$\\mathbf{U}$求一阶导，求极值\n+ $\\mathbf{V}$的优化来自对$\\eqref{eq:2-7}$的求解——将MSE表达式代入$\\eqref{eq:2-7}$，对$\\mathbf{V}$利用Lagrange乘数法，解出$\\mathbf{V}$与$\\mu_k$有关，根据约束条件求$\\mu_k^\\star$，回代\n\n这种方法也适用于general utility maximization\n\n### Contributions\n\n（7） is in the space of $(u,v,w)$ and is easier to handle since optimizing each variable while holding others fixed is convex and easy (e.g., closed form).\n\nthe sum-rate maximization problem is first equivalently transformed into an  MMSE problem and then a block coordinate descent (BCD) method is proposed to solve the resultant MMSE problem.\n\n---\n\n## Low-Complexity Hybrid Precoding in Massive Multiuser MIMO Systems【混合预编码】——2014-LWC\n\n![混合预编码](https://z3.ax1x.com/2021/11/08/I8Ss1I.png)\n\n混合预编码——传统数字预编码的RF chain数量需要和$N_t$相等，通过$\\mathbf{WF}$的统一考虑，减少RF chain。\n$$\ny_k=\\mathbf{h}_k^H\\mathbf{F}_{N_t\\times K}\\mathbf{W}_{K\\times K}\\mathbf{s}_{K\\times 1}+n_k\n$$\n\n### 方法\n\napply phase-only control to couple the $K$ RF chain outputs with $N_t$ transmit antennas, using cost-effective RF phase shifters.（$\\mathbf{F}$只相移，将K条射频链和$N_t$个发射天线耦合）\n\n### 思路\n\n+ $\\bf F$只调相\n    $$\n    \\mathbf{F}_{i,j}=\\frac{1}{\\sqrt{N_t}}e^{j\\varphi_{i,j}}\n    $$\n    This is to align the phases of channel elements and can thus harvest the large array gain provided by the massive multiuser MIMO systems.\n\n+ $\\bf W$调幅、调相：将$\\bf HF$看作等效的$\\bf H$，利用非注水的ZF（块对角化）\n    $$\n    \\mathbf{W}=\\mathbf{H}_{eq}^H(\\mathbf{H}_{eq}\\mathbf{H}_{eq}^H)^{-1}\\mathbf{\\Lambda}\n    $$\n    $\\mathbf{\\Lambda}$为列功率归一化。类似【1】的$\\eta_i$\n\n+ Quantized RF Phase Control：由于$\\mathbf{F}$控制相位，实际中移相器位数有限，需要量化，则再计算$\\mathbf{W}$时利用量化后的$\\mathbf{\\hat F}$\n\n### 结果\n\n#### 频谱利用率(Spectral Efficiency)分析\n\n——当$N_t$足够大，用户间干扰可以忽略\n\nPhased-ZF的上界$R\\leq K \\mathcal{R}$，且\n$$\n\\begin{gathered}\n\\lim_{N_t\\to \\infty}\\frac{\\mathcal{R}}{\\log_2\\left(1+\\frac{\\pi}{4}\\frac{PN_t}{K}\\right)}=1\\\\ \n\\mathcal{R}=\\mathbb{E}\\left[1+\\frac PK |\\mathbf{h}_k^H\\mathbf{f}_k|^2\\right]\n\\end{gathered}\n$$\n\n#### 仿真1：Rayleigh信道\n\n```matlab\n        F = 1/sqrt(Nt)*exp(j.*angle(H))';   % RF precoder 128x4\n        Fb = CalBDPrecoder(H*F);            % 4x(128)x4, baseband, same as inverse with column normalization W = Fb\n                                            % (BD precoder is a method of ZF)\n        wt = F*Fb;                          % aggregate precoder wt=FW\n        WPR = wt*inv(sqrt(diag(diag(wt'*wt))));  % normalized columns \n        rateHyb(isnr) = rateHyb(isnr) + CalRate((P/K)*eye(K), H, WPR);% ZF-PRP\n```\n\n#### 仿真2：mmWave信道\n\n毫米波信道的特点：limited multipath components.—— poor scattering nature\n$$\n\\mathbf{h}_k^H=\\sqrt{\\frac{N_t}{N_p}}\\sum_{l=1}^{N_p}\\alpha_l^k\\mathbf{a}^H(\\phi_l^k,\\theta_l^k)\n$$\n\n### Contribution\n\n在性能减弱不大的情况下，减少射频链(RF chains)的数量\n\n---\n\n## Hybrid Digital and Analog Beamforming Design for Large-Scale Antenna Arrays【混合预编码】——2016-JSTSP\n\n![image-20211109103444712](image-20211109103444712.png)\n$$\n\\mathbf{x}=\\underbrace{\\mathbf{V}_{RF}}_{N\\times N_t^{RF}}\\underbrace{\\mathbf{V}_D}_{N_t^{RF}\\times N_s}\\mathbf{s}=\\sum_{\\ell=1}^K\\mathbf{V}_{RF}\\mathbf{V}_{D_\\ell}\\mathbf{s}_\\ell\n$$\n其中，$N_s=Kd$ ， $K$个用户，每个用户$d$个符号\n\n接收信号\n$$\n\\mathbf{\\tilde s}_k=\\tilde{\\mathbf{y}}_{k}=\\underbrace{\\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{H}_{k} \\mathbf{V}_{\\mathrm{t}_{k}} \\mathbf{s}_{k}}_{\\text {desired signals }}+\\underbrace{\\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{H}_{k} \\sum_{\\ell \\neq k} \\mathbf{V}_{\\mathrm{t}_{\\ell}} \\mathbf{s}_{\\ell}}_{\\text {effective interference }}+\\underbrace{\\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{z}_{k}}_{\\text {effective noise }}\n$$\n其中，基站的预编码$\\mathbf{V}_{\\mathrm{t}_k}=\\mathbf{V}_{RF}\\mathbf{V}_{D_k}$，同理，用户侧的预编码$\\mathbf{W}_{\\mathrm{t}_k}=\\mathbf{V}_{RF_k}\\mathbf{V}_{D_k}$\n\n优化问题sum-rate problem(4)\n$$\n\\begin{aligned}\n&R_{k}=\\log _{2}\\left|\\mathbf{I}_{M}+\\mathbf{W}_{\\mathrm{t}_{k}} \\mathbf{C}_{k}^{-1} \\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{H}_{k} \\mathbf{V}_{\\mathrm{t}_{k}} \\mathbf{V}_{\\mathrm{t}_{k}}^{H} \\mathbf{H}_{k}^{H}\\right|\\\\\n&\\text { where } \\quad \\mathbf{C}_{k}=\\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{H}_{k}\\left(\\sum_{\\ell \\neq k} \\mathbf{V}_{\\mathrm{t}_{\\ell}} \\mathbf{V}_{\\mathrm{t}_{\\ell}}^{H}\\right) \\mathbf{H}_{k}^{H} \\mathbf{W}_{\\mathrm{t}_{k}}+\\sigma^{2} \\mathbf{W}_{\\mathrm{t}_{k}}^{H} \\mathbf{W}_{\\mathrm{t}_{k}}\n\\end{aligned}\n$$\n\n\n+ Point-to-Point MIMO——两侧都是大规模天线阵列\n+ 下行链路MU-MIMO——基站侧多天线，用户侧单天线\n\n### Fully Digital Beamformer（全数字波束赋形）\n\n$\\mathbf{V}_{FD}\\in \\mathbb{C}^{N\\times N_s}$\n\n+ 必要条件：$N^{RF}\\geq N_s$\n+ 充分条件：$N^{RF}\\geq 2N_s$\n+ $N_s\\geq 2N^{RF}$的构造方法：it is in fact possible to realize any fully digital beamformer using the hybrid structure with $N_s$ RF chains and $2N_sN$ phase shifters.\n+ 当$N^{RF}\\approx N$，可以达到近似最优解，此时移相器数量为$N_sN$。\n+ 在低信噪比环境中，若$\\mathbf{V}_{FD}$非满秩矩阵，则先进行满秩分解($\\mathbf{V}_{FD}=\\mathbf{A}_{N\\times r}\\mathbf{B}_{r\\times N_s}$)，将$\\mathbf{A}=\\mathbf{V}_{RF}\\mathbf{V}'_D$作为预编码矩阵，射频链数量为$2r$，此时模拟预编码$\\mathbf{V}_{RF}$，数字预编码$\\mathbf{V}'_D\\mathbf{B}$\n\n### SU-Point-to-Point MIMO\n\n假设$N_t^{RF}=N_r^{RF}=N^{RF}$\n\n优化目标：由$\\eqref{eq:4-4}$化简：\n$$\nR=\\log _{2}\\left|\\mathbf{I}_{M}+\\frac{1}{\\sigma^2}\\mathbf{W}_{\\mathrm{t}} (\\mathbf{W}_t^H\\mathbf{W}_t)^{-1} \\mathbf{W}_{\\mathrm{t}}^{H} \\mathbf{H} \\mathbf{V}_{\\mathrm{t}} \\mathbf{V}_{\\mathrm{t}}^{H} \\mathbf{H}^{H}\\right|\n$$\n\n+ 先考虑必要条件$N^{RF}=N_s$的启发式算法\n\n    + 数字预编码：由注水法$\\mathbf{V}_D=(\\mathbf{V}_{RF}^H\\mathbf{V}_{RF})^{-\\frac12}\\mathbf{U}_e\\mathbf{\\Gamma}_e$(11)，得$\\mathbf{V}_D\\mathbf{V}_D^H=\\gamma^2\\mathbf{I},\\gamma=\\frac{P}{NN^{RF}}$\n\n    + RF预编码：优化函数(12)\n        $$\n        \\begin{aligned}\n        \\max _{\\mathbf{V}_{\\mathrm{RF}}}\\quad & \\log _{2}\\left|\\mathbf{I}+\\frac{\\gamma^{2}}{\\sigma^{2}} \\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{F}_{1} \\mathbf{V}_{\\mathrm{RF}}\\right| \\\\\n        \\text { s.t. }\\quad &\\left|\\mathbf{V}_{\\mathrm{RF}}(i, j)\\right|^{2}=1, \\forall i, j\n        \\end{aligned}\n        $$\n        目标函数也可写为(13)\n        $$\n        \\log _{2}\\left|\\mathbf{C}_{j}\\right|+\\log _{2}\\left(2 \\operatorname{Re}\\left\\{\\mathbf{V}_{\\mathrm{RF}}^{*}(i, j) \\eta_{i j}\\right\\}+\\zeta_{i j}+1\\right)\n        $$\n\n        $$\n        \\begin{aligned}\n        &\\hline \\text { Algorithm 1. Design of } \\mathbf{V}_{\\mathrm{RF}} \\text { by solving (12) } \\\\\n        &\\hline \\text { Given: } \\mathbf{F}_{1}, \\gamma^{2}, \\sigma^{2} \\\\\n        &\\text { 1: Initialize } \\mathbf{V}_{\\mathrm{RF}}=1_{N \\times N^{\\mathrm{RF}}} \\\\\n        &\\text { 2: \\textbf{for} } j=1 \\rightarrow N^{\\mathrm{RF}} \\textbf { do } \\\\\n        &\\text { 3: Calculate } \\mathbf{C}_{j}=\\mathbf{I}+\\frac{\\gamma^{2}}{\\sigma^{2}}\\left(\\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j}\\right)^{H} \\mathbf{F}_{1} \\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j} \\\\\n        &\\text { 4: Calculate } \\mathbf{G}_{j}=\\frac{\\gamma^{2}}{\\sigma^{2}} \\mathbf{F}_{1}-\\frac{\\gamma^{4}}{\\sigma^{4}} \\mathbf{F}_{1} \\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j} \\mathbf{C}_{j}^{-1}\\left(\\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j}\\right)^{H} \\mathbf{F}_{1} . \\\\\n        &\\text { 5: } \\quad \\textbf { for } i=1 \\rightarrow N \\\\\n        &\\text { 6: } \\quad \\text { Find } \\eta_{i j}=\\sum_{\\ell \\neq i} \\mathbf{G}_{j}(i, \\ell) \\mathbf{V}_{\\mathrm{RF}}(\\ell, j) . \\\\\n        &\\text { 7: } \\quad \\mathbf{V}_{\\mathrm{RF}}(i, j)=\\left\\{\\begin{array}{cc}\n        1, & \\text { if } \\eta_{i j}=0, \\\\\n        \\frac{\\eta_{i j}}{\\left|\\eta_{i j}\\right|}, \\text { otherwise. }\n        \\end{array}\\right. \\\\\n        &\\text { 8: } \\quad \\textbf { end for } \\\\\n        &\\text { 9: \\textbf{end for} } \\\\\n        &\\text { 10: Check convergence. If yes, stop; if not go to Step } 2 . \\\\\n        \\hline\n        \\end{aligned}\n        $$\n\n        算法运行中，目标函数不减\n\n    + RF合并：将优化函数中的$\\mathbf{W}_{RF}^H\\mathbf{W}_{RF}\\approx M\\mathbf{I}$，后续类似上述算法1（16）\n\n    + 数字合并：MMSE方法，类似【2】-$\\eqref{eq:2-5}$\n\n+ 后考虑将$N^{RF}=N_s$扩展到$N_s<N^{RF}<2N_s$：多余的射频链可用作相移器精度的折中\n    $$\n    \\begin{aligned}\n    &\\hline \\begin{array}{l}\n    \\text { Algorithm 2. Design of Hybrid Beamformers for Point-to- } \\\\\n    \\text { Point MIMO systems }\n    \\end{array} \\\\\n    &\\hline \\text { Given: } \\sigma^{2}, P \\\\\n    &\\text { 1: Assuming } \\mathbf{V}_{\\mathrm{D}} \\mathbf{V}_{\\mathrm{D}}^{H}=\\gamma^{2} \\mathbf{I} \\text { where } \\gamma=\\sqrt{P /\\left(N N^{\\mathrm{RF}}\\right)}, \\text { find } \\\\\n    &\\mathbf{V}_{\\mathrm{RF}} \\text { by solving the problem in (12) using Algorithm 1. } \\\\\n    &\\text { 2: Calculate } \\mathbf{V}_{\\mathrm{D}}=\\left(\\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{V}_{\\mathrm{RF}}\\right)^{-1 / 2} \\mathbf{U}_{e} \\boldsymbol{\\Gamma}_{e} \\text { where } \\mathbf{U}_{e} \\text { and } \\boldsymbol{\\Gamma}_{e} \\\\\n    &\\text { are defined as following }(11) \\text {. } \\\\\n    &\\text { 3: Find } \\mathbf{W}_{\\mathrm{RF}} \\text { by solving the problem in (16) using } \\\\\n    &\\text { Algorithm 1. } \\\\\n    &\\text { 4: Calculate } \\mathbf{W}_{\\mathrm{D}}=\\mathbf{J}^{-1} \\mathbf{W}_{\\mathrm{RF}}^{H} \\mathbf{H V}_{\\mathrm{RF}} \\mathbf{V}_{\\mathrm{D}} \\text { where } \\mathbf{J}=\\mathbf{W}_{\\mathrm{RF}}^{H} \\mathbf{H} \\\\\n    &\\mathbf{V}_{\\mathrm{RF}} \\mathbf{V}_{\\mathrm{D}} \\mathbf{V}_{\\mathrm{D}}^{H} \\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{H}^{H} \\mathbf{W}_{\\mathrm{RF}}+\\sigma^{2} \\mathbf{W}_{\\mathrm{RF}}^{H} \\mathbf{W}_{\\mathrm{RF}} \\text {. } \\\\\n    \\hline\n    \\end{aligned}\n    $$\n\n### MU-MISO\n\n+ 考虑用户间干扰的因素\n+ 考虑streams的优先级\n+ proposes a design for the scenarios where $N^{RF} > K$ with practical $N$ and show numerically that adding a few more RF chains can increase the overall performance of the system and reduce the gap to capacity.\n\n方法：**在$\\mathbf{V}_{RF}$和$\\mathbf{P}$的设计之间迭代**\n\n+ 先优化$\\mathbf{V}_{RF}=e^{-j\\theta_{i,j}}$\n\n+ $\\mathbf{V}_{RF}$收敛，注水法功控\n    $$\n    \\begin{gathered}\n    \\mathbf{P}=\\mathrm{diag}(p_1,\\cdots,p_k)\\\\ \n    p_k=\\frac{1}{\\tilde q_{kk}}\\left(\\frac{\\beta_k}{\\lambda}-\\tilde q_{kk}\\sigma^2\\right)^+\n    \\end{gathered}\n    $$\n    其中，$\\tilde q_{kk}$ 是 $\\mathbf{\\tilde Q}=\\mathbf{\\tilde V}_D^H\\mathbf{V}_{RF}^H\\mathbf{V}_{RF}\\mathbf{\\tilde V}_D $ 的主对角线元素。同时 $\\lambda$ 使 $\\sum_{k=1}^K\\left(\\frac{\\beta_k}{\\lambda}-\\tilde q_{kk}\\sigma^2\\right)^+=P$ ， $\\mathbf{\\tilde V}_D$是$\\mathbf{H}_{eq}=\\mathbf{HV}_{RF}$的ZF数字预编码。\n\n+ 整个算法收敛，应用注水功控的ZF数字预编码\n    $$\n    \\mathbf{V}_{\\mathrm{D}}^{\\mathrm{ZF}}=\\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{H}^{H}\\left(\\mathbf{H V}_{\\mathrm{RF}} \\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{H}^{H}\\right)^{-1} \\mathbf{P}^{\\frac{1}{2}}=\\tilde{\\mathbf{V}}_{\\mathrm{D}} \\mathbf{P}^{\\frac{1}{2}}\n    $$\n\n$$\n\\begin{aligned}\n&\\hline \\begin{array}{l}\n\\text { Algorithm 3. Design of Hybrid Precoders for MU-MISO } \\\\\n\\text { systems }\n\\end{array} \\\\\n&\\hline \\text { Given: } \\beta_{k}, P, \\sigma^{2} \\\\\n&\\text { 1: Start with a feasible } \\mathbf{V}_{\\mathrm{RF}} \\text { and } \\mathbf{P}=\\mathbf{I}_{K} \\text {. } \\\\\n&\\text { 2: for } j=1 \\rightarrow N^{\\mathrm{RF}} \\\\\n&\\text { 3:\\quad  Calculate } \\mathbf{A}_{j}=\\mathbf{P}^{-\\frac{1}{2}} \\mathbf{H} \\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j}\\left(\\overline{\\mathbf{V}}_{\\mathrm{RF}}^{j}\\right)^{H} \\mathbf{H}^{H} \\mathbf{P}^{-\\frac{1}{2}} \\\\\n&\\text { 4: } \\quad \\text { for } i=1 \\rightarrow N \\\\\n&\\text { 5: } \\quad\\quad  \\text { Find } \\zeta_{i j}^{B}, \\zeta_{i j}^{D}, \\eta_{i j}^{B}, \\eta_{i j}^{D} \\text { as defined in Appendix A. } \\\\\n&\\text { 6: } \\quad\\quad  \\text { Calculate } \\theta_{i, j}^{(1)} \\text { and } \\theta_{i, j}^{(2)} \\text { according to }(27) . \\\\\n&\\text { 7: } \\quad\\quad  \\text { Find } \\theta_{i, j}^{\\text {opt }}=\\arg \\min \\left(\\hat{f}\\left(\\theta_{i, j}^{(1)}\\right), \\hat{f}\\left(\\theta_{i, j}^{(2)}\\right)\\right) . \\\\\n&\\text { 8:\\quad  Set } \\mathbf{V}_{\\mathrm{RF}}(i, j)=e^{-j \\theta_{i, j}^{\\text {opt }}} \\text {. } \\\\\n&\\text { 9: \\quad end for } \\\\\n&\\text { 10: end for } \\\\\n&\\text { 11: Check convergence of RF precoder. If yes, continue; if not } \\\\\n&\\text { go to Step } 2 . \\\\\n&\\text { 12: Find } \\mathbf{P}=\\operatorname{diag}\\left[p_{1}, \\ldots, p_{k}\\right] \\text { using water-filling as in (23). } \\\\\n&\\text { 13: Check convergence of the overall algorithm. If yes, stop; } \\\\\n&\\text { if not go to Step } 2 . \\\\\n&\\text { 14: Set } \\mathbf{V}_{\\mathrm{D}}=\\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{H}^{H}\\left(\\mathbf{H V}_{\\mathrm{RF}} \\mathbf{V}_{\\mathrm{RF}}^{H} \\mathbf{H}^{H}\\right)^{-1} \\mathbf{P}^{\\frac{1}{2}} \\text {. }\\\\\\hline\n\\end{aligned}\n$$\n\n### 相移器精度有限\n\n与第三篇先计算波束赋形矢量后再进行量化不同，在**迭代优化过程中就开始量化**，尤其是$\\max\\ \\mathrm{Re}\\{\\mathbf{V}_{RF}^*(i,j)\\eta_{ij}\\}$即最小化复平面上$\\mathbf{V}_{RF}$和$\\eta_{ij}$的夹角。\n\n---\n\n## Weighted Sum-Rate Maximization for Reconfigurable Intelligent Surface Aided Wireless Networks【智能反射面】——2020-TWC\n\nMU-MISO\n\n![image-20211111150451134](image-20211111150451134.png)\n\n基站$M$根天线，RIS有$N$个反射单元，$K$个单天线用户\n$$\n\\begin{aligned}\ny_{k} &=\\underbrace{\\mathbf{h}_{\\mathrm{d}, k}^{\\mathrm{H}} \\mathbf{x}}_{\\text {Direct link }}+\\underbrace{\\mathbf{h}_{\\mathrm{r}, k}^{\\mathrm{H}} \\Theta \\mathbf{G} \\mathbf{x}}_{\\text {RIS-aided link }}+u_{k} \\\\\n&=\\left(\\mathbf{h}_{\\mathrm{d}, k}^{\\mathrm{H}}+\\mathbf{h}_{\\mathrm{r}, k}^{\\mathrm{H}} \\Theta \\mathbf{G}\\right) \\sum_{k=1}^{K} \\mathbf{w}_{k} s_{k}+u_{k}\\\\ \n&=\\left(\\mathbf{h}_{d,k}^H+\\boldsymbol{\\theta}^H\\mathbf{H}_{r,k}\\right)\\sum_{k=1}^K\\mathbf{w}_ks_k+u_k\n\\end{aligned}\n$$\n其中，$\\boldsymbol{\\Theta}=diag(\\theta_1,\\cdots,\\theta_N),\\boldsymbol{\\theta}=[\\theta_1,\\cdots,\\theta_N]^H$，$\\mathbf{H}_{r,k}=diag(\\mathbf{h}_{r,k}^H)\\mathbf{G}\\in\\mathbb{C}^{N\\times M}$\n\n+ perfect CSI：weighted sum-rate maximization\n    $$\n    \\begin{aligned}\n    \\max _{\\mathbf{W}, \\boldsymbol{\\theta}} \\quad &f_{\\mathrm{A}}(\\mathbf{W}, \\boldsymbol{\\theta})=\\sum_{k=1}^{K} \\omega_{k} \\log \\left(1+\\gamma_{k}\\right) \\\\\n    \\text { s.t. }\\quad&\\left|\\theta_{n}\\right|=1, \\quad \\forall n=1, \\cdots, N \\\\\n    &\\sum_{k=1}^{K}\\left\\|\\mathbf{w}_{k}\\right\\|^{2} \\leq P_{\\mathrm{T}}\n    \\end{aligned}\n    $$\n    $\\gamma_k$即SINR。\n\n+ imperfect CSI：$ \\mathbf{h}_{d,k}$ ， $\\mathbf{G}$ ， $\\mathbf{h}_{r,k}$可以看成由非完美CSI $({\\hat{\\mathbf{h}}}_{d,k}$ ， $\\hat{\\mathbf{G}}$ ， ${\\hat{\\mathbf{h}}}_{r,k}$)与信道估计误差($\\mathbf{z}_{d,\\ k}$ ， $\\mathbf{Z}_G$，$\\mathbf{z}_{r,k}$)分布的样本空间的一个随机样本。\n    $$\n    \\begin{aligned}\n    \\max _{ \\boldsymbol{\\theta}} \\quad &f_{\\mathrm{B}}(\\boldsymbol{\\theta})=\\mathbb{E}_\\xi\\left[\\max_{\\mathbf{W}_\\xi}f_A\\left(\\mathbf{W}(\\xi) ,\\boldsymbol{\\theta};\\xi \\right)\\right] \\\\\n    \\text { s.t. }\\quad&\\left|\\theta_{n}\\right|=1, \\quad \\forall n=1, \\cdots, N \\\\\n    &\\sum_{k=1}^{K}\\left\\|\\mathbf{w}_{k}(\\xi)\\right\\|^{2} \\leq P_{\\mathrm{T}},\\quad\\forall\\xi.\n    \\end{aligned}\n    $$\n\n---\n","tags":["无线通信","MIMO","预编码"],"categories":["科研向"]},{"title":"尘埃落定——XDU to SEU","url":"/2021/09/29/xdu-to-seu/","content":"\n# 尘埃落定——XDU to SEU\n\n## 保研经验贴\n\n### 基本情况\n\n+ 专业：西电·电子信息工程普通班\n+ 均分排名：\n    + 前五裸分：93.94，16/495（夏令营材料是这个）\n    + 前六裸分：94.21，14/490（面试时候提到）\n    + 保研总评：115.03（94.21+20+0.83），6/489\n    \n    ![系统](/系统.png)\n+ 竞赛和获奖：\n    + 国奖一次\n    + 美赛冠名O奖\n+ 英语：六级570+\n+ 去向：东南大学-通信专硕（只报名了东南，虽然非常险，但最后过了）\n\n### 联系老师\n\n我是三月中旬联系老师的，相对来说比较早。在看经验贴的时候发现了X老师，然后问了一下学长，在网上也查了一些X老师的信息，感觉很不错，就给老师发了邮件（邮件里包括读研意向和简历）。我是周四晚上8点发的，原本以为第二天才会有回信了，结果晚上10点就收到回信了。然后X老师说下个周二可以聊一下。\n\n![邮件](/邮件.png)\n\n面试时候主要是自己的自我介绍和针对简历里的一些问题，当时完全没准备简历问题，就回答的比较糟糕。最后老师再三让我和实验室的学长学姐了解清楚了，再决定去不去，因为去年鸽了一个。考虑了两天，就给了老师回复，因为东南也一直是我想去的学校也就没有什么纠结的了。然后老师就给我发了一本无线通信的书，让我看一下里面MIMO的部分。因为大三下只有dsp算均分，所以比较空，我也就每半个月和老师沟通一下我的学习进展，一直到期末。\n\n### 东南信息学院夏令营&预推免\n\n因为疫情影响，其实我们这级也非常卷。6月25日东南信息学院出夏令营预推免政策。七月初考完问了一下X老师学硕和专硕的问题，老师的意思是往年的话我的排名应该是学硕边缘、专硕比较稳，然后也了解了一下东南学硕和专硕基本没什么太大区别，就求稳报名了专硕。事实证明这个决定是对的，今年东南通信学硕大约卡的2%，专硕大约卡的5-7%左右，报学硕我连初审都过不了。报名是在[“东南大学接收推荐免试研究生网上申请系统”](http://121.248.63.139/zsgl/tmsgl/login.aspx?oid=edit)报名（报了就不能改，*建议不报报名太早，我因为报名太早，第一个面试*），然后给邮箱投材料。材料截止时间是7月20日，预推免面试原计划是7月31日，受疫情影响推迟到8月15日。通信学硕7月23日收到入营短信，通信专硕7月27日系统状态改变，30日收到入营短信（有状态没变的也收到入营短信）。8月6日正式出了全院的入营名单。\n\n我们面试分上午场和下午场，我是B组，还排在了第一个。上午有七十几套题，抽一套。主要是“自我介绍”->“英语问题”->“专业课问题”->“自由问答”。下午就是针对简历的问题，一开始也是自我介绍。我准备的比较充分基本都回答出来了。面试完感觉有点凉，尤其是上午的回答的很不好，就和X老师说一下，老师就回了一个👌（估计老师面试一天也很累了）。\n\n然后面试完就是无尽的等待，有的老师可能会提前告诉面试结果（X老师没有），我也没敢问。所幸8月21日出面试结果，排名进了南京的专硕。学硕竞争很激烈（进20），电院有三个通信学硕（第5，6，9），排名进前20有1个（学硕最后被鸽穿了）。专硕是33南京+14无锡，电院有六个通信专硕（除了我都是教改的），五个进前33，另外一个也进了前47。相对而言，专硕比学硕简单。\n\n![seu](/seu.png)\n\n\n\n### 填系统\n\n9月28日凌晨开系统，中午12点开始学校可以发复试通知。东南信息学院通信学硕、信号学硕、微波应该都被鸽穿了，通信专硕应该没穿（谁让他开的这么早），但最后也没有第二批预推免。\n\n2021年填报志愿的基本流程：\n\n+ 凌晨开始填系统![系统1](/系统1.png)\n\n+ 各个学校12点开始可以发放复试通知，学生端基本没崩，高校招生老师那边崩的比较厉害，具体可以见知乎的保研填系统名场面。收到复试通知前会先收到短信。![系统2-1](/系统2-1.png)\n\n    **(千万不要点错啊！！！)**![系统2-2](/系统2-2.png)\n\n+ 拟录取通知也会有短信，拟录取通知发的比较慢，通信专硕第一3点就收到了，到我都三点半了，差不多2分钟一个人。![系统3-1](/系统3-1.png)![系统3-2](/系统3-2.png)\n\n\n\n## 一些可能有用的材料\n\n+ 简历模板（[$\\LaTeX$](https://levitate.lanzoub.com/i3nkbut5c3e)）：还不错的简历模板，可以改颜色，记得安装思源黑体、江城斜黑体，来自[GitHub - lcfyi/software-resume-template: A simple LaTeX template for software engineering resumes.](https://github.com/lcfyi/software-resume-template)，做了一定的修改\n+ 一个勉强能用的东南大学信息学院详细材料模板（[$\\LaTeX$](https://levitate.lanzoub.com/iNl47ungnfc)）：记得安装思源宋体、思源黑体、江城斜宋体、江城斜黑体\n+ 西电电院2018级保研、优研方案（[PDF](https://levitate.lanzoub.com/ie8cDung49c)）：非官方制作，仅供参考，截止2021年9月29日（密码为：电院新院长拼音首字母+电院在西电的院系排序+2018级所住宿舍区首字母，共3字母+1数字+2字母=6位）\n+ 面试专业课整理：\n    + 一部分在[笔记整理](https://levitate-qian.github.io/2020/05/01/XDU-note/#%E4%BF%9D%E7%A0%94%E5%A4%8D%E4%B9%A0)中\n    + 另外一部分见[这个链接](https://levitate.lanzoub.com/iQFVvut5r8j)：部分内容来自于qq群（密码为：西电\\_\\_部电台起家+2019级所住宿舍区首字母，共占3位小数+2字母=5位）\n","categories":["总结"]},{"title":"【转】Github+hexo博客搭建教程","url":"/2021/08/27/hexo-blog/","content":"\n# Github+hexo博客搭建教程\n\n## hexo博客的作用\n\n博客就像一个人公开的日记一般，可以记录很多包括生活学习在内的诸多事情，作为IT的学生，拥有一个属于自己的博客，也将是未来校招或研究生面试重要的加分项。\n\n\n## 教程内容\n\n本文将带你从0开始，根据以下5个内容，搭建属于自己的hexo博客。\n\n* 1. 部署环境\n* 2. 初始化个人博客\n* 3. markdown写博客\n* 4. 通过github把博客部署到远端\n* 5. 设置博客主题\n\n## 博客搭建\n\n### 软件准备\n\n> node.js\n> git工具\n\n首先需要下载`nodejs`，我们可以去<https://nodejs.org/>下载\n![nodejis](https://i.loli.net/2020/02/11/EuDAUeitgs1L3jm.png)\n下载完按照其默认安装即可。\n下载安装完之后，本地就有了两个组件：`nodejs`和`npm`。\n\n下面我们下载git工具，直接在官网上下载即可。<https://git-scm.com/download/win>\n和nodejs一样根据他的提示下载安装。\n安装完成后，本地将会有三个东西：`Git Gui` `Git cmd` `Git Bash`\n我们打开`Git Bash`输入以下指令，来设置自己的用户名和邮箱\n\n``` python\ngit config --global user.name \"nameVal\"   # 全局配置自己的用户名\ngit config --global user.email \"emailVal\" # 全局配置自己的邮箱\n```\n\n配置完之后我们可以确认下\n\n``` python\ngit config --list  # 查看git配置信息\n```\n\n以上便是hexo博客搭建的软件准备了，下面我们开始部署环境。\n\n### 环境部署\n\n打开电脑终端`cmd`，在`shell`中输入命令\n\n``` python\nnode -v # 查看nodejs版本\nnpm -v  # 查看npm版本\n```\n\n查看无误后，下面开始在终端输入命令，安装hexo博客框架。\n由于国内`npm`安装速度问题，我们可以通过淘宝镜像换成`cnpm`\n\n``` python\nnpm install -g cnpm --registry=https://registry.taobao.org\n# 安装完成之后可以查看版本来验证安装成功\ncnpm -v\n```\n\n这样`cnpm`安装完成，接下来安装hexo。\n\n``` python\ncnpm install -g hexo-cli\n# 安装完成后同样查看下版本\nhexo -v\n```\n\n以上便是hexo博客的环境部署，非常方便。\n\n### 初始化个人博客\n\n下面我们在`cmd`的默认路径下`C:\\Users\\nameVal>`下新建一个文件夹，名为blog(名字当然随便取)\n\n``` python\nmkdir blog\n```\n\n然后我们在本地就能看到一个新的文件夹blog，我们的所有配置都在此文件夹下面。\n然后我们在`cmd`中进入blog这个目录下面\n\n``` python\ncd blog\n```\n\n下面开始初始化博客\n\n``` python\nhexo init  # 需要一些时间等待\n```\n\n经过等待之后，博客已经搭建完成。大家可以进入blog文件夹查看生成的配置文件。然后我们启动博客预览。\n\n``` python\nhexo s # hexo s==hexo server意思是启动本地服务器\n```\n\n然后我们在本地服务器中输入`cmd`中提示的4000端口就可以看到自己的博客了。\n![](https://i.loli.net/2020/02/11/ms53VpJQgfMWRcO.png)\n`hexo s`一般是在本地作为博客预览的一个命令。\n\n### markdown写博客\n\n下面我们就要开始在我们的hexo博客下写博客了。我们首先需要创建一篇新的博客，在blog目录下输入命令。\n\n``` python\nhexo n \"我的第一篇博客\"  # 引号内写博客的标题\n```\n\n然后在`blog/source/_posts/`的目录下就能找到我们创建的第一篇博客的markdown文件。\nmarkdown格式是程序员常用写博客的方式，markdown的语法十分简单。\n给大家markdown的菜鸟教程<https://www.runoob.com/markdown/md-tutorial.html>\n基本上里面的语法就能解决常用的问题了，如果有里面没有的，要善用搜索引擎。\n完成博客内容后，我们首先要在本地预览此篇博客的内容，写完之后打开`cmd`终端，在blog目录下输入两个命令。\n\n``` python\nhexo g # hexo g==hexo generate生成博客\nhexo s # 在本地服务器上启动\n```\n\n这是我们刷新本地服务器地址，就能看到我们的博客了。\n\n### 通过github把博客部署到远端\n\n`local:4000`作为我们本地的测试端，但是我们的博客内容不可能仅仅在本地用，所以我们需要把它部署到远端去。\ngithub是一种非常稳定的方式，以后我们只要通过github的方式来访问我们的博客就可以了，而且此方法免费。\n**当然大家也可以购买阿里云服务器，为自己的博客地址更改域名，这就看个人需求了**\nps：如果你还没有github账号，请赶紧注册<https://www.github.com/>，这可是程序员乃至所有工科生必备神器，以及最大的同性交友网站gayhub(滑稽)。\n下面打开自己的github，我们首先新建一个仓库(new repository)。\n![](https://i.loli.net/2020/02/11/5SoyteL4BYb3pnR.png)\n用户部署个人博客的github仓库的命名必须要与你的用户名一致才行。如下图所示，因为我的博客已经部署好了，所以它会提示已存在。\n![](https://i.loli.net/2020/02/11/QMuhEzAomG4lc2S.png)\n然后按照默认的点击`create repository`就行了。这现在是个空仓库，这是我们部署的博客地址<https://Alpha-Yang.github.io>\n![](https://i.loli.net/2020/02/11/mikay2LEFxNPHvd.png)\n下面我们先不管它，打开终端命令行`cmd`下载git插件。\n\n``` python\ncnpm install --save hexo-deployer-git\n```\n\n然后我们需要设置其配置文件，在`blog/`目录下找到配置文件`_config.yml`，用notepad或vim等记事本工具将其打开，更改该文件底部Deployment的内容。\n\n![](https://i.loli.net/2020/02/11/bNcDdlqYVOIJ5gL.png)\n\n> 这里会出现一些问题（2021年8月以后）：\n>\n> 请按照本文操作[Github 强制要求使用 Personal access token | 素生 (arlmy.me)](https://z.arlmy.me/posts/hexo/Hexo_PersonalAccessToken/)\n\n\n\n\n\n最后一步，我们将博客部署到远端，打开`cmd`终端。\n\n``` python\nhexo d # hexo d=hexo deployer部署到远端\n```\n\n这时候输入你的github账号及密码(**这里注意你的密码不会显示出来，所以输入即可**)\n这时候你会发现的仓库多了很多东西，然后把我们的仓库名拿出来访问，即<https://alpha-yang.github.io>\n就能看到我们的博客被部署到github上了，这样的话博客的部署工作也就完成了。所以我们今后使用hexo的命令基本为五个，这里我做下整理。\n\n``` python\nhexo n \"博客名\"   # 新建一篇博客\nhexo g           # 博客内容生成\nhexo s           # 启动本地服务器，预览更改后的博客\nhexo d           # 将更改后的博客部署到远端\nhexo clean       # 在hexo g之前的文件清理，不是必要。\n```\n\n以上就完成了所有的博客搭建的内容教程，这时候你就有了属于你自己的博客了。\n\n## 设置博客主题\n\nhexo博客的默认主题为landscape，我们可以自由地更换主题，大家可以去github上广泛地搜索，下面我们来讲解下如何更换主题。\n\n### 博客主题下载\n\n在hexo博客中有好多主题被广泛使用，这里我推荐我使用的两款主题\n\n> next(杨神原先使用)：https://github.com/theme-next/hexo-theme-next\n>\n> yimlia：https://github.com/litten/hexo-theme-yilia\n>\n> casper（我所使用的）：由[GitHub - xzhih/hexo-theme-casper: New casper theme ported to hexo.](https://github.com/xzhih/hexo-theme-casper)和[GitHub - GeekMubai/hexo-casper: hexo theme](https://github.com/GeekMubai/hexo-casper)两者综合\n\n可以现在github上预览看下自己喜欢的主题。\n我们下面来下载主题，打开`cmd`终端，在blog目录下输入命令。\n\n``` python\ngit clone https://github.com/theme-next/hexo-theme-next.git themes/next\n```\n\n克隆完之后，在`blog/themes/`的目录下就有next文件夹了。\n\n### 将主题导入自己的博客\n\n打开blog目录下的配置文件`_config.yml`，更改theme的内容\n![](https://i.loli.net/2020/02/11/Umzn6IaltJZPXi7.png)\n这样主题就导入成功了，接下来生成新内容，并部署到远端就可以了。\n\n``` python\nhexo g\nhexo d\n```\n\n就可以在我们的网址上看到新的主题了。\n**有可能出现尚未生效的情况，大家多刷新或等待就可以了，这是正常情况**\n\n### 常用更改\n\n最后的最后，我们需要学会更改配置文件的内容，根据自己的喜好优化博客即可，比如更改名字背景或添加特效等等。\n\n第一个是`blog/`目录下的`_config.yml`配置文件\n![](https://i.loli.net/2020/02/11/238yAmoSVrMPkHj.png)\n我们可以设置博客标题，副标题，描述，昵称，语言以及时区等等。\n\n第二个是`blog/themes/next/`目录下的`_config.yml`配置文件\n其实next主题还有四种样式可以选择，我选择的是Gemini样式\n![](https://i.loli.net/2020/02/11/ko1bgBWGqX89QlJ.png)\n大家想要哪儿个样式，就在配置文件中取消注释就可以了。\n\n## 总结\n\n以上所有内容便是hexo博客搭建的所有内容了。除了hexo以外，当然还有其他很多博客的框架，选择hexo的原因是应用比较广泛，可讨论的地方比较多。当然大家搭建博客还是先玩起来，至于其他的之后再考虑。\n关于博客的其他细节内容，大家一定要善用搜索引擎，我也会考虑写一篇hexo next主题优化的博客内容，供大家参考。\n","tags":["博客"],"categories":["杂七杂八"]},{"title":"【深度学习笔记（四）】卷积神经网络","url":"/2021/05/07/DL-Coursera-4-Convolutional-Neural-Networks/","content":"\n> 这个专项课程一共五门，包括\n>\n> + [Neural Networks and Deep Learning（神经网络与深度学习）](https://levitate-qian.github.io/2021/03/26/DL-Coursera-1-Neural-Networks-and-Deep-Learning/)\n> + [Improving Deep Neural Networks: Hyperparameter Tuning, Regularization and Optimization（改进深度神经网络：超参数、正则化和优化）](https://levitate-qian.github.io/2021/04/17/DL-Coursera-2-Improving-Deep-Neural-Networks/)\n> + [Structuring Machine Learning Projects（构建机器学习项目）](https://levitate-qian.github.io/2021/05/04/DL-Coursera-3-Structuring-Machine-Learning-Projects/)\n> + **Convolution Neural Networks（卷积神经网络）**\n> + Sequence Model（序列模型）\n\n\n\n> 最近在做图像大作业和各种课内作业，比较忙，搁置几天在更新。\n\n\n\n# Convolution Neural Networks 学习笔记\n\n第四门课的主体框架\n\n+ Week 1: Foundations of Convolutional Neural Networks\n    + Convolution NN\n+ Week 2: Deep Convolutional Models: Case Studies\n    + Case Studies\n    + Practical advices for using ConvNets\n+ Week 3: Object Detection\n    + Detection algorithm\n+ Week 4: Special Applications: Face recognition & Neural Style Transfer\n    + Face Recognition\n    + Neural Style transfer\n\n---\n\n待更新\n\n---\n\n## Week 1: Foundations of Convolutional Neural Networks\n\n### 图像处理基础知识\n\n#### Computer Vision\n\n+ Computer Vision\n    + brand new applications\n    + create a lot of cross_fertilization into other areas\n+ CV problems——photos are large\n    + Image classification\n    + Object detection\n    + Neural Style Transfer\n\n#### Edge detection Example\n\n在传统的图像分析中，我们可以利用模板卷积的方式实现图像的平滑，锐化，边缘检测等操作。这里就以垂直、水平边缘检测为例介绍了模板卷积的基本操作。\n\n在使用模板卷积进行边缘检测时，我们一般先检测垂直线条，再检测水平线条。\n\n+ 垂直边缘检测：\n    ![垂直边缘检测](/edge_detection_1.png)\n\n    + 这里的卷积就是将模板滤波器（filter）在实际的图片上拖动，并且相乘相加。\n\n    + 比较这里的卷积（convolution）和信号与系统中的卷积运算，其实是将一维卷积拓展到了二维，但少了翻转（slips）这一步骤，故在图像处理中的卷积运算其实是相关（correlation）运算，但因为约定俗成的名称，我们将他叫做卷积。\n\n    + 二维的卷积在各种编程语言中可以用简单的命令实现。\n\n        ```python\n        conv-forward()\t # python\n        tf.nn.conv2d()\t # tensorflow\n        Conv2D()\t\t# keras\n        ```\n\n        ```matlab\n        conv2()\t\t\t# matlab\n        ```\n\n    + 举个垂直边缘检测的例子\n        ![垂直边缘检测例子](/edge_detection_2.jpg)\n        可以发现他利用$3\\times 3$的卷积模板$\\begin{bmatrix}1&0&-1\\\\1&0&-1\\\\1&0&-1\\end{bmatrix}$检测出了垂直线条，他的原理其实是利用图像边缘是一阶导数的极值点，利用梯度算子来检测边缘。\n\n+ 垂直边缘检测模板和水平边缘检测模板\n\n    + 垂直边缘检测模板：$\\begin{bmatrix}1&0&-1\\\\1&0&-1\\\\1&0&-1\\end{bmatrix}$\n    + 水平边缘检测模板：$\\begin{bmatrix}1&1&1\\\\0&0&0\\\\-1&-1&-1\\end{bmatrix}$\n    + 水平边缘检测模板例子\n        ![水平边缘检测例子](/edge_detection_3.png)\n\n+ 更多种类的边缘检测模板\n    ![边缘检测模板](/edge_detection_4.png)\n    注意到这些检测模板都只能检测水平或者是垂直的线条，当然也有利用平均差分方向梯度、十二方向梯度等方式检测斜线，但显然还是很复杂。下面我们将谈到如何解决这个问题。\n\n+ 传统图像分析的平滑、锐化、边缘检测模板类型特点（来自`《现代图像分析》幻灯片`）\n    ![传统模板](/edge_detection_model.png)\n\n+ **深度学习——让神经网络自己训练学习$3\\times3$卷积模板中的9个参数**\n    ![深度学习](/edge_detection_5.png)\n    为了让能检测各种方向的线条，利用图像卷积实现更多的效果，我们可以通过深度学习来训练这个卷积模板，当然他不一定是$3\\times 3$的，可以是$5\\times 5$甚至更高维度的。一般我们选择奇数维的卷积模板。\n\n### CNN基本组件\n\n在本节中，我们介绍卷积的基本操作方式和CNN的常见组件，是他的的有序结合得到了CNN。\n\n#### Padding\n\n注意到上面的例子中，我们对一个$6\\times 6$的图像利用$3\\times3$的模板进行卷积，得到了$4\\times 4$的结果。推而广之，对一个$n\\times n$的图像利用$f\\times f$的模板进行卷积，将得到了$(n-f+1)\\times (n-f+1)$的结果。可以发现：\n\n+ 矩阵的维数变少了（shrinking output）\n+ 注意到在角落和边缘的数据信息没有被充分利用\n\n解决上述两个问题的方法就是——Padding\n\n![padding](/padding.jpg)\n\n对$6\\times6$的图像用0加一圈边就变成了$8\\times 8$的图像，再用$3\\times 3$的模板进行卷积得到的结果就是$6\\times6$的了，此时图片的维度没有发生变化。我们把这种情况记作$p=1$。推而广之，对一个$n\\times n$的图像，进行$p$-Padding，利用$f\\times f$的模板进行卷积，将得到了$(n+2p-f+1)\\times (n+2p-f+1)$的结果。\n\nPadding的两种极端是：\n\n+ Valid Convolution：有效卷积，即我们进行卷积的都是有效数据，这种情况就退化到了最一般的二维卷积\n    $$\n    \\begin{aligned}\n    n\\times n &*&f\\times f&=(n-f+1)\\times (n-f+1)\n    \\end{aligned}\n    $$\n\n+ Same Convolution：相同卷积，即保持我们卷积输出结果和输入矩阵维数一致。\n    $$\n    \\begin{aligned}\n    (n+2p)\\times (n+2p) &*&f\\times f&=(n+2p-f+1)\\times (n+2p-f+1)\n    \\end{aligned}\n    $$\n    若保持输出与输入维数一致，则$n+2p-f+1=n$，即$p=\\frac{f-1}{2}$。\n\n    \n\n\n\n#### Strided convolution\n\n在进行卷积操作时，我们有时也需要压缩矩阵的维数，以获得一个更小的矩阵，我们可以通过卷积模板两次移动之间的跨越方格数来调整，而这就被称为stride。\n\n<img src=\"/strided.jpg\" alt=\"stride\" style=\"zoom:50%;\" />\n\n上图蓝色点的移动跨度$s$为2，对应于卷积模板的左上角点。对于一个$7\\times 7$的图像，以$s=2$为跨度用$3\\times 3$的模板进行卷积，得到的结果图像是$3\\times 3$维的。更一般的可以写成\n$$\n\\begin{aligned}\nn\\times n &*&f\\times f&=\\left\\lfloor\\frac{n+2p-f}{s}+1\\right\\rfloor\\times\\left\\lfloor\\frac{n+2p-f}{s}+1\\right\\rfloor\n\\end{aligned}\n$$\n\n\n#### Convolutions Over Volume\n\n卷积不光可以对二维的图像进行，还可以对有多个维度的图像进行，比如对RGB三个通道的灰度图像分别进行卷积。\n![Volume](/volume_1.png)\n\n注意到图片的前两个维度表示长和宽，第三个维度表示通道数（number of channel，也被叫做深度，depth）。对于存在通道数的卷积其实和二维卷积类似，我们计算每个通道上的卷积，再将对应点相加即可得到在Volume进行的卷积结果。值得注意的是，**对于多通道的图像利用有多通道的卷积模板进行卷积最后得到的是一个二维图像。**\n\n那么如何得到有多个通道的图像呢？——我们需要利用多个卷积模板滤波器\n\n![Volume_2](/volume_2.png)\n\n我们**对多通道的图像利用$N$次多通道的卷积模板进行卷积即可得到$N$个通道的图像**，比如我们对RGB三通道图像施加一个垂直边缘检测模板，一个水平边缘检测模板，即可得到一个两通道的图像含有水平和平行边缘的信息。\n\n\n\n#### Pooling Layers\n\nPooling实际上和卷积操作机理并不相同，但是他也是CNN中常用的组件。Pooling主要有两种方式：Max pooling和Average pooling。\n\n+ Max pooling：移动模板，取每次被框选的数据中最大的一个（注意这里不再需要卷积，也就不需要模板的数值了）\n    + 对一个$4\\times 4$的图像，使用$2\\times 2$的模板以$stride=2$为跨度，每次取框选数值中的最大值得到右图的数值。\n        ![pooling](/pooling_1.png)\n    + 换言之，如果这些特征在这个filter中被检测到，那么保持一个高的数字。这样可以显著的降低矩阵的维数。\n    + 但是对于有多个通道的图像，我们需要注意pooling仅是针对一个维度而言的，这个卷积的操作并不一样。\n        ![pooling_channel](/pooling_2.jpg)\n        如上图对于一个$5\\times 5\\times 2$的图像，使用$3\\times 3$的模板以$s=1$为跨度进行Max Pooling得到的结果是一个$3\\times 3\\times 2$的图像。\n+ Average Pooling：和Max pooling不同的是，此时所取得值为被框选数值得平均值。\n    + ![pooling_3](/pooling_3.jpg)\n    + Average Pooling的主要用途为在深度很深的NN中，⽤均值采样合并表示\n\n小小总结以下，在Padding操作中，只存在超参数($f$ for filfter size, $s$ for stride)，不需要Padding。不论是对于Max Pooling还是Average Pooling都没有参数需要学习。经过Pooling后矩阵的维数变为\n$$\n\\begin{aligned}\nn_H\\times n_W \\times n_C\\to\\left\\lfloor\\frac{n-f}{s}+1\\right\\rfloor\\times\\left\\lfloor\\frac{n-f}{s}+1\\right\\rfloor\n\\end{aligned}\n$$\n\n\n\n\n### 构建CNN\n\n下面，利用上面学习到的卷积的基本操作和CNN组件来一步一步搭建CNN。\n\n#### One layer of CNN\n\n首先考虑对于单层的CNN的搭建。\n\n卷积实际上是一个线性的过程，我们显然需要非线性函数使他变成一个标准的NN，比如ReLU。\n![one_layer](/one_layer_1.png)\n\n那么我们可以把这个前向传播过程表述为\n$$\n\\begin{gathered}\nz^{[1]}=w^{[1]}a^{[0]}+b^{[1]}\\\\\na^{[1]}=g(z^{[1]})\n\\end{gathered}\n$$\n上图可以简单表示为\n![one_layer](/one_layer_2.png)\n\n+ 在一层CNN中参数的个数\n    例如，对于利用$3\\times 3\\times 3$的卷积模板作卷积需要$(3\\times 3\\times 3+bias)=28$个参数，如果产生的通道数为10，则需要10个这样的模板，即需要$28\\times 10=280$个参数。\n\n+ Notation：\n    If layer $l$ is a convolution layer.\n\n    + Input: $n_{H}^{[ l-1]} \\times n_{W}^{[l-1]} \\times n_{c}^{[l-1]}$\n        Output: $n_{H}^{[ l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]}$（其中，$n_{\\bullet}^{[l]}=\\left\\lfloor\\frac{n_{\\bullet}^{[l-1]}+2p^{[l]}-f^{[l]}}{s^{[l]}}+1\\right\\rfloor$,$\\bullet=H\\text{ or }W$）\n        + $f^{[l]}$: filter size of $l^{th}$ layer\n        + $p^{[l]}$: padding\n        + $s^{[l]}$: stride\n        + $n_c^{[l]}$: number of filters\n    + Each filter is $f^{[l]}\\times f^{[l]}\\times n_c^{[l-1]}$\n    + Activation: $a^{[l]}\\to n_{H}^{[ l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]},\\quad A^{[l]}\\to m\\times n_{H}^{[ l]} \\times n_{W}^{[l]} \\times n_{c}^{[l]}$\n    + Weight: $f^{[l]}\\times f^{[l]}\\times n_{c}^{[ l-1]}  \\times n_{c}^{[l]}$\n    + Bias: $n_{c}^{[l]}\\to 1\\times 1\\times 1\\times n_c^{[l]}$\n\n    \n\n\n\n#### Simple Convolutional Network example\n\n对于一个简单的卷积网络（ConvNet），我们可以用单层CNN组装而成\n![SImple](/simple_convnet.png)\n\nCNN网络中常见的组件：\n\n+ **CONV**: Convolution\n+ **POOL**：Pooling\n+ **FC**：Fully Connected\n\n\n\n#### CNN example\n\n下图是一个使用LeNet-5实现手写数字识别的过程。\n\n![LeNet-5](/LeNet-5.png)\n\n#### Why convolution？\n\n相对于前面三门课程的DNN，为何对于图像要使用CNN呢？\n\n+ parameter sharing 参数共享：可以减少parameters 的个数\n+ sparsity of connection 稀疏性： each output value depends only a small number ofinputs\n+ put it together\n    ![Why?](/Why.jpg)\n\n## Week 2：Deep Convolutional Models: Case Studies\n\n### Case Studies\n\n本节中主要介绍一些常用的CNN模型，包括传统模型、ResNet和Inception Network.\n\n#### Classic Networks\n\n1. LeNet-5(1998年)\n    ![LeNet-5](/LeNet-5_2.jpg)\n\n    网络特点：\n\n    + 60k parameters（比较小）\n    + 随着网络的深入，$n_H,n_W\\downarrow,\\ n_c\\uparrow$\n    + 网络结构：CONV→POOL→CONV→POOL→FC→FC→Output\n    + 由于提出时间比较早，使用的主要是sigmoid/tanh，而不是现在比较流行的ReLU\n\n2. AlexNect（2012年）\n    ![AlexNet](/AlexNet.png)\n\n    网络特点：\n\n    + 有更多的参数，达到了60 M。\n    + 使用性能更好的ReLU函数，而非sigmoid或是tanh。\n    + 但是文章中的多GPU是现在不需要考虑的，Local response Normalization （LRN）是吴恩达不推荐的，Andrew Ng认为他没有必要\n\n3. VGG-16\n\n    网络最突出的特点就是所有CONV层和POOL层采用的都是一样的参数\n\n    + CONV: 采用$3\\times 3$ filters，$s=1$，same\n    + MAX-POOL：采用$2\\times 2$ filters, $s=2$\n\n    ![VGG-16](/VGG-16.png)\n\n    + 该网络有128 M的参数\n    + 除此以外还有VGG-19\n\n\n\n#### ResNet (Residual Networks)\n\ngradient vanishing/exploding → skip connection → ResNet（残差⽹络）\n\n为了抑制梯度消失或者梯度爆炸，我们采取跳过几层网络直接作用的方式，这就构成了残差网络。\n\n1. Residual block\n    ![block](/ResNet.png)\n\n    更细致的可以画成这样：\n\n    <img src=\"/ResNet_2.png\" alt=\"path\" style=\"zoom:50%;\" />\n\n    将Residual block用数学公式表达：\n    $$\n    \\begin{aligned}\n    z^{[l+1]}=&W^{[l+1]}a^{[l]}+b^{[l+1]}\\\\ \n    a^{[l+1]}=&g(z^{[l+1]})\\\\ \n    z^{[l+2]}=&W^{[l+1]}a^{[l+1]}+b^{[l+2]}\\\\ \n    a^{[l+2]}=&g(z^{[l+2]})\\\\ \n    \\boldsymbol{a^{[l+2]}=}&\\boldsymbol{g(z^{[l+2]}+a^{[l]})}\n    \\end{aligned}\n    $$\n\n2. Residual Network\n\n    + 我们Residual block级联，就可以构成一个最简单的ResNet。其中黑色的是plain network，加上了skip connection后它就变成了ResNet\n        ![ResNet_plain](/ResNet_3.png)\n\n    + 对比普通网络和ResNet的性能\n\n        ![compare](/ResNet_4.jpg) 可以发现一般的网络在网络层数增加到一定多时，错误率不降反升，这是因为前后参数之间没有建立起联系，而ResNet通过跳跃的方式是的前后之间有所牵制，不至于梯度消失或爆炸。\n\n    + 为什么ResNet能够运行起来呢？\n        + The identity function（恒等函数） is easy for residual block to learn.\n            ![ identity function](/ResNet_6.png)\n        + Adding residual block doesnt hurt NN only\n        + help performance——底线是不会破坏网络，可能会出奇效\n            + baseline: not hurt NN\n            + help: gradient descent mayhelp improve\n\n    ![ResNet](/ResNet_5.jpg)\n\n     \n\n\n\n\n#### Inception Network\n\n1. Networks in Networks and $1\\times 1$ convolution\n\n    \n\n\n\n### Practical advices for using ConvNets\n\n#### Transfer learning\n\n\n\n#### Data Augmentation\n\n\n\n#### State of CV\n\n\n\n\n\n## Week 3: Object Detection\n\n### 目标识别基础\n\n#### Object localization\n\n\n\n#### Landmark Detection\n\n\n\n### 目标识别组件\n\n#### Object detection\n\n\n\n\n\n#### Convolutional Implementation of Sliding Windows\n\n\n\n#### Bounding Box Algorithm\n\n\n\n#### Make YOLO Better\n\n\n\n\n\n### 应用YOLO\n\n#### YOLO Algorithm\n\n\n\n#### Region Proposals\n\n\n\n## Week 4: Special Applications: Face recognition & Neural Style Transfer\n\n\n\n### Face Recognition\n\n#### What is face recognition？\n\n\n\n#### One-shot learning\n\n\n\n#### Siamese Network\n\n\n\n#### triplet loss\n\n\n\n#### Face verification and Binary classification\n\n\n\n### Neural Style transfer\n\n<object data=\"style_transfer_beamer_handout.pdf\" type=\"application/pdf\" width=\"100%\" height=\"450px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF。请点击下载查看: \n<a href=\"style_transfer_beamer_handout.pdf\">Download PDF</a>.</p>\n</object>\n\n\n该beamer建议在支持动画的PDF阅读器上播放。比如Adobe Acrobat DC等，否则无法播放动画哦。\n\n\n\n\n\n\n\n\n\n\n\n","tags":["深度学习","机器学习"],"categories":["科研向"]},{"title":"【无线通信学习笔记（五）】分集","url":"/2021/05/07/Wireless-Communications-Ch-7/","content":"\n> *Wireless Communications* (Andrea Goldsmith)学习笔记。\n\n# Diversity\n\n在“衰落信道中数字带通传输系统的性能分析”中，我们注意到瑞利衰落（多径衰落）和对数正态分布（阴影衰落）会对数字带通传输系统造成很大的影响，减轻衰落的最有力的方法就是分集-合并（diversity-combining）技术。\n\n+ 理论依据：\n    + 分：独立信号路径经由很小概率会同一时刻经历深衰落（deep fades）\n    + 集：经过合并接收信号的衰落就会很小。例如选择信号最强的那根天线就是selection combining\n+ 微分集（microdiversity）：减弱多径衰落（multipath）影响\n+ 宏分集（macrodiversity）：减弱来自建筑、物体的阴影衰落（shadowing）\n    + 做法：combining signals received by several base stations or access points\n\n\n\n## 独立衰落信道（Independent Fading Paths）\n\n+ **space diversity（空间分集）**：\n    + 单侧阵列天线（antenna array）——多发射天线**或**多接收天线\n    + 不增加发射功率或带宽\n    + 阵列增益：相干合并可以提高信噪比，降低检测因子的要求\n    + 空间分集还需要有足够大的天线间距以保证衰落幅度近似独立\n        + 对于全向天线，衰落独立需要半波长\n        + 对于方向性天线需要更大的天线间距\n+ polarization diversity（极化分集）：\n    + 两接收天线或两发射天线（水平极化和垂直极化）\n    + 极化分集最有只有两个分集分支\n    + 极化分集有3 dB的功率损耗\n+ 方向性天线（Directional antennas）：\n    + 对于方向性天线，波束对准某一角度\n    + 要求有足够多天线以覆盖到所有可能的来波方向，或者一个天线恰好对准来波方向。\n    + 当未对准时，信噪比将会降低\n+ Frequency diversity（频率分集）：通过不同载波频率传输同一窄带信号。需要额外的发射功率\n+ Time diversity（时间分集）：在不同时间传输同一信号。时间差要大于信道相干时间。\n\n\n\n## 接收机分集（Receiver Diversity）\n\n在接收机分集中，多个接收天线的独立衰落路径被结合起来，得到一个结果信号，然后通过一个标准解调器。\n\n![线性合并器](/linear_combining.png)\n\n+ combiner的输出时不同衰落路径（分支）的**加权求和**，一般是线性的。\n\n+ co-phaseing（共相位）：当合并超过一条支路是需要co-phaseing，加权时乘$\\alpha_i=a_ie^{-j\\theta_i}$来消除相位，确保实现相干合并。一般采用先检测后合并的相干合并策略，这样可以确定合适的$\\alpha_i$。\n\n+ 分集的目的：对独立衰落信道相干合并，以减弱衰落的影响。\n    $$\n    \\alpha_\\Sigma=\\sum_ia_ir_i\n    $$\n\n+ 阵列增益（array gain）：对多路信号的相干合并（不必在衰落条件下）。\n    $$\n    A_g=\\frac{\\bar\\gamma_\\Sigma}{\\bar \\gamma}\n    $$\n    对于MRC（最大比合并）：\n    $$\n    \\gamma_\\Sigma=\\frac{ME_s}{N_0}\n    $$\n    相比于未合并提高了M倍。\n\n    > 其实这边的概念可以用《雷达原理与系统》中的相干积累来理解，也是比较类似的。\n    >\n    > ![相干积累](/integration.png)\n    > 只需要相干积累前的$\\frac{1}{M}$，即\n    > $$\n    > D_0(M)=\\frac 1MD_0(1)\n    > $$\n    > 在相同检测条件下，相干积累增加了SNR，就可以减小对于单个脉冲串的SNR要求。对于同样作用距离，雷达可以减小发射峰值功率。\n    >\n    > 同理对于无线通信系统来说，这里的相干合并提高了总体的信噪比，也就降低了对于每一分支SNR要求有，但是在这里我们不是为了降低发射功率，而是为了减小衰落带来的影响。\n    >\n    > 在雷达中还有一种非相干积累，即视频积累。他在检波后进行积累就不需要相干载波，但是非相干对于无线通信来说是不可能的，因为非相干合并并没有消除相位的影响，也就没有不能消除衰落的影响。\n\n    + 所有分集合并都有阵列增益，MRC的阵列增益最大\n    \n+ 分集增益（diversity gain）：分集带来了$\\gamma_\\Sigma$更好的分布，从而降低了平均误码率$\\bar P_s$和中断率$P_\\text{out}$。\n\n    + 分集阶数（diversity order）：误码率表示为$\\bar P_s=c\\bar\\gamma^{-M}$中的$c$，取决于具体调制方式。The diversity order indicates how the slope of the average probability of error as a function of average SNR changes with diversity.\n    + The maximum diversity order of a system with $M$ antennas is $M$, and when the diversity order equalsM the system is said to achieve **full diversity order**.\n\n### SC(选择合并)\n\n+ 选择合并（selection combining，SC）：合并器在具有最高信噪比$\\frac{r_i^2}{N_i}$的分支上输出信号。\n\n+ 特点：\n\n    + 如果所有分支上的噪声功率$N_i = N$相同，这就相当于选择具有最高$r^2_i + N_i$的分支。\n    + 只需要一个接收机，时分复用\n    + 不需要co-phasing，可以应用于相干解调和差分解调\n\n+ i.i.d Rayleigh衰落合并输出的平均信噪比：\n    $$\n    \\bar\\gamma_\\Sigma=\\bar\\gamma\\sum_{i=1}^M\\frac{1}{i}\n    $$\n\n    + 平均信噪比增益随$M$增加而增加，但**非线性**。\n    + 随着$M$的进一步增大，阵列增益趋于0.\n    \n+ 性能分析\n\n     + 给定中断率$P_{out}$时检测因子（单支路接收信噪比）的改善(设所有支路信噪比一致)\n        $$\n        P_{out}=p(\\gamma_\\Sigma<\\gamma_0)=\\left[1-e^{-\\frac{\\gamma_0}{\\bar \\gamma}}\\right]^M\n     \t$$\n     \t![SC](SC.png)\n     \n     + 给定平均误比特率$\\bar P_b$时的检测因子（一般无闭式解）\n\t\t$$\n        \tp_{\\gamma_{\\Sigma}}(\\gamma)=\\frac{M}{\\bar{\\gamma}}\\left[1-e^{-\\gamma / \\bar{\\gamma}}\\right]^{M-1} e^{-\\gamma / \\bar{\\gamma}}\n       $$\n        ![SC_Pb](/SC_Pb.png)\n     \t由于组合器的阵列增益，$M\\ge 8$的分集系统的误比特率低于相同信噪比的AWGN信道。\n\n### Threshold Combining（门限合并）和SSC\n\n+ 门限合并（Threshold Combining）：合并器按顺序扫描每个分支，输出信噪比高于给定阈值$\\gamma_T$的第一个信号。\n+ SSC（切停合并，switch and stay combining）：在只有两个分支的情况下，相当于在活动分支的信噪比低于$\\gamma_T$时切换到另一个分支。性能介于无分集和SC之间。\n+ 性能分析：\n    + 在任意衰落分布下，对于最佳门限的SSC和SC有相同的**中断率**。\n    + 采用SSC的相干解调，平均误比特率一般没有闭式解\n\n### MRC（最大比合并）\n\n+ 最大比合并（Maximal Ratio Combining，MRC）：合并器输出各分支信号的加权求和。\n\n+ 合并输出信噪比：\n    $$\n    \\max_{a_i} \\gamma_{\\Sigma}=\\frac{r^{2}}{N_{t o t}}=\\frac{1}{N_{0}} \\frac{\\left(\\sum_{i=1}^{M} a_{i} r_{i}\\right)^{2}}{\\sum_{i=1}^{M} a_{i}^{2}}\n    $$\n    最佳加权值为$a_i^2=\\frac{r_i^2}{N_0}$，合并输出信噪比为\n    $$\n    r_{\\Sigma}=\\sum_{i=1}^M\\frac{r^2_i}{N_0}=\\sum_{i=1}^M\\gamma_i\n    $$\n    可见，合并输出的平均信噪比随分集分支$M$增加而**线性增加**。\n\n+ 性能分析\n  \n    + 中断率：\n    \n    \t$$\n    \tP_{\\text {out }}=p\\left(\\gamma_{\\Sigma}<\\gamma_{0}\\right)=\\int_{0}^{\\gamma_{0}} p_{\\gamma_{\\Sigma}}(\\gamma) d \\gamma=1-e^{-\\gamma_{0} / \\bar{\\gamma}} \\sum_{k=1}^{M} \\frac{\\left(\\gamma_{0} / \\bar{\\gamma}\\right)^{k-1}}{(k-1) !}\n    \t$$\n    \t![MRC](MRC.png)\n    \t\n\t+ 平均误码率可由合并输出信噪比的分布求得：\n    \t$$\n    \tp_{\\gamma_{\\Sigma}}(\\gamma)=\\frac{\\gamma^{M-1} e^{-\\gamma / \\bar{\\gamma}}}{\\bar{\\gamma}^{M}(M-1) !}, \\quad \\gamma \\geq 0\n    \t$$\n    \t![MRC_Pb](/MRC_Pb.png)\n\n+ **MRC的性能远好于SC**\n\n+ 用MGF求MRC分集的平均误码率\n\n    + 平均误码率通式：\n        $$\n        \\bar{P}_{s}=\\int_{0}^{\\infty} c_{1} \\exp \\left[-c_{2} \\gamma\\right] p_{\\gamma_{\\Sigma}}(\\gamma) d \\gamma\n        $$\n        用MGF表示\n        $$\n        \\bar{P}_{s}=c_{1} \\int_{A}^{B} \\prod_{i=1}^{M} \\int_{0}^{\\infty} \\exp \\left[-c_{2}(x) \\gamma_{i}\\right] p_{\\gamma_{i}}\\left(\\gamma_{i}\\right) d \\gamma_{i}=c_{1} \\int_{A}^{B} \\prod_{i=1}^{M} M_{\\gamma_{i}}\\left(-c_{2}(x)\\right) d x\n        $$\n        适用于任意分集分支和任意支路衰落分布\n        \n    + 具体调制与衰落分布的平均误码率这里不抄了\n+ $\\gamma_i$分布相同，高信噪比时的平均误码率\n    $$\n    \\bar P_s\\approx\\alpha_M\\left(\\frac{\\beta_M\\bar \\gamma}{2}\\right)^{-M}\n    $$\n    分集阶数为M，为满分集阶数\n### EGC（等增益合并）\n\n+ 等增益合并（Equal-Gain Combining，EGC）：以相同权重$\\alpha_i=e^{-j\\theta_i}$对所有分支加权求和。\n\n    > 基本上就是相干解调的意思了。\n\n+ 合并输出信噪比\n    $$\n    \\gamma_{\\Sigma}=\\frac{1}{N_{0} M}\\left(\\sum_{i=1}^{M} r_{i}\\right)^{2}\n    $$\n\n+ 性能分析：\n\n    + 中断率：\n        $$\n        P_{\\text {out }}\\left(\\gamma_{0}\\right)=1-e^{-2 {\\frac{\\gamma_0}{\\bar\\gamma}}}-\\sqrt{\\pi \\frac{\\gamma_0}{\\bar\\gamma}} e^{-\\frac{\\gamma_0}{\\bar\\gamma}}\\left(1-2 Q\\left(\\sqrt{2 \\frac{\\gamma_0}{\\bar\\gamma}}\\right)\\right)\n        $$\n\n    + 平均误码率可由输出信噪比的分布求得\n        $$\n        p_{\\gamma_{\\Sigma}}(\\gamma)=\\frac{1}{\\bar{\\gamma}} e^{-2 \\gamma / \\bar{\\gamma}}+\\sqrt{\\pi} e^{-\\gamma / \\bar{\\gamma}}\\left(\\frac{1}{\\sqrt{4 \\gamma \\bar{\\gamma}}}-\\frac{1}{\\bar{\\gamma}} \\sqrt{\\frac{\\gamma}{\\bar{\\gamma}}}\\right)(1-2 Q(\\sqrt{2 \\gamma / \\bar{\\gamma}}))\n        $$\n\n+ EGC的性能非常接近MRC，功率损耗不超过1 dB，但是复杂度更低。\n\n+ 用MGF求EGC分集的平均误码率\n\n    + MGFs are less useful in the analysis of EGC and SC than in MRC.\n    + working with the MGF of $\\gamma_\\Sigma$ can sometimes lead to simpler results than working directly with its pdf. 比如将$s$变为$j2\\pi f$就将MGF变为特征函数，可以求得EGC分集MPSK的误码率的精确式。\n\n## 发射机分集（Transmitter Diversity）\n\n发射机分集一般被用在有充足的空间、功率和处理能力的地方。假设CSIR（Receiver CSI）讨论接收机是否知道CSI。\n\n### CSIR和CSIT\n\n+ CSIT：发射机已知第$i$根天线上的路径增益$r_ie^{j\\theta_i}$\n\n+ 最大化接收信噪比\n    $$\n    \\gamma_{\\Sigma}=\\frac{E_{s}}{N_{0}} \\sum_{i=1}^{M} r_{i}^{2}=\\sum_{i=1}^{M} \\gamma_{i}\n    $$\n    此时的加权值\n    $$\n    a_i=\\frac{r_i}{\\sqrt{\\sum_{i=1}^Mr_i^2}}\n    $$\n    当CSIT，发射机分集与MRC分集类似。接受信噪比为各支路信噪比之和\n\n+ $\\gamma_i$分布相同，高信噪比时的平均误码率\n    $$\n    \\bar P_s\\approx\\alpha_M\\left(\\frac{\\beta_M\\bar \\gamma}{2}\\right)^{-M}\n    $$\n    分集阶数为M，为满分集阶数\n    \n+ 发射机分集的问题：发射机获取信道相位和幅度信息\n\n    + 导频（pilot technique）\n    + 利用时分（time-division）的互易性（reciprocal）\n\n### 仅CSIR——The Alamouti Scheme\n\n该方案在两个符号周期内工作，假定信道增益在这段时间内是不变的。在第一个码元间隔，两个不同的码元$s_1$和$s_2$分别从天线1和2同时传输，每个码元的能量为$\\frac{E_s}{2}$。在下一个码元间隔，符号$s^∗_2$从天线1发射，符号$s^∗_1$从天线2发射，每个码元能量为$ \\frac{E_s}{2}$。\n\n接收信号\n$$\n\\mathbf{y}=\\left[\\begin{array}{cc}\nh_{1} & h_{2} \\\\\nh_{2}^{*} & -h_{1}^{*}\n\\end{array}\\right]\\left[\\begin{array}{l}\ns_{1} \\\\\ns_{2}\n\\end{array}\\right]+\\left[\\begin{array}{c}\nn_{1} \\\\\nn_{2}^{*}\n\\end{array}\\right]=\\mathbf{H}_{A} \\mathbf{s}+\\mathbf{n}\n$$\n接收信噪比\n$$\n\\gamma_{i}=\\frac{\\left(\\left|h_{1}^{2}\\right|+\\left|h_{2}^{2}\\right|\\right) E_{s}}{2 N_{0}}\n$$\n分集阶数为2，但阵列增益只有1.\n\n> 这章内容和《雷达原理与系统》里面的雷达信号检测部分有异曲同工之妙，但是雷达往往发射重频信号，可以采用积累的方法来降低降低因子。而在无线通信中，我们不太可能反反复复发射一样的信号，所以就采用分集-合并的方式来降低对于检测因子的要求。但是有一些思路是一致的。\n\n## 参考文献\n\n1. ANDREA GOLDSMITH.*WIRELESS COMMUNICATIONS*.2005.\n2. （美）Andrea Goldsmith著；杨鸿文，李卫东，郭文彬等译. 无线通信. 北京：人民邮电出版社, 2007.06.","tags":["无线通信"],"categories":["课程向"]},{"title":"【无线通信学习笔记（四）】数字调制及其性能","url":"/2021/05/05/Wireless-Communications-Ch-5-6/","content":"\n>  *Wireless Communications* (Andrea Goldsmith)学习笔记。\n\n# Digital Modulation and Performance\n\n本书第五、六章主要介绍数字调制及其性能和同步原理的部分内容。\n\n+ 数字调制的优势：传输速率高，纠错能力强，抗信道失真，高效的多址接入和更好的安全和隐私性。\n+ 选择数字调制的考虑因素：\n    + 高传输速率\n    + 高频带利用率（最小化带宽占用）\n    + 高功率利用率（最小化发射功率）\n    + 对信道失真的稳健性（最小化误比特率/误信率）\n    + 低功耗，低成本\n+ 数字调制的分类：\n    + linear modulation（线性调制）：调幅，调相\n        + 有更好的频谱特性\n        + 易受到衰落和干扰的影响\n        + 需要昂贵功率利用率差的线性放大器\n    + constant envelope modulation (nonlinear modulation，恒包络调制，非线性调制)：调频\n    + trade-off of linear or nonlinear modulation\n        + 线性调制：频带利用率更佳\n        + 非线性调制：功率利用率更佳，抗信道失真的干扰更强\n+ 其它数字调制需要考虑的方面：\n    + 星座大小（constellations）：星座越大，给定带宽传输速率越高，对噪声、衰落和硬件干扰性能变差。\n    + 是否需要相干载波（coherent reference）：实现困难\n+ 数字调制的主要性能指标：\n    + 错误率（可靠性指标）：误码率和误比特率（误信率）\n    + 中断率：瞬时SNR低于门限的概率\n+ 无线信道传输过程中各种损耗带来的影响：\n    + 频率选择性衰落带来ISI，ISI又会造成error floor\n    + 多普勒频移会带来频谱扩展，频谱扩展会造成adjacent channel interference（邻信道干扰）。还会给差分编码造成不可避免的error floor\n\n\n\n## 信号空间分析\n\n数字调制与解调直观来说就是接收机将`接收信号`和`所有可能出现的发射信号`比较，选择`最接近`的作为检测结果，从而使得`错误率最低`。信号空间就是将信号embed到一个向量空间中，从而可以比较他们的接近程度。\n\n+ 符号说明：\n    + 系统以$T$间隔，发射$K=\\log_2M$ bits\n    + 在时间间隔$[kT,(k+1)T)$内，$K$ bits长的发射消息序列$m_i=\\{b_1,\\cdots,b_K\\}$\n    + 数字域所有可能发射消息所构成的集合$\\mathcal{M}$，$m_i\\in\\mathcal{M}(i=1,2,\\cdots, M=2^K)$，即发送消息序列每一个码元可以取0或者1\n    + 模拟域所有发射消息所构成的集合$\\mathcal{S}$，$s_i(t)\\in\\mathcal{S}(i=1,2,\\cdots, M=2^K)$\n\n一段时间内发射的消息是模拟域发射消息的组合\n$$\ns(t)=\\sum_ks_i(t-kT)\n$$\n接收信号为$r(t)=s(t)+n(t)$。在时间间隔$[kT,(k+1)T)$用接收信号$r(t)$作$s_i(t),m_i$的估计，最佳估计消息序列记作$\\hat m$.\n\n**接收机的目标——错误率最小**\n$$\nP_e=\\sum_{i=1}^Mp(\\hat m \\ne m_i|\\text{发射序列为}m_i)p(\\text{发射序列为}m_i)=\\frac{N_{error}}{N}\n$$\n\n### 信道的几何表示\n\n+ 将$M$个实信号构成的集合$\\mathcal{S}=\\{s_1(t), s_2(t),\\cdots, s_M(t) \\}$表示为$N(\\le M)$个实正交基函数$\\{\\phi_1(t), \\phi_2(t),\\cdots,\\phi_N(t) \\}$的线性组合。\n    $$\n    s_i(t)=\\sum_{j=1}^Ms_{ij}\\phi_{j}(t)\n    $$\n\n    + the minimum number $N$ of basis functions needed to represent any signal $s_i(t)$ of duration $T$ and bandwidth $B$ is roughly $2BT$.\n    + For linear passband modulation techniques, the basis set consists of the sine and cosine function with $\\sqrt{\\frac{2}{T}}$ factor.\n    + The simplest pulse shape that satisfies the orthonormal properties is the rectangular pulse shape $g(t) =\\sqrt{\\frac{2}{T}}(0\\le t<T)$.\n\n+ **信号的星座点与星座图**\n\n    + **信号的星座点（signal constellation point）**：将$s_i(t)$的系数矩阵$\\{s_{ij}\\}$的每一行表示成向量$\\mathbf{s}_i=(s_{i1},s_{i2},\\cdots.s_{iN})\\in\\mathbb{R}^N$\n    + **星座图（signal constellation）**：所有星座点构成的集合$\\{\\mathbf{s}_1,\\mathbf{s}_2 ,\\cdots,\\mathbf{s}_M\\}$.\n    + 信号$s_i(t)$和星座点$\\mathbf{s}_i$是一一的，将信号用星座点表示称为**信号空间表示（signal space representation）**\n    + 包含所有星座点的向量空间称为**信号空间（signal space）**\n\n+ 向量的长度与距离\n\n    + 向量的长度（length）：\n        $$\n        ||\\mathbf{s}_i||=\\sqrt{\\sum_{j=1}^Ns_{ij}^2}\n        $$\n\n    + 向量之间的距离（distance）：\n        $$\n        ||\\mathbf{s}_i-\\mathbf{s}_k ||=\\sqrt{\\sum_{j=1}^N(s_{ij}-s_{kj})^2}=\\sqrt{\\int_0^T(s_{i}(t)-s_{k}(t))^2\\mathrm{d}t}\n        $$\n        第二个等号通过正交基底的正交性获得\n\n### 充分统计量、判决域与接收机结构\n\n+ 使用正交基底，将接收信号$r(t)$转化为向量。\n\n    + 使用最大似然接收机\n      \n    + 接收信号:\n        $$\n      r(t)=\\sum_{j=1}^N(s_{ij}+n_j)\\phi_j(t)+n_r(t)=\\sum_{j=1}^Nr_j\\phi_j(t)+n_r(t)\n      $$\n        $n_r(t)$是不在与向量空间正交的噪声分量。\n    \n+ 充分统计量（sufficient statistic）：对$\\mathbf{s}_i$进行估计时，给定$r(t)$的最佳检测不会用到$n_r(t)$，那么最佳估计$\\hat m$只是$\\mathbf{r}=(r_1,r_2,\\cdots,r_N)$的函数，称$\\mathbf{r}$是最佳检测$r(t)$的充分统计量。\n\n    + 直观上可以看到$n_r(t)$在信号空间上的投影为0\n    \n    + 数学上可以证明发射信号与噪声是相互独立的，故$s_{ij}$与$n_r(t)$也是相互独立的。接收机设计准则\n       $$\n       \\max p(\\hat m=m_i|r(t))\\Leftrightarrow\\max p(\\text{发射星座点为}\\mathbf{s}_i|r(t))\n       $$\n       可以证明上式等于$p(\\text{发射信号为}(s_{i1},s_{i2},\\cdots,s_{iN})|(r_1,r_2,\\cdots,r_N))$，即在检测发射信息时不需要$n_r(t)$，只需要用$\\mathbf{r}$即可检测就可以使得错判概率最小。\n    \n+ 由于$\\mathbf{r}$是接收信号$r(t)$的充分统计量，$\\mathbf{r}$对应于$r(t)$的接收向量。\n\n+ 判决域（decisions regions）——信号空间的子集\n    $$\n    Z_i=\\{\\mathbf{r}:p(\\text{发射星座点为}\\mathbf{s}_i|\\mathbf{r})>p(\\text{发射星座点为}\\mathbf{s}_j|\\mathbf{r})\\forall j\\ne i\\}\n    $$\n    即在已知接收向量时，发射星座点为$\\mathbf{s}_i$比其余任何星座点的可能都大，则称为发射星座点$\\mathbf{s}_i$的判决域。\n    \n+ 最大似然接收机\n\n    ![最大似然接收机](/Receiver_Structure.png)有贝叶斯公式和等概率条件可以推出，要使错误率最低应满足\n    $$\n    \\arg\\max_{\\mathbf{s}_i}p(\\mathbf{r}|\\mathbf{s}_i)(i=1,\\cdots, M)\n    $$\n    最大化似然函数$L(\\mathbf{s}_i)=p(\\mathbf{r}|\\mathbf{s}_i)$，应该在星座图中扎到与$\\mathbf{r}$最近的星座点$\\mathbf{s}_i$。这个星座点由判决域决定：\n    $$\n    Z_{i}=\\left(\\mathbf{r}:\\left\\|\\mathbf{r}-\\mathbf{s}_{i}\\right\\|<\\left\\|\\mathbf{r}-\\mathbf{s}_{j}\\right\\| \\forall j=1, \\ldots, M, j \\neq i\\right) \\quad i=1, \\ldots, M\n    $$\n\n    + 非等概时，要对判决域进行修正\n\n+ 匹配滤波器是另一种接收机结构，两种接收机是等价的。\n    ![匹配滤波器接收机](/matched_filter.png)\n\n\n\n## 数字带通调制信号\n\n### 带通调制原理\n\n数字带通调制就是利用载波携带消息信号在信道中传输。调制的目的就是以更高速率传输的同时最下滑数据损失的概率。\n\n+ 已调信号的表示形式：\n    $$\n    s(t)=\\alpha(t) \\cos \\left[2 \\pi\\left(f_{c}+f(t)\\right) t+\\theta(t)+\\phi_{0}\\right]=\\alpha(t) \\cos \\left(2 \\pi f_{c} t+\\phi(t)+\\phi_{0}\\right)\n    $$\n    其中，$\\alpha(t)$表示调幅项，$f(t)$表示调频项，$\\theta(t)$表示调相项，而把调频调相合并也就是调角项$\\phi(t)=2\\pi f(t)+\\theta(t)$，$\\phi_0$是初相。\n\n+ 已调信号的正交表示和复包络表示\n    $$\n    \\begin{aligned}\n    s(t)=&\\alpha(t) \\cos \\phi(t) \\cos \\left(2 \\pi f_{c} t\\right)-\\alpha(t) \\sin \\phi(t) \\sin \\left(2 \\pi f_{c} t\\right)\\\\=&s_{I}(t) \\cos \\left(2 \\pi f_{c} t\\right)-s_{Q}(t) \\sin \\left(2 \\pi f_{c} t\\right)\\\\ \n    =&\\Re\\{u(t)e^{j2\\pi f_ct} \\}\n    \\end{aligned}\n    $$\n    其中，$u(t)=s_I(t)+js_Q(t)$。这种表示方式使用正交检波比较方便。\n\n### 线性调制——调幅/调相(Amplitude and Phase Modulation)\n\n+ AM/PM信号的信号空间表示\n    $$\n    s(t)=s_{i1}\\phi_1(t)+s_{i2}\\phi_2(t)\n    $$\n    其中，$\\phi_1(t)=g(t)\\cos(2\\pi f_c t+\\phi_0)$,$\\phi_1(t)=-g(t)\\sin(2\\pi f_c t+\\phi_0)$.\n\n+ AM/PM信号的复包络表示\n    $$\n    s(t)=\\Re\\{x(t)e^{j\\phi_0}e^{j2\\pi f_c t} \\}\n    $$\n    其中，$x(t)=(s_{i1}+js_{i2})g(t)$，$\\mathbf{s}_i=\\{s_{i1},s_{i2}\\}$被称为$\\log_2 M$ bits对应的符号(symbol)，$T_s$被称为码长(symbol time)，比特率是\n    $$\n    R=\\frac{\\log_2M}{T_s}(bps)\n    $$\n\n+ AM/PM的分类\n\n    + *M进制*脉幅调制(Pulse Amplitude Modulation, MPAM): information encoded in amplitude only.\n    + *M进制*相移键控(Phase Shift Keying, MPSK): information encoded in phase only.\n    + 正交振幅调制(Quadrature Amplitude Modulation, MQAM): information encoded in both amplitude and phase.\n\n+ AM/PM调制与解调\n    ![调幅调相的调制与解调](/AM_PM_modulate.png)\n\n    + 载波相位恢复（carrier phase recovery）→相干解调（coherent detection）\n    + 码元同步（synchronization）\n\n### MPAM（脉幅调制）\n\n+ 发射信号\n\t$$\n\ts_{i}(t)=\\Re\\left\\{A_{i} g(t) e^{j 2 \\pi f_{c} t}\\right\\}=A_{i} g(t) \\cos \\left(2 \\pi f_{c} t\\right), \\quad 0 \\leq t \\leq T_{s}\\gg1 / f_{c}\n\t$$\n\t\n\t+ 脉幅$A_i=(2i-1-M)d$（等间隔分布）\n\t\n\t+ 距离$d$是能量的函数，星座图最小距离$d_{\\min}=2d$\n\t\n\t+ 第$i$个星座点对应的MPAM信号的能量\n\t    $$\n\t    E_{\\mathbf{s}_i}=A_i^2\n\t    $$\n\t    平均能量为\n\t    $$\n\t    \\bar E_s=\\frac 1M\\sum_{i=1}^MA_i^2\n\t    $$\n\t\n+ 星座图——MPAM星座映射通常采用格雷码（Gray Coding），当判决错误为临近星座点时，$K$ bits中只错1 bit。\n    ![MPAM](MPAM.png)\n\n+ 判决域\n    $$\n    Z_{i}=\\left\\{\\begin{array}{ll}\\left(-\\infty, A_{i}+d\\right) & i=1 \\\\ {\\left[A_{i}-d, A_{i}+d\\right)} & 2 \\leq i \\leq M-1 \\\\ {\\left[A_{i}-d, \\infty\\right)} & i=M\\end{array}\\right.\n    $$\n    MPAM只有一个基函数$\\phi_1(t)=g(t)\\cos(2\\pi f_ct+\\phi_0)$\n    ![MPAM判决域](/MPAM_DR.png)\n\n+ MPAM的相干解调器\n    ![MPAM解调](/MPAM_dm.png)\n\n\n\n### MPSK（相移键控）\n\n+ 发射信号(圆上等间隔分布)\n    $$\n    \\begin{aligned}\n    s_{i}(t) &=\\Re\\left\\{A g(t) e^{j 2 \\pi(i-1) / M} e^{j 2 \\pi f_{c} t}\\right\\}, \\quad 0 \\leq t \\leq T_{s} \\\\\n    &=A g(t) \\cos \\left[2 \\pi f_{c} t+\\frac{2 \\pi(i-1)}{M}\\right] \\\\\n    &=A g(t) \\cos \\left[\\frac{2 \\pi(i-1)}{M}\\right] \\cos 2 \\pi f_{c} t-A g(t) \\sin \\left[\\frac{2 \\pi(i-1)}{M}\\right] \\sin 2 \\pi f_{c} t .\n    \\end{aligned}\n    $$\n\n    + 星座点由$s_{i 1}=A \\cos \\left[\\frac{2 \\pi(i-1)}{M}\\right]$ , $s_{i 2}=A \\sin \\left[\\frac{2 \\pi(i-1)}{M}\\right]$给定，在圆上等间隔分布\n    + 相移$\\theta_i=\\frac{2\\pi(i-1)}{M}$\n    + 星座图最小距离$d_{\\min}=2A\\sin\\left(\\frac{\\pi}{M}\\right)$\n    + 第$i$个星座点对应的MPAM信号的能量，且平均分布\n\t    $$\n\t    E_{\\mathbf{s}_i}=A_i^2\n\t    $$\n\t\n+ 星座图——格雷码映射\n    ![MPSK](/MPSK.png)\n\n+ 判决域\n    $$\n    Z_i=\\left\\{re^{j\\theta}:\\frac{2\\pi(i-0.5)}{M}\\le\\theta<\\frac{2\\pi(i+0.5)}{M} \\right\\}\n    $$\n    MPSK含有同相分量和正交分量![MPSK_DR](/MPSK_DR.png)\n\n+ 2PSK的相干解调\n\n    2PSK只有一个基函数$\\phi_{1}(t)=g(t) \\cos \\left(2 \\pi f_{c} t\\right)$![2PSK解调](/MPSK_dm.png)\n\n### MQAM（正交振幅调制）\n\nMQAM有两个自由度，幅度和相位均携带信息，故有更高的频谱利用率。\n\n+ 发射信号（下述对正方形星座分析）\n    $$\n    s_{i}(t)=\\Re\\left\\{A_{i} e^{j \\theta_{i}} g(t) e^{j 2 \\pi f_{c} t}\\right\\}=A_{i} \\cos \\left(\\theta_{i}\\right) g(t) \\cos \\left(2 \\pi f_{c} t\\right)-A_{i} \\sin \\left(\\theta_{i}\\right) g(t) \\sin \\left(2 \\pi f_{c} t\\right), \\quad 0 \\leq t \\leq T_{s}\n    $$\n\n    + 任意两个星座点的距离$d_{i j}=\\left\\|\\mathbf{s}_{i}-\\mathbf{s}_{j}\\right\\|=\\sqrt{\\left(s_{i 1}-s_{j 1}\\right)^{2}+\\left(s_{i 2}-s_{j 2}\\right)^{2}}$，星座图最小距离$d_{\\min}=2d$\n    + 星座点由$s_{i 1},s_{i2}$在$(2i-1-L)d,i=1,2,\\cdots,L=2^l$上取值\n    \n+ 星座图——正方形星座\n    ![MQAM](/MQAM.png)\n\n    + 有$M=L^2=2^{2l}$个星座点\n    + $2l$ bits/symbol\n    + 每维度多传1 bit，即每symbol多传2 bits，需要增加6 dB能量来保持星座图最小距离不变\n\n+ 判决域\n    ![MQAM_DR](/MQAM_DR.png)\n\n\n\n### 调幅/调相时其它方法\n\n1. 差分调制（Differential Modulation）\n    + 差分调制属于更普遍的带记忆的调制类别，在时间$[kT_s, (k + 1)T_s)$上传输的符号取决于与当前要传输的信息和在先前符号时间上的比特。\n    + 差分调制的基本原理是将先前的符号作为当前符号的相位参考，从而避免了在接收端需要相干相位参考。\n    + 差分相干解调\n        ![差分相干解调](/DPSK_dm.png)\n    + 差分编码对随机相位漂移不敏感，单对系统性的多普勒频移敏感，多普勒频移会造成error floor。\n2. 星座成形（Constellation Shaping）\n    + if a complex channel code is already being used and little further improvement can be obtained by a more complex code, constellation shaping may obtain around 1 dB of additional gain.\n3. 正交偏移（Quadrature Offset）\n    + 为防止信号倒相引起180度相移，将正交分量$g(t)$偏移半个码长，可消除突变，其目的是降低非线性失真的灵敏度\n        ![OMPSK](/OMPSK.png)\n    + Phase modulation with phase offset is usually abbreviated as O-MPSK, 例如$\\frac{\\pi}{4}$-QPSK\n\n### 调频\n\n+ FM信号的空间表示\n    $$\n    s_i(t)=\\sum_js_{ij}\\phi_j(t)=A\\phi_i(t)\n    $$\n    其中，$s_{ij}=A\\delta(i-j)$，$\\phi_j(t)=\\cos(2\\pi f_jt +\\phi_j)$。当$\\phi_i=\\phi_j$，则正交基函数的最小载波频率间隔为$\\frac{1}{2T_s}$。\n\n+ 调频信号的特点\n\n    + 恒包络，对幅度失真不敏感\n    + 频谱利用率低\n\n+ FM信号的调制与解调\n    ![FM信号的调制与解调](/FM_modulate.png)\n\n    + 解调器要求第$j$个载波相位域发射机第$j$个载波相位一致\n    + 载波相位不一致$\\phi_i\\ne \\phi_j$，或造成发射信号不连续，增大信号带宽\n\n\n\n### FSK（频移键控）&MSK（最小频移键控）\n\n+ FSK（Frequency Shift Keying）发射信号\n    $$\n    s_{i}(t)=A \\cos \\left[2 \\pi f_{c} t+2 \\pi \\alpha_{i} \\Delta f_{c} t+\\phi_{i}\\right], \\quad 0 \\leq t<T_{s}\n    $$\n\n    + 频移项系数$\\alpha_i=({2i-1-M}).i=1,2,\\cdots,M=2^K$，圆上等间隔分布\n    + 基函数$\\phi_{i}(t)=\\sqrt{\\frac 2{T_{s}}} \\cos \\left[2 \\pi f_{c} t+2 \\pi \\alpha_{i} \\Delta f_{c} t+\\phi_{i}\\right]$\n    + 最小频率间隔$2\\Delta f_c$\n\n+ 2FSK：只有两种频率变化\n\n+ MSK（Minimum Shift Keying）：对于2FSK，当$\\phi_1=\\phi_2$且频率间隔为$2\\Delta f=\\frac{1}{2T_s}$，此时有最小带宽\n\n### CPFSK（连续相位频移键控）\n\n+ 用数字基带信号调制单音载波，构成Continuous-Phase FSK（CPFSK）信号\n    $$\n    s_{i}(t)=A \\cos \\left[2 \\pi f_{c} t+2 \\pi \\beta \\int_{-\\infty}^{t} u(\\tau) d \\tau\\right]=A \\cos \\left[2 \\pi f_{c} t+\\theta(t)\\right]\n    $$\n\n    + $u(t)$时MPAM信号\n\n+ 卡森带宽（Carson）：$B_s\\approx M\\Delta f_c+B_g$，$B_g$是MPAM脉冲成形信号的带宽\n\n+ The spectral efficiency penalty of CPFSK increases with data rate.\n\n+ Coherent detection of CPFSK can be done symbol-by-symbol or over a sequence of symbols.\n\n### FSK的非相干检波\n\n当第$i$个分支（branch）的能量是所有分支中最高的，那么接收机就会输出信息$m_i$。\n![FSK非相干解调](/FSK_dm.png)\n\n\n\n## 脉冲成形、同步与载波恢复\n\n### 脉冲成形\n\n+ Nyquist准则：\n\n    + 时域：$p\\left(k T_{s}\\right)=\\left\\{\\begin{array}{ll}\n        p_{0}=p(0) & k=0 \\\\\n        0 & k \\neq 0\n        \\end{array}\\right.$\n    + 频域：$\\sum_{l=-\\infty}^{\\infty}P(f+\\frac{l}{T_s})=p_0T_s$\n\n+ 几种脉冲：\n\n    + Rectangular pulses(矩形脉冲) \n        $$\n        g(t)=\\sqrt{\\frac 2{T_s}}\n        $$\n        等效三角脉冲：\n        $$\n        p(t)=\\left\\{\\begin{array}{ll}2+2 t / T_{s} & -T_{s} \\leq t<0 \\\\ 2-2 t / T_{s} & 0 \\leq t<T_{s} \\\\ 0 & \\text { else }\\end{array}\\right.\n        $$\n        旁瓣较高\n\n    + Cosine pulses(余弦脉冲)\n        $$\n        p(t)=\\sin\\frac{\\pi t}{T_s}\n        $$\n        旁瓣比矩形脉冲低10 dB\n\n    + Raised Cosine Pulses（升余弦脉冲）\n\n        + 频域\n            $$\n            P(f)=\\left\\{\\begin{array}{ll}T_{s} & 0 \\leq|f| \\leq(1-\\beta) / 2 T_{s} \\\\ \\frac{T_{s}}{2}\\left[1-\\sin \\frac{\\pi T_{s}}{\\beta}\\left(f-\\frac{1}{2 T_{s}}\\right)\\right] & (1-\\beta) / 2 T_{s} \\leq|f| \\leq(1+\\beta) / 2 T_{s}\\end{array}\\right.\n            $$\n            \n        + 时域\n            $$\n            p(t)=\\frac{\\sin \\pi t / T_s}{\\pi t / T_s} \\frac{\\cos \\beta \\pi t / T_s}{1-4 \\beta^2 t^2 / T_s^2}\n            $$\n        \n        + 升余弦序列拖尾衰减很快，ISI小\n\n### 码元同步、载波同步\n\n+ 码元同步（Symbol Synchronization）：需要通过码元同步来划定与特定符号相关的接收信号。\n\n+ 载波同步（Carrier Phase Recovery）：得到相位信息。\n\n+ 接收机形式\n    ![接收机形式](/receiver.png)\n\n    + 接收信号\n        $$\n        r(t)=\\Re\\left\\{\\left(x(t-\\tau) e^{j \\phi}+z(t)\\right) e^{j 2 \\pi f_{c} t}\\right\\}\n        $$\n        码元同步需要估计$\\tau$，载波同步需要估计$\\phi$，表示成向量$\\theta=(\\phi,\\tau)$，则\n        $$\n        r(t)=s(t;\\theta)+n(t)\n        $$\n\n    + 最大似然估计（the maximum-likelhood criterion, ML）\n        $$\n        \\max p(\\mathbf{r} \\mid \\theta)=\\left(\\frac{1}{\\sqrt{\\pi N_{0}} \\sigma}\\right)^{K} \\exp \\left[-\\sum_{k=1}^{K} \\frac{\\left(r_{k}-s_{k}(\\theta)\\right)^{2}}{N_{0}}\\right]\n        $$\n        似然函数（likelihood function）\n        $$\n        \\Lambda(\\theta)=\\exp \\left[-\\frac{1}{N_{0}} \\int_{T_{0}}[r(t)-s(t ; \\theta)]^{2}\\right] d t\n        $$\n\n+ 最大似然相位估计（Maximum Likelihood Phase Estimation）\n    假设时钟已知，可得\n    $$\n    \\hat{\\phi}=-\\arctan \\left[\\frac{\\int_{T_{0}} r(t) \\sin \\left(2 \\pi f_{c} t\\right) d t}{\\int_{T_{0}} r(t) \\cos \\left(2 \\pi f_{c} t\\right) d t}\\right]\n    $$\n\n    + 实现方法——锁相环（phase lock loop）\n        ![PLL](/PLL.png)\n\n+ 最大似然定时估计（Maximum Likelihood Timing Estimation）\n    假设载波已知，可得\n    $$\n    \\sum_{k} s_{I}(k) \\frac{\\partial}{\\partial \\tau} z_{k}(\\tau)=0\n    $$\n\n    + decision-directed estimation(非盲估计)： voltage-controlled clock (VCC)\n        ![decision-directed](/feimang.png)\n    + non decision-directed timing estimation(盲估计)：early-late gate synchronizer（超前滞后门）\n        ![超前滞后门](/Early-Late_gate.png)\n\n\n\n## 数字带通传输系统的性能指标\n\n### 信噪比\n\n+ 接收信噪比（received SNR）\n    $$\n    \\mathrm{SNR}=\\frac{P_r}{N_0B}\n    $$\n\n    + 接收功率$P_r$取决于发射功率$P_t$，路径损耗（path loss），阴影衰落（shadowing），多径衰落（multipath）。\n    + 噪声功率取决于$s(t)$的带宽和噪声频谱特性。$s(t)$基带的带宽为$B$，传入带通传输系统时候的带宽$2B$，白噪声双边噪声功率谱密度$\\frac{N_0}{2}$，噪声功率$N=\\frac{N_0}{2}2B=N_0B$\n\n+ 接收信-干-噪比（received signal-to-interference-plus-noise power ratio, SINR）\n    $$\n    \\mathrm{SINR}=\\frac{P_r}{N_0+P_I}\n    $$\n\n+ 信噪比的能量表示\n    $$\n    \\mathrm{SNR}=\\frac{P_r}{N_0B}=\\frac{E_s}{N_0BT_s}=\\frac{E_b}{N_0BT_b}\n    $$\n    其中，$T_s$是码长（码元间隔），$T_b$是比特间隔\n\n+ 符号信噪比（SNR per symbol）与比特信噪比（SNR per bit）\n\n    + 符号信噪比\n        $$\n        \\gamma_s=\\frac{E_s}{N_0}\n        $$\n\n    + 比特信噪比\n        $$\n        \\gamma_b=\\frac{E_b}{N_0}\n        $$\n\n    + 对于任意成形脉冲满足$T_s=\\frac{k}{B}$，有\n        $$\n        k\\times \\mathrm{SNR}=\\frac{E_s}{N_0}=\\gamma_s\n        $$\n\n\n\n### 误码率和Q函数\n\n+ 误码率：\n    $$\n    \\begin{aligned}\n    P_e=&\\sum_{i=1}^Mp(\\mathbf{r}\\notin Z_i|\\text{发射序列为}m_i)p(\\text{发射序列为}m_i)\\\\ \n    =&1-\\frac 1M\\sum_{i=1}^M\\int_{Z_i-\\mathbf{s}_i}p(\\mathbf{n})d\\mathbf{n}\n    \\end{aligned}\n    $$\n\n    + 形象地理解错误率就是星座点$\\mathbf{s}_i$加上噪声后变成$\\mathbf{s}_i+\\mathbf{n}$后不在判决域$Z_i$中概率。\n    + 错误率积分具有平移不变性和旋转不变性\n\n+ 利用联合界（Union bound）描述错误概率：\n\n    + 用联合界表示发射序列为$m_i$的错误概率\n        $$\n        P_{e}\\left( \\text {发射序列为 }m_{i}\\right)=p\\left(\\bigcup_{k=1 \\atop k \\neq i}^{M} A_{i k}\\right) \\leq \\sum_{k=1 \\atop k \\neq i}^{M} p\\left(A_{i k}\\right)\n        $$\n        其中，$A_{ik}$表示发射星座点$\\mathbf{s}_i$时，$\\left\\|\\mathbf{r}-\\mathbf{s}_{k}\\right\\|<\\left\\|\\mathbf{r}-\\mathbf{s}_{i}\\right\\|$\n\n    + 经过化简可以发现错判概率等于噪声向量$\\mathbf{n}$离矢量$\\mathbf{s}_i-\\mathbf{s}_k$比离原点跟近的概率\n\n\n+ 误码率的界：\n\n    + **联合界估计的界**：\n        $$\n        P_{e}=\\sum_{i=1}^{M} p\\left(m_{i}\\right) P_{e}(\\text {发射序列为 }m_{i}) \\leq \\frac{1}{M} \\sum_{i=1}^{M} \\sum_{k=1 \\atop k \\neq i}^{M} Q\\left(\\frac{d_{i k}}{\\sqrt{2 N_{0}}}\\right)\n        $$\n        其中，Q函数为\n        $$\n        Q(z)=\\int_z^\\infty \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\\mathrm{d}x=\\frac 12\\mathrm{erfc}\\left(\\frac{z}{\\sqrt{2}}\\right)\n        $$\n\n    + 利用**最小距离估计的界**：\n        $$\n        P_{e} \\leq(M-1) Q\\left(\\frac{d_{\\min }}{\\sqrt{2 N_{0}}}\\right)= \\frac{M-1}{\\sqrt{\\pi}} \\exp \\left[\\frac{-d_{\\min }^{2}}{4 N_{0}}\\right]\n        $$\n        其中，最小距离（minimum distance）为$d_{\\min}=\\min_{i,k}d_{ik}=\\min_{i,k}||\\mathbf{s}_i-\\mathbf{s}_k||$\n\n+ **最近邻近似(the nearest neighbor approximation)**\n    $$\n    P_{e} \\approx M_{d_{\\min }} Q\\left(\\frac{d_{\\min }}{\\sqrt{2 N_{0}}}\\right)\n    $$\n    其中，$M_{d_{\\min}}$是相邻为$d_{\\min}$的星座点的个数。\n\n    + 最近邻近似小于最小距离估计的界，略小于联合界估计的界\n\n    + 在高信噪比情况下，最近邻近似解接近误码率的准确值\n\n    + 最近邻近似仅取决于**最小距离$d_{\\min}$和相邻星座点个数$M_{d_{\\min}}$**\n\n    + 对于$M=2$的二元调制，误信率为\n        $$\n        P_b=P_s=Q\\left(\\frac{d_{\\min}}{\\sqrt{2N_0}}\\right)\n        $$\n\n+ 误码率与误信率\n\n    + 误码率（误符号率，symbol error probability，$P_e,P_s$）\n    + 误信率（误比特率，bit error probability，$P_b$）\n    + 对于Gray encoding，高信噪比时可以认为一码元错误对应一比特错误，则\n    \n    $$\n    P_b\\approx\\frac{P_s}{\\log_2M}\n    $$\n    \n+ Q函数表现形式\n\n    + 形式一：\n        $$\n        Q(z)=\\int_z^\\infty \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{x^2}{2}}\\mathrm{d}x=\\frac 12\\mathrm{erfc}\\left(\\frac{z}{\\sqrt{2}}\\right)\n        $$\n\n    + 形式二：\n        $$\n        Q(z)=\\frac{1}{\\pi} \\int_{0}^{\\pi / 2} \\exp \\left[\\frac{-z^{2}}{2 \\sin ^{2} \\phi}\\right] d \\phi \\quad (z>0)\n        $$\n\n    + 注意到形式一积分区间为无穷，函数变量$z$出现在积分限上，而形式二的积分区间是和$z$无关的有限区间。\n\n## AWGN信道中数字带通传输系统的性能\n\n### MPSK的错误率\n\n+ 2PSK的误比特率（注意对于$M=2$的调制，最近邻近似是精确答案）\n    $$\n    P_b=Q\\left(\\frac{d_{\\min}}{\\sqrt{2N_0}}\\right)=Q\\left(\\frac{2\\sqrt{E_b}}{\\sqrt{2N_0}}\\right)=Q\\left(\\sqrt{2\\gamma_b}\\right)\n    $$\n    \n+ QPSK的误码率与误比特率\n\n    + QPSK的同相和正交分量都是2PSK\n\n    + 误码率\n        $$\n        P_s=1-\\left[1-Q\\left(\\sqrt{2\\gamma_b}\\right)\\right]^2=1-\\left[1-Q\\left(\\sqrt{\\gamma_s}\\right)\\right]^2\n        $$\n\n    + 误码率的最近邻近似\n        $$\n        P_s=2Q\\left(\\frac{A^2}{N_0}\\right)=2Q\\left(\\sqrt{\\frac{\\gamma_s}{2}}\\right)\n        $$\n        根据格雷码映射，误比特率为\n        $$\n        P_b\\approx \\frac{P_s}{2}=Q\\left(\\sqrt{\\frac{\\gamma_s}{2}}\\right)\n        $$\n    \n+ MPSK的误码率\n\n    + 误码率的最近邻近似——近邻$d_{\\min}=2A\\sin\\left(\\frac{\\pi}{M}\\right)$\n        $$\n        P_s\\approx2Q\\left(\\frac{2A\\sin\\left(\\frac{\\pi}{M}\\right)}{\\sqrt{2N_0}}\\right)=2Q\\left(\\sqrt{2\\gamma_s}\\sin\\left(\\frac{\\pi}{M}\\right)\\right)\n        $$\n\n    + 通过同相和正交支路噪声的联合分布得到$\\gamma,\\theta$的联合分布，考虑误码率与$\\gamma$无关，且具有对称性，得到积分:\n        $$\n        P_{s}=1-\\int_{-\\pi / M}^{\\pi / M} \\frac{1}{\\pi} e^{-2 \\gamma_{s} \\sin ^{2}(\\theta)} \\int_{0}^{\\infty} z \\exp \\left[-\\left(z-\\sqrt{2 \\gamma_{s}} \\cos (\\theta)\\right)^{2}\\right] d z\n        $$\n        但$M>4$时无闭式解\n\n+ MPSK对于相位误差敏感，但相位误差很大是会带来error floor\n\n### MPAM和MQAM的错误率\n\n+ MPAM的误码率\n    $$\n    P_{s}=\\frac{2(M-1)}{M} Q\\left(\\sqrt{\\frac{6 \\bar{\\gamma}_{s}}{M^{2}-1}}\\right)\n    $$\n\n+ MQAM的误码率\n\n    + $M=L^2$的正方形星座，同相和正交支路都是MPAM，有MPAM推出的误码率\n        $$\n        P_{s}=1-\\left(1-\\frac{2(\\sqrt{M}-1)}{\\sqrt{M}} Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{s}}{M-1}}\\right)\\right)^{2}P\n        $$\n\n    + 最近邻近似（正方形星座）\n\n        + 英文原版——用两支路MPAM来近似（偏小）\n            $$\n            P_s=\\frac{2(\\sqrt{M}-1)}{\\sqrt{M}} Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{s}}{M-1}}\\right)\n            $$\n\n        + 中文翻译版——假设内点外点都有4个距离为$2d$的近邻(偏大)\n            $$\n            P_s=4 Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{s}}{M-1}}\\right)\n            $$\n\n    + 最近邻近似（非正方形星座）\n        $$\n        P_{s} \\approx M_{d_{\\min }} Q\\left(\\frac{d_{\\min }}{\\sqrt{2 N_{0}}}\\right)\n        $$\n\n+ For the same energy per symbol or bit, MQAM makes more efficient use of energy and thus has better performance.\n\n+ MQAM解调需要对幅度和相位两方面进行估计\n\n    + 相位估计与MPSK类似\n    + 幅度估计可以使用AGC（自动增益控制）\n\n### MFSK和CPFSK的错误率\n\n+ 2FSK的误比特率：\n    $$\n    P_b=P_s=Q\\left(\\frac{A}{\\sqrt{N_0}}\\right)=Q\\left(\\sqrt{\\gamma_b}\\right)\n    $$\n\n+ MFSK的误码率：\n    $$\n    P_{s}=\\sum_{m=1}^{M}(-1)^{m+1}\\mathbf{C}_{M-1}^{m} \\frac{1}{m+1} \\exp \\left[\\frac{-m \\gamma_{s}}{m+1}\\right]\n    $$\n\n+ CPFSK的错误率取决于检波器是相干的还是非相干的，也取决于它是使用逐码元检测还是序列估计。\n\n### 相干解调的错误率近似\n\n+ 误码率的近似\n    $$\n    P_s(\\gamma_s)\\approx\\alpha_MQ\\left(\\sqrt{\\beta_M\\gamma_s}\\right)\n    $$\n    对于最近邻近似，$\\alpha_M=M_{d_{\\min}}$，$\\beta_M$反映$d_{\\min}$和平均码元能量有关。\n\n+ 误比特率的近似\n    $$\n    P_b(\\gamma_b)=\\frac{\\alpha_M}{\\log_2M}Q\\left(\\sqrt{\\frac{\\log_2M}{\\beta_M}\\gamma_b}\\right)\n    $$\n\n$$\n\\begin{array}{|c|c|c|}\n\\hline \\text { Modulation } & P_{s}\\left(\\gamma_{s}\\right) & P_{b}\\left(\\gamma_{b}\\right) \\\\\n\\hline \\text { 2FSK: } & & P_{b}=Q\\left(\\sqrt{\\gamma_{b}}\\right) \\\\\n\\hline \\text { 2PSK: } & & P_{b}=Q\\left(\\sqrt{2 \\gamma_{b}}\\right) \\\\\n\\hline \\text { QPSK,4QAM: } & P_{s} \\approx 2 Q\\left(\\sqrt{\\gamma_{s}}\\right) & P_{b} \\approx Q\\left(\\sqrt{2 \\gamma_{b}}\\right) \\\\\n\\hline \\text { MPAM: } & P_{s} \\approx \\frac{2(M-1)}{M} Q\\left(\\sqrt{\\frac{6 \\bar{\\gamma}_{s}}{M^{2}-1}}\\right) & P_{b} \\approx \\frac{2(M-1)}{M \\log _{2} M} Q\\left(\\sqrt{\\frac{6 \\bar{\\gamma}_{b} \\log _{2} M}{M^{2}-1}}\\right) \\\\\n\\hline \\text { MPSK: } & P_{s} \\approx 2 Q\\left(\\sqrt{2 \\gamma_{s}} \\sin \\left(\\frac {\\pi}{M}\\right)\\right) & P_{b} \\approx \\frac{2}{\\log _{2} M} Q\\left(\\sqrt{2 \\gamma_{b} \\log _{2} M} \\sin \\left(\\frac {\\pi}{M}\\right)\\right) \\\\\n\\hline \\text { Rectangular MQAM: } & P_{s} \\approx \\frac{4(\\sqrt{M}-1)}{\\sqrt{M}} Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{s}}{M-1}}\\right) & P_{b} \\approx \\frac{4(\\sqrt{M}-1)}{\\sqrt{M} \\log _{2} M} Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{b} \\log _{2} M}{(M-1)}}\\right) \\\\\n\\hline \\text { Nonrectangular MQAM: } & P_{s} \\approx 4 Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{s}}{M-1}}\\right) & P_{b} \\approx \\frac{4}{\\log _{2} M} Q\\left(\\sqrt{\\frac{3 \\bar{\\gamma}_{b} \\log _{2} M}{(M-1)}}\\right) \\\\\n\\hline\n\\end{array}\n$$\n\n中文版在矩形MQAM中有一些区别，没有$\\frac{4(\\sqrt{M}-1)}{\\sqrt{M}}$项。具体原因见上\n\n### 差分译码的错误率\n\n+ 差分解调利用相位比较器求得相位，进行抽样判决。\n\n+ Performance of differential modulation that is roughly 3 dB worse than that of coherent modulation.\n\n+ DPSK的误比特率：\n    $$\n    P_b=\\frac 12 e^{-\\gamma_b}\n    $$\n\n+ DQPSK的误比特率：\n    $$\n    P_{b} \\approx \\int_{b}^{\\infty} x \\exp \\left(\\frac{-\\left(a^{2}+x^{2}\\right)}{2}\\right) \\mathrm{I}_{0}(a x) d x-\\frac{1}{2} \\exp \\left(\\frac{-\\left(a^{2}+b^{2}\\right)}{2}\\right) \\mathrm{I}_{0}(a b)\n    $$\n    其中， $a \\approx 0.765 \\sqrt{\\gamma_{b}}$ ， $b \\approx 1.85 \\sqrt{\\gamma_{b}}$, $I_0(x)$是修正的零阶第一类贝塞尔函数\n\n## 衰落信道中数字带通传输系统的性能\n\n性能指标的选取取决于衰落信道变换快慢：\n\n+ 中断率$P_{out}$：信道衰落很慢($T_c\\gg T_s$)\n+ 平均错误率$\\bar P_s$：衰落的相干时间和码长可比拟（$T_c\\approx T_s$）.码元间隔内的衰落近似不变\n+ 中断率和平均错误率的结合：信道衰落快慢结合，例如慢变对数正态分布的shadowing和快变Rayleigh衰落。\n+ 信道衰落非常快（$T_c\\ll T_s$），近似AWGN信道。\n\n### （慢变）中断率（Outage Probability）\n\n+ 中断率（Outage Probability）的定义\n    $$\n    P_{out}=p(\\gamma<\\gamma_0)=\\int_0^{\\gamma_0}p_{\\gamma_s}(\\gamma)\\ \\mathrm{d}\\gamma\n    $$\n    其中，$\\gamma_0$是可以接受的最小信噪比。\n\n+ 瑞利信道的中断率\n\n    + 中断率\n        $$\n        P_{out}=\\int_0^{\\gamma_0}\\frac{1}{\\bar \\gamma_s}e^{-\\frac{\\gamma_s}{\\bar \\gamma_s}}d\\gamma_s=1-e^{-\\frac{\\gamma_0}{\\bar\\gamma_s}}\n        $$\n\n    + 对应所需的平均信噪比\n        $$\n        \\bar \\gamma_s=\\frac{\\gamma_0}{-\\ln(1-P_{out})}\n        $$\n\n    + dB fade margin（分贝衰落余量）：\n        $$\n        F_d=-\\log[-\\ln(1-P_{out})]\n        $$\n\n### （可比拟）平均误码率（Average Probability of Error）\n\n+ 平均误码率：根据衰落的分布对AWGN信道的误码率积分。\n    $$\n    \\bar P_s=\\int_0^\\infty P_s(\\gamma)p_{\\gamma_s}(\\gamma)\\mathrm{d}\\gamma\n    $$\n\n    + $p_{\\gamma_s}(\\gamma)$的求解——变量代换\n        $$\n        p_{\\gamma_s}(\\gamma)d\\gamma=p(r)dr\n        $$\n\n    + 瑞利衰落的分布\n        $$\n        p_{\\gamma_s}(\\gamma)=\\frac{1}{\\bar{\\gamma_s}}\\exp\\left(-\\frac{\\gamma}{\\bar \\gamma_s}\\right)\n        $$\n        其中，$\\bar \\gamma_s=\\frac{\\sigma^2T}{\\sigma_n^2}$\n\n+ 瑞利信道中二元调制的平均误码率\n\n    + 2PSK\n        $$\n        \\bar{P}_{b}=\\frac{1}{2}\\left[1-\\sqrt{\\frac{\\bar{\\gamma}_{b}}{1+\\bar{\\gamma}_{b}}}\\right] \\approx \\frac{1}{4 \\bar{\\gamma}_{b}}\n        $$\n\n    + 2FSK\n        $$\n        \\bar{P}_{b}=\\frac{1}{2}\\left[1-\\sqrt{\\frac{\\bar{\\gamma}_{b}}{2+\\bar{\\gamma}_{b}}}\\right] \\approx \\frac{1}{4 \\bar{\\gamma}_{b}}\n        $$\n\n    + 2DPSK\n        $$\n        \\bar{P}_{b}=\\frac{1}{2\\left(1+\\bar{\\gamma}_{b}\\right)} \\approx \\frac{1}{2 \\bar{\\gamma}_{b}}\n        $$\n        约等号仅当$\\bar\\gamma_b$较大时取。\n\n    + 通用近似式$P_s(\\gamma_s)\\approx\\alpha_MQ\\left(\\sqrt{\\beta_M\\gamma_s}\\right)$\n        $$\n        \\bar{P}_{s} \\approx \\int_{0}^{\\infty} \\alpha_{M} Q\\left(\\sqrt{\\beta_{M} \\gamma}\\right) \\cdot \\frac{1}{\\bar{\\gamma}_{s}} e^{-\\gamma / \\bar{\\gamma}_{s}} d \\gamma_{s}=\\frac{\\alpha_{m}}{2}\\left[1-\\sqrt{\\frac{0.5 \\beta_{M} \\bar{\\gamma}_{s}}{1+0.5 \\beta_{M} \\bar{\\gamma}_{s}}}\\right] \\approx \\frac{\\alpha_{M}}{2 \\beta_{M} \\bar{\\gamma}_{s}}\n        $$\n\n+ AWGN信道与衰落信道中调制方式的比较\n\n  + 在AWGN信道中，误比特率随着$\\gamma_b$的增加呈**指数级下降**。在衰落信道中，所有调制类型的误比特率随着$\\gamma_b$的增加而**线性下降**。同样误码率条件下，衰落信道中需要更高的信噪比。\n  + 瑞利衰落是最差的衰落情况。Nakagami fading随$m$的增大，衰落减小，趋于AWGN。\n  \n+ Moment Generating Function（矩函数产生函数，矩母函数）\n    $$\n    \\mathcal{M}_{\\gamma}(s)=\\int_{0}^{\\infty} p_{\\gamma}(\\gamma) e^{s \\gamma} d \\gamma\n    $$\n\n    + 求矩函数：\n        $$\n        E[\\gamma^n]=\\frac{\\partial^n}{\\partial s^n}[\\mathcal{M}_{\\gamma_s}(s)]_{s=0}\n        $$\n\n    + 常见信道的Moment Generating Function\n\n        + Rayleigh:\n            $$\n            \\mathcal{M}_{\\gamma_{s}}(s)=\\left(1-s \\bar{\\gamma}_{s}\\right)^{-1}\n            $$\n        + Ricean with factor $K$ :\n            $$\n            \\mathcal{M}_{\\gamma_{s}}(s)=\\frac{1+K}{1+K-s \\bar{\\gamma}_{s}} \\exp \\left[\\frac{K s \\bar{\\gamma}_{s}}{1+K-s \\bar{\\gamma}_{s}}\\right]\n            $$\n        + Nakagami- $m$ :\n            $$\n            \\mathcal{M}_{\\gamma_{s}}(s)=\\left(1-\\frac{s \\bar{\\gamma}_{s}}{m}\\right)^{-m}\n            $$\n    \n    > 其实这里的矩母函数类似于《随机信号分析》中的特征函数，其实在第七章分集中也谈到了用$j\\lambda$来替代$s$可以表示一些复数。\n    >\n    > + 特征函数\n    >     $$\n    >     \\varphi_x(\\lambda,t )=\\int_{-\\infty}^{\\infty}p(x,t)e^{j\\lambda x}\\mathrm{d}x\n    >     $$\n    >\n    > + 用特征函数求各阶矩\n    >     $$\n    >     E[X^n(t)]=(-j)^n\\left.\\frac{\\partial^n}{\\partial \\lambda^n}\\varphi_x(\\lambda,t)\\right|_{\\lambda=0}\n    >     $$\n    \n+ 用Moment Generating Function求平均误码率\n\n    + 相关解调误码率的近似($\\alpha=\\alpha_M,g=\\frac{\\beta_M}{2}$，用Q函数形式二)\n        $$\n        \\begin{aligned}\n        P_s(\\gamma_s)\\approx&\\alpha Q\\left(\\sqrt{2g\\gamma_s}\\right)\\\\ \n        =&\\frac{\\alpha}{\\pi}\\int_0^{\\frac \\pi2}\\exp\\left(\\frac{-g\\gamma}{\\sin^2\\phi}\\right)\\mathrm{d}\\phi\n        \\end{aligned}\n        $$\n\n    + 衰落信道的平均误码率\n        $$\n        \\bar P_s=\\frac{\\alpha}{\\pi} \\int_{0}^{\\frac \\pi 2} \\mathcal{M}_{\\gamma_{s}}\\left(\\frac{-g}{\\sin ^{2} \\phi}\\right) d \\phi\n        $$\n\n### （快慢结合）中断率和平均误码率结合\n\n+ Let $\\bar{\\bar {\\gamma_s}}$ denote the average SNR per symbol for a fixed path loss with averaging over fast fading and shadowing.\n+  Let $\\bar \\gamma_s$ denote the (random) SNR per symbol for a fixed path loss and random shadowing but averaged overf ast fading. Its average value is $\\bar{\\bar {\\gamma_s}}$.\n+ Let $\\gamma_s$ denote the random SNR due to fixed path loss, shadowing, and multipath.\n\n$$\n\\bar{P}_{s}=\\int_{0}^{\\infty} P_{s}\\left(\\gamma_{s}\\right) p\\left(\\gamma_{s} \\mid \\bar{\\gamma}_{s}\\right) d \\gamma_{s}\n$$\n\n\n\n## 无线信道传输过程中各种损耗带来的影响\n\n### 多普勒扩展\n\n多普勒频移扩展会使得差分编码在解调时出现不可避免地error floor。码元之间的相位相关性以及因此而产生的性能下降是多普勒频率$f_D=\\frac{v}{\\lambda}$和码长$T_s$的函数。\n\n+ 2DPSK的error floor\n    $$\n    \\bar{P}_{\\text {floor }}=\\frac{\\left(1-\\rho_{C}\\right) e^{-K}}{2}\n    $$\n\n+ DQPSK的error floor\n    $$\n    \\bar{P}_{\\text {floor }}=\\frac{1}{2}\\left[1-\\sqrt{\\frac{\\left(\\rho_{C} / \\sqrt{2}\\right)^{2}}{1-\\left(\\rho_{C} / \\sqrt{2}\\right)^{2}}}\\right] \\exp \\left[-\\frac{(2-\\sqrt{2})(K / 2)}{1-\\rho_{C} / \\sqrt{2}}\\right]\n    $$\n\n$$\n\\begin{array}{|c|c|c|}\n\\hline \\text { Type } & \\text { Doppler Power Spectrum } S_{C}(f) & \\rho_{C}=A_{C}(T) / A_{C}(0) \\\\\n\\hline \\text { Rectangular } & \\frac{S_{0}}{2 B_{D}},|f|<B_{D} & \\operatorname{sinc}\\left(2 B_{D} T\\right) \\\\\n\\hline \\text { Gaussian } & \\frac{S_{0}}{\\sqrt{\\pi} B_{D}} e^{-f^{2} / B_{D}^{2}} & e^{-\\left(\\pi B_{D} T\\right)^{2}} \\\\\n\\hline \\text { Uniform Scattering } & \\frac{S_{0}}{\\pi \\sqrt{B_{D}^{2}-f^{2}}},|f|<B_{D} & J_{0}\\left(2 \\pi B_{D} T\\right) \\\\\n\\hline \\text { 1st Order Butterworth } & \\frac{S_{0} B_{D}}{\\pi\\left(f^{2}+B_{D}^{2}\\right)} & e^{-2 \\pi B_{D} T} \\\\\n\\hline\n\\end{array}\n$$\n\n+ the error floor decreases with data rate $R = \\frac{1}{T_b}$.\n+ increasing the data rate  $R = \\frac{1}{T_b}$ by an order of magnitude decreases the error floor by roughly two orders of magnitude.\n\n### ISI(码间串扰)\n\n频率选择性衰减会产生ISI，即在给定的码元间隔内，接收到的码元会受到其他被多径延迟的码元的干扰。\n\n+ error floor取决于ISI特性和调制格式，而ISI特性取决于信道的特性和传输符号的序列。\n\n+ 通过将ISI视为不相关的白高斯噪声，可得到有ISI的符号错误概率的近似值。\n    $$\n    \\hat \\gamma_s=\\frac{P_r}{N_0B+I}\n    $$\n    其中$I$是与ISI相关的功率。\n\n+ 由于ISI引起的error floor可以通过仿真得到的。Chuang的结果表明，error floor对信道的均方根时延扩展比功率时延谱的形状更敏感。此外，脉冲成形可以极大地影响error floor：在升余弦脉冲中，将$\\beta$从0增加到1可以将error floor降低一个数量级以上。\n\n    ![ISI](ISI.png)\n\n## 参考文献\n\n1. ANDREA GOLDSMITH.*WIRELESS COMMUNICATIONS*.2005.\n2. （美）Andrea Goldsmith著；杨鸿文，李卫东，郭文彬等译. 无线通信. 北京：人民邮电出版社, 2007.06.","tags":["无线通信","通信原理"],"categories":["课程向"]},{"title":"【深度学习笔记（三）】构建机器学习模型","url":"/2021/05/04/DL-Coursera-3-Structuring-Machine-Learning-Projects/","content":"\n> 这个专项课程一共五门，包括\n>\n> + [Neural Networks and Deep Learning（神经网络与深度学习）](https://levitate-qian.github.io/2021/03/26/DL-Coursera-1-Neural-Networks-and-Deep-Learning/)\n> + [Improving Deep Neural Networks: Hyperparameter Tuning, Regularization and Optimization（改进深度神经网络：超参数、正则化和优化）](https://levitate-qian.github.io/2021/04/17/DL-Coursera-2-Improving-Deep-Neural-Networks/)\n> + **Structuring Machine Learning Projects（构建机器学习项目）**\n> + Convolution Neural Networks（卷积神经网络）\n> + Sequence Model（序列模型）\n\n# Structuring Machine Learning Projects 学习笔记\n\n第三门课程主要介绍Machine Learning的一些模型评估方法。\n\n+ Introduction to ML Strategy\n+ Setting up your goal\n+ Comparing to Human level performance\n+ Error Analysis\n+ Mismatched training and dev/test set\n+ Learing from multiple tasks\n+ End to End deep learning\n\n在使用机器学习模型训练模型遇到问题时，我们可能会有以下一些想法。但是我们并不能确定哪个能够改善我们的模型，本课程主要就是分析在哪些情况下使用哪些方法比较好。\n\n![ideas](/ML_strategy.jpg)\n\n## Orthogonalization\n\n+ 正交化的思想可以看作设计旋钮(knobs)时，每个旋钮只控制一件事。\n\n+ 在ML项目中如何使用“正交化”优化我们的思考过程呢？在ML项目中我们主要要完善四个问题：\n\n    + Fit training set well on cost function, 否则我们需要bigger network, Adam……\n    + Fit dev set well on cost function, 否则我们需要Regularization, Bigger training set……\n    + Fit test set well on cost function, 否则我们需要bigger dev set……\n    + Performs well in real world, 否则我们需要改变dev set或是cost function\n\n    上面我们谈到的*Fit well on cost function*指的是达到Human level performance.\n\n\n\n## Setting up your goal\n\n### Single number evaluation metric （单一量化评估指标）\n\n对学习模型的泛化能力进行评估，需要有衡量模型泛化能力的指标，也就是性能度量。这里我们使用🍉西瓜书中一套符号来表示下面的概念。\n\n|            | 预测为正例 Positive | 预测为反例 Negative |\n| ---------- | ------------------- | ------------------- |\n| 实际为正例 | TP（真正例）        | FN（假反例）        |\n| 实际为反例 | FP（假正例）        | TN（真反例）        |\n\n+ Precision（准确率，查准率）——总样本为预测为正例\n    $$\n    P=\\frac{TP}{TP+FP}\n    $$\n\n+ Recall（召回率，查全率）——总样本为实际为正例\n    $$\n    R=\\frac{TP}{TP+FN}\n    $$\n\n+ F1 score——Precision和Recall的调和平均\n    $$\n    F1=\\frac{2}{\\frac 1P+\\frac 1Q}\n    $$\n\n+ 在机器学习模型的迭代过程中，一个好的dev set（用来测量P和R）加上单一量化评估指标（singal real number evaluation metric）可以大大加快iterating的速度。\n\n### Satisfy and Optimizing metric（受限指标和优化指标）\n\n在机器学习模型中会有很多指标（metrics），一般有一个Optimizing metric（优化指标）和其它一些Satisfy metric（受限指标），即在**满足受限指标的条件下，调节优化指标达到最佳的效果**。下面举两个栗子：\n\n+ 针对一个classifier，我们有两个指标：accuracy（准确率）和Running time（运算时间），我们需要\n    $$\n    \\begin{gathered}\n    \\max accuracy\\\\ \n    s.t.\\ running\\ time<100\\ \\text{ms}\n    \\end{gathered}\n    $$\n    即在运行时间小于100 ms前提下，最大化准确率。在这个问题中，准确率就是一个优化指标，运行时间是一个受限指标。\n\n+ 针对智能助手的唤醒词（wake word/ Trigger word），有两个指标：accuracy（准确率）和False Positive次数，我们需要\n    $$\n    \\begin{gathered}\n    \\max accuracy\\\\ \n    s.t.\\ \\text{仅出现1 FP in 24 h}\n    \\end{gathered}\n    $$\n    在这个问题中，准确率就是一个优化指标，False Positive次数是一个受限指标。\n\n### Train/ dev / test set（训练集、验证集、测试集）\n\n1. Train/ dev / test set的分布\n    在第二门课程中已经谈到过这三个集合，这里再次强调\n    + Development  and test sets come from **same distribution.**\n    + 我们需要从两方面考虑选择Dev set和test sets，即在未来你希望在哪些数据上有所体现，或是你认为重要的一些方面。\n    + 下面的图像很生动地显示出了未好好选择Dev set和test sets的后果：类似于射箭，在测试时你要求射中左上角的靶子，而在实际应用中却要求射中右下角的靶子，这是现在不切实际的。\n        ![target](bad_target.jpg)\n2. Size of dev/ test set\n    这个问题也在第二门中谈到过了。一般我们选取较多数据作为train set，较少的数据作为dev和test set。这里主要强调的是test set。\n    + 虽然我们只选择很少的一部分作为测试集，但是既然选取了测试集，我们需要**保证测试集的数量足够多，能够支撑起对于整个模型的评价**，且有较高的置信度。\n    + 但是没有测试集也是可以的。\n    + 在学习模型中，training set用于训练模型，dev set用于调节(tune)模型参数，test set用于评估模型最后的cost。\n\n### When to change dev/test sets and metrics\n\n+ 假设有两个分类器：\n\n    | 指标 | 错误率 | 问题               |\n    | ---- | ------ | ------------------ |\n    | A    | 3%     | 出现了porn graphic |\n    | B    | 5%     |                    |\n\n    从指标上看来，A分类器仿佛更好，但是从主观来说我们不希望出现porn graphic，会更倾向于B。所以很容易想到，我们需要对出现porn graphic这种情况加大惩罚，所以我们采用一个单独的参数来表征\n    $$\n    w^{(i)}=\\left\\{\\begin{array}{ll}\n    1,& \\text { if } x^{(i)} \\text { is non-porn } \\\\\n    10,& \\text { if } x^{(i)} \\text { is porn }\n    \\end{array}\\right.\n    $$\n    而我们的cost function也就变为\n    $$\n    J=\\frac{1}{\\sum_iw^{(i)}}\\sum_{i=1}^{m_{dev}}w^{(i)}\\mathscr{L}\\{y_{pred}^{(i)}\\neq y^{(i)} \\}\n    $$\n    $w^{(i)}$起到了惩罚出现porn图片的作用。\n\n+ 同时我们也可以从“正交化”的角度来防止出现porn\n\n    + 定义一个新的指标（是否porn）用来评价分类器👉`放置了一个靶子`\n    + 单独考虑模型是否在这个指标上做的好不好👉`射击靶子`\n\n+ 如果模型在你的指标在验证集、测试集做得很好，但是当真正落地到应用上时并不好，这就说明你的指标或是验证集、测试集可能存在问题，需要更换。\n\n\n\n## Comparing to Human level performance\n\n### Human level performance & Avoidable bias\n\n![human_level](/human_level.jpg)\n\n+ 人们在处理很多事情时都很有优势，当模型比人类水准差时，你需要考虑：\n    + 通过人手动获取标签\n    + 从人的角度来思考为什么错了？为什么人能分辨出来？\n    + 对于bias和variance进一步分析\n+ 一般我们将Human level performance（人类水准）作为Bayes optimal error（贝叶斯误差）的近似估计。\n+ 当出现下面情况时，误差一般是能被避免的\n    + 人类水准←→训练误差(train error)相差大：专注于bias\n    + 训练误差←→验证误差(dev error)相差大：专注于variance\n+ 如何定义人类水准（human-level performance）？我们将人类水准定义为最有经验的一群人的误差，一般$\\le 0.5\\%$。\n    ![error_ecample](/error_analysis_ex.png)\n+ People are good at natural perception.\n\n### Improving your model performance\n\n1. 监督学习（supervised learning）的两个基本假设：\n    + 训练集很好地符合要求（Avoidable bias）\n    + 训练集的表现很好的概括了验证集和测试集的特征（variance）\n2. 抑制bias和variance的方法\n    ![抑制bias和variance的方法](/bias_variance.png)\n\n\n\n## Error Analysis\n\n### 模型可能会出现的错误\n\n1. Look at der examples to evaluate ideas\n    + 从mislabeled dev set中⼿动数可以处理的照⽚，根据此确定如何处理\n    + 考虑什么是重要的？\n2. Evaluate multiple ideas in parallel\n    在一个猫的分类器中，可能会出现这些错误：把狗、猫科动物当作猫，因为模糊而导致误判，我们通过列表可以并行手动识别问题，并根据比例处理这些问题。\n    ![Evaluate multiple ideas in parallel](/parallel.png)\n\n### 数据中可能出现的错误\n\n1. DL算法对训练集中的**随机错误是比较稳健的**，但是对于系统性错误鲁棒性就比较差。\n2. 在验证集和测试集中误标注标签的数据：通过列表来处理，同时要注意每种错误标签的占比\n3. Correcting incorrect dev/ test set example的步骤：\n    + 对你的验证集和测试集应用同样的过程，以确保它们继续来自相同的分布。\n    + 考虑检查你的算法所做的正确和错误的例子\n    + 此时，训练和验证/测试数据现在可能来自稍微不同的分布\n\n### Build your first system quickly, then iterate\n\n一般地，建议尽快建立模型，并开始迭代，在迭代中再去改进模型。一个系统的基本运作过程如下：\n\n1. 设立验证集、测试集和评价指标\n2. 快速建立初始的系统\n3. 使用bias/variance分析和error分析确定下一步的优先次序\n\n## Mismatched training and dev/test set\n\n### Training and Testing a different distribution\n\n有时候获取来自同一分布的大量数据很难，我们需要使用一部分其他分布的数据，那么如何在训练、验证、测试集中分配这两部分的数据。下面有两个例子：\n\n![ex1](/distribution_ex1.png)\n\n注意我们不能将同一分布、不同分布的数据合并，平均分配到训练、验证、测试集中去，而应该有倾向性地将同一分布的数据分配到验证集和测试集。\n\n![ex2](/distribution_ex2.png)\n\n### Bias and Variance with mismatched data distribution\n\n1. 利用Training-dev set\n    ![Training-dev set](/Training-dev_set.png)\n\n    + 和训练集来自同一分布\n    + 不被用于训练\n\n    下面通过一组数据来了解如何利用Training-dev set分辨Bias and Variance从而处理数据来自不同分布地情况。\n\n    ![Training-dev set2](/Training-dev_set2.png)\n\n2. 更一般的情况\n\n    ![更一般的情况](/general.jpg)\n\n### Addressing data mismatch\n\n+ 手工处理👉需要了解训练集和验证、测试集之间的不同到底导致哪方面的问题\n+ 使得训练集更类似类似于验证、测试集即收集更多类似的数据\n+ 但在手工处理时，需要防止NN适应了重复性的元素，从而带来过拟合\n\n## Learning from multiple tasks\n\n### Transfer learning\n\n![Transfer learning](/transfer_learning.png)\n\n何时可以用Transfer learning？\n\n+ 任务A和B的输入是一致的\n+ 相比于任务B，任务A有更多的数据\n\n### Multi-task learning\n\n![Multi-task learning](/multi-task.png)\n\n何时可以用Multi-task learning？\n\n+ 在一组任务上进行训练，可以从**有共享的低级特征**可以从中受益。\n+ 通常情况下，每个任务的数据量是**相似**的。\n+ 可以训练**一个足够大的NN**，以便在所有的任务中表现良好。\n+ 这在第四门CNN的目标识别中经常使用。\n\n### End to End DL\n\n当一个问题有很多步骤来处理时，我们可以把整个过程看作一个黑箱，作为一个神经网络，这就是端到端学习（end-to-end deep learning）。\n\n+ 优点：\n\n    + 让数据“说话”\n    + 手工处理的部分很少\n\n+ 缺点：\n\n    + 可能需要大量的数据\n    + 可能缺少了一些有益的手工处理，但是在黑箱中我们没法处理\n\n+ 在使用end-to-end deep learning时，我们需要考虑是否有充足的数据来实现一个足够复杂的从$X\\to Y$的映射。\n\n+ 应对方法：\n\n  + 使用DL学习一个个小子块；\n  + 仔细选择$X\\to Y$的映射，以保证你可以获得充足的数据\n  \n    \n\n\n\n## 参考文献\n\n1. 周志华著. 机器学习. 北京：清华大学出版社, 2016.01.\n\n\n\n\n\n\n\n","tags":["深度学习","机器学习"],"categories":["科研向"]},{"title":"【无线通信学习笔记（三）】无线信道的信道容量","url":"/2021/05/03/Wireless-Communications-Ch-4/","content":"\n>  *Wireless Communications* (Andrea Goldsmith)学习笔记。\n\n# Capacity of Wireless Channels\n\n在第二、三章中，主要介绍无线信道传输过程中发射信号到接收信号之间的损耗——路径损耗、阴影和多径模型。第四章讨论另外无线信道的一个重要参数——信道容量（Capacity）。\n\n1. **香农编码定理（Shannon’s coding theorem）**：a code did exist that could achieve a data rate close to capacity with negligible probability of error, and that any data rate higher than capacity could not be achieved without an error probability bounded away from zero. 一定存在一种编码，可以在误码率可忽略不计的情况下实现接近信道容量的传输速率，而任何高于信道容量的传输速率都不可能在误码率接近于零的情况下实现。\n2. 本章主要讨论单用户无线信道（single-user wireless channel），即收发天线都只有一根。\n3. 当收发都已知CSI时，最佳功率分配方式是water-filling法。\n4. 本章循序渐进从三种大类来讨论无线信道的容量，先是最简单的AWGN信道，进而讨论窄带的平衰落信道，最后讨论宽带的频率选择性衰落信道。\n\n## Capacity in AWGN\n\n+ AWGN（加性高斯白噪声）有扰信道的容量：\n    $$\n    C=B\\log_2(1+\\gamma)\\quad bps\n    $$\n\n    + 证明方法：信道容量是mutual information（互信息量）的最大值\n        $$\n        C=\\max _{p(x)} I(X ; Y)=\\max _{p(x)} \\sum_{x, y} p(x, y) \\log \\left(\\frac{p(x, y)}{p(x) p(y)}\\right)\n        $$\n\n+ Shannon capacity is generally used as an upper bound on the data rates that can be achieved under real system constraints. 香农容量一般被作为实际信道传输速率的上限。\n\n## Capacity of Flat-Fading Channels\n\n对于平衰落信道结构大致如下图，在信道中：\n\n+ 时变增益为$\\sqrt{g[i]}$。下面我们假设$g[i]$与信道输入无关。$g[i]$也被称为CSI，在码字传输过程中是时变的。分析$g[i]$有两种途径——分布和瞬时值。\n+ 噪声为$n[i]$（加性高斯白噪声）。\n+ $\\bar P$是平均发射功率，瞬时接收信噪比为$\\gamma[i]=\\frac{\\bar P g[i]}{N_0B}$。\n\n<img src=\"/Flat-Fading Channel and System Model.png\" alt=\"Flat-Fading Channel and System Model\"  />\n\n信道容量取决于发射机和接收机对CSI的了解情况：\n\n+ **CDI**(Channel Distribution Information)：发射机、接收机仅知道$g[i]$的分布。\n+ **Receiver CSI**:发射机、接收机知道$g[i]$的分布，且接收机知道CSI瞬时值。\n+ **Transmitter and Receiver CSI**:发射机、接收机知道$g[i]$的分布和瞬时值。\n\n### CDI（仅知道信道分布）\n\n+ 对于几乎所有的信道分布，寻找CDI下的容量达到的输入分布和相应的衰减信道的容量仍然是一个未解之谜。\n+ 一般仅有两种情况在CDI情况下可求解：\n    + i.i.d. Rayleigh fading channels(独立同分布的瑞利衰减信道)\n    + FSMC（有限状态马尔可夫信道）\n+ i.i.d. Rayleigh fading channels无闭式解，只能求解数值解。\n+ FSMC：the receiver must decode all past channel outputs jointly with the current output for optimal (i.e. capacity-achieving) decoding.\n\n### Receiver CSI\n\n+ **Shannon capacity** (ergodic capacity, capacity with outage)香农容量给出的是一个恒定的速率。\n    $$\n    C=\\int_0^{\\infty} B\\log_2(1+\\gamma)p(\\gamma)\\ \\mathrm{d}\\gamma\n    $$\n\n    + 这个式子就是对信噪比为$\\gamma$的AWGN信道按信噪比分布加权作平均。\n    \n    + 香农容量下，信道传输速率是恒定值。\n    \n    + 香农容量下，编码必须足够长，以便收到的码字变量所有可能的衰落状态的影响。（这也是为什么被称为*遍历信道*）这可能会导致显著的延迟。\n    \n    + 由Jensen不等式有\n        $$\n        E[B\\log_2(1+\\gamma)]\\le B\\log_2(1+\\bar\\gamma)\n        $$\n        即Receiver CSI情况下香农容量比AWGN信道容量小。\n    \n+ Capacity with Outage（带中断容量）带中断容量允许在给定突发时间端，以一定的概率译错所传输的bits。\n    $$\n    C_{out}=(1-p_{out})B\\log_2(1+\\gamma_{\\min})\n    $$\n\n    + $p_{out}$是中断概率，$\\gamma_{\\min}$是接收机允许的最小正确接收信噪比。\n    + 当中断概率很小时，信道容量趋于0.\n    + 当中断概率提高后，信道容量提升，带来的问题是高中断率高速率意味着高错误接收率。\n    + 通过$\\gamma_{\\min}$和$p_{out}$的优化，可以最大化平均正确接收率，从而提升带中断容量的质量。 \n\n### Transmitter and Receiver CSI\n\n当接收机和发射机都知道CSI时，可以通过CSI实时调整发送策略，比较好的功率控制方式为——water-filling法（注水法）。\n\n+ 收发均知CSI的模型\n    ![CSITR](/TR_CSI.png)\n    \n+ 最佳功率控制、速率自适应下的**香农容量**——最佳，注水法难\n    + 发射机不功率控制，CSIT不能增加信道容量。\n    \n    + 考虑时变信道，信道状态有无限种可能，允许发射功率$P(\\gamma)$随信道状态变化并受限于平均功率，定义**fading channel capacity with average power constraint**（受限于平均功率的衰落信道容量）\n        $$\n        C=\\max _{P(\\gamma): \\int P(\\gamma) p(\\gamma) d \\gamma=\\bar{P}} \\int_{0}^{\\infty} B \\log _{2}\\left(1+\\boldsymbol{\\frac{P(\\gamma) \\gamma}{\\bar{P}}}\\right) p(\\gamma) d \\gamma\n        $$\n    \n        + 上式可通过多路输入多路输出的time-diversity来实现。将时变信道分解为一组并行的时不变信道，每个时不变信道仅在$\\gamma[i]=\\gamma_j$时工作。\n    \n    + 利用Lagrange乘数法求解最优功率控制方案为：\n        $$\n        \\frac{P(\\gamma)}{\\bar{P}}=\\left\\{\\begin{array}{ll}\\frac{1}{\\gamma_{0}}-\\frac{1}{\\gamma} & \\gamma \\geq \\gamma_{0} \\\\ 0 & \\gamma<\\gamma_{0}\\end{array}\\right.\n        $$\n        其中，$\\gamma_0$时截断值，只在信噪比大于截断值时使用信道。此时信道容量为\n        $$\n        C=\\int_{\\gamma_0}^\\infty B\\log_2\\left(\\frac{\\gamma}{\\gamma_0}\\right)p(\\gamma)\\mathrm{d}\\gamma\n        $$\n        \n    + 信道容量的实现——注水法（water-filling）：\n      ![water-filling](/water-filling.png)\n      \n        原理：**利用良好的信道条件**。当信道条件良好（$\\gamma$大）时，多分配功率，用更高的传输速率。当信道质量下降时（$\\gamma$小），减小发射发射传输速率。如果信道瞬时SNR低于截断值，就不使用该信道。\n      \n    + 截断值$\\gamma_0$的取值：同时我们认为最佳功率分配时，动态调整的功率的平均功率达到最大即原来的平均发射功率$\\bar P$，则必然满足\n        $$\n        \\int_{\\gamma_0}^{\\infty}\\left(\\frac{1}{\\gamma_0}-\\frac{1}{\\gamma}\\right)p(\\gamma)\\mathrm{d}\\gamma=1\n        $$\n    \n+ Zero-Outage Capacity（零中断容量）——次佳但简单\n    零中断功率利用CSIT，实现**接收功率恒定**，即将信道衰落折算进发射机中（信道衰落进行反转）。\n\n    + 发射功率自适应方案——信道反转（Channel Inversion）\n\n    + 设$\\sigma$是恒定的接收信噪比，则$\\sigma=\\frac{1}{E[\\frac{1}{\\gamma}]}$，此时的信道容量(零中断容量)为\n        $$\n        C=B\\log_2[1+\\sigma]=B\\log_2\\left[1+\\frac{1}{E[\\frac 1\\gamma]}\\right]\n        $$\n        \n    + 在所有信道条件下传输速率均恒定，不需要考虑中断。\n    \n    + 在衰落严重环境下，零中断容量接近于0.\n    \n    + Channel inversion is common in spread spectrum systems with near-far interference imbalances\n    \n+ Outage Capacity（中断容量）——次佳但简单\n    为避免在衰落严重条件下，信道容量趋于0，设在特别差的信道上停止发射数据，即可提高传输速率进而提高信道容量。\n\n    + 发射功率自适应方案——截断式信道反转（Truncated Channel Inversion）\n        $$\n        \\frac{P(\\gamma)}{\\bar{P}}=\\left\\{\\begin{array}{ll}\\frac{\\sigma}{\\gamma} & \\gamma \\geq \\gamma_{0} \\\\ 0 & \\gamma<\\gamma_{0}\\end{array}\\right.\n        $$\n\n    + 设$\\sigma$是非中断时恒定的接收信噪比，则$\\sigma=\\frac{1}{E_{\\gamma_0}[\\frac{1}{\\gamma}]}=\\frac{1}{\\int_{\\gamma_0}^{\\infty}\\frac{1}{\\gamma}p(\\gamma)d\\gamma}$，此时的信道容量（中断容量）为\n        $$\n        C(p_{out})=B\\log_2\\left(1+\\frac{1}{E_{\\gamma_0}\\left[\\frac 1 \\gamma\\right]}\\right)p(\\gamma\\ge \\gamma_0)\n        $$\n\n    + 最大中断容量：\n        $$\n        C=\\max_{\\gamma_0}B\\log_2\\left(1+\\frac{1}{E_{\\gamma_0}\\left[\\frac 1 \\gamma\\right]}\\right)p(\\gamma\\ge \\gamma_0)\n        $$\n\n+ Capacity with Receiver Diversity（接收分集）\n    利用多天线可以减小衰落带来的波动，接收天线数量越多，信道接近AWGN信道，各种容量趋于相近。\n\n### 信道容量的比较\n\n![comparasion](/comparasion.png)\n\n+ AWGN信道容量比其余任何衰落情况信道容量都大。\n    + 信噪比低时与Transmitter and Receiver CSI接近。\n    + AWGN信道总是总是较低SNR，限制了信道容量。\n+ 当传输速率相对于信道进行调整时，调整功率的调整对容量的增加忽略不计。\n+ 相对于只使用CSIR，CSIT自适应带来的容量增加可以忽略不计。\n+ 信道容量和实现复杂度的trade-off\n\n\n\n## Capacity of Frequency-Selective Fading Channels\n\n频率选择性衰落信道可以看作是平衰落信道的延伸。\n\n### 时不变信道\n\n在时不变情况下，频率选择性衰落信道的频域可以看作分段平衰落信道。\n<img src=\"Block Frequency-Selective Fading.png\" alt=\"Block Frequency-Selective Fading\" style=\"zoom:80%;\" />\n\n+ 考虑信号（功率谱$P_j$）通过时不变系统后功率谱变为$|H_j|^2P_j$，信噪比为$\\frac{|H_j|^2P_j}{BN_0}$\n\n+ 受限于平均功率的衰落信道容量\n    $$\n        C=\\sum_{\\max P_{j}: \\sum_{j} P_{j} \\leq P} B \\log _{2}\\left(1+\\frac{\\left|H_{j}\\right|^{2} P_{j}}{N_{0} B}\\right)\n    $$\n\n+ 最佳功率分配下的信道容量：\n    $$\n    C=\\sum_{j:\\gamma_j>\\gamma_0}B\\log_2\\left(\\frac{\\gamma_j}{\\gamma_0}\\right)\n    $$\n    利用**频域注水法功率控制**，在不同子信道上分配不同功率并且以不同传输速率传输达到。\n    ![Water-Filling in Block Frequency-Selective Fading](/Water-Filling_freq.png)\n\n+ 当$H(f)$连续，则求和变积分。\n\n### 时变信道\n\n+ 频率选择性衰落时变信道的处理方式主要是将*频率变化、时间变化*分块变成*仅时间变化*。即假设个子信道变成独立的时变平衰落信道，对$H(f,i)=H_f[i]$。\n\n+ 收发CSI的香农容量是其它非AWGN信道容量的上限，利用二维注水法，求解香农容量。\n\n    + 收发CSI，时域（$\\gamma_j[i]=\\gamma_j$）、频域（子信道）均最佳功率控制\n        $$\n        C=\\max _{P_{j}\\left(\\gamma_{j}\\right): \\sum_{j} \\int_{0}^{\\infty} P_{j}\\left(\\gamma_{j}\\right) p\\left(\\gamma_{j}\\right) d \\gamma_{j} \\leq \\bar{P}} \\sum_{j} \\int_{0}^{\\infty} B_{c} \\log _{2}\\left(1+\\frac{P_{j}\\left(\\gamma_{j}\\right) \\gamma_{j}}{\\bar{P}}\\right) p\\left(\\gamma_{j}\\right) d \\gamma_{j}\n        $$\n\n    + 二维注水法截断值$\\gamma_0$对于所有子信道都是一致的，信道容量为\n        $$\n        C=\\sum_{j} \\int_{\\gamma_{0}}^{\\infty} B_{c} \\log _{2}\\left(\\frac{\\gamma_{j}}{\\gamma_{0}}\\right) p\\left(\\gamma_{j}\\right) d \\gamma_{j}\n        $$\n\n## 参考文献\n\n1. ANDREA GOLDSMITH.*WIRELESS COMMUNICATIONS*.2005.\n2. （美）Andrea Goldsmith著；杨鸿文，李卫东，郭文彬等译. 无线通信. 北京：人民邮电出版社, 2007.06.\n\n","tags":["无线通信"],"categories":["课程向"]},{"title":"【B测】数字2DPSK频带传输系统的设计","url":"/2021/04/22/b-test/","content":"\n# 数字2DPSK频带传输系统的设计\n\n> 以下是我们B测题的大致思路。\n>\n> 作者：钱辰涞、许琛、刘育涵\n\n# 一、任务要求\n\n## 任务\n\n编程语言不限（推荐使用LabVIEW软件，其他编程语言，如Matlab、C等也可），对一数字频带传输系统进行调制与解调设计，输入输出时域波形和频域波形等，数字频带传输系统为2DPSK。\n\n## 要求\n\n1.  码率：24kbit/s；\n\n2.  获取时域波形和频域波形；\n\n3.  完成实验报告。\n\n## 说明\n\n1.  信道采用高斯信道；\n2.  解调采用相干解调；\n3.  要求波形正确、清晰，便于分析；\n4.  报告要对数据、波形进行分析、说明，获取信息，得出合理、正确结论。\n\n\n\n# 二、仿真环境\n\n-   OS环境：Windows 10\n-   处理器类型：x86\\_64\n-   软件名称：Matlab\n-   Matlab版本：R2020a (9.8.0.1323502)\n\n\n\n# 三、实现原理与方案\n\n## 2DPSK信号的调制与解调原理\n\n传输系统中要保证信息的有效传输就必须要有较高的传输速率和较低的误码率，为实现低误码率，传输信号本身的误码率应控制在一定的范围内。在传输信号中，2PSK 信号和2ASK 及2FSK 信号相比，具有较好的误码率性能。但是，在2PSK信号传输系统中 存在载波相位模糊，会造成倒$\\pi$工作（反相工作），恢复出的数字信号\"1\"和\"0\"倒置，故2PSK难以应用。为克服此缺点，提出了*二进制差分相移键控*(2DPSK)方式。\n\n### 2DPSK信号的产生原理\n\n2DPSK信号利用前后相邻码元的载波相对相位变化传递数字信息。于是可以将一组二进制数字信息与其对应的2DPSK信号的载波相位关系示意如下[^1]：\n\n---------------- ------- ------- --- --- ------- ------- ------- --- ------- ------- --- --- -------\n\n   二进制数字信息             1     1   0     1       0       0     1     1       0     1   0     1\n   2DPSK信号相位    \\(0\\)   $\\pi$   0   0   $\\pi$   $\\pi$   $\\pi$   0   $\\pi$   $\\pi$   0   0   $\\pi$\n\n---------------- ------- ------- --- --- ------- ------- ------- --- ------- ------- --- --- -------\n\n2DPSK*信号产生的原理*为：\n\n1.  对二进制数字基带信号进行差分编码，获得$a(t)$，即把数字信息序列的绝对码变为相对码；\n\n2.  根据相对码，对其进行绝对调相，产生二进制差分相移键控(2DPSK)信号$b(t)$。\n\n差分编码中，相对码可取传号差分或空号差分。这里取传号差分码，其编码规则为 \n\n$$ a_n=s_n\\oplus a_{n-1} $$ \n\n其中：$s_n$是绝对码，$a_n$是相对码。使用相对码对应基带信号$a(t)$实现2DPSK。\n\n### 2DPSK信号的解调原理\n\n2DPSK信号的解调方式主要有两种：\n\n-   相干解调（极性比较法）加码变换法\n\n-   差分相干解调（相位比较法）\n\n在本文中，我们使用\"相干解调（极性比较法）加码变换法\"，故仅对此进行一定说明。其*解调原理*是：\n\n1.  对2DPSK信号进行相干解调，恢复出相对码；\n\n    1.  带通滤波滤除噪声，获得$c(t)$；\n\n    2.  与相干载波相乘，将码元间的相位不同转变为极性不同，得到$d(t)$；\n\n    3.  低通滤波滤除载波信号，获得$e(t)$；\n\n    4.  经抽样、判决后将码元再生，恢复出相对码数字信息$f(t)$。\n\n2.  经码反变换器变换为绝对码，从而恢复出发送的二进制数字信息$g(t)$。\n\n在解调过程中，由于载波相位模糊性的影响，使得解调出的相对码也可能是\"1\"和\"0\"倒置，但经差分译码（码反变换）得到的绝对码不会发生任何倒置的现象，从而解决了载波相位模糊性带来的问题。\n\n## 总体工作流程图\n\n总结上述2DPSK调制与解调的原理，结合高斯信道，可以画出如图的流程图，上述提到的各点的信号均标注在图上。\n\n![总体工作原理层级图](/image_0.png)\n\n\n\n# 四、设计过程与仿真结果\n\n下面从基带信号的产生、2DPSK 信号的产生、高斯信道、2DPSK 信号的相关解调四部分，对上述图2 中的各模块的代码和波形进行分析。\n\n## 基带信号的产生\n\n### 数据初始化\n\n```matlab\nclear; clc;\nfs = 4.8e6;             % 设置采样频率\nTB = 1/24000;           % 传送一个码元所需要的时间\nNs = fs * TB;           % 每个码元的抽样次数\nHL = ones (1, Ns);      % 设置码元信号高电平\nLL = zeros(1, Ns);      % 设置码元信号低电平\nfc = 1e6;               % 设置载波信号频率\nSignal_absolute = [1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,1];    % 设定初始输入信号（绝对码）\n% L_rand = 12;\n% Signal_absolute = randi(2,1,L_rand) - ones(1,L_rand);\nL = length (Signal_absolute);                   % 信号长度\nSignal_relative = zeros(1,L);                   % 初始化相对码\nst = zeros (1, Ns * L);                         % 基带信号（绝对码）\nat = zeros (1, Ns * L);                         % 基带信号（相对码）\nbt = zeros (1, Ns * L);                         % 基带信号调制后信号\nft = zeros (1, Ns * L);\ngt = zeros (1, Ns * L);\nt = 0 : 1/fs : TB * L - 1/fs;                   % 总时间\nNfft = 4800;                                    % FFT点数\nk = 0 : Nfft-1;\nf = round(k / Nfft * fs);                       % FFT采样频率\n```\n\n### 基带信号的产生\n\n下面将输入离散序列扩展为时域信号，码率为 24 kbit/s。\n\n```matlab\nfor i = 1 : L\n    if Signal_absolute(i) == 1\n        st((i-1)*Ns + 1 : i*Ns) = HL;\n    else\n        st((i-1)*Ns + 1 : i*Ns) = LL;\n    end\nend\n\nGs =cpsd(st,st,[],[],Nfft,fs,'twosided');\n\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot(t/TB, st);\nset(gca,'XTick',0:1:max(t/TB));\ntitle ('(a)基带信号（绝对码）时域波形');\nxlabel('t/($\\frac{1}{2.4 \\times 10^4}$ s)',\"Interpreter\",\"latex\");\nylabel('s(t)');\ngrid\nsubplot(3,1,2);\nplot(f,abs(Gs)/max(abs(Gs)));\nset(gca,'xlim',[0,2.4e6]);\ntitle('(b)基带信号（绝对码）功率谱');\nxlabel('f/Hz');\nylabel('G_s(f)');\ngrid\nsubplot(3,1,3);\nplot(f,abs(Gs)/max(abs(Gs)));\nset(gca,'xlim',[0,0.1e6]);\ntitle('(c)基带信号（绝对码）功率谱（局部）');\nxlabel('f/Hz');\nylabel('G_s(f)');\nax = gca;\nchart = ax.Children(1);\nn = find(f==24000);\ndatatip(chart,f(n),Gs(n));\ngrid\n```\n\n![image](figure_0.png)\n\n观察图(a) 波形可以发现，基带信号（绝对码）符合输入序列 \\[1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,1\\] 的分布特点。值得注意的是为了方便观察，这里的横坐标的最小分度取的是$\\frac{1}{2.4\\times 10^4 }$ s，对应每个码元长度，体现出了码率为 24 kbit/s。图(b,c) 是基带信号（绝对码）的功率谱密度，以下不特别说明将功率谱进行了归一化。观察图(b,c) 中的功率谱 可以发现，基带信号主要为直流分量，频率较低，因此功率谱主要集中在低频 部分。同时，带宽为$B=f_B =\\frac{1}{T_B }=2.4\\times 10^4$ Hz，与单极性非归零码的性质一致。由于FFT的周期性和对称性，对于4.8 MHz的采样频率我们仅取$[0~\\textrm{Hz},2.4~\\textrm{MHz}]$ 部分的功率谱（如图(b)）。\n\n## 2DPSK调制\n\n### 差分编码\n\n下面对绝对码进行差分编码，假设参考相位为0，若第一个码元为0则不变，为1则便为1，即$\\pi$。\n\n```matlab\nfor i = 1 : L\n    if (i == 1)\n        if (Signal_absolute(1) == 0)\n            Signal_relative(1) = 0;\n            at(1:Ns) = LL;\n        else\n            Signal_relative(1) = 1;\n            at(1:Ns) = HL;\n        end\n    elseif (Signal_absolute(i) == at((i-1)*Ns - 1))\n        Signal_relative(i) = 0;\n        at((i-1)*Ns + 1 : i*Ns) = LL;\n    else\n        Signal_relative(i) = 1;\n        at((i-1)*Ns + 1 : i*Ns) = HL;\n    end\nend\n\nGa = cpsd(at,at,[],[],Nfft,fs,'twosided');\n\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot(t/TB, at);\nset(gca,'XTick',0:1:max(t/TB));\ntitle ('(a)基带信号（相对码）时域波形');\nxlabel('t/($\\frac{1}{2.4 \\times 10^4}$ s)',\"Interpreter\",\"latex\");\nylabel('a(t)');\ngrid\nsubplot(3,1,2);\nplot(f,abs(Ga)/max(abs(Ga)));\nset(gca,'xlim',[0,2.4e6]);\ntitle('(b)基带信号（相对码）功率谱');\nxlabel('f/Hz');\nylabel('G_a(f)');\ngrid\nsubplot(3,1,3);\nplot(f,abs(Ga)/max(abs(Ga)));\nset(gca,'xlim',[0,0.1e6]);\ntitle('(c)基带信号（相对码）功率谱（局部）');\nxlabel('f/Hz');\nylabel('G_a(f)');\nax = gca;\nchart = ax.Children(1);\nn = find(f==24000);\ndatatip(chart,f(n),Ga(n));\ngrid\n```\n\n![image](figure_1.png)\n\n此处实现绝对码的传号差分码编码，将输入的绝对码序列 \\[1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,1\\] 通过编码后得到相对码序列 \\[1,0,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0\\]，并转化为图(a) 中相应时域信号输出。\n\n同时，通过计算功率谱函数，输出功率谱波形图。观察图(b,c) 中的功率谱可以发现，和绝对码基带信号类似的是，其主要为直流分量，频率较低，功率谱主要集中在低频部分，且带宽为$B=f_B =2.4\\times 10^4$ Hz。\n\n### 相移键控\n\n将绝对码转化为相对码后，根据相对码对输入载波进行绝对调相，若为低电平 则相移为 0，高电平相移为$\\pi$ 。输出后的$b(t)$即为相移键控后所得到的调制信号。\n\n```matlab\nfor i = 1 : L\n    if Signal_relative(i) == 1\n        bt((i-1)*Ns + 1 : i*Ns) = cos (2 * pi * fc * t((i-1)*Ns + 1 : i*Ns) + pi);\n    else\n        bt((i-1)*Ns + 1 : i*Ns) = cos (2 * pi * fc * t((i-1)*Ns + 1 : i*Ns));\n    end\nend\n\nGb =cpsd(bt,bt,[],[],Nfft,[],\"twosided\");\n\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot (t, bt);\naxis([0, TB * L, -1.5, 1.5 ]);\ntitle ('(a)调制后信号时域波形');\nxlabel('t/s');\nylabel('b(t)');\ngrid\nsubplot(3,1,2);\nplot(f,abs(Gb)/max(abs(Gb)));\nset(gca,'xlim',[0,2.4e6]);\ntitle('(b)调制后信号功率谱');\nxlabel('f/Hz');\nylabel('G_b(f)');\ngrid\nsubplot(3,1,3);\nplot(f,abs(Gb)/max(abs(Gb)));\nset(gca,'xlim',[0.95e6,1.05e6]);\ntitle('(c)调制后信号功率谱（局部）');\nxlabel('f/Hz');\nylabel('G_b(f)');\nax = gca;\nchart = ax.Children(1);\nn1 = find(f==1024000);\ndatatip(chart,f(n1),Gb(n1));\nn2 = find(f==976000);\ndatatip(chart,f(n2),Gb(n2));\ngrid\n```\n\n![image](figure_2.png)\n\n若放大观察已调信号的时域波形图\\\\(a) 可以看到，波形的相位变化点的分布符合相对码序列的分布规律。 从图(b)中可以看出调制信号的功率谱密度主要集中在 载波频率1  MHz 点处，带宽为$B=2f_B =4.8\\times 10^4$ Hz，与2DPSK码的功率谱特点一致。\n\n## 高斯信道\n\n因题目要求信道采用高斯信道，这里生成$\\mu =0,~\\sigma^2 =0.05^2$的高斯噪声与调制后的信号相叠加，相移键控调制后的信号通过高斯信道后的频谱分布。\n\n```matlab\nvn = 0.05;\nnt = vn .* (randn(size(t))); %产生噪音\ndpsk = (bt + nt);\n\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot(t,nt);\ngrid\ntitle('(a)噪声信号（局部）时域波形');\nxlabel('t/s');\nylabel('n(t)');\naxis([0 1e-4 -0.2 0.2]);\nsubplot(3,1,2);\nplot(t,dpsk);\naxis([0 1e-4 -1.2 1.2]);\ntitle('(b)加噪2DPSK信号（局部）时域波形');\nxlabel('t/s');\nylabel('e_{2DPSK}(t)');\nsubplot(3,1,3);\nplot(t,dpsk);\ntitle('(c)加噪2DPSK信号时域波形');\nxlabel('t/s');\nylabel('e_{2DPSK}(t)');\ngrid\n```\n\n![image](figure_3.png)\n\n所产生的高斯信号与加噪后的噪声如图所示。\n\n## 2DPSK解调\n\n### 带通滤波器\n\n解调过程中，首先应该考虑高斯信道产生的噪声影响，故设计带通滤波器滤除 加噪2DPSK信号中的噪声，采用切比雪夫II型数字滤波器实现带通滤波器。这里设置采样频率为4.8 MHz，载波频率为1 MHz，故选取通带截止频率为$f_{pl} =0.9$ MHz,  $f_{pu} =1.1$ MHz，且要求幅度失真大于1 dB，即通带最大衰减$\\alpha_p =1$ dB。同时我们滤除小于$f_{sl} =0.8$ MHz和大于$f_{su} =1.2$  MHz的干扰和噪声，衰减大于 40 dB，即阻带最小衰减$\\alpha_s =40$ dB。\n\n```matlab\nWpl = 2 *  9e5/fs; Wpu = 2  * 11e5/fs; Wsl = 2 * 8e5/fs; Wsu= 2  *12e5/fs; Rp = 1; Ra = 40;  % 滤波器指标\nWp = [Wpl, Wpu];\nWs = [Wsl, Wsu];\n[N, Wso] = cheb2ord(Wp, Ws, Rp, Ra);     % 计算切比雪夫Ⅱ型数字滤波器的阶N和阻带边界频率Wso\n[Bz, Az] = cheby2(N, Ra, Wso);           % 用双线性变换法设计切比雪夫Ⅱ型数字带通滤波器\nct = filter(Bz,Az,dpsk);\n\nw = 0.2 * pi: 0.05 :  0.8 * pi;\n[H, ~] = freqz(Bz ,Az, w); \nH = 20 * log10(abs(H));\nfigure;\nplot(w/pi,H),grid on\nxlabel('\\omega/\\pi') ;ylabel('|H(e^{j\\omega})| /dB');\n```\n\n![image](figure_4.png)\n\n画出切比雪夫II型数字滤波器的幅频响应如图所示，可以看出符合上述数字带通滤波器设计要求。\n\n加噪2DPSK信号通过带通滤波器后得到滤除部分噪声和干扰的信号$c(t)$。\n\n```matlab\nfigure;\nset(gcf,'position',[0,0,800,300],'color','w');\nplot(t,ct);\ntitle('带通滤波后的时域波形');\nxlabel('t/s');\nylabel('c(t)');\ngrid\n```\n\n![image](figure_5.png)\n\n图所示信号与上图(c) 相比可发现谱线变得更加清晰，可清晰观察到倒相现象。\n\n### 相乘器\n\n通过相乘器将带通滤波器输出的信号$c(t)$与本地载波$\\cos \\omega_c t$相乘，相乘器起 相位恢复的作用，相乘结果反映了前后码元的相位差。\n\n```matlab\ndt = ct .* cos (2 * pi * fc * t);\n\nfigure;\nset(gcf,'position',[0,0,800,300],'color','w');\nplot(t, dt);\naxis([0, TB * L, -1.5, 1.5]);\ntitle('相乘后的时域波形');\nxlabel('t/s');\nylabel('d(t)');\ngrid\n```\n\n![image](figure_6.png)\n\n观察图中的波形可以发现，相乘后的时域波形，横轴上方代表相对码中的 0，下方表示相对码中的 1，符合反向的相对 码序列\\[1,0,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0, 1,1,0,1,0\\] 的分布规律。同时可以看到信号幅度减半，这是由于相乘器在应用积化和差时引入了一个$\\frac{1}{2}$的因子。\n\n### 低通滤波器\n\n下面需要滤除载波1 MHz，设计低通滤波器滤除掉相乘器的输出信号 d(t) 的高频部分，便于后续抽样判决，所设计滤波器采用巴特沃斯模拟低通滤波器，并采用脉冲响应不变法将模拟滤波器转换为数字滤波器。这里我们将基带信号从已调波中滤出，从图 中可以看到基带信号集中在低频部分，故选取通带截止频率$f_p =0.2$ MHz，通带最大衰减$\\alpha_p =1$ dB阻带截止频率$f_s =0.5$ MHz，阻带最小衰减$\\alpha_s =30$ dB，采样频率为4.8 MHz。\n\n```matlab\n[N,Wn] = buttord(2 * pi * 2e5, 2 * pi * 5e5, 1, 30,'s');\n[Bs,As] = butter(N, Wn, 's');\n[Bz,Az] = impinvar(Bs, As, fs); % 脉冲响应不变法，将模拟滤波器转换为数字滤波器\net = filter(Bz, Az, dt);\n\n\nw = 0: 0.1 : pi;\n[H, ~] = freqz(Bz ,Az, w); \nH = 20 * log10(abs(H));\nfigure;\nplot(w/pi,H),grid on\nxlabel('\\omega/\\pi') ;ylabel('|H(e^{j\\omega})| /dB');\n```\n\n![image](figure_7.png)\n\n画出巴特沃斯低通滤波器的幅频响应如图所示，可以看出符合上述数字带通 滤波器设计要求。\n\n已调信号通过低通滤波器后得到滤除载波的信号$e(t)$。\n\n```matlab\nfigure;\nset(gcf,'position',[0,0,800,300],'color','w');\nplot (t, et);\naxis([0, TB * L, -1.5, 1.5]);\ntitle('低通滤波后的时域波形');\nxlabel('t/s');\nylabel('e(t)');\ngrid\n```\n\n![image](figure_8.png)\n\n如图所示，时域波形是没有了载波恢复成了基带信号，下面需要进行抽样判决。可以看到曲线上出现了一些振铃噪声，这是因为sinc函数的拖尾被截断而导致，也印证了矩形信号无法完美实现。\n\n### 抽样判决\n\n抽样判决器包括抽样、判决及码元形成，经抽样、判决后将码元再生，即可恢 复出数字序列。定时抽样脉冲（位同步信号）是很窄的脉冲，位于每个码元的 中央位置。通过将中央位置的码元幅度与门限电平（此处为 0 V）相比较，横轴 上方代表相对码中的 0，下方表示相对码中的 1，即可恢复相对码序列 \\[1,0,0,1,1,1,0,1,1,0,0,0,0,0,0,1,1,1,0, 1,1,0,1,0\\] 。\n\n```matlab\nfor i = 1 : L\n    if et((2*i-1)*Ns/2) < 0\n        ft((i-1)*Ns + 1 : i*Ns) = HL;\n    else\n        ft((i-1)*Ns + 1 : i*Ns) = LL;\n    end\nend\n\nfigure;\nset(gcf,'position',[0,0,800,300],'color','w');\nplot (t, ft);\ntitle('抽样判决后的时域波形');\nxlabel('t/s');\nylabel('f(t)');\ngrid\n```\n\n![image](figure_9.png)\n\n抽样判决后生成的数字序列如图所示，可以看到和 4(a) 的波形是完全一致。这相当于完成了2PSK的任务，但是2DPSK和2PSK还相差了码反变换。\n\n### 码反变换\n\n通过模二加运算实现码反变化，将当前相对码序列幅度与前一周期时刻幅度进 行模二加运算，即可恢复出绝对码波形。\n\n```matlab\nfor i = 1 : L\n    if (i==1)\n        if (mod(ft(1), 2) == 1)\n            gt(1:Ns) = HL;\n        else\n            gt(1:Ns) = LL;\n        end\n    elseif mod(ft((i-1)*Ns - 1)+ft((i-1)*Ns + 1),2)\n        gt((i-1)*Ns + 1 : i*Ns) = HL;\n    else\n        gt((i-1)*Ns + 1 : i*Ns) = LL;\n    end\nend\n\nGg=cpsd(gt,gt,[],[],Nfft,fs,'twosided');\n\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot (t, gt);\ntitle ('(a)解调后信号时域波形');\nxlabel('t/s');\nylabel('g(t)');\ngrid\nsubplot(3,1,2);\nplot(f,abs(Gg)/max(abs(Gg)));\nset(gca,'xlim',[0,2.4e6]);\ntitle('(b)解调后信号功率谱');\nxlabel('f/Hz');\nylabel('G_g(f)');\ngrid\nsubplot(3,1,3);\nplot(f,abs(Gg)/max(abs(Gg)));\nset(gca,'xlim',[0,0.1e6]);\ntitle('(c)解调后信号功率谱（局部）');\nxlabel('f/Hz');\nylabel('G_g(f)');\nax = gca;\nchart = ax.Children(1);\nn = find(f==24000);\ndatatip(chart,f(n),Gg(n));\ngrid\n```\n\n![image](figure_10.png)\n\n所得到的绝对码时间波形如图所示， 符合绝对码输入序列 \\[1,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,1\\] 的分布规律。解调后的信号功率谱中主要 为直流分量，低频信号，因此功率谱主要集中在低频部分。同时，带宽为$B=f_B =\\frac{1}{T_B }=2.4\\times 10^4$ Hz，恢复到单极性非归零码的性质。\n\n# 五、输入输出波形的比较\n\n输入输出信号的时域波形和频域波形如图所示。从图可以看出时域波形和频域波形完全重合，说明数字 2DPSK 频带传输系统的设计。\n\n```matlab\nfigure;\nset(gcf,'position',[0,0,800,900],'color','w');\nsubplot(3,1,1);\nplot (t, st,\"b\", t, gt, \"r--\");\nset(gca,'ylim',[0,1.5]);\nlegend('输入信号s(t)','输出信号g(t)');\ntitle ('(a)输入信号s(t)和输出信号g(t)时域波形');\nxlabel('t/s');\nylabel('s(t) & g(t)');\ngrid\nsubplot(3,1,2);\nplot(f,abs(Gs)/max(abs(Gs)),\"b\",f,abs(Gg)/max(abs(Gg)),\"r--\");\nlegend('输入信号s(t)','输出信号g(t)');\nset(gca,'xlim',[0,2.4e6]);\ntitle('(b)输入信号s(t)和输出信号g(t)功率谱');\nxlabel('f/Hz');\nylabel('G_s(f) & G_g(f)');\ngrid\nsubplot(3,1,3);\nplot(f,abs(Gs)/max(abs(Gs)),\"b\",f,abs(Gg)/max(abs(Gg)),\"r--\");\nlegend('输入信号s(t)','输出信号g(t)');\nset(gca,'xlim',[0,0.1e6]);\ntitle('(c)输入信号s(t)和输出信号g(t)功率谱（局部）');\nxlabel('f/Hz');\nylabel('G_s(f) & G_g(f)');\ngrid\n```\n\n![image](figure_11.png)\n\n# 六、心得体会\n\n这次仿真实验我们实现了一个基本的通信系统模型，主要研究的是数字频带传输系统的设计与工作原理分析。\n\n电院电子信息工程专业本学期开设的《通信原理》课程尚未进行到数字调制部分，在前期准备阶段，我们自学了相关章节，并构建了从数字调制部分到数字解调部分的原理框图。在数字调制部分，通过差分编码，将原始基带信号序列（绝对码形式）转变为相对码形式，克服了2PSK相位模糊性的缺点；以转换后的信号作为控制电平，控制本振信号的相移，从而生成二进制差分相移键控信号，信息挂载于载波上。信号在信道中传输时会受到干扰，我们添加了加性高斯噪声来模拟高斯信道。信道到达接收端，在进行数字解调前，需要让信号通过带通滤波器，以削弱高斯信道的噪声影响。解调采用的方式是相干解调，需要用与载波频率一致的本振信号参与解调。经滤波后的信号与本振信号相乘，再经过低通滤波器（低通滤波器的作用等同于包络检波），得到相对码形式的数字基带信号。经过抽样判决器，并经过码反变换，最终得到与原始信号相同的信息序列。\n\n整个过程中我们遇到了很多问题，通过数学分析与反复试验得以解决。在信号码速一定的情况下，我们尝试了多组采样率与载波信号频率，观察信号时域图，选取最佳的组合；在相移键控部分，我们没有正确理解相对码与相移键控信号的关系，在向量构造上多次出现不匹配的情况，经推导解决；此外，我们还研究了数字角频率与模拟频率的数学关系，正确对各信号频谱的横坐标进行了标注。任务圆满完成。\n\n本次实验综合运用了《通信原理》与算法相关知识，将理论与实践相结合，强化了我们系统分析与算法设计的能力。我们初步学习了现代通信系统的构成与运作方式，对数字编解码进行了实践，可谓受益匪浅。\n\n\n\n# 参考文献\n\n1. 樊昌信，曹丽娜. 通信原理(第7版)[M]. 北京：国防工业出版社, 2012: 184-189.\n2. 史林，赵树杰. 数字信号处理[M]. 北京：科学出版社, 2007: 240, 258-259.\n\n\n\n","tags":["通信原理","MATLAB"],"categories":["课程向"]},{"title":"【无线通信学习笔记（二）】统计多径信道模型","url":"/2021/04/22/Wireless-Communications-Ch-3/","content":"\n>  *Wireless Communications* (Andrea Goldsmith)学习笔记。\n\n# Statistical Multipath Channel Models\n\n1. 在第二章中，着重讨论的确知信道，但是实际中确知信道是极为少见的。第三章将通过**随机时变冲激响应**(random time-varying impulse response)来刻画多径信道。路径损耗、阴影和多径模型共同刻画了信号传输过程中发射信号到接收信号之间的损耗。\n\n2. 多径信道的两个基本特征：\n\n    + **时延扩展(delay spread)**：这个延迟扩散等于第一个收到的信号分量（LOS或多径）到达与单个传输脉冲相关的最后一个收到的信号分量之间的时间延迟。\n    + **时变性（time-varying）**：如果我们从一个**移动**的发射器重复发射脉冲，我们将观察到每个脉冲对应的**振幅(amplitudes)、延迟(delays)和多径分量(number of multipath components)**的变化。\n\n    > 散射函数其实有点《雷达原理与系统》中雷达波形模糊函数的意味在里面了。\n    > $$\n    > \\chi\\left(\\tau, f_{d}\\right)=\\int_{-\\infty}^{\\infty} u(t) u^{*}(t+\\tau) e^{j 2 \\pi f_{d} t} \\mathrm{~d} t\n    > $$\n    \n3. 本章的主要思路是：先给出一个时变信道的冲激响应(Time-Varying Channel Impulse Response)，利用随机信号分析的知识应用到窄带衰落模型（the channel bandwidth is small compared to the inverse delay spread.$B<\\frac 1{\\Delta\\tau}$）和宽带多径模型中。最后讨论另外两种离散时间(Discrete-Time)信道模型和空时(Space-time)信号模型。\n\n\n\n## Time-Varying Channel Impulse Response\n\n### 接收信号及其可分辨性(resolvable)\n\n+ 发射信号：\n    $$\n    s(t)=\\Re[u(t)e^{j2\\pi f_ct}]\n    $$\n    发射基带信号$u(t)$的带宽为$B_u$。\n\n+ 接收信号：\n    $$ {eq2}\n    r(t)=\\Re\\left\\{\\sum_{n=0}^{N(t)} \\alpha_{n}(t) u\\left(t-\\tau_{n}(t)\\right) e^{j\\left(2 \\pi f_{c}\\left(t-\\tau_{n}(t)\\right)+\\phi_{D_{n}(t)}\\right)}\\right\\}\n    $$\n    其中，$N(t)$是可分辨多径(multipath)的数量，$\\alpha_n(t)$是第$n$个分量幅度(amplitude)上的变化，$\\tau_n(t)=\\frac{r_n(t)}{c}$是第$n$个分量的时延(delay)，$r_n(t)$是路径长，$\\phi_{D_n}(t)$是第$n$个分量的多普勒频移。注意到这些参量都是**时变**的。\n\n+ 对于单一反射体，接收信号的参数：\n\n    + **幅度**变化：$\\alpha_n(t)$是第$n$个分量幅度(amplitude)上的变化，主要由path loss和shadowing决定\n    + **频率**变化主要有两方面组成：时延$\\tau_n(t)$带来的相移分量$e^{-j2\\pi f_C \\tau_n(t)}$，多普勒频移$\\phi_{D_n}(t)=\\int_t 2\\pi \\frac{v\\cos\\theta_n(t)}{\\lambda}\\ d\\tau$\n\n    > 值得注意的是，在雷达中的多普勒频移刚好和这里差了一个2倍的关系，这是因为对于收发公用天线的雷达，需要考虑去程和回程。在雷达回波信号模型中，回波信号的基带复包络为\n    > $$\n    > S(t)=As_e(t-\\tau_0)\\exp (j2\\pi f_dt)\n    > $$\n    > 多普勒频移项为$j2\\pi f_d t=j 2\\pi \\frac{2v\\cos\\theta f_0}{c}t=j 2\\pi \\frac{2v\\cos\\theta }{\\lambda}t$。\n\n+ **可分辨性(resolvable)**：对于时延分别为$\\tau_1,\\tau_2$的径，若\n    $$\n    |\\tau_1-\\tau_2|\\gg \\frac{1}{B_u}\n    $$\n    则称这两个径是可分辨的。\n\n    > 这里的$\\frac{1}{B_u}$在雷达信号处理中实际上就是时延分辨率$\\Delta\\tau$，即\n    > $$\n    > \\Delta \\tau=\\frac{\\int_{-\\infty}^{\\infty}|\\chi(\\tau, 0)|^{2} \\mathrm{~d} \\tau}{|\\chi(0,0)|^{2}}=2 \\pi \\frac{\\int_{-\\infty}^{\\infty}|U(\\omega)|^{4} \\mathrm{~d} \\omega}{\\left[\\int_{-\\infty}^{\\infty}|U(\\omega)|^{2} \\mathrm{~d} \\omega\\right]^{2}}=\\frac{1}{B}\n    > $$\n    > 其中，$\\chi(\\tau,f_d)$是雷达信号的模糊函数，$B$是信号的有效带宽。时延分辨率在雷达中反映的就是距离分辨率，对应关系为\n    > $$\n    > \\Delta R=\\frac{c\\Delta\\tau}{2}=\\frac{c}{2B}\n    > $$\n    > 而可分辨性的定义即表明当两径时延差远大于时延分辨率时，两径是可分辨的，对应于雷达中的概念就是当两个目标对应回波延时差大于某一距离分辨率，两个目标在距离上是可以分辨的。这也正反映出窄带信道和宽带信道的区别。窄带信道，我们将所有多径分量都看作时一个独立反射体反射出的，对应距离上无法分辨；宽带信道，我们可以将多径分量看作是不同反射体反射出的，对应距离上可以分辨。\n    \n+ 参数$\\alpha_n(t),\\tau_n(t),\\phi_{D_n}(t)$都是各态历经过程，那么接收信号也是各态历经过程。\n\n    + **窄带**信道下，每个径都是**不可分辨(nonresolvable)**的，有$u(t-\\tau_1)\\approx u(t-\\tau_2)$。这些不可分辨分量的叠加使得信号幅度快速起伏，信号的变化速度和信号波长可比拟。\n\n    + **宽带**信道一般都**有可分辨的**多径分量，那么接收信号中的每一项对应一个单独的反射体，则随环境变化是缓变得。\n\n### 时变脉冲响应(Time-Varying Channel Impulse Response)\n\n+ 一由$\\phi_{n}(t)=2\\pi f_c\\tau_n(t)-\\phi_{D_n}(t)$，则接收信号为\n    $$\n        r(t)=\\Re\\left\\{\\left[\\sum_{n=0}^{N(t)} \\alpha_{n}(t) e^{-j \\phi_{n}(t)} u\\left(t-\\tau_{n}(t)\\right)\\right] e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n\n+ 二由时变系统分析（基带输入信号通过时变信道再上变频到载频）可知\n    $$\n    r(t)=\\Re\\left\\{\\left(\\int_{-\\infty}^{\\infty} c(\\tau, t) u(t-\\tau) d \\tau\\right) e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n    其中，$c(\\tau,t)$表示在$(t-\\tau)$时刻发射冲激脉冲，$t$时刻在接收端观察到脉冲响应。\n\n+ 则可获得（离散）等效基带信道的时变脉冲响应,  $\\phi_n=e^{-j2\\pi f_C \\tau_n(t)}$\n    $$\n        c(\\tau, t)=\\sum_{n=0}^{N(t)} \\alpha_{n}(t) e^{-j \\phi_{n}(t)} \\delta\\left(\\tau-\\tau_{n}(t)\\right)\n    $$\n    ​    将求和变成积分，即可得到（连续）时变脉冲响应\n    $$\n        c(\\tau, t)=\\int \\alpha(\\xi, t) e^{-j \\phi(\\xi, t)} \\delta(\\tau-\\xi) d \\xi=\\alpha(\\tau, t) e^{-j \\phi(\\tau, t)}\n    $$\n\n+ 时不变信道的脉冲响应就是将上述两式的$t$全部去掉\n\n### 衰落(fading)    \n\n+ **衰落(fading)**：Rapid phase changes in each multipath component gives rise to constructive and destructive addition of the multipath components comprising the received signal, which in turn causes rapid variation in the received signal strength. (每个多径分量的快速相位变化引起构成接收信号的多径分量的叠加，这反过来又引起接收信号强度的快速变化。这种现象，称为**衰落**。)\n    + time delay(时延扩展)$T_m\\ll\\frac 1B$小，多径分量不可分辨，则为窄带衰落信道。\n    + time delay(时延扩展)大，多径分量可分辨，则为宽带衰落信道。宽带衰落中的可分辨分量实际上就是若干不可分辨分量的叠加。\n+ 在时变信道中，多径时延随时间变化，所以time delay $T_m$是一个随机变量。下面的分析其实很多都是针对时延扩展来分析的。\n\n\n\n\n\n## Narrowband fading models\n\n窄带衰落模型(Narrowband fading model)中，时延扩展$T_m$远小于带宽的倒数（时延分辨率）$\\frac 1B$。\n\n### 窄带衰落模型的接收信号\n\n+ 对于窄带衰落模型，所有分量的时延不可分辨，$\\tau_i=\\tau$，则接收信号：\n    $$\n    r(t)=\\Re\\left\\{u(t) e^{j 2 \\pi f_{c} t}\\left(\\sum_{n} \\alpha_{n}(t) e^{-j \\phi_{n}(t)}\\right)\\right\\}\n    $$\n\n+ 令$u(t)=1$，则发射信号为$s(t)=\\Re\\left\\{ e^{j 2 \\pi f_{c} t}e^{j\\phi_0(t)}\\right\\}$，接收信号（此处窄带信号的正交表示中文版和英文版有区别，中文版与随机信号课程中一致。）    为\n    $$\n    r(t)=\\Re\\left\\{ e^{j 2 \\pi f_{c} t}\\left(\\sum_{n} \\alpha_{n}(t) e^{-j \\phi_{n}(t)}\\right)\\right\\}=r_I(t)\\cos 2\\pi f_c t-r_Q(t)\\sin 2\\pi f_c t\n    $$\n    即对其进行模拟正交检波得到\n\n    + 同相分量（in-phase）：$r_I(t)=\\sum_{n=1}^{N(t)}\\alpha_n(t)\\cos\\phi_n(t)$\n    + 正交分量（quadrature）：$r_Q(t)=\\sum_{n=1}^{N(t)}\\alpha_n(t)\\sin\\phi_n(t)$\n    + 相移：$\\phi_n(t)=2\\pi f_c\\tau_n(t)-\\phi_{D_n}-\\phi_0$（受时延、多普勒频移、发送初相）\n\n    \n\n\n\n\n### 接收信号的自相关与互相关\n\n在不考虑LOS分量的前提下考虑同相分量和正交分量。同时我们认为幅度、多径的时延和多普勒频移都是缓变的。\n\n+ 由《随机信号分析》有，$N(t)$很大时，不考虑LOS分量，剩余的多径分量近似于窄带噪声。$r_I(t),r_Q(t)$服从联合高斯分布，$\\alpha_n(t)$服从瑞利(Rayleigh)分布，$\\phi_n(t)$服从均匀分布。\n\n+ 均值：$2\\pi f_c\\tau_n$是快变的，则接收信号在不考虑LOS分量时，是零均值高斯变量。\n\n+ 自相关(Autocorrelation)、互相关(Cross Correlation)\n\n    + 接收信号的同相分量和正交分量时正交且不相关的。\n\n    + 自相关函数：（为了方便理解，这里的书写方式与《随机信号分析》保持一致）同相分量的自相关函数为\n        $$\n        A_{r_I}(t,t+\\tau)=\\frac 12\\sum_nE[\\alpha_n^2]E\\left[\\cos\\frac{2\\pi v\\tau\\cos\\theta_n}{\\lambda}\\right]=A_{r_I}(\\tau)\n        $$\n        由于自相关与$t$无关，则为宽平稳随机过程(WSS)，同理正交分量也是WSS，且$A_{r_I}(t)=A_{r_Q}(t)$。\n\n    + 互相关函数：\n        $$\n        A_{r_I,r_Q}(t,t+\\tau)=\\frac 12\\sum_nE[\\alpha_n^2]E\\left[\\sin\\frac{2\\pi v\\tau\\cos\\theta_n}{\\lambda}\\right]=A_{r_I,r_Q}(\\tau)=-A_{r_Q,r_I}(\\tau)\n        $$\n        同样互相关函数也是WSS。\n\n    + **接收信号的自相关函数：**\n        $$\n        A_{r}(\\tau)=A_{r_{I}}(\\tau) \\cos \\left(2 \\pi f_{c} \\tau\\right)+A_{r_{I}, r_{Q}}(\\tau) \\sin \\left(2 \\pi f_{c} \\tau\\right)\n        $$\n\n### 均匀散射环境的谱分析\n\n+ 均匀散射环境(uniform scattering environment)\n    <img src=\"/scattering_environment.png\" alt=\"uniform scattering environment\" style=\"zoom:60%;\" />\n\n    + $N$个多径分量，第$n$径的angle  of arrive为$\\theta_n=n\\Delta\\theta=\\frac {2\\pi n}{N}$。若各径有相同的接收功率$E[\\alpha_n^2]=\\frac{2P_r}{N}$。\n\n+ 均匀散射环境条件下的自相关和互相关\n\n    + 自相关函数(中文版有误)\n        $$\n        A_{r_{I}}(\\tau)=\\frac{P_{r}}{2 \\pi} \\int \\cos \\left(\\frac{2 \\pi v \\tau \\cos \\theta}{\\lambda}\\right) d \\theta=P_{r} J_{0}\\left(2 \\pi f_{D} \\tau\\right)\n        $$\n\n    + 互相关函数(中文版有误)\n        $$\n        A_{r_{I},r_Q}(\\tau)=\\frac{P_{r}}{2 \\pi} \\int \\sin \\left(\\frac{2 \\pi v \\tau \\cos \\theta}{\\lambda}\\right) d \\theta=0\n        $$\n        其中，$J_0(x)$是零阶贝塞尔函数。\n\n    + 根据该假设，观察贝塞尔函数图\n        <img src=\"/bessel_function.png\" alt=\"零阶贝塞尔函数\" style=\"zoom:60%;\" />\n\n        + 在相位均匀分布的前提下，信号在经过半波长后变得不相关。\n        + 当利用阵列天线时，为保证接收天线衰落彼此独立，需保证间距为$0.4\\lambda$。\n        + 当信号相关接近为0时，可近似认为是马尔可夫过程。\n\n+ 均匀散射环境条件下的功率谱(PSD, Power Spectral Density)\n\n    + 自谱密度：\n        $$\n        S_{r_{I}}(f)=S_{r_{Q}}(f)=\\mathscr{F}\\left[A_{r_{I}}(\\tau)\\right]=\\left\\{\\begin{array}{ll}\\frac{P_{r}}{2 \\pi f_{D}} \\frac{1}{\\sqrt{1-\\left(f / f_{D}\\right)^{2}}} & |f| \\leq f_{D} \\\\ 0 & \\text { else }\\end{array}\\right.\n        $$\n\n    + 互谱密度：\n        $$\n        S_{r}(f)=\\mathscr{F}\\left[A_{r}(\\tau)\\right]=\\frac 14\\left[S_{r_{I}}\\left(f-f_{c}\\right)+S_{r_{I}}\\left(-f-f_{c}\\right)\\right]=\\left\\{\\begin{array}{cl}\\frac{P_{r}}{4 \\pi f_{D}} \\frac{1}{\\sqrt{1-\\left(\\frac{\\left|f-f_{c}\\right|}{f_{D}}\\right)^{2}}} & \\left|f-f_{c}\\right| \\leq f_{D} \\\\ 0 & \\text { else }\\end{array}\\right.\n        $$\n\n    + 对于有密集散射体的环境，PSD通常在接近最大多普勒频率时频率达到最大。\n\n    + 模拟窄带衰减过程包络的常用方法是将两个独立的高斯白噪声源($S=\\frac{N_0}{2}$，通过频率响应为$H(f)$的低通滤波器，满足以下条件\n        $$\n        S_{r_I}(f)=S_{r_Q}(f)=\\frac{N_0}{2}|H(f)|^2\n        $$\n\n+ 窄带信道中功率随距离变化的模型\n    ![窄带信道中功率随距离变化](/narrowband_P.png)\n\n    + 路径损耗(path loss)随$d^{\\gamma}$速度下降，$\\gamma$为路径损耗因子。\n    + 阴影衰落(shadowing fading)和去相关距离$X_c$在同一数量级\n    + 多径衰落(multipath fading)的变化速度和半波长可比拟\n    + 一个以固定速度$v$运动的移动接收器，接收功率呈现为各态历经的平稳过程。\n\n### 包络与功率的分布\n\n+ 对于均匀分布的相位，同相分量和正交分量服从零均值联合高斯分布。功率的分布就是包络平方的分布。\n\n+ 不考虑LOS分量包络的分布（窄带高斯噪声包络的分布）——瑞利分布(Rayleigh-distributed)\n    $$\n        p_{Z}(z)=\\frac{2 z}{\\bar P_{r}} \\exp \\left[-\\frac{z^{2}} {\\bar P_{r}}\\right]=\\frac{z}{\\sigma^{2}} \\exp \\left[-\\frac{z^{2}}{2 \\sigma^{2}}\\right], \\quad x \\geq 0\n    $$\n    ​    $\\bar P_r$是不考虑多径时信号的平均接收功率。\n\n+ 不考虑LOS分量包络平方（功率）的分布（窄带高斯噪声包络的分布）——均值为$2\\sigma^2$的指数分布(exponentially distributed)\n    $$\n    P_{Z^2}(x)=\\frac{1}{P_r}e^{-\\frac x{P_r}}=\\frac{1}{2\\sigma^2}e^{-\\frac x{2\\sigma^2}},x\\ge 0\n    $$\n    \n+ 考虑LOS分量包络的分布（窄带高斯噪声+信号包络的分布）——莱斯分布(广义瑞利分布，Rician distribution)\n   $$\n   p_{Z}(z)=\\frac{z}{\\sigma^{2}} \\exp \\left[\\frac{-\\left(z^{2}+s^{2}\\right)}{2 \\sigma^{2}}\\right] I_{0}\\left(\\frac{z s}{\\sigma^{2}}\\right), \\quad z \\geq 0\n   $$\n   其中，$s^2=\\alpha_0^2$时LOS分量功率，$2\\sigma^2$是其它多径分量的平均功率。$I_0(x)$是零阶修正贝塞尔函数。\n   + 平均接收功率$\\bar P_r=s^2+2\\sigma^2$\n   \n   + 衰落系数（其实也是信噪比的意思）\n       $$\n       K=\\frac{s^2}{2\\sigma^2}\n       $$\n   \n       + $K=0$为瑞利衰落，$K=\\infty$为无衰落。\n       + 因此，衰落系数$K$是衡量消退严重程度的标准：小的$K$意味着严重的衰落，大的$K$则意味着更温和的衰落。\n   \n+ 考虑LOS分量包络平方（功率）的分布（窄带高斯噪声+信号包络的分布）——自由度$n=2$的非中心卡方分布(书上没有)\n\n+ 包络分布的经验公式——Nakagami fading distribution\n   $$\n   p_{Z}(z)=\\frac{2 m^{m} z^{2 m-1}}{\\Gamma(m)\\bar P_{r}^{m}} \\exp \\left[\\frac{-m z^{2}}{\\bar P_{r}}\\right], \\quad m \\geq 0.5\n   $$\n\n   + $\\bar P_r$为平均接收功率\n   + $m=1$退化为瑞利衰落，$m=\\infty$近似无衰落，$m=\\frac{(K+1)^2}{2K+1}$近似衰落系数为$K$的莱斯分布\n\n+ 包络平方（功率）分布的经验公式\n   $$\n   p_{Z^{2}}(x)=\\left(\\frac{m}{P_{r}}\\right)^{m} \\frac{x^{m-1}}{\\Gamma(m)} \\exp \\left(\\frac{-m x}{P_{r}}\\right)\n   $$\n\n### Level Crossing Rate and Average Fade Duration\n\n+ Level Crossing Rate(电平通过率)$L_Z$：信号包络在向下方向穿越电平$Z$的平均速率（以每秒穿越次数计）\n    $$\n    L_Z=\\frac{N_Z}{T}=\\int_{-\\infty}^{0}\\dot zp(Z,\\dot z)\\ \\mathrm{d}\\dot z\n    $$\n    其中，$Z$是跨越的电平，$\\dot z$是包络的时间导数。\n\n    + 莱斯衰落的Level Crossing Rate：\n        $$\n        L_{Z}=\\sqrt{2 \\pi(K+1)} f_{D} \\rho e^{-K-(K+1) \\rho^{2}} I_{0}(2 \\rho \\sqrt{K(K+1)})\n        $$\n\n    + 瑞利衰落的Level Crossing Rate：\n        $$\n        L_{Z}=\\sqrt{2 \\pi} f_{D} \\rho e^{-\\rho^{2}}\n        $$\n        其中，$\\rho=\\frac{Z}{\\bar P_r}$\n\n+ average signal fade duration（平均衰减时长）$\\bar t_z$：信号包络保持在给定目标电平$Z$以下的平均时间。\n    $$\n    \\bar{t}_{Z}=\\frac{1}{T L_{Z}} \\sum_{i=1}^{L_{Z} T} t_{i} \\approx \\frac{p(z(t)<Z)}{L_{Z}}=\\frac{\\text{小于Z的总时间/单位时间}}{\\text{下穿过Z的次数/单位时间}}\n    $$\n\n    + 瑞利分布的average signal fade duration：\n        $$\n        \\bar{t}_{Z}=\\frac{e^{\\rho^{2}}-1}{\\rho f_{D} \\sqrt{2 \\pi}}\n        $$\n\n    + average signal fade duration随多普勒频移的增加而减少。\n\n    + The average fade duration indicates the number of bits or symbols affected by a deep fade.\n\n### 有限状态马尔可夫信道\n\n有限状态马尔可夫信道（FSMC）是一个比较简单的模型，它捕捉到了平衰落信道的主要特征。在这个模型中，衰落被近似为一个离散时间马尔可夫过程，时间被离散为一个给定的间隔$T$（通常是符号周期）。具体来说，所有可能的衰落增益的集合被建模为一组有限的信道状态。根据一组马尔可夫转移概率，信道在每个区间$T$的这些状态中变化。\n\n\n\n## Wideband fading models\n\n宽带衰落模型(Wideband fading models)中，多出了多径时延扩展导致的失真(distortion due to the multipath delay)。若发射脉冲宽度为$T$，回波信号的脉宽扩展为$T+T_m$，则时延扩展为$T_m$。\n![多径分辨率](/Multipath_Resolution.png)\n\n+ 当$T_m\\ll T$时，重叠的信号叠加造成窄带衰落，无明显时延扩展，对后续干扰很小。\n+ 当$T_m\\gg T$时，多径分量可分辨，造成ISI(码间串扰)。\n+ 解决方法：equalization（均衡）, multicarrier modulation（多载波调制）, and spread spectrum（扩频）\n\n### 散射函数(scattering function)\n\n+ 对于宽带衰落模型，$u(t - \\tau_n(t))\\approx u(t)$的近似值不再有效。因此，接收信号是发射信号的拷贝之和，其中每个副本在时间上延迟了$\\tau_n$，在相位上移位了$\\phi_n(t)$。\n\n+ 对于窄带信道，我们主要从幅度和相位随机过程来刻画。对于宽带信道，必须要考虑**多径时延扩展(multipath delay spread)和信道时变(time-variations associated with the channel)**的影响。\n\n+ deterministic scattering function（确知散射函数）：\n    $$\n    c(\\tau,t)\\longleftrightarrow S_{c}(\\tau, \\rho)=\\int_{-\\infty}^{\\infty} c(\\tau, t) e^{-j 2 \\pi \\rho t}\\ \\mathrm{d} t\n    $$\n    $S_{c}(\\tau, \\rho)$是等效基带信道的时变脉冲响应$c(\\tau,t)$关于$t$的Fourier变换。通过频率参数$\\rho$反映信道的多普勒特性。\n\n+ random scattering function（随机散射函数）\n\n    + 考虑到$c(\\tau,t)$的随机性，用时变随机过程的自相关函数$A_c(\\tau_1,\\tau_2;t,t+\\Delta t)$，并假设信道宽平稳$A_c(\\tau_1,\\tau_2;\\Delta t)$，同时假设信道为不相关散射(uncorrelated scattering)信道($\\tau_1\\neq\\tau_2$)\n        $$\n        E\\left[c^{*}\\left(\\tau_{1} ; t\\right) c\\left(\\tau_{2} ; t+\\Delta t\\right)\\right]=A_{c}\\left(\\tau_{1} ; \\Delta t\\right) \\delta\\left[\\tau_{1}-\\tau_{2}\\right] \\triangleq A_{c}(\\tau ; \\Delta t)\n        $$\n        其中$A_{c}(\\tau ; \\Delta t)$给出了与信道相关的平均输出功率，作为多径延迟$\\tau=\\tau_1=\\tau_2$和观察时间差$\\Delta t$的函数。\n\n    + 定义scattering function：\n        $$\n        A_c(\\tau,\\Delta t)\\longleftrightarrow S_{c}(\\tau, \\rho)=\\int_{-\\infty}^{\\infty} A_c(\\tau, \\Delta t) e^{-j 2 \\pi \\rho \\Delta t}\\ \\mathrm{d} \\Delta t\n        $$\n        散射函数描述了与信道相关的平均输出功率，是多径延迟$\\tau$和多普勒频移$\\rho$的函数。\n\n### 功率时延谱、相干带宽、多普勒功率谱、相干时间\n\n+ **功率时延谱(power delay profile)**：令$A_c(\\tau,\\Delta t)$中$\\Delta t=0$，则得到功率时延谱(power delay profile)$A_c(\\tau)=A_c(\\tau,0)$。\n  \n    + 时延扩展的概率密度分布\n        $$\n        p_{T_m}=\\frac{A_c(\\tau)}{\\int_o^{\\infty}A_c(\\tau)d\\tau}\n        $$\n    \n    + 时延扩展\n        + 平均时延扩展（average delay）$\\mu_{T_m}$\n        + 均方根时延扩展（rms delay）$\\sigma_{T_m}$\n        + 平均和均方根时延扩展都是**把各径的时延按照功率加权**。\n        + The time delay $T$ where $A_c(\\tau)\\approx 0$ for $\\tau\\ge T$ can be used to roughly characterize by a small integer multiple of the rms delay spread ($n\\sigma_{T_m}$). When symbol period $T_s$ is within an order of magnitude of σTm then there will be some ISI.\n        + $\\mu_{T_m}\\approx \\sigma_{T_m}$ in many channels with a large number of scatterers.\n\n+  **相干带宽（Coherence Bandwidth）**\n    + 对$c(\\tau;t)$关于$\\tau$作傅里叶变换\n\t\t$$\n\t\tC(f, t)=\\int_{-\\infty}^{\\infty} c(\\tau, t) e^{-j 2 \\pi f \\tau}\\ \\mathrm{d} \\tau\n\t\t$$\n\t\t再对$C(f,t)$求自相关函数，设其宽平稳，且不相关散射\n\t\t$$\n\t\tA_C(f_1,f_2;\\Delta t)=E[C^*(f_1;t)C(f_2;t+\\Delta t)]=A_C(\\Delta f,\\Delta t)\n\t\t$$\n\t\t令$A_C(\\Delta f,\\Delta t)$中$\\Delta t=0$，则得到$A_C(\\Delta f)$，也有傅里叶变换关系\n\t\t$$\n\t\tA_C(\\Delta f)=\\int_{-\\infty}^{\\infty} A_c(\\tau) e^{-j 2 \\pi \\Delta f \\tau}\\ \\mathrm{d} \\tau\n\t\t$$\n\t\t\n\t+ **相干带宽（Coherence Bandwidth）**：\n\t\t$$\n\t\t\\forall \\Delta f>B_c,A_C(\\Delta f)\\approx 0\n\t\t$$\n\t\t+ 对$\\tau>T$有$A_C(\\Delta f)\\approx 0$，$B_c\\approx \\frac 1T$\n\t\t+ 更一般的近似\n\t    $$\n\t    B_c\\approx \\frac{k}{\\sigma_{T_m}}\n\t    $$\n\t    其中，$k$ depends on the shape of $A_c(τ )$ and the precise specification of coherence bandwidth.\n\t  \n\t+ 信号带宽与相干带宽\n\t    ![fading](/fading.png)\n\t\n\t    + **平衰落(flat fading)**：对于$B\\ll B_c$的窄带信号，信号带宽内衰落高度相关，整个带宽上的衰落近似相等。$T_s\\approx \\frac 1B\\gg\\frac 1{B_c}\\approx \\sigma_{T_m}$，可以忽略ISI。\n\t    + **频率选择性衰落(requency-selective fading)**：对于$B\\gg B_c$的宽带信号，信道幅度在不同带宽间变化很大。$T_s\\approx \\frac 1B\\ll \\frac 1{B_c}\\approx \\sigma_{T_m}$，不可以忽略ISI。\n\t\n+ 多普勒功率谱（Doppler Power Spectrum）与相干时间（Channel Coherence Time）\n\n    + 令$A_C(\\Delta f,\\Delta t)$中$\\Delta f=0$，则得到$A_C(\\Delta t)$，也有傅里叶变换关系\n        $$\n        S_{C}(\\rho)=\\int_{-\\infty}^{\\infty} A_{C}(\\Delta t) e^{-j 2 \\pi \\rho \\Delta t} d \\Delta t\n        $$\n\n    + 多普勒功率谱（Doppler Power Spectrum）描述接收功率在多普勒频率$\\rho$上的密度\n\n    + Doppler spread（多普勒扩展）：\n        $$\n        \\forall \\Delta \\rho>B_D,|S_C(\\rho)|\\approx 0\n        $$\n\n    + 相干时间（Channel Coherence Time）$T_c$：$A_C(\\Delta t)$近似为非零的数值范围。\n\n        > 根据随机信号分析知识，\n        > $$\n        > T_c=\\int_0^\\infty A_C(\\Delta t)\\ d\\Delta t\n        > $$\n        \n    + 多普勒扩展和相干时间的关系：\n        $$\n        B_D\\approx \\frac 1{T_c}\n        $$\n\n### 自相关与散射函数\n\n$$\nS_{c}(\\tau ; \\rho)=\\mathscr{F}_{\\Delta t}\\mathscr{F}_{\\Delta f}^{-1}[ A_{C}(\\Delta f ; \\Delta t)]=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} A_{C}(\\Delta f ; \\Delta t) e^{-j 2 \\pi \\rho \\Delta t} e^{j 2 \\pi \\tau \\Delta f} d \\Delta t d \\Delta f\n$$\n\n![transform](/transforms.png)\n\n## Discrete-Time Model\n\n通常情况下，时变脉冲响应信道模型对于简单的分析来说过于复杂。在这种情况下，可以使用宽带多径模型的离散时间近似值。这个离散时间模型是基于一个由孤立的点状散射体组成的物理传播环境。\n![散射点信道模型](/Point_Scatterer.png)\n$$\nc(\\tau ; t)=\\sum_{n=0}^{N} \\alpha_{n}(t) e^{-j \\phi_{n}(t)} \\delta\\left(\\tau-\\tau_{n}(t)\\right)\n$$\n给定$t$的情况下，将时延轴$\\tau$分为间隔为$T$的$M$个时间段，且$MT\\ge \\sigma_{T_m}$，每个径分配到这$M$个时间段中。则离散时间模型的多径时延扩展为$MT$，各径之间分辨率为$T\\approx \\frac 1B$。\n\n随着时间的推移，用一连串的时间点配置数据刻画信道脉冲响应的变化。\n\n## Space-Time Channel Models\n\n多天线在无线系统中变得非常普遍。具有多天线的系统需要信道模型来体现信道的空间（到达角）和时间特性。\n\n对于二维多径传播环境，接收天线或发射天线配备$M$个天线单元，则时变脉冲响应模型为\n$$\nc(\\tau, t)=\\sum_{n=0}^{N(t)} \\alpha_{n}(t) e^{-j \\phi_{n}(t)} \\bar{a}\\left(\\theta_{n}(t)\\right) \\delta\\left(\\tau-\\tau_{n}(t)\\right)\n$$\n其中，$\\bar{a}\\left(\\theta_{n}(t)\\right)$是阵因子矢量。\n\n\n\n## 参考文献\n\n1. ANDREA GOLDSMITH.*WIRELESS COMMUNICATIONS*.2005.\n2. （美）Andrea Goldsmith著；杨鸿文，李卫东，郭文彬等译. 无线通信. 北京：人民邮电出版社, 2007.06.\n3. 陈伯孝. 雷达原理与系统（讲义）. 西安电子科技大学, 2021.02.","tags":["无线通信"],"categories":["课程向"]},{"title":"【深度学习笔记（二）】改进深度神经网络：超参数、正则化和优化","url":"/2021/04/17/DL-Coursera-2-Improving-Deep-Neural-Networks/","content":"\n> 这个专项课程一共五门，包括\n>\n> + [Neural Networks and Deep Learning（神经网络与深度学习）](https://levitate-qian.github.io/2021/03/26/DL-Coursera-1-Neural-Networks-and-Deep-Learning/)\n> + **Improving Deep Neural Networks: Hyperparameter Tuning, Regularization and Optimization（改进深度神经网络：超参数、正则化和优化）**\n> + Structuring Machine Learning Projects（构建机器学习项目）\n> + Convolution Neural Networks（卷积神经网络）\n> + Sequence Model（序列模型）\n>\n> 部分内容参考了左老板的博客（http://www.cyzuo.cn/）\n\n\n\n# Improving Deep Neural Networks 学习笔记\n\n第二门课程的主体框架：\n\n+ Week 1: Practical aspects of DL\n    + Setting up your Machine learning Application\n    + Regularizing your NN\n    + Setting up your optimization problem\n+ Week 2: Optimization algorithms\n+ Week 3: Hyperparameter tuning, Batch Normalization, Programming frameworks\n    + Hyperparameter tuning\n    + Batch Normalization\n    + Multi-class classification\n    + Programming frameworks\n\n\n\n## Week 1\n\n### 1-1 Setting up your Machine learning Application\n\n在这个section里面主要讨论的是机器学习中基本的性能度量和评价指标。主要谈到了这两点：\n\n+ Training/dev/Test sets（训练集/验证集（开发集）/测试集）\n+ Bias/Variance（偏差和方差）\n\n#### 1. Training/dev/Test sets\n\n1. Applied ML is a highly iterative process.（应用机器学习是一个高度重复的过程）\n\n2. Train/dev/Test sets的划分\n\n    ![Training/dev/Test sets](/Train_Dev_Test.png)\n\n3. Mismatched train/test distribution\n\n    + **验证集要和训练集来自于同一个分布**（数据来源一致），可以使得机器学习算法变得更快并获得更好的效果。\n    + 同时，没有测试集是可以的，但是不能没有验证集用于交叉验证。\n\n#### 2. Bias/Variance\n\n下面通过图片和数据两种方式形象地展示在机器学习中偏差(Bias)和方差(Variance)指什么，过拟合(overfitting)和欠拟合(underfitting)。\n\n+ **偏差(Bias)**：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了**学习算法本身的拟合能力**；\n+ **方差(Variance)**：度量了同样大小的训练集的变动所导致的学习性能的变化，即**刻画了数据扰动所造成的影响**；\n+ **噪声(noise)**：表达了在当前任务上任何学习算法所能够达到的期望泛化误差的下界，即**刻画了学习问题本身的难度**。\n+ 过拟合(overfitting)：模型过分地契合训练集，但泛化能力不够。\n+ 欠拟合(underfitting)：模型和真实情况还有较大偏差\n\n从坐标图像角度来看：\n\n![Bias/Variance](/bias_variance.png)\n\n从数据角度来看：\n\n| 数据              | 1                            | 2                                                | 3                                            | 4                                            |\n| ----------------- | ---------------------------- | ------------------------------------------------ | -------------------------------------------- | -------------------------------------------- |\n| 测试集错误率      | 1%                           | 15%                                              | 15%                                          | 0.5%                                         |\n| 验证集错误率      | 11%                          | 16%                                              | 30%                                          | 1%                                           |\n| 存在的问题        | 验证集和测试集错误率相差很大 | 验证集和测试集错误率相差不大，但是错误率都比较高 | 验证集和测试集错误率相差大，同时错误率比较高 | 验证集和测试集错误率相差不大，错误率都比较低 |\n| Bias/Variance分析 | high variance (overfitting)  | high bias (underfitting)                         | high bias & high variance                    | low bias & low variance                      |\n\n同时，我们将最优误差(optimal error)也称为贝叶斯误差(Bayes error)，一般取$\\approx 0$。\n\n#### 3. Basic Recipe for ML\n\n![Basic Recipe for ML](/basic_recipe.png)\n\n对于以前的Bias-variance trade-off（偏差方差均衡），则是由于过去无法控制单个Bias或是variance，使得只减少偏差或方差而不影响到另外一方。而在大数据时代不需要去考虑均衡问题。\n\n\n\n### 1-2 Regularizing your NN\n\n本section主要讲述正则化的原理与相关方法。正则化是为了解决过大的方差而提出的。主要思想就是引入一个正则项防止模型过于复杂，导致过拟合。\n\n#### 1. Regularization & Why？\n\n1. 对Logistic Regression的正则化\n    $$\n    \\begin{gathered}\n    \\min\\ J(w,b)\\qquad w\\in\\mathbb{R}^{n_x},b\\in\\mathbb{R}\\\\\n    J(w,b)=\\frac 1m\\sum_{i=1}^m\\mathscr{L}(\\hat y^{(i)},y^{(i)})+\\boldsymbol{\\frac{\\lambda}{2m}||w||_2^2}\\underbrace{+\\frac{\\lambda}{2m}b^2}_{\\text{omit}}\n    \\end{gathered}\n    $$\n    注意加粗项 $\\frac{\\lambda}{2m}||w||_2^2$ 即为我们引入的正则项，其中$\\lambda$被称为正则因子，是一个超参数。上式中我们采用的是L2 正则化（L2范数），下面介绍两种不同的范数可以替代上述损失函数$J(w,b)$中的范数。\n\n    + L2正则化（L2范数）：$||w||_2^2=\\sum_{j=1}^{n_x}w_j^2=\\mathbf{w}^T\\mathbf{w}$\n    + L1正则化（L1范数）：$||w||_1=\\sum_{j=1}^{n_x}|w|$\n\n2. 对于神经网络的正则化\n   \n    + 损失代价函数\n    \n    $$\n    J\\left(w^{[1]}, b^{[1]}, \\ldots, w^{[L]}, b^{[L]}\\right)=\\frac{1}{m} \\sum_{i=1}^{m} L\\left(\\hat{y}^{(i)}, y^{(i)}\\right)+\\frac{\\lambda}{2 m} \\sum_{l=1}^{L}\\left\\|w^{[l]}\\right\\|_{F}^{2}\n    $$\n    这里将范数项取Frobenius范数，又$w$的大小为 $\\left(n^{[l-1]}, n^{[l]}\\right)$，故\n    $$\n     \\left\\|w^{[l]}\\right\\|_{F}^{2}=\\sum_{i=1}^{n^{[l-1]}} \\sum_{j=1}^{n [l]}\\left(w_{i j}^{[l]}\\right)^{2} \n    $$\n    + 反向传播中权重衰减为\n    \n    $$\n    \\left\\{\\begin{array}{l}dw^{[l]}=\\mathtt{(from\\_back\\_prop.)}+\\boldsymbol{\\frac{\\lambda}{m}w^{[l]}}\\\\\n    w^{[l]}:=w^{[l]}-\\alpha dw^{[l]}\n    \\end{array}\\right.\n    $$\n    将两个式子合并起来，得到权重衰减(weight-decay)为\n    $$\n    w^{[l]}:=w^{[l]}-\\alpha \\mathtt{(from\\_back\\_prop.)}-\\alpha{\\frac{\\lambda}{m}w^{[l]}}\\\n    $$\n    \n3. 为什么正则化能防止过拟合？\n    $$\n    J\\left(w^{[1]}, b^{[1]}, \\ldots, w^{[L]}, b^{[L]}\\right)=\\frac{1}{m} \\sum_{i=1}^{m} L\\left(\\hat{y}^{(i)}, y^{(i)}\\right)+\\frac{\\lambda}{2 m} \\sum_{l=1}^{L}\\left\\|w^{[l]}\\right\\|_{F}^{2}\n    $$\n\n    + 当$\\lambda\\to \\infty$时，权重$w^{[l]}\\to 0$，此时每个神经元都很小，则隐层是无用的，也就退化为了单层的Logistic Regression。\n\n    + 用tanh函数来解释的话，\n\n        ![tanh](/tanh.png)\n\n        当$\\lambda\\nearrow$，则权重$w^{[l]}\\searrow$，又$z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$，当$\\lambda$相当大时，$w^{[l]}$相当小，此时用到了tanh的线性段，即$a^{[l]}=g^{[l]}(z^{[l]})$是近乎线性的。当每一层都近乎线性时，整个神经网络都是线性的也就不存在过拟合一说了。\n\n    \n\n     \n\n#### 2. Dropout Regularization\n\n1. Dropout的概念与操作\n\n    + 概念![dropout](/drop-out.jpg)\n\n        dropout（随机失活）是在神经网络的隐藏层为每个神经元结点设置一个随机消除的概率，保留下来的神经元形成一个结点较少、规模较小的网络用于训练。\n\n    + 操作——Inverted dropout\n\n        假设我们在第3层应用dropout，并将0.2的神经元抛弃，即`keep.prob<0.8`\n\n        ```python\n        keep.prob = 0.8\t# 保留率为0.8\n        d3 = np.random.rand(a3, shape[0], a3.shape[1]) < keep.prob\n        # 0.8的概率被保留，0.2的概率被dropout，其中np.random.rand表示0-1分布\n        a3 = np.multiply(a3, d3)\t# 实现a3和d3的相乘\n        a3 /= keep.prob\t\t\t\t# 恢复期望值，确保a3的期望值不变\n        ```\n\n    + 注意：\n\n        + 每次应当dropout不同的元素\n        + 不要在test期间进行dropout，这对模型的优化无意义，反而会增加噪声。\n\n2. Dropout的解释\n\n    + 解释1：就像在更小的NN上训练，⽤更⼩的NN好像具有Regularization的作用。\n    + 解释2：由于dropout的存在，神经网络不能依赖于任何单独一个特征，所以会将权重分散开来，因此，通过传播过程，dropout 将产生和 L2 正则化相同的shrink weights(收缩权重)的效果。\n    + 注意：\n        + 对于不同的层，设置的`keep.prob`也可以不同。当你担心某一层比其他层更有可能过拟合了，那么你可以对那层设置一个更小的`keep.prob`值。\n        + 由于图像网络很庞大，故在CV领域使用较多\n        + dropout由于随机抛弃一些神经元，不能采用画图的方式来判定$J$，也无法确保无法确保成本函数单调递减。\n\n#### 3. Other Regularization methods\n\n1. Data argument（数据量的扩大）\n\n    + flipping（翻折）\n    + random crop（随机裁剪），但可能导致关键部分被裁剪\n    + random rotations（随机旋转）\n    + distortion（扭曲）\n\n2. Early Stopping\n\n    可以采用Early Stopping来替代L2正则化\n\n    训练集和验证集进行梯度下降时的成本变化曲线画在同一个坐标轴内，当训练集误差降低但验证集误差升高，两者开始发生较大偏差时及时停止迭代，并返回具有最小验证集误差的连接权和阈值，以避免过拟合。这种方法的缺点是无法同时达成偏差和方差的最优。\n\n    ![early_stop](/early_stop.png)\n\n\n\n### 1-3 Setting up your optimization problem\n\n#### 1. Normalizing inputs\n\n1. Normalizing inputs（标准化输入）的方法\n\n    【S1】 Subtract mean（将数据移到原点位置）\n    $$\n    \\begin{gathered}\n    \\mu=\\frac 1m\\sum_{i=1}^mx^{(i)}\\\\ \n    x:=x-\\mu\n    \\end{gathered}\n    $$\n    【S2】Normalize variance（⽅差标准化）\n    $$\n    \\begin{gathered}\n    \\sigma^2=\\frac 1m \\sum_{i=1}^{m}x^{(i)2}\\\\ \n    x/=\\sigma\\\\\n    x:=\\frac{x-\\mu}{\\sigma}\n    \\end{gathered}\n    $$\n    注意：请**使用相同的$\\mu,\\sigma^2$来标准化测试集**。\n\n2. 为何需要Normalizing inputs？\n\n    在不使用归一化的代价函数中，如果我们设置一个较小的学习率，那么很可能我们需要很多次迭代才能到达代价函数全局最优解；如果使用了归一化，那么无论从哪个位置开始迭代，我们都能以相对很少的迭代次数找到全局最优解，也可以选择更大的步长。\n\n    ![Normalizing inputs](/normalizing_inputs.jpg)\n\n    \n\n#### 2. Vanishing/Exploding gradients\n\n![Vanishing/Exploding gradients](/gradient.jpg)\n\n1. Vanishing/Exploding gradients\n\n    + 假设$g(z)=z$，$b^{[l]}=0$，则上述网络输出为$\\hat y=w^{[L]}w^{[L-1]}\\cdots w^{[2]}w^{[1]}x$\n        + 若$w^{[l]}=\\begin{bmatrix}1.5& 0\\\\ 0& 1.5\\end{bmatrix}$，则$\\hat y=w^{[L]}\\begin{bmatrix}1.5& 0\\\\ 0& 1.5\\end{bmatrix}^{L-1}x\\to 1.5^{L-1}x$，则发生了Exploding gradients\n        + 若$w^{[l]}=\\begin{bmatrix}0.5& 0\\\\ 0& 0.5\\end{bmatrix}$，则$\\hat y=w^{[L]}\\begin{bmatrix}0.5& 0\\\\ 0& 0.5\\end{bmatrix}^{L-1}x\\to 0.5^{L-1}x$，则发生了Vanishing gradients\n\n    + 在梯度函数上出现的以指数级递增或者递减的情况分别称为**梯度爆炸(Exploding gradients)**或者**梯度消失(Vanishin gradients**。\n    + 更一般的来说\n\t\t$$\n\t\t\\left\\{\\begin{array}{l}w^{[l]} >\\mathbf{I}\\\\w^{[l]}<\\mathbf{I} \\end{array} \\right.\\xrightarrow{\\text{很深}} \\begin{array}{l}\\text{exploding}\\\\\\text{decrease exponatially}\\end{array}\n\t\t$$\n    + 所以需要小心谨慎地取权重的初值。\n\n1. Weight Initialization for Deep network\n\n    ![Weight Initialization](/weight_initialize.png)\n\n    + 当输入的数量 $n$ 较大时，我们希望每个 $w_i$ 的值都小一些，这样它们的和得到的 $z$ 也较小。为了得到较小的 $w_i$，我们设置 $Var(w_i)=\\frac{2}{n}$，即\n        $$\n        w^{[L]}=\\mathtt{np.random.randn(shape)}*\\mathtt{np.sqrt}\\left(\\frac{2}{n^{L-1}}\\right)\n        $$\n        这样，激活函数ReLU的输入 $x $近似设置成均值为 $0$，标准方差为 $1$，神经元输出 $z$ 的方差就正则化到 $1$ 了。虽然没有解决梯度消失和爆炸的问题，但其在一定程度上确实减缓了梯度消失和爆炸的速度。\n\n    + 对于其他的activation function也有类似的初始化方式：\n\n        + tanh：$\\sqrt{\\frac{1}{n^{[l-1]}}}$，这也被称为Xavier initialization\n        + 另外有$\\sqrt{\\frac2{n^{[l-1]}+n^{[l]}}}$\n\n\n\n#### 4. Gradient Checking\n\n1. 梯度数值的逼近\n\n    我们使用双侧差值来求解梯度，即倒数的定义。\n    $$\n    f'(\\theta)=\\lim_{\\varepsilon\\to 0}\\frac{f(\\theta+\\varepsilon)-f(\\theta-\\varepsilon)}{2\\varepsilon}\n    $$\n\n2. Gradient Checking的实现\n\n    + 将$W^{[1]},b^{[1]},\\cdots, W^{[L]},b^{[L]}$首尾连接，成为一个大的向量$\\theta$。\n        $$\n        J(W^{[1]},b^{[1]},\\cdots, W^{[L]},b^{[L]})=J(\\theta)\n        $$\n\n    + 将$dW^{[1]},db^{[1]},\\cdots, dW^{[L]},db^{[L]}$首尾连接，成为一个大的向量$d\\theta$。它与$\\theta$是同型的。\n\n    + for each $i$:\n        $$\n        \\begin{aligned}\n        d\\theta_\\text{approx}[i]=& \\frac{J(\\theta_1,\\theta_2,\\cdots,\\theta_i+\\varepsilon,\\cdots)-f(\\theta_1,\\theta_2,\\cdots,\\theta_i-\\varepsilon,\\cdots)}{2\\varepsilon}\\\\\n        \\approx &d\\theta[i]=\\frac{\\partial J}{\\partial \\theta_i}\n        \\end{aligned}\n        $$\n        \n    + 用梯度检验值\n        $$\n        \\frac{||d\\theta_\\text{approx} -d\\theta ||_2}{||d\\theta_\\text{approx} ||_2+||d\\theta ||_2}\\triangleq(*)\n        $$\n    \n    + 对于$\\varepsilon=10^{-7}$\n    \n        - 如果`(*)`小于$10^{-7}$ 则一般没有问题\n        - 如果`(*)`为 $10^{-5}$的量级，则可以考虑一下是否出现了bug\n        - 如果`(*)`大于$ 10^{-3}$ 的量级，则大概率存在 bug\n    \n3. 注意：\n\n    + Don't use in training. Only to **debug**.\n    + If algorithm fails grad check, look at components to identify bug.（即确定哪个$d\\theta_\\text{approx}$与$d\\theta$相距较远）\n    + Remember regularization.\n    + Doesn't use with dropout, make sure`keep.prob = 1.0`.\n    + Run at random initialization, perhaps again after some training.\n## Week 2\n\n### Optimization algorithms\n\n#### 1. Mini-batch gradient descent\n\nbatch 梯度下降法（批梯度下降法）是最常用的梯度下降形式，即同时处理整个训练集。其在更新参数时使用所有的样本来进行更新。\n\n对整个训练集进行梯度下降法的时候，我们必须处理整个训练数据集，然后才能进行一步梯度下降，即每一步梯度下降法需要对整个训练集进行一次处理，如果训练数据集很大的时候，处理速度就会比较慢。\n\n但是如果每次处理训练数据的一部分即进行梯度下降法，则我们的算法速度会执行的更快。而处理的这些一小部分训练子集即称为 mini-batch。\n\n1. vectorization allows you to efficiently compute on $m$ examples\n\n    + $x^{(1)}$：第$i$个example\n    + $z^{[l]}$：第$l$层layer\n    + $X^{\\{t\\}},Y^{\\{t\\}}$：第$t$个mini-batch\n\n    举个栗子：数据量$m=5,000,000$，要将其划分成每份1000大小的mini-batch，可以描述为\n\n    ![mini-batch](/mini-batch.png)\n\n2. Mini-batch gradient descent\n\n    ![mini-batch gradient descent](/mini-batch2.png)\n\n    从上述mini-batch gradient descent中可以看到，对于5,000,000的训练集我们将其分为5000个mini-batch，每个mini-batch有1000个数据。在红色大括号围起来的部分被称为一个epoch，只对mini-batch做一次梯度下降，并更新参数和代价函数。显然对整个训练集做一次梯度下降，需要的时间显然比一次epoch的时间来的多，这也就是我们引入mini-batch的原因。\n\n3. size of mini-batch\n\n    + 首先思考使用mini-batch是否会对梯度下降带来影响呢？很显然，mini-batch相较于对整个训练集训练其实是一个随机的抽取，必定会带来代价函数$J$的震荡，但鉴于时间代价，使用mini-batch还是值得的。对整个训练集梯度下降和使用mini-batch梯度下降的区别可以用下图表现。\n        ![compare](/compare_batch.jpg)\n    + 下面分析选取不同mini-batch尺寸对梯度下降的影响：\n        + 若mini-batch的大小为$m$，实际上就是对整个训练集进行梯度下降，此时$(X^{\\{t\\}},Y^{\\{t\\}})=(X,Y)$，这样每次迭代显然会消耗大量的时间。\n        + 若mini-batch的大小为1，这就退化为了随机梯度下降，此时每个样本都是一个mini-batch：$(X^{\\{t\\}},Y^{\\{t\\}})=(X^{(t)} ,Y^{(t)})$，这就失去了Vectorization带来的加速。\n    + 所以在实际使用中，我们一般选取一个介于1和$m$的mini-batch，此时能够达到最快的学习速度，也可以使用到vectorization带来的加速。\n        + 对于较小的训练集（例如$m\\leq 2000$），可以只用batch gradient descent，即对于整个训练集梯度下降。\n        + 典型的mini-batch尺寸有64，128，256，512，1024……，注意到这些值都是2的整数倍，这是为了和计算机的存储方式相匹配。\n        + 最后mini-batch的大小要适应于CPU、GPU的容量。\n\n#### 2. Exponentially weighed(moving) averages\n\nExponentially weighed(moving) averages是帮助我们提高mini-batch梯度下降效率方法的预备知识。\n\nExponentially weighed(moving) averages（指数加权平均）的公式可以表述为\n$$\nV_t=\\beta V_{t-1}+(1-\\beta)\\theta_t\n$$\n其中，$V_t$是拟合值，$\\theta_t$是真实值。\n\n首先通过一个例子来了解什么是Exponentially weighed averages，给定一个时间序列给例如伦敦一年每天的气温值，图中蓝色的点代表真实数据。\n![Exponentially weighed average](Exponentially weighed average.jpg)\n\n我们看到蓝色的点非常杂乱，为了使得曲线变得更平滑，使用上公式进行Exponentially weighed average，红绿黄线都是我们根据上述公式求得拟合曲线。我们可以大致近似$V_t$是根据$\\frac 1{1-\\beta}$天温度平均出来的值。\n\n+ 当$\\beta=0.9$时，我们可以得到红色曲线，近似于根据最近10天天气得到的\n+ 当$\\beta=0.98$时，我们可以得到绿色曲线，近似于根据最近50天天气得到的。我们可以发现相较于红线，它更加平滑，但是也有些右移的迹象。\n+ 当$\\beta=0.5$时，我们可以得到黄色曲线，近似于根据最近2天天气得到的。可见相较于红线他的噪声非常严重。\n\n1. 理解Exponentially weighed averages\n\n    + 将上式展开\n        $$\n        \\begin{aligned}\n        V_{100}=&0.1\\theta_{100}+0.9(0.1\\theta_{99}+0.9(0.1\\theta_{98}+\\cdots))\\\\\n        =& 0.1\\theta_{100}+0.1\\times 0.9^1\\theta_{99}+0.1\\times 0.9^2\\theta_{98}+\\cdots+ 0.1\\times 0.9^{99}\\theta_1\n        \\end{aligned}\n        $$\n\n    + 这实际上就是对每天的气温乘指数衰减项(exponetially decay)，再将其相加的过程。\n\n    + 根据函数极限的定理：\n        $$\n        \\lim_{\\beta\\to 0}(1-\\beta)^{\\frac 1\\beta}=\\frac 1e\n        $$\n        实际上就是经过$\\frac{1}{1-\\beta}$的时间，影响将下降到$\\frac 1e$。\n\n2. Exponentially weighed averages的实现\n\n   考虑到这是一个迭代的过程，我们可以通过以下方式进行迭代：\n   \n   $V_\\theta=0$\n   Repeat {\n   　　Get next $\\theta_t$\n   　　$V_\\theta:=\\beta V_\\theta+(1-\\beta)\\theta_t$\n   }\n   \n   指数加权平均数公式的好处之一在于它只需要一行代码，且占用极少内存，因此**效率极高，且节省成本**。但是它也会带来一定的问题，比如在前期，指数加权平均值与正常值的差距会非常大，下面我们就来讨论如何进行修正。\n   \n3. bias correction（误差修正）\n   \n   注意到在前期计算中由于我们初始化$V_\\theta$为0，会带来较大的误差。我们需要在前期减小前期数据的权重。于是，我们对上述公式进行修正\n   $$\n   V_t=\\frac{V_t}{1-\\beta^t}\n   $$\n   随着$t$的增大，$\\beta$的$t$次方趋近于 0。因此当 t 很大的时候，偏差修正几乎没有作用，但是在前期学习可以帮助更好的预测数据。但是如果不是很关心前期值的误差的话，也可以不进行偏差修正，因为毕竟会增加一定量的计算量。\n   \n    \n\n\n\n#### 3. Two ways to reduce oscillations\n\n1. Gradient descent with momentum\n\n     在进行梯度下降时，我们需要设置learning rate $\\alpha$，过大的学习率会导致过头(over shooting)，Gradient descent with momentum（动量梯度下降法）是解决这一问题的方法之一。\n\n    + 算法\n\n        $V_{dW}=0,V_{db}=0$\n        On iteration t:\n        　　Compute $dW,db$ on current mini batch\n        　　$V_{dW}=\\beta V_{dW}+(1-\\beta)dW$\n        　　$V_{db}=\\beta V_{db}+(1-\\beta)db$\n        　　$W:=W-\\alpha V_{dW}$\n        　　$b:=b-\\alpha V_{db}$\n\n    + 注意到在上述式子中，我们对反向传播的参数$dW,db$进行了指数加权平均，这正是减小梯度下降噪声的好方法。\n\n    + 至于为什么叫Gradient descent with momentum，我们可以将$\\beta$看作是摩擦(friction)，$V$看作速率(velocity)，$dW,db$看作加速度(acceleration)。由于摩擦的存在，速度不可能持续增大也就保证了反向传播时步子不会迈的太大。\n\n    + 进行一般的梯度下降将会得到图中的蓝色曲线，由于存在上下波动，减缓了梯度下降的速度，因此只能使用一个较小的学习率进行迭代。如果用较大的学习率，结果可能会像紫色曲线一样偏离函数的范围。而使用Gradient descent with momentum时，通过累加过去的梯度值来减少抵达最小值路径上的波动，加速了收敛，因此在横轴方向下降得更快，从而得到图中红色的曲线。当前后梯度方向一致时，动量梯度下降能够加速学习；而前后梯度方向不一致时，动量梯度下降能够抑制震荡。\n        ![momentum](momentum.png)\n\n    + 注意到上述式子中，$(1-\\beta)$项一般是可以忽略的。同时$\\alpha.\\beta$是两个超参数，一般我们取$\\beta=0.9$，这表明经过10次mini-batch就可以忽略前期bias的影响，不再需要bias correction。\n\n2. RMSprop （root mean square prop)\n\n    RMSProp（Root Mean Square Propagation，均方根传播）算法是在对梯度进行指数加权平均的基础上，引入平方和平方根。\n\n    + 算法\n        $S_{dW}=0,S_{db}=0$\n        On iteration t:\n        　　Compute $dW,db$ on current mini batch\n        　　$S_{dW}=\\beta_2 S_{dW}+(1-\\beta_2)dW^2$\n        　　$S_{db}=\\beta_2 S_{db}+(1-\\beta_2)db^2$\n        　　$W:=W-\\alpha \\frac{S_{dW}}{\\sqrt{S_{dW}}+\\varepsilon}$\n        　　$b:=b-\\alpha \\frac{S_{db}}{\\sqrt{S_{db}}+\\varepsilon}$\n    + 其中，$\\varepsilon$是一个较小的数字(例如$10^{-8}$)，这主要是为了防止除以0的情况。$\\beta_2$是一个超参数，下标2是为了和momentum进行区分。\n    + RMSProp 有助于减少抵达最小值路径上的摆动，并允许使用一个更大的学习率$\\alpha$，从而加快算法学习速度。\n\n\n\n#### 4. Adam optimization algorithm\n\nAdam 优化算法（Adaptive Moment Estimation，自适应矩估计）基本上就是将 Momentum 和 RMSProp 算法结合在一起，通常有超越二者单独时的效果。\n\n+ 算法\n\n    $V_{dW}=0,V_{db}=0,S_{dW}=0,S_{db}=0$\n\n    On iteration t:\n    　　Compute $dW,db$ on current mini batch\n    $$\n    \\begin{aligned}\n    V_{dW}=&\\beta V_{dW}+(1-\\beta_1)dW\\\\ \n    V_{db}=&\\beta V_{db}+(1-\\beta_1)db\\\\ \n    S_{dW}=&\\beta_2 S_{dW}+(1-\\beta_2)dW^2\\\\ \n    S_{db}=&\\beta_2 S_{db}+(1-\\beta_2)db^2\n    \\end{aligned}\n    $$\n    　　进行bias correction:\n    $$\n    \\begin{aligned}\n    V_{dW}^\\text{corrected}=&\\frac{V_{dW}}{1-\\beta_1^t}\\\\\n    V_{db}^\\text{corrected}=&\\frac{V_{db}}{1-\\beta_1^t}\\\\\n    S_{dW}^\\text{corrected}=&\\frac{S_{dW}}{1-\\beta_2^t}\\\\\n    S_{db}^\\text{corrected}=&\\frac{S_{db}}{1-\\beta_2^t}\\\\\n    \\end{aligned}\n    $$\n    　　更新$W,b$\n    $$\n    \\begin{aligned}\n    W:=&W-\\alpha \\frac{S_{dW}^\\text{corrected}}{\\sqrt{S_{dW}^\\text{corrected}}+\\varepsilon}\\\\\n    b:=&b-\\alpha \\frac{S_{db}^\\text{corrected}}{\\sqrt{S_{db}^\\text{corrected}}+\\varepsilon}\n    \\end{aligned}\n    $$\n\n+ 超参数：\n\n    + $\\alpha$： 需要调参\n    + $\\beta_1$：momentum的参数，一般取为0.9\n    + $\\beta_2$：RMSprop的参数，一般取为0.999\n    + $\\varepsilon$：一般取为$10^{-8}$\n\n\n\n#### 5. Learning rate decay\n\n如果设置一个固定的学习率$\\alpha$，在最小值点附近，由于不同的 batch 中存在一定的噪声，因此不会精确收敛，而是始终在最小值周围一个较大的范围内波动。而如果随着时间慢慢减少学习率$\\alpha$的大小，在初期 $\\alpha$较大时，下降的步长较大，能以较快的速度进行梯度下降；而后期逐步减小 $\\alpha$ 的值，即减小步长，有助于算法的收敛，更容易接近最优解。\n\n常用的Learning rate decay方法有：\n\n+ $\\alpha=\\frac{1}{1+\\mathtt{decay\\_rate}*\\mathtt{epoch\\_num}}\\alpha_0$\n+ exponetially decay: $\\alpha=0.95^\\mathtt{epoch\\_num}\\alpha_0$\n+ $\\alpha=\\frac{k}{\\sqrt{\\mathtt{epoch\\_num}}}\\alpha_0$或$\\alpha=\\frac{k}{\\sqrt{t}}\\alpha_0$\n+ discrete staircase：![discrete staircase](/discrete_stair.png)\n+ manual decay\n\n\n\n#### 6. Local optima\n\n在低维度的情形下，我们可能会想象到一个Cost function存在一些**局部最小值**点，在初始化参数的时候，如果初始值选取的不得当，会存在陷入局部最优点的可能性。\n\n但是，如果我们建立一个神经网络，通常梯度为零的点，是**鞍点**(Saddle point)，即位于$\\bigcap$位置的点。在鞍点附近会有一段plateaus（停滞区），这段区域的梯度一直为0。因此当我们建立一个神经网络时，通常梯度为零的点是的鞍点，而非局部最小值。减少损失的难度也来自误差曲面中的鞍点，而不是局部最低点。因为在一个具有高维度空间的成本函数中，如果梯度为 0，那么在每个方向，成本函数或是凸函数，或是凹函数。而所有维度均需要是凹函数的概率极小，因此在低维度的局部最优点的情况并不适用于高维度。\n\n![local optima](/plateau.jpg)\n\n结论：\n\n+ Unlikely to get stuck in a bad local optima. 在存在大量参数，成本函数在高维空间时，可以困在很差的局部最优点是不太可能的。\n+ plateaus会使得学习变慢，这时momentum、RMSprop、Adam就能帮助走出plateaus。\n\n\n\n## Week 3\n\n### 3-1 Hyperparameter tuning\n\n#### 1. Tuning process\n\n在上面的讨论中给出了许多的超参数，超参数的调试也是有技巧的，比如：\n\n+ 超参数的重要性（重要程度从红→黄→绿→蓝）\n\n    <img src=\"/hyperparameter_important.png\" alt=\"importance\" style=\"zoom:50%;\" />\n\n+ Try random values： Don't use grid\n\n    ![random_value](/hyperparameter_random_value.jpg)\n\n    使用打点的方式选取的值太少了，对于上述左图我们只分别尝试了5个$\\alpha,\\varepsilon$\n\n+ Coarse to fine（区域定位的采样⽅式）\n\n    <img src=\"/coarse.jpg\" alt=\"coarse\" style=\"zoom: 50%;\" />\n\n    聚焦效果不错的点组成的小区域，在其中更密集地取值，以此类推；\n\n    \n\n\n\n#### 2. Using an appropriate scale to pick parameters\n\n1. logarithmic scale(对数尺度)\n\n    + $\\alpha=0.0001\\sim 1$\n\n        ![logarithmic scale](logarithmic scale.png)\n\n    + Python 实现：\n\n        ```python\n        r = -4 * np.random.rand()\t# r in U[-4,0]\n        learning_rate = 10 ** r\t\t# 取alpha为 10^r\n        ```\n\n2. 在exponentially weighted averages中，我们选取$\\beta=0.9\\sim 0.999$。显然均匀采点是不合适的。我们可以使$1-\\beta=0.1\\sim 0.001$，这样就可以在对数坐标下进行采点。即\n    $$\n    1-\\beta=10^r\\Rightarrow \\beta=1-10^r\n    $$\n\n####  3. Hyperparameters tuning in practice\n\n![Hyperparameters tuning in practice](/hyperparameter_tuning.png)\n\n- Panda（熊猫方式）：在在线广告设置或者在计算机视觉应用领域有大量的数据，但受计算能力所限，同时试验大量模型比较困难。可以采用这种方式：试验一个或一小批模型，初始化，试着让其工作运转，观察它的表现，不断调整参数；\n- Caviar（鱼子酱方式）：拥有足够的计算机去平行试验很多模型，尝试很多不同的超参数，选取效果最好的模型；\n\n### 3-2 Batch Normalization\n\n#### 1. Normalizing activations in a network\n\n为了使得网络easier 、robust 、bigger range，我们需要Normalizing。常用的方式是将隐藏层的经过激活函数前的 $z^{[l]}$进行归一化。\n\n+ 算法\n\n    Given Some intermediate values in NN: $z^{(1)},\\cdots,z^{(m)}$\n    $$\n    \\begin{gathered}\n    \t\\mu=\\frac 1m\\sum_iz^{(i)}\\\\ \n    \t\\sigma^2=\\frac 1m\\sum_i(z^{(i)}-\\mu)^2\\\\ \n    \tz_\\text{norm}^{(i)}=\\frac{z^{(i)}-\\mu}{\\sqrt{\\sigma^2+\\varepsilon}}\\\\ \n    \t\\tilde z^{(i)}=\\gamma z_\\text{norm}^{(i)}+\\beta\n    \\end{gathered}\n    $$\n    　　use $\\tilde z^{i}$ instead of $z^{(i)}$\n\n+ 一些说明：\n\n    + 此处$z^{[l](i)}$简记为$z^{(i)}$\n    + 使用$\\frac{z^{(i)}-\\mu}{\\sqrt{\\sigma^2+\\varepsilon}}$归一化后所有的$z^{(i)}$均服从$N(0,1)$，但是不同的高斯分布也许更有意义，所以使用$\\gamma,\\beta$，我们让$\\tilde z^{(i)}$服从$N(\\gamma,\\beta)$。其中，$\\gamma,\\beta$都是可以学习的参数。设置$\\gamma$ 和 $\\beta$的原因是，如果各隐藏层的输入均值在靠近 0 的区域，即处于激活函数的线性区域，不利于训练非线性神经网络，从而得到效果较差的模型。因此，需要用$\\gamma$ 和 $\\beta$对标准化后的结果做进一步处理。\n\n\n\n\n\n#### 2. Fitting Batch Norm into a NN\n\n1. 将BN应用于NN中\n\n    ![BN in NN](/BN_NN.png)\n\n    Batch Norm在tensorflow中可以用以下代码实现：\n\n    ```python\n    tf.nn.batch-normalization\n    ```\n\n2. 将Batch Norm和mini-batch一起使用\n\n    ![Batch Norm mini-batch](/BN_mini-batch.png)\n\n    其中的参数有$W^{[l]},\\beta^{[l]},\\gamma^{[l]}$，注意$b^{[l]}$在进行高斯分布的标准化时被减均值减去了，因此在使用BN后，$b^{[l]}$不再有用。因此，\n    $$\n    \\begin{aligned}\n    Z^{[l]}=&W^{[l]}a^{[l-1]}\\\\ \n    \\tilde Z^{[l]}=&\\gamma^{[l]}_{n^{[l]}\\times 1}Z_\\text{norm}^{[l]}+\\beta^{[l]}_{n^{[l]}\\times 1}\n    \\end{aligned}\n    $$\n\n3. 使用梯度下降：\n\n    for $t=1, \\cdots,\\mathtt{mini\\_batch\\_num}$:\n    　　Compute forward prop on $X^{\\{t\\}}$:\n    　　　　In each hidden layer, use BN to replace $ Z^{[l]}$ with $\\tilde Z^{[l]}$\n    　　Use Backpop to compute $dW^{[l]},d\\beta^{[l]},d\\gamma^{[l]}$\n    　　Update parameters: \n    $$\n    \\begin{gathered}\n    W^{[l]}=W^{[l]}-\\alpha dW^{[l]}\\\\ \n    \\beta^{[l]}=\\beta^{[l]}-\\alpha d\\beta^{[l]}\\\\ \n    \\gamma^{[l]}=\\gamma^{[l]}-\\alpha d\\gamma^{[l]}\n    \\end{gathered}\n    $$\n    除了传统的梯度下降算法之外，还可以使用之前学过的动量梯度下降、RMSProp 或者 Adam 等优化算法。\n\n#### 3.  Why does BN works?\n\n1. learning on shifting input distribution\n    <img src=\"/BN_why.png\" alt=\"BN_why\" style=\"zoom:50%;\" />\n\n    针对后续hidden layer $l$ 来说其输入 $a_1^{[l-1]},\\cdots,a_m^{[l-1]}$ 在训练过程中是变化的,这就引入covariant shift。而BN就是消除了$a_1^{[l-1]},\\cdots,a_m^{[l-1]}$分布中协方差的影响，而保持了$z_1^{[l-1]},\\cdots,z_m^{[l-1]}$中均值$\\mu$，方差$\\sigma^2$。\n\n2. BN reduces the problem of input values changing. 即使输入的值改变了，由于 Batch Normalization 的作用，使得均值和方差保持不变，限制了在前层的参数更新对数值分布的影响程度，削弱了前层参数与后层参数之间的联系，因此后层的学习变得更容易一些。Batch Normalization 减少了各层$W$ 和 $b$之间的耦合性，让各层更加独立，从而实现自我训练学习的效果。\n\n3. BN as regularizaion\n\n    + 在每个 mini-batch 估计得出的均值和方差会有一些噪声，最终的$z^{(i)}$也有一定噪声。这也就变相起到了一定regularization的作用。要削弱这一影响，可以使用更大的mini-batch尺寸。\n    + 不要将 Batch Normalization 作为正则化的手段，而是当作加速学习的方式。正则化只是一种非期望的副作用，Batch Normalization 解决的还是反向传播过程中的梯度问题（梯度消失和爆炸）。\n\n#### 4. BN at test time\n\n$\\mu,\\sigma^2$对于单独的样本是没有意义的。理论上，我们可以将所有训练集放入最终的神经网络模型中，然后将每个隐藏层计算得到的$\\mu^{[l]},\\sigma^{2[l]}$直接作为测试过程的$\\mu$ 和 $\\sigma^2$来使用。但是，实际应用中一般不使用这种方法，而是使用之前学习过的exponentially weighted average在mini-batch中估计获得。\n\n<img src=\"BN.png\" alt=\"BN_test\" style=\"zoom:60%;\" />\n\n### 3-3 Multi-class classification\n\n#### 1. Softmax Regression\n\n对于一个四分类的网络，有$C=\\text{number of classes}=4\\quad(0,1,2,3)$\n\n![softmax](/softmax.png)\n\n对于Softmax回归模型的输出层，即第$L$层，有：\n$$\nz^{[l]}=W^{[L]}z^{[L-1]}+b^{[L]}\n$$\nSoftmax函数是一个vector对vector的激活函数，对于第L层第i个元素：\n$$\na_i^{[L]}=\\frac{e^{z_i^{[L]}}}{\\sum_{i=1}^{C}e^{z_i^{[L]}}}\\quad\\left(\\sum_{i=1}^{C}a_i^{[L]}=1\\right)\n$$\n\n\n#### 2. Turning a Softmax Classifier\n\n1. Softmax & Hardmax\n    + Softmax：$\\begin{bmatrix}0.842\\\\ 0.042\\\\ 0.002\\\\ 0.114\\end{bmatrix}$\n    + Hardmax:$\\begin{bmatrix}1\\\\ 0\\\\ 0\\\\ 0\\end{bmatrix}$\n    + Softmax regression generalizes logistic regression to $C$ classes. 当$C=2$就退化成了Logictic Regression\n    \n2. Loss function & Cost function\n\n   + Loss function：我们用最大似然来定义Loss function，其实也就是信息量。\n       $$\n       \\mathscr{L}(\\hat y,y)=-\\sum_{j=1}^Cy_j\\log\\hat y_j\n       $$\n       若$i$为真实情况，则$y_j=0(j\\neq i)$，有\n       $$\n       \\mathscr{L}(\\hat y, y)=-y_i\\log \\hat y_i=-\\log\\hat y\n       $$\n   \n   + Cost function:\n       $$\n       J(w^{[1]},b^{[1]},\\cdots)=\\frac 1m\\sum_{i=1}^m\\mathscr{L}(\\hat y^{(i)},y^{(i)})\n       $$\n   \n3. Gradient descent with Softmax\n   \n   在反向传播时：\n   $$\n   dz^{[L]}=\\hat y-y\n   $$\n   \n   \n   \n   \n\n## 参考文献\n\n1. 左辰宇.深度学习（五）：正则化.http://www.cyzuo.cn/index.php/archives/61/\n2. 左辰宇.深度学习（六）：标准化与梯度检验.http://www.cyzuo.cn/index.php/archives/62/\n3. 左辰宇.深度学习（七）：优化算法.http://www.cyzuo.cn/index.php/archives/65/\n4. 左辰宇.深度学习（八）：Batch Normalization与Softmax 回归.http://www.cyzuo.cn/index.php/archives/67/","tags":["深度学习","机器学习"],"categories":["科研向"]},{"title":"【无线通信学习笔记（一）】路径损耗与阴影衰落","url":"/2021/04/16/Wireless-Communications-Ch-2/","content":"\n> *Wireless Communications* (Andrea Goldsmith)学习笔记。\n\n\n\n# Path Loss and Shadowing\n\n1. 主要讲述 **path loss**（路径损耗） and **shadowing**（阴影衰弱）相对于距离对接收信号功率的影响。并考虑这两方面的影响建立信道模型。\n    + **Path loss** is caused by **dissipation of the power** radiated by the transmitter as well as effects of the propagation channel. (be the same at a given transmit-receive distance)\n    + **Shadowing** is caused by **obstacles between the transmitter and receiver** that attenuate signal power through absorption, reflection, scattering, and diffraction. (When the attenuation is very strong, the signal is blocked)\n\n2. 大尺度传播效应和小尺度传播效应\n\n\t+ large-scale propagation effects: occur over relatively large distances. e.g. variations due to path loss and shadowing\n\t+ small-scale propagation effects: occurs over very short distances, **on the order of the signal wavelength**\n\n3. 开发了一些近似方法来描述信号传播的特点，而不需要借助麦克斯韦方程。最常见的近似方法是使用 **ray-tracing techniques**（射线跟踪技术）。\n\n    \n\n## Transmit and Receive Signal Models\n\n+ transmitted signal: \n    $$\n        s(t)=\\Re\\left\\{u(t)e^{2\\pi f_c t}\\right\\}=x(t)\\cos(2\\pi f_ct)-y(t)\\sin(2\\pi f_c t)\n    $$\n    其中，信号 $u(t)=x(t)+jy(t)$ 是复包络，带宽为 $B_u$,，功率为 $P_u$. 发射机发射功率为 $P(t)=\\frac{ P_u}{2}$\n    \n+ received signal:\n    $$\n        r(t)=\\Re{\\left\\{v(t)e^{j2\\pi f_c t}\\right\\}}=\\Re{\\left\\{u(t)*c(t)\\cdot e^{j2\\pi f_c t}\\right\\}}\n    $$\n    其中，$c(t)$是等效低通信道的脉冲响应。接收信号可能会存在多普勒频移(Doppler shift)$f_D=\\frac{v\\cos\\theta}{\\lambda}$.\n\n\n\n## Path Loss Models\n\n由free-space path loss出发建立最基础的模型。由于处理RCS过于复杂，在本章中都是从ray tracing的角度来建立复杂模型分析问题的，包括two-ray model, 10-ray model进而推广到一般的general ray tracing。\n\n### 路径损耗的定义\n\n+ 路径损耗（Path Loss）\n\n$$\nP_L=\\frac{P_t}{P_r}\n$$\n+ 路径增益（Path gain）\n    $$\n    P_G \\text{ dB}=-P_L \\text{ dB}\n    $$\n\n### 自由空间路径损耗\n\n+ 视距信道（LOS，line-of-sight）\n\n    + 没有障碍物\n    + 信号沿直线传播\n\n+ 接收信号\n    $$\n    r(t)=\\Re\\left\\{\\frac{\\lambda \\sqrt{G_{l}} e^{-j 2 \\pi d / \\lambda}}{4 \\pi d} u(t) e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n    其中，$\\sqrt{G_l}$是发射天线和接收天线增益的乘积。$e^{-j 2 \\pi d / \\lambda}$是距离$d$带来的相移。*功率是信号的平方。*\n\n    > 注：这里$\\sqrt{G_l}$是发射天线和接收天线的增益乘积，而非原书的field radiation(直译为场强方向图$F(\\theta,\\phi)$)，也并非方向系数$D$（在一定意义上可以认为是方向系数）。具体可以看到下面路径增益的表达式实际上就是《天线原理》中的**Friis传输方程**：\n    > $$\n    > P_R=P_i\\left(\\frac{\\lambda}{4\\pi r}\\right)^2D_iD_r\n    > $$\n    > 上式是在满足极化匹配、共轭匹配和收发最大辐射方向对准时的表达式。在天线原理书后习题中也被写作\n    > $$\n    > P_R=P_i\\left(\\frac{\\lambda}{4\\pi r}\\right)^2G_iG_r\n    > $$\n    > 显然这是在考虑天线效率情况下的Friis传输方程。注意到下面路径增益中将收发天线的增益看作是一样的也就是$G_l$。\n\n+ 路径增益\n    $$\n    \\frac {P_r}{P_t}=\\left[\\frac{\\sqrt{G_l}\\lambda}{4\\pi d}\\right]^2\n    $$\n\n    + 接收机接收功率随着收发天线之间距离$d$平方成反比。\n    + 当载波频率增加，接收功率下降。\n\n+ 自由空间路径损耗\n    $$\n    P_L\\text{ dB}=10 \\lg\\frac{P_t}{P_r}=-10\\lg\\left[\\frac{\\sqrt{G_l}\\lambda}{4\\pi d}\\right]^2\n    $$\n\n### 射线跟踪(Ray tracing)\n\n+ multipath signal components：additional copies of the transmitted signal\n+ multipath signal components相对于LOS信道的接收信号有功率衰减，延时，相移和/或频移。\n+ 射线追踪技术通过将波面表示为简单的粒子来逼近电磁波的传播。\n+ **smallest** when the receiver is many wavelengths from the nearest scatterer, and all the scatterers are large relative to a wavelength and fairly smooth. \n+ 射线跟踪不能很好的反映多径时延扩展(delay spread)\n\n\n\n### Two-Ray Model\n\n当单一地面反射主导多径效应时，采用Two-Ray Model。\n<img src=\"Two-Ray Model.png\" alt=\"Two-Ray Model\" style=\"zoom:67%;\" />\n    \n\n+ 由LOS路径的接受的直射信号和经过$x,x'$反射信号的叠加，忽略反射面衰减，有\n    $$\n        r_{2 \\text {ray }}(t)=\\Re\\left\\{\\frac{\\lambda}{4 \\pi}\\left[\\frac{\\sqrt{G_{l}} u(t) e^{-j 2 \\pi l / \\lambda}}{l}+\\frac{R \\sqrt{G_{r}} u(t-\\tau) e^{-j 2 \\pi\\left(x+x^{\\prime}\\right) / \\lambda}}{x+x^{\\prime}}\\right] e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n+ 进一步假设接收信号相对于delay spread($\\tau$)是窄带的，即$\\tau\\ll B_u^{-1}$，有$u(t)\\approx u(t-\\tau)$，有\n    $$\n        P_{r}=P_{t}\\left[\\frac{\\lambda}{4 \\pi}\\right]^{2}\\left|\\frac{\\sqrt{G_{l}}}{l}+\\frac{R \\sqrt{G_{r}} e^{-j \\Delta \\phi}}{x+x^{\\prime}}\\right|^{2}\n    $$\n   其中，$\\Delta\\phi=2\\pi (x+x'-l)/\\lambda$是接收到的两个信号的相位差。\n+ 当$d$相当大时，$x+x^{\\prime} \\approx l \\approx d, \\theta \\approx 0, G_{l} \\approx G_{r},R=-1$，有\n    $$\n        P_{r} \\approx\\left[\\frac{\\lambda \\sqrt{G_{l}}}{4 \\pi d}\\right]^{2}\\left[\\frac{4 \\pi h_{t} h_{r}}{\\lambda d}\\right]^{2} P_{t}=\\left[\\frac{\\sqrt{G_{l}} h_{t} h_{r}}{d^{2}}\\right]^{2} P_{t}\n    $$\n    \n+ 一些说明：\n    + 接收功率与$\\lambda$无关。\n    + 近距离($d<h_t$)：两路径分量正向相加，路径损耗粗略的是平坦的，接收功率近似与$\\frac {1}{d^2+h_t^2}$成正比。\n    + 远距离($h_t<d<d_c$)：两路径分量相加此消彼长，造成一系列极大极小值，接收功率近似于$d^{-4}$成正比。\n    + $d>d_c$：critical distance($d_c$)时到达了最后一个极大值。超过$d_c$后，接收功率急剧下降。$d_c$可由$\\Delta \\phi=\\pi$估计，即$d_c=\\frac{4h_th_r}{\\lambda}$。\n    + 蜂窝系统(cellular systems)中传播很少符合two-ray model。\n      \n        <img src=\"/Received Power versus Distance for Two-Ray Model.png\" alt=\"Received Power versus Distance for Two-Ray Model\" style=\"zoom:67%;\" />\n\n### Ten-Ray Model (Dielectric Canyon)\n\n当单一路径反射超过三次可以被忽略。后向反射也可以被忽略。\n\n<img src=\"Overhead View of the Ten-Ray Model.png\" alt=\"Overhead View of the Ten-Ray Model\" style=\"zoom:99%;\" />\n\n+ Ten-Ray Model下的接收信号为\n    $$\n    r_{10 \\text {ray }}(t)=\\Re\\left\\{\\frac{\\lambda}{4 \\pi}\\left[\\frac{\\sqrt{G_{l}} u(t) e^{-j 2 \\pi l / \\lambda}}{l}+\\sum_{i=1}^{9} \\frac{R_{i} \\sqrt{G_{x_{i}}} u\\left(t-\\tau_{i}\\right) e^{-j 2 \\pi x_{i} / \\lambda}}{x_{i}}\\right] e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n    \n+ 进一步假设接收信号相对于delay spread($\\tau$)是窄带的，有$u(t)\\approx u(t-\\tau)$，有Ten-Ray Model的接收功率\n    $$\n        P_{r}=P_{t}\\left[\\frac{\\lambda}{4 \\pi}\\right]^{2}\\left|\\frac{\\sqrt{G_{l}}}{l}+\\sum_{i=1}^{9} \\frac{R_{i} \\sqrt{G_{x_{i}}} e^{-j \\Delta \\phi_{i}}}{x_{i}}\\right|^{2}\n    $$\n    \n+ Ten-Ray Model的接收功率随$d^{2}$下降\n\n### General Ray Tracing(GRT)\n\n+ 对于GRT模型，建筑物参数（高度、位置和介电性质）以及发射机和接收机相对于建筑物的位置必须准确确定。\n\n+ 一般来说，由于绕射(diffraction)和散射(scattering)的损耗很大，所以在接收信号中起主导作用的十LOS信号和反射信号。\n\n+ diffraction（绕射）分量可由Fresnel knife edge diffraction model求得，接收信号为\n    $$\n    r(t)=\\Re\\left\\{L(v) \\sqrt{G_{d}} u(t-\\tau) e^{-j 2 \\pi\\left(d+d^{\\prime}\\right) / \\lambda} e^{j 2 \\pi f_{c} t}\\right\\}\n    $$\n    其中，$\\sqrt{G_d}$是天线增益，$\\tau=\\frac{\\Delta d}{c}$绕射分量相对于直射分量的时延\n\n+ scattered ray（散射）分量可有双基地雷达方程（bistatic radar equation）获得，接收信号为\n\t$$\n\tr(t)=\\Re\\left\\{u(t-\\tau) \\frac{\\lambda \\sqrt{G_{s} \\sigma} e^{-j 2 \\pi\\left(s+s^{\\prime}\\right) / \\lambda}}{(4 \\pi)^{3 / 2} s s^{\\prime}} e^{j 2 \\pi f_{c} t}\\right\\}\n\t$$\n  \n\n\t其中，$\\tau=\\frac{s+s'-l}{c}$是散射分量相对于直射分量的时延，$\\sigma$是雷达散射截面积(RCS)，$\\sqrt{G_s}$是天线增益。\n\t\n+ 结合上述各种分量的影响，假设有一个LOS路径，$N_r$个反射路径，$N_d$个绕射路径，$N_s$个散射路径，则总的接收信号为\n  $$\n  \\begin{aligned}\n  r_{\\text {total }}(t) &=\\Re\\left\\{\\left[ \\frac { \\lambda } { 4 \\pi } \\right] \\left[\\frac{\\sqrt{G_{l}} u(t) e^{j 2 \\pi l / \\lambda}}{l}+\\sum_{i=1}^{N_{r}} \\frac{R_{x_{i}} \\sqrt{G_{x_{i}}} u\\left(t-\\tau_{i}\\right) e^{-j 2 \\pi x_{i} / \\lambda}}{x_{i}}\\right.\\right.\\\\\n  &+\\sum_{j=1}^{N_{d}} L_{j}(v) \\sqrt{G_{d_{j}}} u\\left(t-\\tau_{j}\\right) e^{-j 2 \\pi\\left(d_{j}+d_{j}^{\\prime}\\right) / \\lambda} \\\\\n  &\\left.\\left.+\\sum_{k=1}^{N_{s}} \\frac{\\sqrt{G_{s_{k}} \\sigma_{k}} u\\left(t-\\tau_{k}\\right) e^{j 2 \\pi\\left(s_{k}+s_{k}^{\\prime}\\right) / \\lambda}}{s_{k} s_{k}^{\\prime}}\\right] e^{j 2 \\pi f_{c} t}\\right\\}\n  \\end{aligned}\n  $$\n  \n  如果其传播路径被建筑物或其他物体阻挡，任何一个多径分量都可能有一个额外的衰减系数。\n  \n+ local mean received power($\\bar P_r$，本地平均接收功率)：射线跟踪中所有路径的幅度平方和，可以较好地反映link quality（链路质量）。\n\n### Empirical Path Loss Model\n\n为了消除多径效应，路径损耗的经验测量通常将其接收功率测量值和相应的路径损耗在给定距离上的几个波长上求平均值。这个平均路径损耗称为距离$d$处的**本地平均衰减(LMA)**，由于自由空间的路径损耗和信号障碍物的影响，一般会随着$d$的增大而减小。\n\n+ The Okumura Model: One of the most common models for signal prediction in large urban macrocells is the Okumura model . This model is applicable over **distances of 1-100 km and frequency ranges of 150-1500 MHz.** The base station heights\n    for these measurements were **30-100 m**, the upper end of which is higher than typical base stations today\n    $$\n    P_{L}(d) \\mathrm{dB}=L\\left(f_{c}, d\\right)+A_{m u}\\left(f_{c}, d\\right)-G\\left(h_{t}\\right)-G\\left(h_{r}\\right)-G_{A R E A}\n    $$\n\n+ Hata Model: This empirical model **simplifies calculation of path loss** since it is a closed-form formula and is not based on empirical curves for the different parameters. the same range of frequencies, 150-1500 MHz.\n    $$\n    P_{L, u r b a n}(d) \\mathrm{dB}=69.55+26.16 \\log _{10}\\left(f_{c}\\right)-13.82 \\log _{10}\\left(h_{t}\\right)-a\\left(h_{r}\\right)+\\left(44.9-6.55 \\log _{10}\\left(h_{t}\\right)\\right) \\log _{10}(d)\n    $$\n\n+ COST 231 Extension to Hata Model: The Hata model was extended  to 2 GHz .\n    $$\n    P_{L, u r b a n}(d) \\mathrm{dB}=46.3+33.9 \\log _{10}\\left(f_{c}\\right)-13.82 \\log _{10}\\left(h_{t}\\right)-a\\left(h_{r}\\right)+\\left(44.9-6.55 \\log _{10}\\left(h_{t}\\right)\\right) \\log _{10}(d)+C_{M}\n    $$\n    This model is referred to as the COST 231 extension to the Hata model, and is restricted\n    to the following range of parameters: 1.5GHz < $f_c$ < 2 GHz, 30m < $h_t$ < 200 m, 1m < $h_r$ < 10 m, and 1km < $d$ < 20 km.\n\n+ Piecewise Linear (Multi-Slope) Model\n\n+ Indoor Attenuation Factors: it is difficult to find generic models that can be accurately applied to determine empirical path loss in a specific indoor setting.\n\n### Simplified Path Loss Model\n\n+ 对于一般的衰减分析，可以使用路径损耗的简化模型：\n    $$\n    P_r=P_tK\\left[\\frac{d_0}{d}\\right]^\\gamma\n    $$\n    用分贝表示\n    $$\n    P_{r} \\mathrm{dBm}=P_{t} \\mathrm{dBm}+K \\mathrm{~dB}-10 \\gamma \\log _{10}\\left[\\frac{d}{d_{0}}\\right]\n    $$\n    其中，$K$是一个无量纲常数，由天线特性和平均信道特性决定，$d_0$是天线远场的参考距离，$\\gamma$是路径衰落指数。\n\n+ $K$的取值：为了简化计算，将$K<1$取为全向天线自由空间内在$d_0$处的路径增益：\n    $$\n    K \\mathrm{~dB}=20 \\log _{10} \\frac{\\lambda}{4 \\pi d_{0}}\n    $$\n\n    > 这里假设天线效率$\\eta_A$为1，则天线增益$G=\\eta_A D$与天线方向系数$D$就是一致的。\n    >\n    > 对于全向辐射的假想元：\n    > $$\n    > D=\\frac{4\\pi}{\\int_o^{2\\pi}\\int_{0}^{\\pi}\\sin \\theta \\mathrm{d}\\theta\\mathrm{d}\\phi}=1=0\\text{ dBi}\n    > $$\n    > 代入路径增益的表达式即为上式。\n\n+ $\\gamma$的取值：$\\gamma$在自用空间一般取2，在Two-Ray model中取4，对于更复杂的环境可通过对实测数据进行MMSE(minimum mean square error)拟合。\n    $$\n    F(\\gamma)=\\sum_{i=1}^{n}\\left[M_\\text{measured}-M_\\text{model}\\right]^2\n    $$\n    其中$M_\\text{measured}$是实测的$10\\lg\\frac{P_r}{P_t}  \\text{ dB}$，而$M_\\text{model}$是上述路径损耗的简化模型计算得到的$10\\lg\\frac{P_r}{P_t}  \\text{ dB}=K \\mathrm{~dB}-10 \\gamma \\log _{10}\\left[\\frac{d}{d_{0}}\\right]$。对$F(\\gamma)$求极值点：\n    $$\n    \\frac{\\partial F(\\gamma)}{\\gamma}=0\\to\\gamma\n    $$\n    也可以通过经验数据获得：\n\n| Environment                       | γ range |\n| --------------------------------- | ------- |\n| Urban macrocells                  | 3.7-6.5 |\n| Urban microcells                  | 2.7-3.5 |\n| Office Building (same floor)      | 1.6-3.5 |\n| Office Building (multiple floors) | 2-6     |\n| Store                             | 1.8-2.2 |\n| Factory                           | 1.6-3.3 |\n| Home                              | 3       |\n\n\n\n## Shadow Fading\n\n通过无线信道传输的信号通常会因为信号路径中物体的阻挡而发生随机变化，从而引起给定距离内接收功率的随机变化。由于参数是未知的，所以只能通过统计模型来表征这种随机变化。\n\n### log-normal shadowing model\n\n+ 最常用来描述这种加性衰减的模型是log-normal shadowing。\n\n+ 在log-normal shadowing model中，发射接收功率比$\\psi=\\frac{P_t}{P_r}$是服从对数正态分布的\n    $$\n    p(\\psi)=\\frac{\\xi}{\\sqrt{2 \\pi} \\sigma_{\\psi_\\text{dB}} \\psi} \\exp \\left[-\\frac{\\left(10 \\log _{10} \\psi-\\mu_{\\psi_\\text{dB}}\\right)^{2}}{2 \\sigma_{\\psi_\\text{dB}}^{2}}\\right], \\psi>0\n    $$\n    其中，$\\xi=\\frac{10}{\\ln 10}$，$\\psi_\\text{dB}=10\\lg\\psi$。同时，$\\mu_{\\psi_\\text{dB}},\\sigma_{\\psi_\\text{dB}}$都是$\\psi_\\text{dB}$按分贝计算的均值和方差。\n\n+ $\\psi=\\frac{P_t}{P_r}$服从对数正态分布，则接收功率和接收信噪比都服从对数正态分布。\n\n+ 注意：在经验路径损耗模型中，由于无法拆分，$\\mu_{\\psi_\\text{dB}}$已经包含Shadowing的影响。而对于理论分析，必须单独考虑Shadowing的影响。\n\n+ 通常我们对测量值的分贝值取平均来确定平均的路径损耗和方差。\n\n### correlation of shadowing over distance\n\n+ 假设Shadowing $\\psi(d)$是一个一阶自回归过程，相距$\\delta$两点Shadowing fading(阴影衰落)的协方差为\n    $$\n    A(\\delta)=\\mathrm{E}\\left[\\left(\\psi_{d B}(d)-\\mu_{\\psi_{d B}}\\right)\\left(\\psi_{d B}(d+\\delta)-\\mu_{\\psi_{d B}}\\right)\\right]=\\sigma_{\\psi_{d B}}^{2} \\rho_{D}^{\\delta / D}\n    $$\n    其中，$\\rho_D$是相距为$D$时的归一化协方差，且必须通过测量得到。\n\n+ 假设固定$D=X_c$时，$\\rho_D=\\frac 1e$，则模型可简化为\n    $$\n    A(\\delta)=\\sigma^2_{\\psi_\\text{dB}}e^{-\\delta/X_c}\n    $$\n    其中，$X_c$是decorrelation distance（去相关距离），指信号自相关等于其最大值的$\\frac 1e$时的距离，并且与障碍物或障碍物群的大小成正比。\n\n+ 当用户以速度$v$运动，$\\delta=v\\tau$代入上式可求得在$\\tau$时刻的阴影-去相关关系。\n\n\n\n## Combined Path Loss and Shadowing\n\n### the ratio of received to transmitted power\n\n综合上述路径损耗的简化模型和对数正态分布的阴影衰减模型，可得接收发射功率比为\n$$\n\\frac{P_{r}}{P_{t}}\\text{(dB)}=10 \\log _{10} K-10 \\gamma \\log _{10} \\frac{d}{d_{0}}-\\psi_{d B}\n$$\n\n+ $\\psi_\\text{dB}\\sim N(0,\\sigma^2_{\\psi_\\text{dB}})$\n+ 路径损耗随着$\\lg d$以 $10\\gamma\\text{ dB/decade}$的斜率线性递减\n+ 阴影衰减导致的变化非常快，和去相关距离$X_c$在同一数量级\n\n### Outage Probability\n\n无线通信中有目标允许最小接收功率$P_{\\min}$。\n\n+ 中断概率（Outage Probability）：在距离$d$上，接收功率$P_r(d)$衰减到小于一个服务质量不可接受的临界值$P_{\\min}$的概率：\n    $$\n    p_\\text{out}(P_{\\min},d)=p\\left(P_r(d)<P_{\\min}\\right)\n    $$\n\n+ 对于路径损耗的简化模型和对数正态分布的阴影衰减模型，上式可写为\n    $$\n    p\\left(P_{r}(d) \\leq P_{\\min }\\right)=1-Q\\left(\\frac{P_{\\min }-\\left(P_{t}+10 \\log _{10} K-10 \\gamma \\log _{10}\\left(d / d_{0}\\right)\\right)}{\\sigma_{\\psi_\\text{dB}}}\\right)\n    $$\n    其中，\n    $$\n    Q(z) \\triangleq p(x>z)=\\int_{z}^{\\infty} \\frac{1}{\\sqrt{2 \\pi}} e^{-y^{2} / 2} d y=\\frac 12\\mathrm{erfc}\\left(\\frac{z}{\\sqrt{2}}\\right)\n    $$\n\n### Cell Coverage Area\n\n<img src=\"Contours of Constant Received Power.png\" alt=\"Contours of Constant Received Power\" style=\"zoom:60%;\" />\n\n+ 考虑路径损耗和平均的阴影衰减，等功率线是以基站(Base station, BS)为圆心的圆。而考虑路径损耗和随机的阴影损耗，等功率线就变成一个不规则图形。\n\n+ 不能保证在cell的边界上的人接收相同的功率量级，两种解决方式\n\n    + transmit extra power to insure users affected by shadowing receive their minimum required power$P_{\\min}$（会影响邻近的cell）\n    + some users within the cell will not meet their minimum received power requirement.\n\n+ outage probability of the cell（小区中的中断概率）：小区内未达到最低功率要求的面积百分比\n    $$\n    p_\\text{out}^\\text{cell}=1-C\n    $$\n\n    $$\n    C=\\frac{1}{\\pi R^{2}} \\int_{\\text {cell area }} P_{A} d A=\\frac{1}{\\pi R^{2}} \\int_{0}^{2 \\pi} \\int_{0}^{R} P_{A} r d r d \\theta\n    $$\n\n    其中，$P_A$表示在元$\\mathrm{d}A$内接收功率达到最小接收功率的概率，即$P_{A}=\\mathrm{E}\\left[1\\left[P_{r}(r)>P_{\\min } \\text { in } d A\\right]\\right]$，$1[\\bullet]$是示性函数。\n\n+ 对于路径损耗的简化模型和对数正态分布的阴影衰减模型，有\n    $$\n    p(P_{r}(r)>P_{\\min })=1-p_\\text{out}(P_{\\min},r)\n    $$\n    小区中接收功率低于$P_{\\min}$的位置被称为outage location（中断位置）。\n\n+ 若目标最小接收功率$P_{\\min}$等于小区边界处的接收功率$\\bar P_r$，再次假设下小区边界上的中断概率为0.5.\n\n\n\n>在整理的时候，真的发现好多和《天线原理》和《雷达原理与系统》交叉的内容。\n\n\n\n## 参考文献\n\n1. ANDREA GOLDSMITH.*WIRELESS COMMUNICATIONS*.2005.\n2. （美）Andrea Goldsmith著；杨鸿文，李卫东，郭文彬等译. 无线通信. 北京：人民邮电出版社, 2007.06.\n3. 魏文元等编. 天线原理. 北京：国防工业出版社, 1985.06.\n4. 无线通信学习笔记(二) 大尺度路径损耗.https://www.jianshu.com/p/5e9141e6cd76","tags":["无线通信"],"categories":["课程向"]},{"title":"【深度学习笔记（一）】神经网络与深度学习","url":"/2021/03/26/DL-Coursera-1-Neural-Networks-and-Deep-Learning/","content":"\n> 如果没有意外的话，我应该有学上了！\n>\n> 所以我又准备开始更新博客了。\n>\n> 这个深度学习专项是杨神推荐的，链接为https://www.coursera.org/specializations/deep-learning（可能需要挂梯子）。吴恩达老师的英语非常通俗易懂啊，基本上开着英文字幕就能听，不需要中文字幕😜。\n>\n> 这个专项课程一共五门，包括\n>\n> + Neural Networks and Deep Learning（神经网络与深度学习）\n> + Improving Deep Neural Networks: Hyperparameter Tuning, Regularization and Optimization（改进深度神经网络：超参数、正则化和优化）\n> + Structuring Machine Learning Projects（构建机器学习项目）\n> + Convolution Neural Networks（卷积神经网络）\n> + Sequence Model（序列模型）\n>\n> 目前我还在学第四门，我准备把每门课的内容在博客上梳理一下。\n>\n> ——3月25日\n>\n> 第四门学完啦，第五门第一周也学完啦。又来更新了！\n>\n> ——4月5日\n\n\n\n# Neural Networks and Deep Learning 学习笔记\n\n\n\n第一门课的主体框架\n\n+ Week 1: Introduction\n+ Week 2: Programming\n+ Week 3: Singal hidden layer NN\n+ Week 4: Deep NN\n\n\n\n## Week 1\n\n*Welcome to the Deep learning Specilization*主要就是五门课程的总体介绍，这里就不放了。\n\n### Introduction to Deep Learning\n\n这个section主要介绍了神经网络和深度学习最基础的内容，并分析了为何深度学习会在当今take-off。\n\n#### 1. Neural Network\n\n![neural](/neural.png)\n\n#### 2. Supervised learning with neural network\n\n+ 监督学习：输入为x，输出为y。（即有标签）\n+ 分不同类型神经网络的应用范围\n    + 标准神经网络(Standard NN)：房地产，网上广告\n    + 卷积神经网络(Convolution NN, CNN)：图像标语\n    + 循环神经网络(Recurrent NN，RNN)：语音识别，翻译\n    + Hybrid：自动驾驶\n+ 监督学习的对象主要有两种\n    + Structured Data：类似于数据表\n    + Unstructured Data：如音频、图像、文本\n\n#### 3. Why DL take-off? (Why now?)\n\n> Scale drives deep learning progress. (规模驱动深度学习的发展)\n\n+ Data（近几年来数据收集量越来越大）\n    + Large NN 需要大的网络、大量的数据\n+ Computation\n+ Algorithm\n\n重要的循环\n\n<img src=\"/循环.png\" alt=\"循环\" style=\"zoom:33%;\" />\n\n\n\n---\n\n\n\n## Week 2\n\n### Logistic Regression as a NN\n\n在这个section中，讲述的是Logistic回归的相关内容，主要包括Logistic回归的正向（cost function）和反向传播（梯度下降最小化cost function），并对Python、numpy、jupyter notebook的使用做了讲解。\n\n#### 1. Binary Classification\n\n+ 二元分类(Binary Classification)： $x\\to y$\n    + 例如处理一幅64×64像素猫的图像时，先将其分成RGB三个通道，再将其unroll成一个列向量，其维数为$64 \\times 64\\times 3=12288$。此时该图像即Binary Classification中的输入$x$。标记(label)用于分类是否为猫，即为$y$。\n+ 符号说明：\n    + One training example: $(x,y),\\ x\\in\\mathbb{R}^{n_x},y\\in\\{0,1\\}$\n    + $m$ training example: $\\{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\\cdots,(x^{(m)},y^{(m)})\\}$\n        + 其中$m$可以取为$m_{\\text{train}},m_{\\text{test}}$分别表示训练样本的个数和测试样本的数量\n    + 训练集：$X=\\begin{bmatrix}|&|&\\vdots&|\\\\\n        x^{(1)}&x^{(2)}&\\cdots&x^{(m)}\\\\\n        |&|&\\vdots&|\\end{bmatrix}, X\\in\\mathbb{R}^{n_x\\times m}$，是一个$(n_x,m)$维的矩阵。\n    + 标签：$Y=[y^{(1)},y^{(2)},\\cdots,y^{(m)}], Y\\in \\mathbb{R}^{1\\times m}$，是一个$(1,m)$维的矩阵。\n\n#### 2. Logistic Regression & cost function\n\n1. 单个样本Logistic Regression的主要流程\n\n    Given $x\\in\\mathbb{R}^{n_x}$, want $\\hat y=P(y=1|x),0\\le \\hat y \\le 1$（即希望$\\hat y$是$y=1$的一个良好估计）\n\n    Parameter: $w\\in \\mathbb{R}^{n_x},b\\in\\mathbb{R}$\n\n    Output: $\\hat y=w^T+b$ (linear regression)\n\n    ​\t\t\t  $\\hat y=\\sigma[w^T+b]$(logistic regression，其中$\\sigma[\\bullet]$是sigmoid function)\n\n    > 此外也可以表示为$\\hat y=\\Theta^Tx\\quad(x_0=1, x\\in\\mathbb{R}^{n_x+1})$\n    >\n    > 其中$\\Theta^T=\\begin{bmatrix}\\theta_0\\\\ \\theta_1\\\\ \\vdots\\\\ \\theta_{n_x}\\end{bmatrix}\\begin{matrix}\\to b\\\\\\rmoustache\\quad\\\\ \\to w\\\\\\lmoustache\\quad \\end{matrix}$\n\n2. sigmoid function\n\n    ![sigmoid_function](sigmoid.png)\n    \n    $$\n    \\sigma(z)=\\frac{1}{1-e^{-z}}\n    $$\n    \n    其中，当$z\\to -\\infty$时，$\\frac{1}{1+\\infty}=0$；当$z\\to \\infty$时，$\\frac{1}{1+0}=1$\n\n3. **对于m个样本的Logistic regression**\n\n    $\\hat y=\\sigma(w^Tx+b)$, where $\\sigma(z^{(i)})=\\frac{1}{1+e^{-z^{(i)}}}$\n\n    Given $\\{(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\\cdots,(x^{(m)},y^{(m)})\\}$, want $\\hat y^{(i)}=y^{(i)}$\n\n    其中，上标$^{(i)}$表示第$i$个training example。\n\n4. Loss Function(损失函数，针对单个样本来说)\n    $$\n    \\mathscr{L}(\\hat y, y)=-(y\\log \\hat y+ (1-y)\\log(1-\\hat y))\n    $$\n\n    + 当$y=1$时，希望$\\hat y$越大越好\n    + 当$y=0$时，希望$\\hat y$越小越好\n\n5. **Cost function**(代价函数，针对全体样本来说，是cost of parameter)\n    $$\n    \\begin{aligned}\n    J(w,b)=&\\frac 1m\\sum_{i=1}^m\\mathscr{L}(\\hat y^{(i)}, y^{(i)})\\\\\n    =&-\\frac 1m\\sum_{i=1}^m(y^{(i)}\\log \\hat y^{(i)}+ (1-y^{(i)})\\log(1-\\hat y^{(i)}))\n    \\end{aligned}\n    $$\n    \n\n#### 3. Gradient Descent\n\n1. Gradient Descent基础\n\n    ![gradient_descent](gradient_descent.png)\n\n    + 梯度下降实际上就是沿着$w,b$梯度(简记作$\\frac{\\partial J(w,b)}{\\partial w}=dw,\\frac{\\partial J(w,b)}{\\partial b}=db$)下降方向，即\n        Repeat{\n        　　$w:=w-\\alpha dw$\n        　　$b:=b-\\alpha db$\n        }\n        + 其中$\\alpha$是learning rate。\n    + 计算$\\frac{\\partial J(w,b)}{\\partial w}=dw,\\frac{\\partial J(w,b)}{\\partial b}=db$的方式是利用计算图(Computation Graph)，其实就是多元微分的内容，即“连线相乘，分线相加，一元全导，多元偏导”。但吴恩达也说在实际应用中，我们只需要考虑正向传播，而不需要考虑反向传播，框架可以自己处理反向传播。\n\n2. Logistic Regression Gradient descent on one example\n\n    LogisticL Regression的步骤主要包括以下三步：\n\n    + $z=w^Tx+b$\n    + $\\hat y=a=\\sigma(z)$\n    + $\\mathscr{L}(a,y)=-(y\\log a+(1-y)\\log (1-a))$\n\n    ![Logistic Regression Gradient descent](logistic_gradient_descent.png)\n\n    计算得\n    $$\n    \\left\\{\\begin{aligned}\n    \\frac{\\partial \\mathscr{L}}{\\partial w_1}=&\\frac{\\partial \\mathscr{L}}{\\partial a}\\cdot\\frac az\\cdot\\frac{\\partial z}{\\partial w_1}\\left(-\\frac ya+\\frac{1-y}{1-a}\\right)\\cdot a(1-a)\\cdot x_1=(a-y)x_1\\\\ \n    \\frac{\\partial \\mathscr{L}}{\\partial w_2}=&(a-y)x_2\\\\\n    \\frac{\\partial \\mathscr{L}}{\\partial b}=&a-y\n    \\end{aligned}\\right.\n    $$\n\n    $$\n    \\Rightarrow\n    \\left\\{\\begin{aligned}\n    w_1:=&w_1-\\alpha \\frac{\\partial \\mathscr{L}}{\\partial w_1}\\\\\n    w_2:=&w_2-\\alpha \\frac{\\partial \\mathscr{L}}{\\partial w_2}\\\\\n    b:=&b-\\alpha \\frac{\\partial \\mathscr{L}}{\\partial b}\n    \\end{aligned}\\right.\n    $$\n\n    > 其中$\\sigma(z)=\\frac{1}{1+e^{-z}}$的导数推导如下\n    > $$\n    > \\begin{aligned}\n    > \t\\left(\\frac{1}{1+e^{-z}}\\right)'&=\\left(1+e^{-z}\\right)^{-2}e^{-z}\\\\\n    > \t&=\\frac{e^{-z}}{(1+e^{-z})^2}\\\\\n    > \t&=\\frac{e^{-z}+1-1}{1+e^{-z}}\\cdot \\frac{1}{1+e^{-z}}\\\\\n    > \t&=\\left(1-\\frac{1}{1+e^{-z}}\\right)\\cdot\\frac{1}{1+e^{-z}}\\\\\n    > \t&=(1-\\sigma(z))\\sigma(z)\n    > \\end{aligned}\n    > $$\n    >\n    \n3. Gradient descent on $m$ example\n\n    + Cost function\n        $$\n        \\begin{gathered}\n        J(\\omega, b)=\\frac{1}{m} \\sum_{i=1}^{m} \\mathcal{L}\\left(a^{i}, y\\right)\\\\\n        a^{(i)}=\\hat{y}^{(i)}=\\sigma(z)=\\sigma\\left(\\omega^{\\top} x^{(i)}+b\\right)\\\\\n        \\frac{\\partial}{\\partial w_{1}} J(w, b)= \\frac{1}{m} \\sum_{i=1}^{m} \\frac{\\partial}{\\partial w_{1}} \\mathcal{L}\\left(a^{(i)}, y\\right)\\end{gathered}\n        $$\n\n    + 算法\n\n        ![Gradient_descent_on_m_example](/gradient_descent_m.png)\n\n        可以注意到在上述算法中存在两个显式的for-loop，这对于加快运算是非常不利的。\n\n    + 解决显式for-loop的方法：Vectorization（向量化）\n\n\n\n### Python and Vectorization\n\n#### 1. Vectorization\n\n> Whenever possible, avoid explicit for-loops.\n\n1. 举例\n\n    + 【Example·01】$z=w^Tx+b$，其中$w$是一个列向量，$x$也是一个列向量。\n\n        ​\tVectorization：`z = np.dot(w, x) + b`\n\n    + 【Example·02】$u=Av$\n\n        ​\tnon-Vectorization: $u_i=\\sum_jA_{ij}v_j$（存在两重for-loop）\n\n        ​\tVectorization: `u = np.dot(A, v)`\n\n    + 【Example·03】\n        $$\n        v=\\begin{bmatrix}v_1\\\\ v_2\\\\ \\vdots\\\\ v_n\\end{bmatrix}\\Rightarrow u=\\begin{bmatrix}e^{v_1}\\\\ e^{v_2}\\\\ \\vdots\\\\ e^{v_n}\\end{bmatrix}\n        $$\n        Vectorization: `u = np.exp(v)`\n\n    + 另外还可以使用`np.log(v)`, `np.abs(v)`, `np.maximum(v, 0)`, `v ** 2`, `1 / v`。\n\n2. 针对logistic regression derivatives的改进（改进第二个for-loop）\n\n    $J = 0$, $\\boldsymbol{dw = \\mathtt{np.zeros([n_x, 1])}}$, $db = 0$\n    For $i=0$ to $m$\n    　　$z^{(i)}=w^Tx^{(i)}+b$\n    　　$a^{i}=\\sigma(z^{(i)})$\n    　　$J_+=-[y^{(i)}\\log a^{(i)}+ (1-y^{(i)})\\log(1-a^{(i)})]$\n    　　$dz^{(i)}=a^{(i)}-y^{(i)}$\n    　　$\\boldsymbol{dw+=x^{(i)}dz^{(i)}}$\n    　　$db+=dz^{(i)}$\n    $J/=m$; $\\boldsymbol{dw/=m}$; $db/=m$;\n\n    注意其中加粗部分即为利用vectorization的部分。\n\n    ​\t\n\n#### 2. Vectorizing Logistic Regression\n\n+ 各参数的矩阵表示：\n    $$\n    \\begin{aligned}\n    X=&\\begin{bmatrix}|&|&\\vdots&|\\\\\n    x^{(1)}&x^{(2)}&\\cdots&x^{(m)}\\\\\n    |&|&\\vdots&|\\end{bmatrix}, X\\in\\mathbb{R}^{n_x\\times m}\\\\\n    Z=&[z^{(1)},z^{(2)},\\cdots, z^{(m)}]_{1\\times m}\\\\\n    =&w^TX+[b, b, \\cdots, b]_{1\\times m}=[w^Tx^{(1)}+b, w^Tx^{(2)}+b, \\cdots, w^Tx^{(m)}+b]_{1\\times m}\\\\\n    =& \\mathtt{np.dot(w.T,X)+b}\\\\\n    dZ=&[dz^{(1)},dz^{(2)},\\cdots, dz^{(m)}]_{1\\times m}=[a^{(1)}-z^{(1)},a^{(2)}-z^{(2)},\\cdots, a^{(m)}-z^{(m)}]_{1\\times m}\\\\\n    =&A-Y\\\\\n    db=& \\frac 1m\\sum_{i=1}^mdz^{(i)}=\\mathtt{np.sum(dZ)}\\\\\n    dw=& \\frac 1m XdZ^{T}=\\begin{bmatrix}|&|&\\vdots&|\\\\\n    x^{(1)}&x^{(2)}&\\cdots&x^{(m)}\\\\\n    |&|&\\vdots&|\\end{bmatrix}\\begin{bmatrix}dz^{(1)}\\\\\\vdots\\\\dz^{(m)}\\end{bmatrix}\n    \\end{aligned}\n    $$\n\n+ 算法：\n    $$\n    \\begin{aligned}\n    Z=&w^TX+b\\\\\n    =&\\mathtt{np.dot(w.T,X)+b}\\\\\n    A=&\\sigma(Z)\\\\ \n    dZ=&A-Y\\\\ \n    dw=&\\frac 1m XdZ^T\\\\ \n    db=&\\frac 1m \\mathtt{np.sum(dZ)}\\\\\n    w=& w-\\alpha dw\\\\\n    b=& b-\\alpha db\n    \\end{aligned}\n    $$\n    即使对参数进行了vectorization，for-loop仍然是需要的。\n\n#### 3. Broadcasting in Python\n\n![Broadcasting](broadcasting.png)\n\n\n\n#### 4. Notes & Tips on Python/numpy\n\n![note](/note.png)\n\n\n\n---\n\n\n\n## Week 3\n\n### Shallow NN\n\n*NN short for Neural Network.*\n\n本section主要介绍单层的神经网络（Shallow NN），介绍了Shallow NN的正向传播(forward prop)和反向传播(Back prop)过程，并讲解了常见的激活函数(Activation Function)和随机初始化(Random Initialization)的相关内容。\n\n#### 1. NN overview\n\n1. NN的计算\n\n    ![Shallow_NN_overview](/shallow_nn_overview.png)\n\n2. NN的表示\n\n    <img src=\"/nn_representation.png\" alt=\"NN_representation\" style=\"zoom: 67%;\" />\n\n    如图所示是一个2层的神经网络，因为输入层不计入。\n\n    + 用上标$^{[i]}$表示第$i$层\n    + 每个矩阵的维数见图中。\n    + 注意到我们把输入层$x$也表示为$a^{[0]}$\n\n#### 2. Computing a NN's Output & Vectorizing\n\n1. 取其中一个unit计算结果，左图显示了只有一个hidden layer，且只有一个unit的情况。\n\n    ![Logistic_nn](/logistic_nn.png)\n\n    如左图所示，在神经元中的计算主要包括线性的$z=w^Tx+b$和非线性激活函数$a=\\sigma(z)$两部分，最后输出的预测结果$\\hat y =a$。从右图可以看到hidden layer的每一个都是这unit样两步。\n\n    + 矩阵表示\n        $$\n        \\begin{aligned}\n        \\sigma(z^{[1]})=&\\sigma\\left(\\begin{bmatrix}-& w_1^{[1]T}&-\\\\-& w_2^{[1]T}&-\\\\-& w_3^{[1]T}&-\\\\-& w_4^{[1]T}&-\\\\\\end{bmatrix}_{4\\times 3}\\begin{bmatrix}x_1\\\\ x_2\\\\ x_3\\end{bmatrix}_{3\\times 1}+\\begin{bmatrix} b_1^{[1]}\\\\ b_2^{[1]}\\\\ b_3^{[1]}\\\\ b_4^{[1]}\\\\\\end{bmatrix}_{4\\times 1}\\right)\\\\ \n        =&\\sigma\\left(\\begin{bmatrix} w_1^{[1]T}x+b_1^{[1]}\\\\w_2^{[1]T}x+b_2^{[1]}\\\\w_3^{[1]T}x+b_3^{[1]}\\\\w_4^{[1]T}x+b_4^{[1]}\\\\\\end{bmatrix}_{4\\times 1}\\right)=\\sigma\\left(\\begin{bmatrix} z_1^{[1]}\\\\ z_2^{[1]}\\\\ z_3^{[1]}\\\\ z_4^{[1]}\\\\\\end{bmatrix}\\right)\n        \\end{aligned}\n        $$\n\n    + 对于1个样本的算法：(右下角标注的是维数)\n        Given input $x$:\n        $$\n        \\begin{gathered}\n        \\left.\\begin{array}{l}z^{[1]}_{4\\times 1}=W^{[1]}_{4\\times 3} a^{[0]}_{3\\times 1}+b^{[1]}_{4\\times1}\\\\ a^{[1]}_{4\\times1}=\\sigma\\left(z^{[1]}_{4\\times1}\\right) \\end{array}\\right\\} &\\text{layer 1}\\\\\n         \\left.\\begin{array}{l}z^{[2]}_{1\\times 1}=W^{[2]}_{1\\times 4} a^{[1]}_{4\\times 1}+b^{[2]}_{1\\times1}\\\\ a^{[2]}_{1\\times1}=\\sigma\\left(z^{[2]}_{1\\times1}\\right) \\end{array}\\right\\} &\\text{layer 2}\n         \\end{gathered}\n        $$\n\n2. Vectorizing across multiple examples（多个样本进行Vectorization）\n\n    + 对于$a^{[2](i)}$\n\n        + [2]表示Layer 2(第二层)\n        + (i)表示第i个training example\n\n    + 对于$m$个样本的算法：\n        for $i=0$ to $m$:\n        $$\n        \\begin{aligned}\n        z^{[1](i)}=&W^{[1]} x^{(i)}+b^{[1]}\\\\ \n        a^{[1](i)}=&\\sigma\\left(z^{[1](i)}\\right) \\\\\n        z^{[2](i)}=&W^{[2]} a^{[1](i)}+b^{[2]}\\\\ \n        a^{[2](i)}=&\\sigma\\left(z^{[2](i)}\\right) \n        \\end{aligned}\n        $$\n\n    + Vectorization\n        $$\n        \\begin{aligned}\n        Z^{[1]}=&W^{[1]} X+b^{[1]}\\\\ \n        A^{[1]}=&\\sigma\\left(Z^{[1]}\\right) \\\\\n        Z^{[2]}=&W^{[2]} A^{[1]}+b^{[2]}\\\\ \n        A^{[2]}=&\\sigma\\left(Z^{[2]}\\right) \n        \\end{aligned}\n        $$\n        其中，$X=\\begin{bmatrix}|&|&\\vdots&|\\\\\n        x^{(1)}&x^{(2)}&\\cdots&x^{(m)}\\\\\n        |&|&\\vdots&|\\end{bmatrix}_{n_x\\times m}$, $Z^{[1]}=\\begin{bmatrix}|&|&\\vdots&|\\\\\n        z^{[1](1)}&z^{[1](2)}&\\cdots&z^{[1](m)}\\\\\n        |&|&\\vdots&|\\end{bmatrix}$, $A^{[1]}=\\begin{bmatrix}|&|&\\vdots&|\\\\\n        a^{[1](1)}&a^{[1](2)}&\\cdots&a^{[1](m)}\\\\\n        |&|&\\vdots&|\\end{bmatrix}$，其水平方向是training examples的数量，垂直方向是hidden unit的数量。\n\n    + Explanation for vectorized Implementation\n\n    ![Explanation_for_vectorized_Implementation](/vectorized_implementation.png)\n\n    \n\n    \n\n#### 3. Activation Function\n\n1. 常用的activation function\n\n    ![activation_function](/activation_function.png)\n\n2. Why non-linear activation function?\n\n    如果使用线性激活函数，则在重复进行线性计算。根据线性运算的齐次性和叠加性，易知该情况和无hidden layer的情况没有区别。即无法构建Deeper NN。\n\n3. Derivatives of activation function\n\n    + sigmoid function\n        $$\n        \\begin{gathered}g(z)=\\frac{1}{1+e^{-z}}\\\\\n        g'(z)=g(z)(1-g(z))\\end{gathered}\n        $$\n\n        + $z\\to \\infty(10)$: $g'(z)=0$\n        + $z\\to-\\infty(10)$: $g'(z)=0$\n        + $z\\to 0$: $g'(z)=\\frac 14$\n        \n    + tanh function\n        $$\n        \t\t\\begin{gathered}\n              \tg(z)=\\frac{e^{z}-z^{-z}}{e^{z}+e^{-z}}\\\\ \n             \tg'(z)=1-\\tanh^2(z)\n        \t \t\\end{gathered}\n        $$\n    \n        + $z\\to \\infty(10)$: $g'(z)=0$\n        + $z\\to-\\infty(10)$: $g'(z)=0$\n        + $z\\to 0$: $g'(z)=1$\n    \n    + ReLU & leaky ReLU\n    \n        + ReLU: \n            $$\n            \\begin{gathered}\n            g(z)=\\max (0, z)\\\\\n            g^{\\prime}(z)=\\left\\{\\begin{array}{ll}0, & \\text { if } z<0 \\\\ 1, & \\text { if } z>0\\end{array}\\right.\n            \\end{gathered}\n            $$\n    \n        + leaky ReLU:\n            $$\n            \\begin{gathered}\n            g(z)=\\max (0.01 z, z)\\\\\n            g^{\\prime}(z)=\\left\\{\\begin{array}{ll}0.01, & \\text { if } z<0 \\\\ 1, & \\text { if } z>0\\end{array}\\right.\n            \\end{gathered}\n            $$\n            \n\n\n\n\n#### 4. Gradient Descent & Back propagation\n\n1. Gradient Descent for NN\n\n    + 参数： $w^{[1]}_{n^{[1]}\\times n^{[0]}},b^{[1]}_{n^{[1]}\\times 1},w^{[2]}_{n^{[2]}\\times n^{[1]}},w^{[2]}_{n^{[2]}\\times 1},n_x=n^{[0]},n^{[1]},n^{[2]}=1$\n\n    + Cost function: $J(w^{[1]},b^{[1]},w^{[2]},w^{[2]})=\\frac 1m\\sum_{i=1}^m\\mathscr{L}(\\hat y, y)$\n\n    + Gradient descent: \n        Repeat{\n        　　Compute predictions ($\\hat y^{(i)},i=1,2,\\cdots,m$)\n        　　$dw^{[1]}=\\frac{\\partial J}{\\partial w^{[1]}},db^{[1]}=\\frac{\\partial J}{\\partial b^{[1]}},\\cdots$\n        　　$w^{[1]}:=w^{[1]}-\\alpha dw^{[1]}$\n        　　$b^{[1]}:=b^{[1]}-\\alpha db^{[1]}$\n        　　同理计算$w^{[2]},b^{[2]}$}\n\n    + Formula for computing derivatives\n\n        | Forward propagation                                          | Back propagation                                             |\n        | ------------------------------------------------------------ | ------------------------------------------------------------ |\n        | $Z^{[1]}=W^{[1]} X+b^{[1]}\\\\ A^{[1]}=g^{[1]}\\left(Z^{[1]}\\right) \\\\Z^{[2]}=W^{[2]} A^{[1]}+b^{[2]}\\\\ A^{[2]}=g^{[2]}\\left(Z^{[2]}\\right)$ | $dZ^{[2]}=A^{[2]}-Y\\\\dW^{[2]}=\\frac 1m dZ^{[2]}A^{[1]T}\\\\db^{[2]}=\\frac 1m \\mathtt{np.sum(dZ^{[2]}, axis = 1, keepdims = True)}\\\\ dZ^{[1]}=W^{[2]T}dZ^{[2]}*g^{[1]\\prime}(z^{[1]})\\\\dW^{[1]}=\\frac 1m dZ^{[1]}X^T\\\\ db^{[1]}=\\frac 1m \\mathtt{np.sum(dZ^{[1]}, axis = 1, keepdims = True)}$ |\n\n        * 其中`axis = 1`表示按行加\n        * $W^{[2]T}dZ^{[2]}$和$g^{[1]\\prime}$都是$n^{[1]}\\times m$维的。`*`表示element wise\n\n2. Back propagation\n\n    ![back_prop](/Back_prop.png)\n\n    对于$m$个examples，\n    $$\n    \\begin{gathered}\n    dZ^{[2]}=A^{[2]}-Y\\\\dW^{[2]}=\\frac 1m dZ^{[2]}A^{[1]T}\\\\db^{[2]}=\\frac 1m \\mathtt{np.sum(dZ^{[2]}, axis = 1, keepdims = True)}\\\\ dZ^{[1]}=W^{[2]T}dZ^{[2]}*g^{[1]\\prime}(z^{[1]})\\\\dW^{[1]}=\\frac 1m dZ^{[1]}X^T\\\\ db^{[1]}=\\frac 1m \\mathtt{np.sum(dZ^{[1]}, axis = 1, keepdims = True)}\n    \\end{gathered}\n    $$\n    \n\n#### 5. Random Initialization\n\n<img src=\"/random_initialization.png\" alt=\"random_initialization\" style=\"zoom:60%;\" />\n\n+ 为什么不能将初始的weight初始化为0？\n\n    若$W^{[1]}=\\begin{bmatrix}0&0\\\\0&0\\end{bmatrix}$，则两个unit算的结果是相同的，每一个hidden layer的unit多少就没有意义了。同时对其求gradient，$dW^{[1]}=\\begin{bmatrix}u&v\\\\u&v\\end{bmatrix}$\n\n+ 恰当的初始化方式为：\n    $W^{[1]}=\\mathtt{np.random.randn((2,2))*0.01}$(这步`*0.01`主要是为了获得一个比较小的靠近0的初始值，这是考虑到sigmoid function只在0附近的取值存在一定的线性，而过大趋于1，过小趋于0)\n    $b^{[1]}=\\mathtt{np.zeros((2,1))}$（由于对于weight的取值已经随机了，bias是否随机不再重要）\n    对于$W^{[2]},b^{[2]}$的取值和上述类似。\n\n\n\n---\n\n\n\n## Week 4\n\n### Deep NN\n\n#### 1. DNN Overview\n\n1. 在week 3主要介绍的是Shallow NN，随着hidden layer越来越多，也就越来越deeper了。\n\n    ![shallow-to-deep](/dnn_class.png)\n\n2. notations\n\n    <img src=\"/dnn_notation.png\" alt=\"dnn_noatations\" style=\"zoom:50%;\" />\n\n    根据上图介绍notations：\n\n    + number of layer(#layer): $L=4$\n    + number of units of layer $l$: $n^{[l]}$\n    + activations of layer $l$: $a^{[l]}=g^{[l]}(z^{[l]})$\n    + weight for $z^{[l]}$: $w^{[l]}$\n    + bias for $z^{[l]}$: $b^{[l]}$\n\n    \n\n#### 2. Forward Propagation in a Deep Network\n\n+ 和Shallow NN类似，计算forward propagation的过程，如下表左侧。若对其进行vectorized，则变为右侧形式。\n\n    | Elements                                                     | Vectorization                                                |\n    | ------------------------------------------------------------ | ------------------------------------------------------------ |\n    | $\\begin{gathered}z^{[1]}=w^{[1]}x+b^{[1]}\\\\a^{[1]}=g^{[1]}(z^{[1]})\\\\z^{[2]}=w^{[2]}a^{[1]}+b^{[2]}\\\\a^{[2]}=g^{[2]}(z^{[2]})\\\\\\cdots\\\\ z^{[4]}=w^{[4]}a^{[3]}+b^{[4]}\\\\a^{[4]}=g^{[4]}(z^{[4]})\\end{gathered}$ | $\\begin{gathered}Z^{[1]}=W^{[1]} X+b^{[1]}\\\\ A^{[1]}=g^{[1]}\\left(Z^{[1]}\\right) \\\\Z^{[2]}=W^{[2]} A^{[1]}+b^{[2]}\\\\ A^{[2]}=g^{[2]}\\left(Z^{[2]}\\right)\\\\\\cdots\\\\ Z^{[4]}=W^{[4]} A^{[3]}+b^{[4]}\\\\ A^{[4]}=g^{[4]}\\left(Z^{[4]}\\right) \\end{gathered}$ |\n\n    更一般的可以写作\n    $$\n    \\begin{gathered}\n    Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}\\\\\n    A^{[l]}=g^{[l]}\\left(Z^{[l]}\\right)\n    \\end{gathered}\n    $$\n\n+ 在处理DNN的forward propagation时需要注意矩阵的维数是否正确。下面是一个例子\n\n    ![dnn_demension](/dnn_dimension.png)\n\n    下面归纳单个样本Deep NN中出现的各个参数的维度：\n\n    + $w^{[l]},dw^{[l]}:(n^{[l]},n^{[n-1]} )$\n    + $b^{[l]},db^{[l]}:\\left(n^{[l]},1 \\right)$\n    + $z^{[l]},a^{[l]}:(n^{[l]},1)$\n\n    针对$m$个样本来说：\n\n    + $Z^{[l]},A^{[l]}:(n^{[l]},m)$（特别地，当$l=0$时，$A^{[0]}=X:(n^{[0]},m)$）\n    + $dZ^{[l]},dA^{[l]}:(n^{[l]},m)$\n\n+ Why deep representation？为何“深度”的NN表现更好？\n\n  + 在early layer，网络主要实现一些简单功能，例如边缘的检测；在对其进行组合后，即到了later layer时，网络将实现一些复杂的功能，例如分类器。\n  + 类似于数字电路理论中的与、或、非门和与非门，层数越多可以减少每个隐层的units的数量\n  \n  \n  \n    \n\n#### 3. Backward Propagation\n\n1. Building blocks of DNN\n\n    blocks可以表明在前向传播的过程中需要对应传递那些参数用于反向传播。\n\n    + 假设针对NN中的layer $l$构建如下图的block进行分析\n\n        <img src=\"/dnn_single_block.png\" alt=\"dnn_single_block\" style=\"zoom:40%;\" />\n\n        + 第$l$层的参数：$w^{[l]},b^{[l]}$\n\n        + 在forward prop中，输入$a^{[l-1]}$，输出$a^{[l]}$\n\n            $z^{[l]}=w^{[l]}a^{[l-1]}+b^{[l]}$（**cache $z^{[l]}$**）\n\n            $a^{[l]}=g^{[l]}(z^{[l]})$\n\n        + 在backward prop中，输入$da^{[l]}$和先前cache的$z^{[l]}$，需要输出$da^{[l-1]},dw^{[l]},db^{[l]}$\n\n    + 假设NN有L层，将上述block组合起来，有\n\n      ![dnn_blocks](dnn_blocks.png)\n    \n2. Forward & Backward Propagation\n   \n   上面构建了block用于分析前向传播的过程中需要对应传递那些参数用于反向传播，下面利用传递的参数构建DNN的反向传播公式。DNN的正、反向传播公式如下：\n   \n   + FORWARD\n   \n       + 输入：$a^{[l-1]}$\n       + 输出：$a^{[l]},\\text{cache}(z^{[l]})$\n       + $Z^{[l]}=W^{[l]}A^{[l-1]}+b^{[l]}$\n           $A^{[l]}=g^{[l]}(Z^[l])$\n   \n   + BACKWARD\n   \n       + 输入：$da^{[l]}$和先前cache的$z^{[l]}$\n   \n       + 输出$da^{[l-1]},dw^{[l]},db^{[l]}$\n   \n           | one example                                                  | $m$ examples                                                 |\n           | ------------------------------------------------------------ | ------------------------------------------------------------ |\n           | $\\begin{aligned}dz^{[l]}=&da^{[l]}*g^{[l]\\prime}(z^{[l]})\\\\dw^{[l]}=&dz^{[l]}\\cdot a^{[l-1]T}\\\\ db^{[l]}=&dz^{[l]}\\\\da^{[l-1]}=&w^{[l]T}\\cdot dz^{[l]}\\\\dz^{l}=&w^{[l+1]T}\\cdot dz^{[l+a]}*g^{[l]\\prime}(z^{[l]}) \\end{aligned}$ | $\\begin{aligned}dZ^{[l]}=&dA^{[l]}*g^{[l]\\prime}(z^{[l]})\\\\dW^{[l]}=&\\frac 1m dZ^{[l]}A^{[l-1]T}\\\\ db^{[l]}=&\\frac 1m \\mathtt{np.sum(dZ^{[l]}, axis = 1, keepdims = True)}\\\\dA^{[l-1]}=&W^{[l]T}\\cdot dZ^{[l]} \\end{aligned}$ |\n   \n   + 其结构如图\n       ![dnn_prop](/dnn_prop_blocks.png)\n   \n   \n\n\n\n\n#### 4. Parameters & Hyperparameters\n\nHyperparameters其实是Course 2主要研究的问题，在这里只是提了一下什么是超参数(Hyperparameters)。\n\n+ 参数：$W^{[1]},b^{[1]},W^{[2]},b^{[2]},\\cdots$\n+ 超参数：(吴恩达用`#`表示number of …)\n    + learning rate $\\alpha$\n    + #iterations\n    + #hidden layer $L$\n    + #hidden units $n^{[1]},n^{[2]},\\cdots$\n    + choice of activation function\n    + 包括Course 2中将涉及的momentum, mini-batch, regulations, …\n+ 参数根据超参数的改变是会有很大的变化的，即*Hyperparameters control parameters*.\n\n> Applied deep learning is a very empirical process.\n\n\n\n\n\n#### 5. Deep learning and brain\n\n![brain](brain.png)\n\n\n\n> + 这个笔记主要是我看coursera课程是笔记的整理，所以文章里面肯定是很多疏漏，也存在很多错误的，欢迎在评论区批评指正。（求轻喷\n>+ 由于整理打公式还是非常麻烦的，也很容易出错，所以会有一些写的不太规范的地方，大家见谅。\n> + 不知道为什么好好的表格到网页框线就没了，大家将就看吧。/(ㄒoㄒ)/~~\n\n","tags":["深度学习","机器学习"],"categories":["科研向"]},{"title":"Vscode配置LaTeX代码片段","url":"/2021/02/06/latex-snippests/","content":"\n# Vscode配置LaTeX代码片段\n\n在使用LaTeX书写论文时，每次从文件中复制代码段无疑是不优雅的，那么如何才能更加方便快捷地重复使用大段LaTeX代码呢？我们可以利用Vscode自带的**用户片段**功能。\n\n\n\n## 用户片段功能在哪里？\n\n在`文件`->`首选项`->`用户片段`里打`latex`，即可打开`latex.json`文件，在这里面就可以书写用户片段啦\n\n<img src=\"/用户片段.png\" alt=\"用户片段\" style=\"zoom:50%;\" />\n\n## 用户片段的基本格式\n\n### 基本格式\n\n```json\n\t\"Print to console\": {\n\t\t\"prefix\": \"log\",\n\t\t\"body\": [\n\t\t\t\"console.log('$1');\",\n\t\t\t\"$2\"\n\t\t],\n\t\t\"description\": \"Log output to console\"\n\t}\n```\n\n用户片段用json来书写，主要包括以下部分（主要来自参考文献3的翻译）：\n\n+ 片段名称：即`Print to console。`\n+ 触发词（prefix）：我们可以通过prefix定义一个或多个显示代码段的触发词。即上文的`log。`\n+ 主体（body）：是一行或多行内容，在插入时将作为多行连接。将根据插入代码段的上下文对分隔符和嵌入选项卡进行格式化。也就是最后实际显示在编辑器中的内容。\n+ 描述（description）：是对显示的代码段的可选说明。即`Log output to console`。\n\n\n\n### 书写的注意点\n\n+ 在使用到反斜杠时，需要写`\\\\`，最终在编辑器中显示为`\\`\n\n+ `body`可以使用特殊构造来控制游标和要插入的文本\n  + **按下Tab键后停止的位置：**使用Tab键，我们能够让编辑器的光标在显示的代码段中移动。使用`Tab`指定光标位置。数字（如`$1`,`$2`）是将访问选项卡停止的顺序，而`$0`表示最终光标位置。如果有同一编号被使用多次将会同步链接更新。值得注意的是这个数字大于等于10也是可行的。\n  + **占位符：**复杂的代码片段会使用到占位符，占位符形如：`${1:xxx}`, `${2:xxx}`, …, 顺序按照数字顺次排列，每个占位符中的`xxx`为占位符的实例内容，结束位置的占位符为`$0`。\n  + **选择占位符：**占位符可以选择在给定的范围内选择值。语法是将值用`,`分隔枚举，与`|`一起括起来。例如 `${1|c,t,b|}`即表示在`1`位置，可以选择`c`,`b`,`t`三种选项，分别对应垂直居中（center），底部对齐（bottom）和顶部对齐（top）\n  + 其他的操作都可以在[Vscode官网](https://code.visualstudio.com/docs/editor/userdefinedsnippets)上找到。\n\n\n\n\n\n## $\\LaTeX$ 书写论文用户片段的基本案例\n\n### `latex.json`文件\n\n下面给出的案例均来自于对[论文常用代码](https://levitate-qian.github.io/2020/08/30/latex-code/)的改写。主要包括\n\n+ 单图：用`image`，`\\image`呼出\n+ 多图\n  + 子图格式：`images_sub`，`\\images_sub`\n  + 全图格式：`images_minipage`，`\\images_minipage`\n+ 普通三线表：`table`，`tabular`，`\\table_tabular`\n+ 代码\n  + 代码段：`code`，`\\code`\n  + 代码文件：`codefile`，`\\codefile`\n+ 【新增】beamer中常用的左图右文\n\n上述这些是我觉得比较实用的一些内容，所以就做成了用户片段，能帮助我们迅速完成图片、表格、代码等的插入。\n\n```json\n{\n\t// Place your snippets for latex here. Each snippet is defined under a snippet name and has a prefix, body and \n\t// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:\n\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the \n\t// same ids are connected.\n\t// Example:\n\t// \"Print to console\": {\n\t// \t\"prefix\": \"log\",\n\t// \t\"body\": [\n\t// \t\t\"console.log('$1');\",\n\t// \t\t\"$2\"\n\t// \t],\n\t// \t\"description\": \"Log output to console\"\n\t// }\n\t\"Image\": {\n\t\t\"prefix\": [\n\t\t\t\"image\",\n\t\t\t\"\\\\image\"\n\t\t],\n\t\t\"body\": [\n\t\t\t\"\\\\begin{figure}[${5|htbp,H,h|}]\",\n\t\t\t\"    \\\\centering\",\n\t\t\t\"    \\\\includegraphics[width=$1\\\\textwidth]{${2:图片位置}}\",\n\t\t\t\"    \\\\caption{${3:图片标题}}\",\n\t\t\t\"    \\\\label{fig:${4:图片标签}}\",\n\t\t\t\"\\\\end{figure}\",\n\t\t\t\"$0\"\n\t\t],\n\t\t\"description\": \"插入单图\"\n\t},\n\t\"ImagesSub\": {\n\t\t\"prefix\": [\n\t\t\t\"images_sub\",\n\t\t\t\"\\\\images_sub\"\n\t\t],\n\t\t\"body\": [\n\t\t\t\"\\\\begin{figure}[${11|htbp,H,h|}]\",\n\t\t\t\"    \\\\centering\",\n\t\t\t\"    \\\\subfigure[${3:图片1标题}]{\",\n\t\t\t\"    \\\\includegraphics[width=$1\\\\textwidth]{${2:图片1位置}}\",\n\t\t\t\"    \\\\label{fig:${4:图片1标签}}}\",\n\t\t\t\"    \\\\subfigure[${7:图片2标题}]{\",\n\t\t\t\"    \\\\includegraphics[width=$5\\\\textwidth]{${6:图片2位置}}\",\n\t\t\t\"    \\\\label{fig:${8:图片2标签}}}\",\n\t\t\t\"    \\\\caption{${9:总图片标题}}\",\n\t\t\t\"    \\\\label{fig:${10:总图片标签}}\",\n\t\t\t\"\\\\end{figure}\",\n\t\t\t\"$0\"\n\t\t],\n\t\t\"description\": \"插入多图并列放置（子图格式）\"\n\t},\n\t\"ImagesMini\": {\n\t\t\"prefix\": [\n\t\t\t\"images_minipage\",\n\t\t\t\"\\\\images_minipage\"\n\t\t],\n\t\t\"body\": [\n\t\t\t\"\\\\begin{figure}[${13|htbp,H,h|}]\",\n\t\t\t\"    \\\\centering\",\n\t\t\t\"    \\\\begin{minipage}[${1|c,t,b|}]{$2\\\\textwidth} \",\n\t\t\t\"         \\\\centering\",\n\t\t\t\"         \\\\includegraphics[width=$3\\\\textwidth]{${4:图片1位置}}\",\n\t\t\t\"         \\\\caption{${5:图片1标题}}\",\n\t\t\t\"         \\\\label{fig:${6:图片1标签}}\",\n\t\t\t\"    \\\\end{minipage}\",\n\t\t\t\"    \\\\begin{minipage}[${7|c,t,b|}]{$8\\\\textwidth} \",\n\t\t\t\"         \\\\centering\",\n\t\t\t\"         \\\\includegraphics[width=$9\\\\textwidth]{${10:图片2位置}}\",\n\t\t\t\"         \\\\caption{${11:图片2标题}}\",\n\t\t\t\"         \\\\label{fig:${12:图片2标签}}\",\n\t\t\t\"    \\\\end{minipage}\",\n\t\t\t\"\\\\end{figure}\",\n\t\t\t\"$0\"\n\t\t],\n\t\t\"description\": \"插入多图并列放置（全图格式）\"\n\t},\n\t\"Table\": {\n\t\t\"prefix\": [\n            \"table\",\n            \"tabular\",\n\t\t\t\"\\\\table_tabular\"\n\t\t],\n\t\t\"body\": [\n\t\t\t\"\\\\begin{table}[${7|!htbp,H|}]\",\n\t\t\t\"    \\\\begin{center}\",\n\t\t\t\"        \\\\caption{${5:表格标题}}\",\n            \"        \\\\begin{tabular}[${1|c,t,b|}]{${2:列对齐}}\",\n            \"            \\\\toprule\",\n            \"            $3\\\\\\\\\\\\\\\\\",\n            \"            \\\\midrule\",\n\t\t\t\"            $0\",\n            \"            \\\\bottomrule\",\n            \"        \\\\end{tabular}\",\n\t\t\t\"        \\\\label{tb:${6:表格标签}}\",\n\t\t\t\"    \\\\end{center}\",\n\t\t\t\"\\\\end{table}\",\n\t\t],\n\t\t\"description\": \"插入传统三线表\"\n    },\n    \"Code\": {\n\t\t\"prefix\": [\n            \"code\",\n\t\t\t\"\\\\code\"\n\t\t],\n\t\t\"body\": [\n\t\t\t\"\\\\begin{lstlisting}[language=$1,numbers=${2|none,left|}]\",\n\t\t\t\"    $0\",\n\t\t\t\"\\\\end{lstlisting}\",\n\t\t],\n\t\t\"description\": \"插入代码段落\"\n    },\n    \"CodeFile\": {\n\t\t\"prefix\": [\n            \"codefile\",\n\t\t\t\"\\\\codefile\"\n\t\t],\n        \"body\": [\n            \"\\\\noindent\\\\textsc{${1:来源章节}} - \\\\textbf{${2:实际显示文件名}}\",\n            \"\\\\lstinputlisting[language=$3]{./code/$0}\"\n\t\t],\n\t\t\"description\": \"插入代码文件\"\n\t},\n    \"FigText\":{\n\t\t\"prefix\": [\n            \"figtext\",\n\t\t\t\"\\\\figtext\"\n\t\t],\n        \"body\": [\n\t\t\t\"\\\\begin{minipage}[m]{.6\\\\textwidth}\",\n\t\t\t\"\\\\vspace{-15pt} \\\\centering\\\\includegraphics[width=\\\\textwidth]{${1:图片}}\",\n\t\t\t\"\\\\end{minipage}　\",\n\t\t\t\"\\\\begin{minipage}[m]{.35\\\\textwidth}\",\n\t\t\t\"\\\\begin{exampleblock}{}\",\n\t\t\t\"\\\\structure{\\\\faArrowCircleLeft}\\\\parbox{.95\\\\textwidth}{\\\\centering ${2:标题}}\",\n\t\t\t\"\\\\end{exampleblock} \",\n\t\t\t\"$0\",\n\t\t\t\"\\\\end{minipage}\"\n\t\t],\n\t\t\"description\": \"左图右文\"\n\t}\n}\n```\n\n\n\n### 使用方式\n\n1. 输入**触发关键词**，例如`image`\n\n   ![ex1](/ex1.png)\n\n2. 利用`↑`，`↓`键选择对应的用户片段，按`Enter`键选中片段\n\n   ![ex2](/ex2.png)\n\n3. 在光标跳动位置输入正确的内容，按`Tab`键移动到下一个占位符处，再次输入，以此类推，直到写完所有内容。\n\n   ![ex3](/ex3.png)\n\n\n\n## 参考文献\n\n1. VScode配置latex+代码片段让写作起飞. https://blog.csdn.net/cfunction/article/details/108591734\n\n2. VSCode插件开发：LaTeX Snippets. https://hexo.gyrojeff.moe/2020/03/04/VSCode%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%9ALaTeX-Snippets/\n\n3. Snippets in Visual Studio Code. https://code.visualstudio.com/docs/editor/userdefinedsnippets\n\n","tags":["论文","Vscode"],"categories":["LaTeX and ..."]},{"title":"LaTeX模板分享","url":"/2020/12/01/latex-lecture/","content":"\n# $\\LaTeX$模板分享\n\n> 上周又是实验，又是考试，又是小测，太忙了。所以准备时间太短了，不够充分。直接导致周五的技术沙龙讲的真的太烂了，我讲着都不想讲了。这里就不放视频了。大家不要去观摩我的丑态了。不过前半部分杨神讲的还是很好的。\n>\n> ——2020年11月30日留\n>\n> 📝更新：\n>\n> + 更新了在overleaf中使用两个课程报告的说明(2021-12-21)\n> + 更新一个自用的beamer导言区，并更新了一些字体相关的说明，请大家自己对照问题哦 (2022-04-14)\n> + 更新一个自用的东大信息beamer模板(2022-12-29)\n\n\n\n这篇文章主要分享一下几个LaTeX的模板，帮助大家日常学习使用。同时把周五的beamer上没有说清的一些问题再予以说明。为了防止大家懒得看，先放一个总的[👉链接](https://www.lanzoui.com/b0deil1ib)（密码:levitate） 。\n\n\n\n❗ 字体问题可以看最新的博客：[LaTeX札记（四）：字体 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2022/04/14/latex-note-04/)。\n\n\n\n## 数模美赛模板分享\n\n### 数模美赛模板（来源于西交钱院学辅，被我改了一丢丢）\n\n+ 链接：[👉2020D源文件（符合2021MCM ICM新要求）.zip](https://levitate.lanzoux.com/idVCykk91oj)\n+ 上述文件是我们去年美赛O奖论文2006782的tex源文件，请勿大面积外传。\n+ 源地址：https://github.com/qyxf/easymcm/releases （不知道会不会更新新的，如果今年Summary Sheet 不改的话问题不大；同时模板顶端的2020MCM/ICM到2021年是会更新成2021的不用手动改）\n\n### 说明\n\n-   文档类型、应用的样式sty文件\n-   本sty文件识别不了中文，故不要输入中文、中文标点\n-   题号、队伍号、标题的输入\n-   **`\\begin{document}……\\end{document}`是必不可少的。**\n-   Notations表格的改进(使用`\\hline`而非`\\midrule`)\n-   三线表的综合应用（在博客的[第二篇LaTeX札记](https://levitate-qian.github.io/2020/07/06/latex-note-02/)有一定的说明）\n-   列表环境中的换行（就是列表环境里面怎么不出现编号，当然就是不写没有`\\item`）\n-   在LaTeX中插入PDF，用于插入信件（见附录前被注释的那一段）\n-   相对位置的引用（指的是图片和代码位置的引用）\n-   **建议使用XeLaTeX进行编译，而非其他编译方法。在生成目录的过程中，做好要编译两次。**\n\n（上述有的没来得及讲，有什么看不懂的在**评论区**问我吧。）\n\n### 最新说明（根据2021MCM/ICM要求对模板进行调整）\n\n+ 上面已经将链接换成新版本的了，下面的说明仅针对使用老模板的同学。\n\n+ 新要求：\n\n  ![20211](/20211.png)\n\n  ![20212](/20212.png)\n\n+ 根据新的要求，我们需要对模板进行改动。几点说明：\n\n  + 摘要页我就不放页码了。\n  + 我的改动方法是从目录页开始标第2页。\n\n+ 方法：在easymcm.sty里面找到最后两段，\n\n  ![20213](/20213.png)\n\n  将两段文字改成新的内容。\n\n  ```tex\n  % Summary Sheet 生成\n  \\def\\@maketitle{\n  \t\\makesheet%\n  \t\\make@abstract\n      \\pagenumbering{gobble}\n      \\pagestyle{empty}\n      \\newpage\n      \\pagenumbering{arabic}\n      \\setcounter{page}{2}}%1\n  \n  % 目录生成\n  \\renewcommand\\tableofcontents{%\n      \\centerline{\\normalfont\\Large\\bfseries\\contentsname%\n      \\@mkboth{%\n      \\MakeUppercase\\contentsname}{\\MakeUppercase\\contentsname}}%\n      \\vskip 3ex%\n      \\@starttoc{toc}%\n      \\thispagestyle{fancy}\n      \\clearpage\n      \\pagestyle{fancy}\n      \\setlength\\parskip{1ex}}  % 调整段间距\n  ```\n\n+ 最终效果如下：\n\n  ![20214](/20214.png)\n\n  \n\n## XDU实验报告、课程报告模板\n\n### 模板链接\n\n+ [👉XDU_LabReport(实验报告封面).zip](https://www.lanzoui.com/if8COiwo43g)\n+ [👉XDU_Report(普通课程报告封面，含老师).zip](https://levitate.lanzoui.com/ibVrbje3oyj)（更新过了，原来下载过的sty文件里面记得把`\\ProvidesPackage{XDULabreport}`改成`\\ProvidesPackage{XDUreport}`）\n\n### 模板样式\n\n1. **XDU_LabReport(实验报告封面)**\n   + 封面基本符合西电实验报告封面要求，仅有一点点小瑕疵。\n\n![LabReport1](LabReport1.png)\n\n![LabReport2](LabReport2.png)\n\n2. **XDU_Report(普通课程报告封面，可以含老师姓名)**\n\n   + 课程报告模板**西电并没有统一标准**，这里只是将我常使用的一种放了上来。\n   + 这个封面基本包括了大家需要的一些内容，如指导老师、学院、专业、班级等。\n   + 如有其他需求，如果能看得懂模板sty文件的话，可以直接自己改；看不懂的话，简单的方法就是用word导出封面pdf，然后封面和正文拼一下。\n\n   ![Report1](Report1.png)\n\n   ![Report2](Report2.png)\n\n### 说明\n\n+ **一定记得先装字体。**\n\n  + 字体仅供自己使用，请勿外传\n  + 字体记住一定要**为所有用户安装**，否则可能会出错。\n\n+ 普通报告封面的校名、校徽是PDF图片格式，故请勿删除\n\n+ 由于姓名学号就改一次，就不放在tex文件里面改了，大家去sty文件里面直接搜索改吧\n\n+ 这个模板仍然是根据西交钱院学辅数模美赛模板改的，在此同时感谢西安电子科技大学本科毕业设计latex模板，电子科技大学实验报告模板，哈尔滨工程大学课程报告模板给我的启发。\n\n+ 两个封面都是根据Word版在LaTeX里面自己画的。学艺不精，所以还是会有比较多的瑕疵，请大家见谅。\n\n+ **一个很容易出现的报错内容**\n\n  + 字体记住一定要**为所有用户安装**，否则可能会出错。\n\n  ![font](/font.png)\n\n+ 一旦在**报错内容中出现“方正小标宋_GBK”、\".PingFang \"、\"DigifaceWide Regular\"等内容**，可以先把几行字体相关的的内容进行注释。查看问题的本质是否为字体。\n\n  + 注释内容1：在模板sty文件中将三行`\\setCJK`的内容进行注释\n\n    ![sty更改](/sty更改.png)\n\n  + 注释内容2：正文中`\\newfontfamily`和含有`\\digi`字体的表格\n\n    ![tex_font](/tex_font.png)\n\n    ![tex_font2](/tex_font2.png)\n\n    如果注释以后，还是报错说明是模板的问题，而非字体的问题。如果注释字体后不报错，则可以将字体取消注释后依次重试以下几步：\n\n    + 重新安装字体（注意是为所有用户安装）\n    + 删除文件夹中除了`.tex`,`.sty`和几个文件夹以外的所有文件，重新编译，注意时使用XeLaTeX进行编译\n    + 重启Vscode\n    + 重启电脑\n    + 若仍然不行，联系我，我再来想想办法。\n\n> 这里说明一下在Overleaf上的使用方法：\n>\n> ![overleaf](overleaf.png)\n>\n> + 你只需要把下载下来的压缩包放到Overleaf上，并对字体做一些调整\n>\n> + 请将字体从`【请先安装字体，否则报错】Fonts`中移到根目录下，并上传常用的“宋体(SIMSUN)”、“楷体(SIMKAI)”和“仿宋(SIMFANG)”（这三个字体因为比较常见在文件夹中并未给出，所有需要用到字体的打包文件看[👉这个链接](https://levitate.lanzouo.com/ixu9nxuglgb\n>     )）\n>\n>     + 我推荐将字体移到根目录下，部分字体在文件夹中使用`.\\fonts\\字体文件名`能识别到，但也有部分不行。\n>     + 如果你需要更换字体，也可以是同样的方法，放到根目录下并修改sty\n>\n> + 打开sty文件，找到设置中文字符的几行大约在213～215行，将字体在系统中的名字，改成字体文件名\n>\n>     ```tex\n>     \\setCJKmainfont[BoldFont={FZXBSK.TTF},ItalicFont={SIMKAI.TTF}]{SIMSUN.TTC}\n>     \\setCJKsansfont[BoldFont={苹方黑体-中粗-简.ttf},ItalicFont={fzbwksjw.ttf}]{苹方黑体-准-简.ttf}\n>     \\setCJKmonofont[ItalicFont={SIMFANG.TTF}]{SIMFANG.TTF}\n>     ```\n> +  其它字体问题可以看最新的博客：[LaTeX札记（四）：字体 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2022/04/14/latex-note-04/)。\n\n\n\n## 一个自用的beamer模板\n\n最后放一个我常用的beamer模板设置，比较乱，毕竟经常在加入新的。大家对beamer有什么疑惑的话可以去读文档，有[中文版](http://static.latexstudio.net/wp-content/uploads/2017/02/BeamerUserGuide_V3.24_zh-cn.pdf)的，比较通俗。字体问题可以看最新的博客：[LaTeX札记（四）：字体 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2022/04/14/latex-note-04/)。\n\n```tex\n\\documentclass[aspectratio=169]{ctexbeamer}\n% \\documentclass[aspectratio=169,draft]{ctexbeamer}\n% \\documentclass[aspectratio=169,handout]{ctexbeamer}\n% \\documentclass[aspectratio=169,handout,draft]{ctexbeamer}\n\\usetheme{Warsaw}\n\\linespread{1.3}\n\\useoutertheme{infolines}\n\\useoutertheme[subsection=false]{smoothbars}\n% \\usecolortheme{XDU} % 颜色主题自己选自己常用的就行了，我自己配了一个西电配色的\n\n\\title{\\textbf{标题balabala}}\n\\subtitle{\\normalfont 副标题balabala}\n\\author[姓名短]{姓名长}\n\\institute[指导教师：XXX~教授]{电子工程学院　电子信息工程　18020XX\\\\指导教师：XXX~教授}\n\\date{\\today}\n\n\\graphicspath{{./}{./img/}{./fig/}{./image/}{./figure/}{./picture/}{../image/}}\n\\usepackage{url}\n\\usepackage{graphicx}  % 插图\n\\usepackage{float} \n% \\usepackage{subfigure}\n\\usepackage{subfig}\n\\newcommand{\\upcite}[1]{\\textsuperscript{\\textsuperscript{\\cite{#1}}}}\n\\usepackage[OT1]{fontenc}\n\\usepackage{cmbright}\n\\usepackage{sansmathfonts}\n% \\usefonttheme[onlylarge]{structurebold}\n% \\setCJKmainfont[ItalicFont={江城斜宋体 300W}]{思源宋体}\n\\setCJKsansfont[ItalicFont={霞鹜文楷}]{思源黑体} % 霞鹜文楷自己去猫啃网下载，感觉不错\n% \\setCJKmonofont{思源等宽}\n\\newcommand{\\XWWK}{\\CJKfontspec{霞鹜文楷}}\n\\usepackage{multicol}\n% \\usepackage{listings} % 一般就不要贴代码了吧\n% \\def\\lstbasicfont{\\ttfamily\\selectfont\\footnotesize}\n% \\lstset{%\n%    numbers=none,\n%    numberstyle=\\tiny\\sffamily,%\n%     showstringspaces=false,\n%     showspaces=false,%\n%     tabsize=4,%\n%     breaklines=true,%\n%     frame=lines,%\n%     basicstyle={\\scriptsize\\ttfamily},%\n%     keywordstyle=\\color{blue},%\n%     identifierstyle=,%\n%     commentstyle=\\itshape\\color{teal},%\\itshape,%\n%     stringstyle=\\color{violet},%\n%     escapeinside=``,%\n%     backgroundcolor=\\color[RGB]{245,245,244},\n% }\n% \\lstloadlanguages{C,C++,Java,Matlab,Mathematica,vhdl}\n\\usepackage{longtable,multirow,array}  % 各种基本的表格宏包\n\\usepackage{booktabs}  % 三线表宏包\n\\usepackage{tabularx}\n\\usepackage{longtable}\n\\usepackage{tabu}\n% \\usepackage{animate} % 动画\n\\usepackage{tikz}\n\\usepackage{fancybox}\n\\usepackage{mathrsfs}\n\\usepackage{mathtools}\n\\usepackage{fontawesome} % 符号宏包\n\\definecolor{XDUcolor}{HTML}{b0252a} %西电红\n% \\definecolor{XDUcolor}{HTML}{004181} %西电蓝\n\n% 定义了一些样式、环境\n\\renewcommand{\\emph}[1]{{\\XWWK \\structure{#1}}} % 重定义了emph样式\n% \\newcommand{\\frametitleb}[1]{\\frametitle{\\bfseries #1}} % 帧标题加粗\n% \\newcommand{\\emph}[1]{{\\color{XDUcolor}#1}}\n% \\renewcommand{\\thefootnote}{[\\arabic{footnote}]} % 如果你需要[1]样式的脚注\n\\newcommand{\\figtext}[3]{\\begin{minipage}[t]{.6\\textwidth}  \\vspace{-15pt}#1 \\end{minipage}　\\begin{minipage}[t]{.35\\textwidth}  \\begin{exampleblock}{}  \\structure{\\faArrowCircleLeft}\\parbox{.95\\textwidth}{\\centering #3}  \\end{exampleblock} \\pause#2\\end{minipage}} % 左图(#1)右文(#2)，并显示图名(#3)\n% \\usepackage[ruled,vlined]{algorithm2e}\n\\logo{\\includegraphics[height=0.2\\textwidth]{logo.eps}} % logo\n\n\\newcommand{\\bs}{\\boldsymbol}\n\\newcommand{\\mb}{\\mathbf}\n\\newcommand{\\rd}{\\mathrm{d}}\n\n% 每节开头显示节标题，每小节开始显示本节所有标题\n\\AtBeginSection[]{\n    %  \\let\\insertsectionnumber\\relax\n     \\let\\sectionname\\relax\n     \\frame{\\sectionpage}\n}\n\\AtBeginSubsection[]\n{\n\\begin{frame}[shrink]\n    \\centering\n    \\tableofcontents[sectionstyle=show/shaded,subsectionstyle=show/shaded/hide]\n \\end{frame}\n}\n```\n\n## 自用的东大信息beamer模板\n\n根据上述**西电**模板，增加**东大元素、东大信息元素**改编而成。下载链接：https://levitate.lanzouf.com/i3ozG0jmc7sj\n\n### 说明\n\n+ 经过测试，该模板直接上传 overleaf 或 TEXLive 2022 均可运行，其他版本未测试。\n  + overleaf 请使用 XeLaTeX 编译器进行编译。\n  + 本地 TEXLive 2022 请使用 XeLaTeX 编译器编译两遍。本地使用 vscode 可参考“Vscode 配置LaTeX 代码片段”配置代码片段，方便使用。\n+ 其中打包进了思源黑体 CN和霞鹜文楷，请参考[github](https://github.com/adobe-fonts/source-han-sans)和[猫啃网](https://www.maoken.com/freefonts/9704.html)相关使用说明。思源黑体、霞鹜文楷均为可商用字体（来源：Github、猫啃网）。本地可以直接安装使用。其余字体问题可参考“LaTeX 札记（四）：字体”。\n+ 请勿删除`SEU_RADIO_image`文件夹，此文件夹内为模板中使用的东大信息相关图片。\n+ 图片请放置在` image `文件夹下，或采用其他相对路径\n\n### 模板样式\n\n![image-20221229123818229](/image-20221229123818229.png)\n\n![image-20221229123901066](/image-20221229123901066.png)\n\n![image-20221229123916022](/image-20221229123916022.png)\n\n\n\n## 一些学习资料的分享\n\n### LaTeX入门beamer（20201127）\n\n下载链接：[👉LaTeX入门(20201127).pdf](https://www.lanzoui.com/i8PlWiwo5uj)\n\n主要针对数模美赛模板的使用。但是由于做的时候没有考虑好受众，既关注于入门，又讲了一些技巧，所以效果不是很好，但还是值得一看的。\n\n<object data=\"LaTeX入门(qcl).pdf\" type=\"application/pdf\" width=\"100%\" height=\"450px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF.请点击查看: \n<a href=\"LaTeX入门(qcl).pdf\">Download PDF</a>.</p></object>\n\n\n\n### 【强推】一份（不太）简短的LATEX2ε 介绍\n\n下载链接：\n\n+ v6.0: [👉一份（不太）简短的 LATEX 2ε 介绍.pdf](https://www.lanzoui.com/ivJGfiwofsh)\n+ 最新版本：[👉lshort-zh-cn.pdf (tsinghua.edu.cn)](https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf)\n\n<object data=\"https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf\" type=\"application/pdf\" width=\"100%\" height=\"900px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF.请点击查看: \n<a href=\"https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf\">Download PDF</a>.</p></object>\n\n\n\n\n### 网址归纳\n\n+ 论文队友Blog：https://levitate-qian.github.io/\n\n  + 【配置环境】[如何优雅的书写LaTeX论文 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/07/21/latex-vscode/)\n  + 【常用代码】[【持续更新】论文常用LaTeX代码 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/08/30/latex-code/)\n  + 【表格相关】[LaTeX札记（二）：表格 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/07/06/latex-note-02/)\n  + 【公式相关】[LaTeX札记（三）：公式 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/07/12/latex-note-03/)\n  + 【作图相关】[10类案例带你了解论文插图制作 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2020/05/04/10类案例带你了解论文插图制作/)（配着下面视频看更佳）\n  + 插图制作视频：[【西电MSC】数模美赛冠名O奖学长教你论文插图制作_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili](https://www.bilibili.com/video/BV1c5411W7U9) （标题有点离谱，为了吸引眼球）\n\n+ 美赛$\\TeX$模板来源：https://github.com/qyxf/easymcm/releases （不知道会不会更新新的，如果今年Summary Sheet 不改的话问题不大；同时模板顶端的2020MCM/ICM到2021年是会更新成2021的不用手动改）\n\n+ 《$\\LaTeX$入门》beamer中出现的网址\n\n  + 一份（不太）简短的$\\LaTeX2\\varepsilon$ 介绍[Index of /CTAN/info/lshort/chinese/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/)\n  + $\\LaTeX$ 科技排版：华师大老师的网站，主要是讲座的beamer [LaTeX科技排版 (ecnu.edu.cn)](http://www.math.ecnu.edu.cn/~jypan/Teaching/Latex/)\n  + MathF(图片转公式)：[MathF (mathcode.herokuapp.com)](https://mathcode.herokuapp.com/)\n  + 在线LaTeX公式编辑器：[在线LaTeX公式编辑器-妈叔出品 (latexlive.com)](https://www.latexlive.com/)\n  + 表格转$\\LaTeX$：[Create LaTeX tables online – TablesGenerator.com](https://www.tablesgenerator.com/latex_tables)\n\n\n\n## 【附录】杨神的beamer——数学建模竞赛入门&美赛经验分享\n\n<object data=\"数学建模竞赛入门&美赛经验分享(ywh).pdf\" type=\"application/pdf\" width=\"100%\" height=\"450px\">\n<p><b>❗Alert</b>: 该浏览器不支持PDF.请点击查看: \n<a href=\"数学建模竞赛入门&美赛经验分享(ywh).pdf\">Download PDF</a>.</p>\n</object>\n\n\n\n### 网址归纳\n\n+ 编程队友知乎：[阿尔法杨XDU - 知乎 (zhihu.com)](https://www.zhihu.com/people/mu-yi-yang-42-66/columns)\n\n+ 《数学建模竞赛入门& 美赛经验分享》beamer中出现的网址\n\n  + 学校选修PPT：https://alpha-yang.lanzoux.com/b01tqvl8h 提取码：ge1o\n  + 阿尔法杨XDU. 数模竞赛备赛常用模型与算法：https://zhuanlan.zhihu.com/p/147853046\n  + 【MATLAB】强推b 站教程，台大郭彦甫.MATLAB 教程：https://www.bilibili.com/video/BV1GJ41137UH?from=search&seid=10111640569179808375\n  + 【ML】[可选]吴恩达教授的《Machine Learning》课程：https://www.bilibili.com/video/BV164411b7dx?from=search&seid=92807526979575575\n  + 阿尔法杨XDU. 如何写出一篇高质量的数模竞赛答卷：https://zhuanlan.zhihu.com/p/145434397\n  + 2017-2020 年数模美赛O 奖论文合集 https://zhuanlan.zhihu.com/p/314325181\n\n  \n\n","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"【无监督学习】聚类算法——K-means","url":"/2020/11/14/clustering-k-means/","content":"\n\n\n# 【无监督学习】聚类算法——K-means\n\n## 1聚类任务\n\n### 1.1 无监督学习概述\n\n机器学习一般包括监督学习、无监督学习、强化学习。有时候还包括半监督学习、主动学习。\n\n#### 1.1.1 监督学习与无监督学习\n\n**监督学习（Supervised learning）**  监督学习（Supervised learning）是指*从标注数据中学习*预测模型的机器学习问题。监督学习的本质是从学习输入到输出的映射的统计规律。\n\n $$T=\\{(\\boldsymbol{x}_1,\\boldsymbol{y}_1),(\\boldsymbol{x}_2,\\boldsymbol{y}_2),\\cdots,(\\boldsymbol{x}_m,\\boldsymbol{y}_m)\\}$$\n\n**无监督学习（Unsupervised learning）**  无监督学习（Unsupervised learning）是指*从无标注数据中学习*数据的统计规律。目标是通过对无标记的训练样本的学习来解释数据的内在性质及规律，为进一步的数据分析提供基础。主要包括*聚类、降维、概率估计*。无监督学习可以用于数据分析获监督学习的前处理。 \n\n$$T=\\{\\boldsymbol{x}_1,\\boldsymbol{x}_2,\\cdots,\\boldsymbol{x}_m\\}$$\n\n![supervise](/supervise.png)\n\n#### 1.1.2 聚类的引入\n\n在数学建模竞赛中，会遇到不少类似这样的问题，比如拍照定价给城市分类(2017国赛B题)，美国阿片危机的城市(2019美赛C题，是一个三维图)，球员之间联系的紧密性研究(2020美赛D题)等，这些都是明显的聚类问题。\n\n![MCM](/MCM.png)\n\n我们再举几个平时生活的例子，比如市场消费调研，社交网络分析，衣服尺码分布等等，这些问题所给出的样本，不像监督学习问题中的房价预测等问题。上述例子并没有带标签，而我们就把这样没有带标签的样本进行算法学习，由参数体现出的分类情况称为聚类，也就是Clustering。\n\n**聚类(Clustering)与簇(Cluster)**\n\n-   聚类试图将数据集中的样本划分为若干个通常是不相交的子集；\n\n-   每个子集被称为一个\"簇\"。\n\n聚类既能作为一个单独过程，用于寻找数据内在的分布结构，也可作为分类等其他学习任务的前驱过程。\n\n### 1.2 预备知识------距离计算\n\n#### 距离计算\n\n在聚类中，我们要将样本集划分为若干个互不相交的自己，即样本簇。那么什么样的聚类效果比较好呢？从直观上来说，我们希望\"物以类聚\"，即同一个簇的样本尽可能彼此相似，不同簇的样本尽可能地不同。换言之，聚类结果中的\"簇内相似度\"(intra-cluster similarity)高，而\"簇间相似度\"(inter-cluster similarity)低。\n\n不论是聚类结果中的\"簇内相似度\"(intra-cluster similarity)还是\"簇间相似度\"(inter-cluster similarity)，我们都可以用*距离*$\\mathrm{dist}$这个参量来定义。这里我只介绍为最基本的连续样本的几个\"距离度量\"。\n\n**闵可夫斯基距离(Minkowski distance)** \n\n$$\\mathrm{dist}_{mk}(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=\\left(\\sum_{u=1}^n|x_{iu}-x_{ju}|^p\\right)^{\\frac{1}{p}}$$ \n\n闵可夫斯基距离其实就是$\\boldsymbol{x}_i-\\boldsymbol{x}_j$的$\\mathrm{L}_p$范数$||\\boldsymbol{x}_i-\\boldsymbol{x}_j||_p$\n\n**欧氏距离(Euclidean distance)** \n\n$$\\mathrm{dist}_{ed}(\\boldsymbol{x}_i,\\boldsymbol{x}_j)=||\\boldsymbol{x}_i-\\boldsymbol{x}_j||_2=\\sqrt{\\sum_{u=1}^n|x_{iu}-x_{ju}|^2}$$\n\n我们可以看出 闵可夫斯基距离其实就是$\\boldsymbol{x}_i-\\boldsymbol{x}_j$的$\\mathrm{L}_p$范数，而当$p=2$时，就退化为了欧氏距离；而当$p=1$时，就退化为曼哈顿距离。\n\n## 2 K-means算法概览\n\n### 2.1 K-means算法的形象化理解\n\n![k-means](/k-means.gif)\n\n我们先来形象的理解一下K-means算法的流程是怎样的（动图）。假设我有一个无标签的数据集，然后我想把它分成3个簇。我们下面一步一步来理解一下这个过程。\n\n1.  随机选择三个点------聚类中心（均值向量）；（我想把这些样本分成3个簇，K-means是一个迭代算法）\n\n2.  第一个是簇分配：我们会遍历图上的每一个样本点，找到每个样本点距离最近的聚类中心，将样本点的颜色染成聚类中心的颜色，换言之分配给三个聚类中心；\n\n3.  第二个是移动聚类中心：接着我们计算所有相同颜色的点的均值向量（质心），将开始的聚类中心移动到我们计算的均值向量处；就变成了这个图。\n\n4.  我们反复操作这个迭代的过程，得到了最后的聚类结果。下面不管我们在怎么去迭代得到的都是这样的结果了。\n\n### 2.2 K-means算法初步\n\n#### 2.2.1 算法的基本流程\n\n**输入**\n\n-   $K$：簇的总数\n-   样本集$D=\\{\\boldsymbol{x}_1,\\boldsymbol{x}_2,\\cdots,\\boldsymbol{x}_m\\}$\n\n首先，我们来看一看K-means 算法有哪些输出，一个是簇的总数，也就是说你最后想\n要得到多少个簇；另一个就是我们的样本集，值得注意的是这个样本集是不带标签的。\n\n![liucheng](/liucheng.png)\n\n下面我们来看一看算法的流程：\n\n1.  **Initialization: 初始化聚类中心（均值向量）；** 从刚刚的图形中，我们可以看出在最开始我们需要根据我们需要的聚类的个数$K$选择相应个数的聚类中心。这个操作我们称之为\"初始化\"(Initialization)。至于如何初始化，我们会在第三部分谈到。\n\n2.  **Cluster assignment: 簇分配；**第二个操作便是K-means算法的最重要的的两个操作之一------\"簇分配\"了，在这个步骤中，我们遍历数据集中的所有样本点，找到离每个点最近的聚类中心，将第$i$个样本分配给簇，并将簇的索引(Index)保存到变量$c_i$中。这个分配过程，我们可以理解为将每个样本点染色。\n\n3.  **Move centroid: 移动聚类中心（均值向量）；**为了让我们的K-means算法\"运动\"起来，我们势必将聚类中心也进行移动。那么如何移动呢？我们在这边先给出结论------我们将所有聚类中心移动到簇中所有点的质心处，即计算所有样本点向量的均值向量。正因如此，我们将聚类中心的位置用均值向量$\\boldsymbol{\\mu}_j$来表示。\n\n4.  **Iteration: 迭代；**最后一个操作，既然我们通过移动聚类中心，使得K-means算法\"运动\"起来。那么\"聚类\"，\"聚类\"，我们最终需要的是各个样本点之间的关系。我们有需要让样本点们重新染色，重新分配到上一步移动过的聚类中心去了。如此循环往复的过程便是\"迭代\"。既然是迭代必定会有一个结束条件------一般有两种：一是，针对小样本集来说，均值向量不再发生移动便为结束；二是，对于上千上万的数据，设置一个最大迭代次数来终止这个迭代过程。但是这个解是个最优解吗？很显然这并不一定，这很可能只是个局部最优解。这个问题，我会在第三部分中继续讨论。\n\n![algorithm](/algorithm.png)\n\n这里我还给出了一个算法流程图，其中第1行就是对聚类中心进行初始化；在第4-7行和8-13行分别对于当前数据进行簇分配和移动聚类中心；2-14行这个总体过程是一个迭代的过程；当迭代更新后的聚类结果保持不见，则输出簇划分。\n\n### 2.3 西瓜数据集4.0例\n\n![watermelon](/watermelon.png)  \n\n下面，我们以周志华老师编写的《机器学习》上的一个西瓜数据集4.0为例来演示K-means算法的学习过程。为了方便需要，我们将编号为$i$的样本成为$\\boldsymbol{x}_i$，$\\boldsymbol{x}_i$是一个包含\"密度\"和\"含糖率\"两属性值的二维向量。\n\n#### 2.3.1 初始化聚类中心（均值向量）(Initialization)\n\n假设聚类簇的个数$K=3$，算法开始时随机选取三个样本$\\boldsymbol{x}_6$,$\\boldsymbol{x}_{12}$,$\\boldsymbol{x}_{24}$作为初始均值向量，即 \n\n$$\\boldsymbol{\\mu}_1=(0.403;0.237),\\quad\n    \\boldsymbol{\\mu}_2=(0.343;0.099),\\quad\n    \\boldsymbol{\\mu}_3=(0.478;0.437).$$\n\n#### 2.3.2 簇分配(Cluster assignment)\n\n考察样本$\\boldsymbol{x}_1=(0.697;0.460)$，它与当前均值向量$\\boldsymbol{\\mu}_1,\\boldsymbol{\\mu}_2,\\boldsymbol{\\mu}_3$的距离分别为0.369, 0.506, 0.220，因此$\\boldsymbol{x}_1$被划入簇$C_3$中。这里我们计算的都是欧氏距离，即$\\mathrm{L}_2$范数。 类似的，对数据集中的所有样本进行考察，可得当前的簇划分为 \n\n$$\\begin{aligned}\n        C_1=&\\{\\boldsymbol{x}_3, \\boldsymbol{x}_5, \\boldsymbol{x}_6, \\boldsymbol{x}_7, \\boldsymbol{x}_8, \\boldsymbol{x}_9, \\boldsymbol{x}_{10}, \\boldsymbol{x}_{13}, \\boldsymbol{x}_{14}, \\boldsymbol{x}_{17}, \\boldsymbol{x}_{18}, \\boldsymbol{x}_{19}, \\boldsymbol{x}_{20}, \\boldsymbol{x}_{23}\\};\\\\\n        C_2=&\\{ \\boldsymbol{x}_{11}, \\boldsymbol{x}_{12}, \\boldsymbol{x}_{16}\\};\\\\\n        C_3=&\\{\\boldsymbol{x}_1, \\boldsymbol{x}_2, \\boldsymbol{x}_4, \\boldsymbol{x}_{15},  \\boldsymbol{x}_{21}, \\boldsymbol{x}_{22}, \\boldsymbol{x}_{24}, \\boldsymbol{x}_{25}, \\boldsymbol{x}_{26}, \\boldsymbol{x}_{27}, \\boldsymbol{x}_{28}, \\boldsymbol{x}_{29}, \\boldsymbol{x}_{30}\\};\\\\\n    \\end{aligned}$$ \n\n我们将这30个样本点染上相应聚类中心的颜色。\n\n#### 2.3.3 移动聚类中心（均值向量）(Move Centroid)\n\n于是我们从$C_1,\\ C_2,\\ C_3$中计算出新的均值向量，即\n\n $$\\boldsymbol{\\mu}_1=(0.493;0.207),\\quad\n\\boldsymbol{\\mu}_2=(0.394;0.066),\\quad\n\\boldsymbol{\\mu}_3=(0.602;0.396).$$ \n\n然后将相应的聚类中心移动到更新的均值向量处。\n\n![cluster_centriod](/cluster_centriod.png)\n\n#### 2.3.4 迭代(Iteration)\n\n更新第一轮的均值向量后，不断重复上述过程，第六轮迭代产生的结果与第五轮迭代结果相同，于是算法停止，得到最终的簇划分。\n\n![iteration](/iteration.png)\n\n## 3 K-means算法再探究\n\n刚刚，我们对于K-means算法的基本流程有了一定的了解了。下面我们就对于刚刚算法流程遗留的一些问题予以说明。在开始之前，我们先约定一些符号。\n\n#### 几个参数的进一步说明\n\n$c_i$ 最靠近$\\boldsymbol{x}_i$的聚类中心的索引编号$(j=1,2,\\cdots,K)$ Index of cluster $(1,2,\\cdots,K)$ to which example $\\boldsymbol{x}_i$ is currently assigned\n\n$\\boldsymbol{\\mu}_j$ 第$j$个簇的中心（均值向量） Cluster centroid $j(\\boldsymbol{\\mu}_j\\in\\mathbb{R}^n)$\n\n$\\boldsymbol{\\mu}_{c_i}$ $\\boldsymbol{x}_i$所处的簇的中心（均值向量） Cluster centroid of cluster to which example $\\boldsymbol{x}_i$ has been assigned\n\n注意：其中，$c_i$是一个索引编号，也就是说是一个标量值；而$\\boldsymbol{\\mu}_j$和$\\boldsymbol{\\mu}_{c_i}$都是一个包含属性的多维向量。对于上面的西瓜数据集来说，$c_i$可以取为$1,2,3$，而$\\boldsymbol{\\mu}_j$和$\\boldsymbol{\\mu}_{c_i}$联同前面提到的$\\boldsymbol{x}_i$是包含\"密度\"和\"含糖率\"两属性值的二维向量。\n\n### 3.1 优化目标\n\n第三部分的题目叫做\"K-means算法再探究\"。首先我们要探究的是一个名为\"优化目标\"的东西。在刚刚算法流程的讲述中，我们谈到了\"簇分配\"和\"移动聚类中心\"两步操作，但为什么我们可以这样来移动使得达到\"聚类\"的效果，这就是\"优化目标\"解决的问题。\n\n#### 3.1.1 损失代价函数\n\nK-means算法的流程\n\n1.  **Initialization:** 初始化聚类中心（均值向量）；\n\n2.  **Cluster assignment:** 簇分配；\n\n3.  **Move centroid:** 移动聚类中心（均值向量）；\n\n4.  **Iteration:** 迭代至（局部）最优解；\n\n这里我们先引入一个\"损失代价函数\"的概念。这将帮助我们更好地理解为什么我们可以通过这样简单的两步来实现\"簇内相似度\"最高的效果；同时也将帮助我们更好选择簇来避免局部最优的情况。\n\n我们将需要优化的参数值也就是每个样本点所属的簇$c_i$和聚类中心的位置$\\boldsymbol{\\mu}_j$。我们把损失代价函数表述为这个式子，很明显右边的求和项求的就是每个样本到它对应的聚类中心的欧氏距离，这个函数实际上就是对这些距离求数学期望。\n\n于是，我们可以很容易的得出损失代价函数和优化目标。\n\n**损失代价函数(Distortion cost function)** \n\n$$J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)=\\frac{1}{m}\\sum_{i=1}^m||\\boldsymbol{x}_i-\\boldsymbol{\\mu}_{c_i}||^2$$\n\n#### 3.1.2 优化目标\n\n而K-means算法要做的是什么呢？就是将这个损失代价函数达到最小，这恰恰也就是我们我们所需要的\"簇内相似度\"最高的这个效果。但是这个式子可以直接实现吗？并不能，这是一个NP难问题，我们只能使用贪心算法来解决这个问题。\n\n**优化目标(Optimization objective)** \n\n$$\\min_{\\substack{c_1,\\cdots,c_m,\\\\ \\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K}}J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$$\n\n\n\n### 3.2 随机初始化\n\n说完了\"簇分配\"和\"移动聚类中心\"的理论，我们还有两个操作没有谈到，就是\"初始化\"和\"迭代\"。\n\n#### 3.2.1 聚类中心如何初始化？\n\nK-means算法的流程\n\n1.  **Initialization:** 初始化聚类中心（均值向量）；\n2.  **Cluster assignment:** 簇分配；\n\n3.  **Move centroid:** 移动聚类中心（均值向量）；\n\n4.  **Iteration:** 迭代至（局部）最优解；\n\n在K-means算法中，我们还有一个悬而未决的问题，到现在也没有说明。那就是如何初始化$K$个聚类中心？ 一般地，*随机选择$K$个样本作为初始化的点*($K<m$)，但是这样确实也会出现一些问题......\n\n#### 3.2.2 局部最优解(Local optima)\n\n我们从下面三个图形可以看到，当我们取定不同的初始聚类中心后，他们的聚类结果并不相同，这是为什么呢？这是因为他们陷入了局部最优解。\n\n![local_optima](/local_optima.png)\n\n当我们随机初始化聚类中心时，很有可能聚类中心会分布在我们意想不到的地方，非常容易造成局部最优解(Local optima)。 解决这个问题的方法就是*尝试多次初始化，并分别迭代到局部最优再对其损失代价函数$J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$分别进行比较*。\n\n#### 3.2.3 基于随机初始化对K-means算法进行改进\n\n下面我们对算法进行改进。刚刚我们已经说了，\"初始化\"的方式我们采取随机选择$K$个样本作为初始化的点来取定。为了尽可能地解决局部最优解的问题，我们采取的是\"多次初始化\"的方式。我们多次随机初始化迭代到最终结果，接着利用我们刚刚谈到的损失代价函数来描述各种初始化最终的效果。最后我们比较各个损失代价函数，取最小的作为我们最后的聚类结论。\n\n**基于随机初始化对K-means算法进行改进**\n\n![gaijin](/gaijin.png)\n\n**对于西瓜数据集4.0的随机初始化**\n\n利用随机初始化100次，得到代价函数的最小值为 0.409663。\n\n![intial_100](/intial_100.png)\n\n**经验公式** 有经验公式表明，当簇的个数$K$取为2-10时，迭代100次一般能收敛到一个比较好的结果。\n\n### 3.3 簇数$K$的选择\n\n在前面两节中，我们讨论了算法流程中四个操作的原理，但是对于输入参数我们并没有进行讨论。下面简要的介绍一下输入参数中簇数$K$的取值方式。\n\n#### 3.3.1 肘部法则(Elbow Method)\n\n我们分别测试不同簇个数$K$情况下代价函数的大小，即可画出如下图的最小代价函数的折线图。仔细分辨两幅图的区别，可以发现左图在$K=3$处有一个明显转折，而右图则比较平滑。那么我们如何选择簇数$K$呢？如果出现了如左边情况的图像，则选择转折点，可以发现，当大于转折点后这个代价函数曲线的变化就不那么明显了，也就说明它趋于稳定；而往往出现的是右边的图像，比如西瓜数据集4.0。而对于右边的数据我们如何处理呢？\n\n![number](/number.png)\n\n#### 3.3.2 平滑下降时的处理方法\n\n一般地，在应用K-means算法时，都是为了将得到的\"簇\"应用于后续的处理。所以，我们也可以根据后续处理需要的类的个数来确定K-means中簇的个数。比如我们上面的右图是西瓜数据集的\"代价函数-K\"曲线，而聚类可能有一个需要的结论，例如\"浅色瓜\"、\"深色瓜\"就需要两个簇；再举个吴恩达机器学习MOOC栗子：例如衬衫厂商想要根据人群的身高体重来制造不同尺寸的衬衫，如果他的心里规划是设置S、M、L三种尺寸，就分三个簇；而想要设置XS、S、M、L、XL号们就需要分五个簇。\n\n![shirt](/shirt.png)\n\n## 4 K-means算法的代码实现\n\n最后，简要的介绍一下Matlab和Python库函数对于K-means算法的支持。其中，特别需要注意的是迭代次数和随机初始化次数的区分要明确。\n\n### 4.1 Matlab库函数\n\n`idx = kmeans(X,k)` 执行 k 均值聚类，以将 $n\\times p$ 数据矩阵 $\\boldsymbol{X}$ 的观测值划分为 $k$ 个聚类，并返回包含每个观测值的簇索引的 $n\\times 1$ 向量 (`idx`)。$\\boldsymbol{X}$ 的行对应于点，列对应于变量。\n\n`[idx,C] = kmeans(___)` 在 $k\\times p$ 矩阵 $\\boldsymbol{C}$ 中返回 $k$ 个簇质心的位置。\n\n其中，$\\boldsymbol{X}$为数据，$\\boldsymbol{X}$的行对应于观测值，而列对应于变量。$k$为簇的数量。$\\boldsymbol{C}$为簇质心位置，第$j$行是簇$j$的质心。\n\n**可能用到的参数**\n\n-   'Display' - 要显示的输出的级别：'off' （默认） \\| 'final'（最终） \\| 'iter'（迭代）\n\n-   'Distance' - 距离度量： 'sqeuclidean' （欧氏距离） \\| 'cityblock'（曼哈顿距离） 等\n\n-   'MaxIter' - 最大迭代次数，默认为100\n\n-   'Replicates' - 使用新初始簇质心位置重复聚类的次数，默认为1\n\n#### Matlab库函数实现西瓜数据集4.0\n\n``` matlab\nclear ,clc ;\ndata = load (’dataset .txt ’);\nopts = statset (’Display ’,’iter ’);\n[idx ,C] = kmeans ( data (: ,2:3) ,3,’Replicates ’ ,100, ’Options ’,opts );\nhold on;\nset (gcf , ’color ’,’w’);\nxlabel (’密度’);\nylabel (’含糖率’);\nplot (C(1 ,1) ,C(1 ,2) ,’g+’,’MarkerSize ’ ,10,’LineWidth ’ ,2);\nplot (C(2 ,1) ,C(2 ,2) ,’r+’,’MarkerSize ’ ,10,’LineWidth ’ ,2);\nplot (C(3 ,1) ,C(3 ,2) ,’b+’,’MarkerSize ’ ,10,’LineWidth ’ ,2);\nplot ( data ( idx ==1 ,2) ,data ( idx ==1 ,3) ,’gd ’);\nplot ( data ( idx ==2 ,2) ,data ( idx ==2 ,3) ,’ro ’);\nplot ( data ( idx ==3 ,2) ,data ( idx ==3 ,3) ,’b^’);\nhold off ;\n```\n\n### 4.2 Python库函数\n\n首先，K-means在sklearn.cluster中，\n\n``` python\nfrom sklearn.cluster import KMeans\n```\n\nK-means在Python的三方库中的定义是这样的：\n\n``` python\nclass sklearn.cluster.KMeans(n_clusters=8, init='k-means++', n_init=10, max_iter=300, tol=0.0001, precompute_distances='auto', verbose=0, random_state=None, copy_x=True, n_jobs=None, algorithm='auto')\n```\n\n其中，`n_clusters`表示的是要生成的簇的数量，`n_init`表示随机初始化的次数，`max_iter`表示最大迭代次数。\n\n`estimator =KMeans(___)` 构造聚类器。其中，`n_clusters`表示的是要生成的簇的数量，`n_init`表示随机初始化的次数，`max_iter`表示最大迭代次数。\n\n`estimator.fit(data)` 计算K-means聚类。\n\n**可能用到的参数**\n\n-   `label_pred = estimator.labels_` ：获取聚类标签\n\n-   `centroids = estimator.cluster_centers_` ：获取聚类中心\n\n-   `inertia = estimator.inertia_` ： 获取聚类准则的总和\n\n## 5 总结\n\n#### K-means算法的思路\n\nfor $k=1$ to 100{\n\n 　　随机初始化$K$个聚类中心（均值向量）$\\boldsymbol{\\mu}_1,\\boldsymbol{\\mu}_2,\\cdots,\\boldsymbol{\\mu}_K\\in\\mathbb{R}^n$;\n\n　　Repeat{ \n\n　　　　　for $i=1$ to $m$\n\n 　　　　　　　$c_i\\leftarrow$ 最靠近$\\boldsymbol{x}_i$的聚类中心的索引编号\n\n 　　　　　for $j=1$ to $K$\n\n 　　　　　　　$\\boldsymbol{\\mu}_j\\leftarrow$ 第$j$簇所有向量的平均（均值向量）\n\n 　　} \n\n　　得到第$k$组$c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K$;\n\n 　　计算代价损失函数$J_k(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$; \n\n} \n\n选择使得代价损失函数$J_k(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$最小的聚类方式。\n\n\n#### 损失代价函数(Cost function)和优化目标(Optimization objective)\n$$J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)=\\frac{1}{m}\\sum_{i=1}^m||\\boldsymbol{x}_i-\\boldsymbol{\\mu}_{c_i}||^2$$ \n\n\n\n$$\\min_{\\substack{c_1,\\cdots,c_m,\\\\ \\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K}}J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$$\n\n#### 随机初始化(Randomly Initialization)\n\n-   初始化方式：随机选择$K$个样本作为初始化的点$(K < m)$；\n\n-   局部最优解：尝试多次初始化，并分别迭代到局部最优再对其损失代价函数 $J(c_1,\\cdots,c_m,\\boldsymbol{\\mu}_1,\\cdots,\\boldsymbol{\\mu}_K)$分别进行比较；\n\n#### 簇数$K$的选择(Choosing the number of clusters)\n\n-   肘部法则 (Elbow Method)；\n-   考虑后续处理需要；\n\n### 参考文献\n\n1.  周志华.机器学习\\[M\\]北京：清华大学出版社,2016:197-204. \n2. 吴恩达.机器学习学习系列课程\\[V/OL\\] <https://study.163.com/course/introduction.htm?courseId=1004570029&_trace_c_p_k2_=60b3accf313c45bcbd5dddc890ff4346>. \n3. 李航. 统计学习方法（第2版）\\[M\\] 北京：清华大学出版社, 2019. \n4. MathWorks.kmeans\\[EB/OL\\] <https://ww2.mathworks.cn/help/stats/kmeans.html#d122e16427>. \n5. Levitate\\_.LaTeX札记（一）：插入动画\\[EB/OL\\] <https://levitate-qian.github.io/2020/06/13/latex-note-01/>. \n6. Levitate\\_.MATLAB札记（一）：让图像动起来\\[EB/OL\\] <https://levitate-qian.github.io/2020/06/27/matlab-note-01/>. \n7. Wong, J. A. Hartiganm. A. . \\\"Algorithm AS 136: A K-Means Clustering Algorithm.\\\" *Journal of the Royal Statistical Society. Series C (Applied Statistics)* 28.1(1979):100-108.","tags":["机器学习"],"categories":["课程向"]},{"title":"乘法器电路总结","url":"/2020/10/29/RF-multiplier/","content":"\n\n# 乘法器电路总结\n\n\n## 1 乘法器基础\n\n### 1.1 开关函数\n\n单向开关函数（阶跃函数$\\varepsilon(t)\\longleftrightarrow\\pi\\delta(\\omega)+\\frac{1}{j\\omega}$）\n\n $$\\begin{aligned}\n        K_1(\\omega_c t)=&\\left\\{\\begin{array}{ll}\n            1, & u_c>0,\\\\\n            0, & u_c<0.\\\\\n        \\end{array}\\right.\\\\\n        =&\\frac{1}{2}+\\frac{2}{\\pi}\\cos\\omega_c t-\\frac{2}{3\\pi}\\cos 3\\omega_ct+\\ldots\n    \\end{aligned}$$\n\n双向开关函数（符号函数$\\mathrm{sgn}(t)\\longleftrightarrow\\frac{2}{j\\omega}$）\n\n $$\\begin{aligned}\n        K_2(\\omega_c t)=&\\left\\{\\begin{array}{ll}\n            1, & u_c>0,\\\\\n            -1, & u_c<0.\\\\\n        \\end{array}\\right.\\\\\n        =&\\frac{4}{\\pi}\\cos\\omega_c t-\\frac{4}{3\\pi}\\cos 3\\omega_ct+\\ldots\n    \\end{aligned}$$\n\n### 1.2 频域分析与滤波\n\n- 窄带滤波器：$LC$并联谐振回路$\\omega_0=\\omega_c$，$\\mathrm{BW}_{BPF}\\boldsymbol{=}2\\Omega$\n\n  $$u_{AM}=R_eI_{c1m}\\left[1+\\boldsymbol{0.707}\\frac{g_1u_\\Omega m}{I_{c1m}}\\cos\\left(\\Omega t\\boldsymbol{-\\frac{\\pi}{4}}\\right)\\right]\\cos\\omega_c t$$\n\n- 宽带滤波器：$LC$并联谐振回路$\\omega_0=\\omega_c$，$\\mathrm{BW}_{BPF}\\boldsymbol{\\gg}2\\Omega$\n\n  $$u_{AM}=R_eI_{c1m}\\left[1+\\frac{g_1u_\\Omega m}{I_{c1m}}\\cos\\left(\\Omega t\\right)\\right]\\cos\\omega_c t$$\n\n### 1.3 大小信号的区分\n\n#### 1.3.1 调幅\n\n$U_{cm}\\gg U_{\\Omega m}$\n\n+ 调制信号 $u_\\Omega=U_{\\Omega m}\\cos \\Omega t$\n+ 载波 $u_c=U_{cm} \\cos \\omega_ct$\n\n#### 1.3.2 检波/解调\n\n$U_{lm}\\gg U_{sm}$\n\n+ 中频已调波 $u_s=U_{sm}\\cos \\Omega t\\cos\\omega_ct$\n+ 本振信号 $u_l=U_{lm}\\cos \\omega_ct$\n\n#### 1.3.3 混频\n\n$U_{lm}\\gg U_{sm}$\n\n+ 中频已调波 $u_s=U_{sm}\\cos\\omega_ct$\n+ 本振信号 $u_l=U_{lm}\\cos \\omega_lt$\n\n### 1.4 利用开关函数来解决各种形式的线性时变调幅的步骤\n\n1.  判断当$u_c\\gtrless 0$时，$i_c(u_o)$的表达式。\n\n2.  利用单向/双向开关函数将$i_c(u_o)$的分段函数化为一个整体表达式。\n\n3.  若$i_c(u_o)$的表达式中出现$\\cos \\omega_c t$和$\\cos \\Omega t$的乘积项，则说明可以实现振幅调制。\n\n4.  代入开关函数，利用和差化积、积化和差等找到表达式中的普通调幅信号或双边带调幅信号。\n\n5.  合理选择中心频率和带宽，使其完成调幅，获得已调波的表达式。\n\n## 2 晶体管\n\n### 2.1 概念\n\n-   非线性电路调幅中的晶体管放大器可以直接应用于线性时变电路调幅 ，除了控制调制信号是小信号而载波是大信号以外，如果晶体管是线性器件，即其转移特性在放大区线性较好，则需要使晶体管*轮流工作在放大区和截止区才能对信号做非线性变换*。\n-   为了提高交流输出的功率和效率，电路一般*将直流静态工作点设置在放大区和截止区之间的临界位置*。\n-   线性时变电路调幅可以利用这些特点近似分析输出电流，既而对输出电流滤波产生输出电压，得到调幅信号。\n\n### 2.2 具体电路\n\n#### 2.2.1 $u_\\Omega$ 和 $u_c$都接在基极，共射组态\n\n$$i_c=g_m(u_\\Omega+u_c)k_1(\\omega_ct)$$\n\n![PNP_B](/PNP_CE.png)\n\n#### 2.2.2 $u_\\Omega$ 和 $u_c$ 都接在射极 ，共基组态\n\n$$i_c=g_m(u_c+u_\\Omega)(k_1(\\omega_ct)-1)$$\n\n<img src=\"/PNP_CB.png\" alt=\"PNP_E\" style=\"zoom:67%;\" />\n\n#### 2.2.3 $u_l$在基极，$u_s$在射极（防止频率牵引导致不稳定） \n\n$$i_c=g_m(u_l-u_s)k_1(w_lt)$$\n\n<img src=\"/PNP_seperate.png\" alt=\"PNP_seperate\" style=\"zoom:60%;\" />\n\n\n\n\n\n## 3 场效应管\n\n### 3.1 概念\n\n-   场效应管放大器的线性时变电路调幅与晶体管放大器的线性时变电路调幅有类似的电路结构。\n\n-   场效应管是非线性器件，其转移特性在恒流区即为非线性，只要调制信号是小信号而载波是大信号，*即使一直工作在恒流区， 放大器也可以实现线性时变电路调幅*。\n\n-   电路可以*将直流静态工作点设置在场效应管的恒流区和截止区之间的临界位置*，这时可以利用单向开关函数分析输出电流。\n\n### 3.2 具体电路（暂略）\n\n\n\n## 4 差分对放大器\n\n### 4.1 概念\n\n-   当差动放大器实现线性时变电路调幅时，调制信号和载波可以分别作为电流源的控制电压和差模输入电压，不必叠加输入。在这种分置电压的设计中，调制信号是小信号而载波是大信号不是必要条件。\n-   同时，差动放大器中的两个晶体管是非线性器件，它们始终导通，不在导通和截止之间转换工作状态。\n-   开关函数的引入:\n    -   当差模输入电压$u_m<U_T$时，$\\tanh \\frac{u}{2U_T}\\approx \\frac{u}{2U_T}$；\n    -   当差模输入电压$u_m>4U_T$时，$\\tanh \\frac{u}{2U_T}\\approx k_2(w_ct)$；\n    -   之间展开为傅里叶级数。\n\n### 4.2 具体电路\n\n4.2.1、4.2.2、4.2.4中，$u_c$和$u_\\Omega$分别作为共模或差模输入时没有大小信号之分；但对于图4.2.3，这里$u_c$和$u_\\Omega$作为差模的两个端输入，则需要区分大小信号。\n\n#### 4.2.1 $u_c$ 为差模、$u_Ω$ 控制共模，且单端输出\n\n<img src=\"/chafendui_1.png\" alt=\"chafendui_1\" style=\"zoom:50%;\" />\n\n$$i_{c1}=\\frac{U_{EE}-U_{BE(on)}}{2R_E}(1+\\tanh\\frac{u_c}{2U_T})+\\frac{1}{2R_E}(1+\\tanh\\frac{u_c}{2U_T})u_\\Omega$$\n\n#### 4.2.2  $u_\\Omega$ 为差模、$u_c$ 控制共模，且双端输出\n\n<img src=\"/chafendui_2.png\" alt=\"chafendui_2\" style=\"zoom:50%;\" />\n\n$$i_o=\\frac{i_{c3}}{2}\\tanh\\frac{u_\\Omega}{2U_T}$$\n\n#### 4.2.3 $u_\\Omega,u_c$串联\n\n<img src=\"/chafendui_3.png\" alt=\"chafendui_3\" style=\"zoom:50%;\" />\n\n#### 4.2.4 吉尔伯特乘法单元\n\n<img src=\"/chafendui_4.png\" alt=\"chafendui_4\" style=\"zoom:50%;\" />\n\n$$i_o=\\frac{I_o}{2}\\tanh\\frac{u_s}{2U_T}\\tanh\\frac{u_l}{2U_T}$$\n\n+ 当小信号$U_{sm}<U_T$，\n\n  $$i_o=\\frac{I_o}{2} \\frac{u_s}{2U_T}\\tanh\\frac{u_l}{2U_T}$$\n\n+ 进一步当$U_{lm}>4U_T$\n\n  $$i_o=\\frac{I_o}{2} \\frac{u_s}{2U_T}k_2(\\omega_lt)$$\n\n  \n\n## 5 二极管\n\n### 5.1 概念\n\n-   当二极管用于线性时变电路调幅时，要求调制信号是小信号，载波是大信号，*载波控制二极管的导通与截止*，且载波的振幅明显大于二极管的导通电压，二极管的工作状态基本随着载波的正负而改变。\n\n-   当二极管导通时，\n\n    1.  如果电路对调制信号或载波等效为二极管与负载电阻串联，则因为二极管的交流电阻远小于负载电阻，调制信号或载波几乎全部加到负载电阻上；\n    2.  如果等效电路中只有导通的二极管而没有负载电阻，则调制信号或载波全部加到二极管上。\n\n### 5.2 具体电路\n\n#### 5.2.1 单二极管（4种）\n\n![VD_singal](/VD_singal.png)\n\n#### 5.2.2 双二极管（2+2+1）\n\n1. 双二极管同向\n\n   ![VD_double1](/VD_double1.png)\n\n2. 双二极管反向\n\n   ![VD_double2](/VD_double2.png)\n\n3. 双二极管面对面\n\n   <img src=\"/VD_double3.png\" alt=\"VD_double3\" style=\"zoom:67%;\" />\n\n   $$u'_o=2u_sk_1(\\omega_lt)$$\n\n   \n\n#### 5.2.3 二极管环形乘法器（2种形式）\n\n![VD_4](/VD_4.png)\n\n任选两输入、一输出\n\n\n\n\n\n\n\n","tags":["射频"],"categories":["课程向"]},{"title":"【持续更新】论文常用LaTeX代码","url":"/2020/08/30/latex-code/","content":"\n# 论文常用LaTeX代码\n\n> 部分代码已经过时，请参考其他用法。\n\n这个代码不局限于数模论文里用的了，但说用在数模里面是一点问题都没有的啊。\n\n由于我现在各类作业、实验报告、大作业均有$\\LaTeX$书写，所以这里面的代码类别就会比较丰富，我也会持续更新的（只要我还在用$\\LaTeX$）。\n\n\n\n\n\n## 图片\n\n+ 导言区代码\n\n  ```tex\n  \\usepackage{graphicx} %插入图片的宏包\n  \\usepackage{float} %设置图片浮动位置的宏包\n  \\usepackage{subfigure} %插入多图时用子图显示的宏包\n  ```\n\n1. 单图\n\n   ```tex\n   \\begin{figure}[htbp]\n       \\centering\n       \\includegraphics[width=.9\\textwidth]{XXX.pdf} \t% 图片相对位置\n       \\caption{Electric Vehicles: January 2020}\t\t% 图片标题 \n       \\label{fig:American}\t\t\t\t\t\t\t% 图片标签\n   \\end{figure}\n   \n   \\begin{figure}[H]\n       \\centering\n       \\includegraphics[width=.4\\textwidth]{ex2-3jie.pdf} \t% 图片相对位置\n       \\caption{习题2.3解图}\t\t% 图片标题 \n       \\label{fig:ex4-9}\n   \\end{figure}\n   ```\n\n2. 多图并列放置（子图格式）\n\n   ```tex\n   \\begin{figure}[htbp]\n       \\centering    \n       \\subfigure[Hot Map of one Room]{\t\t\t\t% 图片1([]内为子图标题)\n       \\label{fig:sub.roomhot}\t\t\t\t\t\t\t% 子图1的标签\n       \\includegraphics[width=0.45\\textwidth]{XXX.jpg}}% 子图1的相对位置\n       \\subfigure[Hot Map of one Floor]{\t\t\t\t% 图片2\n       \\label{fig:sub.floorhot}\t\t\t\t\t\t% 子图2的标签\n       \\includegraphics[width=0.45\\textwidth]{XXX.jpg}}% 子图2的相对位置\n       \\caption{Hot Map of one Room and one Floor}\t\t% 总图标题\n       \\label{fig:hot}\t\t\t\t\t\t\t\t\t% 总图标签\n   \\end{figure}\n   ```\n\n3. 多图并列放置（全图格式）\n\n   ```tex\n   \\begin{figure}[htbp]\n   \t\\centering \t\t\t\t\t\t\t\t\t%图片全局居中\n   %并排几个图，就要写几个minipage\n   \t\\begin{minipage}[b]{0.45\\textwidth} \t\t%所有minipage宽度之和小于1\n   \t\t\\centering \t\t\t\t\t\t\t\t%图片局部居中\n   \t\t\\includegraphics[width=0.8\\textwidth]{DV_demand} \n   \t\t\t\t\t\t\t%此时的图片宽度比例是相对于这个minipage的，不是全局\n   \t\t\\caption{name 1}\n   \t\t\\label{fig:1}\n   \t\\end{minipage}\n   \t\\begin{minipage}[b]{0.45\\textwidth} \n   \t\t\\centering \t\t\t\t\t\t\t\t\t%图片局部居中\n   \t\t\\includegraphics[width=0.8\\textwidth]{P+R_demand}\n   \t\t\\caption{name 2}\n   \t\t\\label{fig:2}\n   \t\\end{minipage}\n   \\end{figure}\n   ```\n\n4. 放置图片过程中，调整图片尺寸\n\n   ```tex\n   \\includegraphics[width=0.45\\textwidth,trim=85 80 80 85,clip]{room_pic_guidance_new/step179.jpg}}\n   % 从左到右依次为左、下、右、上\n   ```\n\n5. Visio画图有多余边框\n\n   http://www.mamicode.com/info-detail-2181323.html\n\n6. 图片环绕文字\n\n   ```tex\n   % \\usepackage{wrapfig} \t\t\t\t%环绕文字需要引用的宏包\n   \\begin{wrapfigure}{r}{8cm}\t\t\t%靠文字内容的左侧\n       \\centering\n       \\includegraphics[width=.45\\textwidth]{01.jpg} \t% 图片相对位置\n       \\caption{程控放大器设计框图}\t\t  % 图片标题 \n       \\label{fig:01}\t\t\t\t\t% 图片标签\n   \\end{wrapfigure}\n       \n       1. 放大器采用同相比例放大器，如图 \\ref{fig:01} 所示。设$R_1=1\\ k\\Omega$，则分别选$R_{f4}=1\\ k\\Omega$,$R_{f3}=3\\ k\\Omega$，$R_{f2}=5\\ k\\Omega$，$R_{f1}=7\\ k\\Omega$，即可实现增益在2、4、6、8倍之间可控。其中$R_{F0}=300\\ k\\Omega\\gg R_{Fi}$，主要是避免开关切换瞬间运放开环工作。\n   ```\n\n\n\n   \n\n## 公式\n\n1. 局部对齐不标序号\n\n   ```tex\n   \\begin{equation*} \n       \\begin{aligned}\n   \t\t\\text{the initial temperature: } &\\quad T_0=1, \\\\\n   \t\t\\text{the terminal temperature: }&\\quad e = 10^{-30},\\\\\n   \t\t\\text{attenuation coefficient: }&\\quad \\alpha =0.999, \\\\\n   \t\t\\text{the solution domain: }&\\quad \\mathbb{S}=\\left\\{p \\in(0, \\infty), t \\in\\left(0, t_{\\max }\\right]\\right\\}\n       \\end{aligned}\n   \\end{equation*}\n   ```\n\n$$\\begin{aligned}\t\\text{the initial temperature: } &\\quad T_0=1, \\\\\n\t\t\\text{the terminal temperature: }&\\quad e = 10^{-30},\\\\\n\t\t\\text{attenuation coefficient: }&\\quad \\alpha =0.999, \\\\\n\t\t\\text{the solution domain: }&\\quad \\mathbb{S}=\\left\\{p \\in(0, \\infty), t \\in\\left(0, t_{\\max }\\right]\\right\\}\n\t \\end{aligned}$$\n2. 一个优化模型的示例\n\n   ```tex\n   \\begin{align}\n   \t\\min &\\,Z=\\sum_{i \\in \\mathbb{I}} \\sum_{j} \\in B(j)\\\\\n   \t\\mathrm{s.t.} &\\left\\{\\begin{array}{llll}\n       \t\\sum\\limits_{i \\in A(i)} V_i y_{ij} \\le \\sum\\limits_{j \\in A(i)} E_j x_j,\\\\\n       \t\\sum\\limits_{j \\in B(i)} y_{ij} \\ge 1, \\forall i\\in \\mathbb{I}, \\forall j \\in B(j), \\\\\n           \\sum\\limits_{i \\in A(i)} x_j \\ge 1, \\forall i \\in \\mathbb{I}, \\\\\n           y_{ij}\\le x_j, \\forall i\\in \\mathbb{I}, j\\in \\mathbb{J}. \\\\\n       \\end{array}\\right.\n   \\end{align}\n   ```\n\n$$\\begin{aligned}\n\t\\min &\\,Z=\\sum_{i \\in \\mathbb{I}} \\sum_{j} \\in B(j)\\\\\n\t\\mathrm{s.t.} &\\left\\{\\begin{array}{llll}\n    \t\\sum\\limits_{i \\in A(i)} V_i y_{ij} \\le \\sum\\limits_{j \\in A(i)} E_j x_j,\\\\\n    \t\\sum\\limits_{j \\in B(i)} y_{ij} \\ge 1, \\forall i\\in \\mathbb{I}, \\forall j \\in B(j), \\\\\n        \\sum\\limits_{i \\in A(i)} x_j \\ge 1, \\forall i \\in \\mathbb{I}, \\\\\n        y_{ij}\\le x_j, \\forall i\\in \\mathbb{I}, j\\in \\mathbb{J}. \\\\\n    \\end{array}\\right.\n\\end{aligned}$$\n3. 添加行属性、列属性的矩阵\n\n   ```tex\n   \\begin{equation}\\label{Eq:matrix1}\n   \\bordermatrix{%\n          & t_1       & t_2     &\\cdots     &t_n\\cr\n   u_1    & ?         & ?       &\\cdots     & ?\\cr\n   u_2    & ?         & ?       &\\cdots     & ?\\cr\n   \\vdots & \\vdots    &\\vdots   &\\cdots     &\\vdots\\cr\n   u_m    & ?         & ?       &\\cdots     &?\n   },\n   \\end{equation}\n   ```\n\n\n4. cases示例\n\n   ```tex\n   \\begin{equation}\\label{eq:food_reqiure_fin1}\n       W_t=\\left\\{\\begin{array}{ll}\n           \\ln (Ft)\\cdot\\left[1-\\mathrm{exp}(-k_{\\max}t)\\right]^3, &\\text{if }F>F_w,\\\\\n           \\ln (Ft)\\cdot\\left[1-\\mathrm{exp}(-(1-\\mathrm{e}^{-\\lambda F})k_{\\max}t)\\right]^3, &\\text{if }0\\le F\\le F_w.\\\\\n       \\end{array}\\right.\n   \\end{equation}\n   ```\n\n\n$$\n    W_t=\\left\\{\\begin{array}{ll}\n        \\ln (Ft)\\cdot\\left[1-\\mathrm{exp}(-k_{\\max}t)\\right]^3, &\\text{if }F>F_w,\\\\\n        \\ln (Ft)\\cdot\\left[1-\\mathrm{exp}(-(1-\\mathrm{e}^{-\\lambda F})k_{\\max}t)\\right]^3, &\\text{if }0\\le F\\le F_w.\\\\\n    \\end{array}\\right.\n$$\n\n\n\n## 表格\n\n+ 由Excel和Markdown中生成LaTeX表格：http://www.tablesgenerator.com/tex_tables\n\n1. 符号说明(基础三线表)\n\n   ```tex\n   \\begin{table}[!htbp]\n   \\begin{center}\n   \\caption{Notations}\t\t\t\t\t\t\t% 表格标题\n   \\begin{tabular}{c|l}\t\t\t% 三线表格式('c'居中，'l'左对齐，'|'表示竖框线)\n   \t\\toprule\t\t\t\t\t\t\t\t% 上框线\n   \t\\multicolumn{1}{m{3cm}}{\\centering Symbol}\n   \t&\\multicolumn{1}{m{8cm}}{\\centering Definition}\\\\\n   \t\\midrule\t\t\t\t\t\t\t\t% 中框线\n       $\\rho$      &   the people density\\\\\n       $\\mathit{SD_i}$ & the spatial danger of the $i^{th}$ cellular\\\\\n       $v_i$       &   the velocity of the $i^{th}$ visitor\\\\\n       $\\overrightarrow{F_{Mi}}$   &   the attractive force (spatial danger and velocity) on the $i^{th}$ visitor\\\\\n       $\\overrightarrow{F_{ppi}}$  &   the people-to-people interaction force on the $i^{th}$ visitor\\\\\n       $\\overrightarrow{d_i}$  &   the expected movement direction the $i^{th}$ visitor\\\\\n   \t$\\alpha$ &the weight of the spatial danger and visitors’ velocity in $\\overrightarrow{d_i}$\\\\\n       $\\beta$ &the weight of interaction force between people in $\\overrightarrow{d_i}$\\\\\n       $p$ &   the ratio of the crowd decentralization\\\\\n       \\bottomrule\t\t\t\t\t\t\t\t%底框线\n   \\end{tabular}\\label{tb:notation}\n   \\end{center}\n   \\end{table}\n   ```\n\n\n\n2. 基础表格\n\n   ```tex\n   \\begin{table}[!htbp]\n       \\begin{center}\n       \\caption{Grey prediction accuracy registration}\n       \\begin{tabular}{c|ccccccc}\n           \\toprule\n           \\textbf{Year}   &2011 &2012 &2013 &2014 &2015 &2016 &2017\\\\\n           \\midrule\n           \\textbf{EV Amount} & 1000& 1800& 3000&5000&8000&15000&20000 \\\\\n           \\bottomrule\n       \\end{tabular}\\label{tb:Gray_Prediction}\n       \\end{center}\n   \\end{table}\n\t```\n\n3. 固定列宽表格\n\n   ```tex\n   \\begin{table}[!htbp]\n       \\begin{center}\n       \\caption{Normalized results of raw data for each indicator}\n       \\begin{tabularx}{32em}\t\t\t\t\t\t% 控制固定总列宽32em\n       {*{8}{>{\\centering\\arraybackslash}X}}\t\t% 8栏每栏表格居中\n           \\toprule\n           \\textit{C}\\textsubscript{1}  &\\textit{C}\\textsubscript{2} &\\textit{C}\\textsubscript{3}  &\\textit{C}\\textsubscript{4} &\\textit{C}\\textsubscript{5} &\\textit{C}\\textsubscript{6} &\\textit{C}\\textsubscript{7} &\\textit{C}\\textsubscript{8}\\\\\n           \\midrule\n           0.0833& 1.0& 0 &0.375& 1 &0.9326 &0.9067 &0 \\\\\n           \\bottomrule\n       \\end{tabularx}\\label{tb:Normalized_results}\n       \\end{center}\n   \\end{table}\n   ```\n\n4. 标题行分两类的表格\n\n   ```tex\n   \\begin{table}[!htbp]\n       \\begin{center}\n       \\caption{Metabolic rate of different Flying creatures in Static and Dynamic}\n       \\begin{tabular}{cccc}\n           \\toprule\n            \\multirow{2}{*}{Flying creatures} & \\multirow{2}{*}{Body weight (g)} &\\multicolumn{2}{c}{Metabolic rate (cal$\\cdot\\text{g}^{-1}\\cdot\\text{hr}^{-1}$)}\\\\\n            \\cmidrule{3-4}\n               & & Dynamic & Static\\\\\n           \\midrule\n           \\textbf{Parrot}    &    42&     106 &       15.4\\\\\n           \\textbf{Gull} &         345     &56      &  7.2\\\\\n           \\textbf{Bat} &          512&    60 &        6.9\\\\\n           \\textbf{Eagle} &        2117&   36 &        4.5\\\\\n           \\bottomrule\n       \\end{tabular}\\label{tb:Metabolic_rate}\n       \\end{center}\n   \\end{table}\n   ```\n\n   \n\n\n\n## 信件\n\n```tex\n% 以下为信件/备忘录部分，不需要可自行去掉\n% 如有需要可将整个 letter 环境移动到文章开头或中间\n% 请在后一个花括号内填写信件（Letter）或备忘录（Memorandum）标题\n\\begin{letter}{Memorandum}\n\\begin{flushleft}  % 左对齐环境，无首行缩进\n\\textbf{To:} Heishan Yan\\\\\n\\textbf{From:} Team XXXXXXX\\\\\n\\textbf{Date:} October 1st, 2019\\\\\n\\textbf{Subject:} A better choice than MS Word: \\LaTeX\n\\end{flushleft}\n\nIn the memo, we want to introduce you an alternate typesetting program to the prevailing MS Word: \\textbf{\\LaTeX}. In fact, the history of \\LaTeX\\ is even longer than that of MS Word. In 1970s, the famous computer scientist Donald Knuth first came out with a typesetting program, which named \\TeX\\ \\ldots\n\nFirstly, \\ldots\n\nSecondly, \\ldots\n\nLastly, \\ldots\n\nAccording to all those mentioned above, it is really worth to have a try on \\LaTeX! \n\\end{letter}\n```\n\n\n\n\n\n## 参考文献（MLA）\n\n1. 普通书籍\n\n   ```tex\n       \\bibitem{1} Venuti, Fiammetta, and Luca Bruno. \"Crowd-structure interaction in lively footbridges under synchronous lateral excitation: A literature review.\" \\emph{Physics of life reviews} 6.3 (2009): 176-206.\n       \\bibitem{6} Yuan, Weifeng, and Kang Hai Tan. \"An evacuation model using cellular automata.\" \\emph{Physica A: Statistical Mechanics and its Applications} 384.2 (2007): 549-566.\n   ```\n\n2. 博士论文\n\n   ```tex\n       \\bibitem{4} Kongjin Zhu. \\emph{Study on Evacuation Characteristics and Evacuation Strategy in Typical Rigions of buildings}. Diss. Hefei: University of Science and Technology of China, 2013.\n   ```\n\n3. 网站\n\n   ```tex\n       \\bibitem{3} \\emph{Charging Station}. (2019). Retrieved January 1, 2020, from\\url{https://en.wikipedia.org/wiki/Charging_station}\n   ```\n\n   \n\n## 代码高亮\n\n```tex\n\\noindent\\textsc{Part A} - \\textbf{lab021.m}\n\\lstinputlisting[language=matlab]{./code/lab021.m}\n```\n\n\n\n```tex\n\\begin{lstlisting}[language=vhdl]\nprocess(sel3) --根据音调编码，分配分频系数\nbegin\n    case sel3 is\n        when\"000\"=>count_ld<=\"0111011101110\"; --3822    -- 1(中音do!)\n        when\"001\"=>count_ld<=\"0000000110010\"; --50      -- 1(低音do)\n        when\"010\"=>count_ld<=\"0000000010100\"; --20      -- 2(低音re)\n        when\"011\"=>count_ld<=\"0000000001010\"; --10      -- 3(低音mi)\n        when\"100\"=>count_ld<=\"0000000000101\"; --5       -- 4(低音fa)\n        when\"101\"=>count_ld<=\"0000000000010\"; --2       -- 5(低音sol)\n        when\"110\"=>count_ld<=\"1000111000000\"; --4544    -- 6(低音la)\n        when\"111\"=>count_ld<=\"0111111010000\"; --4048    -- 7(低音si)\n        when others=>count_ld<=\"0111011101110\"; --3822\nend case;\nend process;   \n\\end{lstlisting}\n```\n\n","tags":["论文","数学建模"],"categories":["LaTeX and ..."]},{"title":"电磁场与电磁波公式整理","url":"/2020/07/31/Formulas-of-Electromagnetic-Field-and-Wave/","content":"\n# 电磁场与电磁波公式整理\n\n> 1. 以下是电磁场与电磁波的公式整理，如有错误欢迎在评论区指出。\n> 2. 电子版见👉[笔记整理部分](https://levitate-qian.github.io/2020/05/01/XDU-note/)电磁场与电磁波整理， **后续增减添补仅在电子PDF版中作修改，此处不再做改动。** 博客网站版截止更新至v1.1版本。\n> 3. 勘误：电阻的公式是 $R=\\frac{l}{\\sigma S}$\n\n\n\n## 场论与电磁模型\n\n1.  散度定理：$\\int_V\\nabla\\cdot\\boldsymbol{A}\\, \\mathrm{d}v=\\oint_s \\boldsymbol{A}\\, \\mathrm{d}\\boldsymbol{s}$\n2.  斯托克斯定理：$\\int_{S} \\nabla \\times \\boldsymbol{A} \\cdot \\mathrm{d} \\boldsymbol{s}=\\oint_{C} \\boldsymbol{A} \\cdot \\mathrm{d} \\boldsymbol{l}$\n3.  矢量恒等式：$\\nabla\\cdot(\\boldsymbol{E}\\times \\boldsymbol{H})=\\boldsymbol{H}\\cdot (\\nabla\\times \\boldsymbol{E})-\\boldsymbol{E}\\cdot(\\nabla\\times \\boldsymbol{H})$\n4.  球坐标\n\n    -   哈密尔顿算子：$\\nabla=\\hat{\\boldsymbol{r}} \\frac{\\partial}{\\partial r}+\\hat{\\boldsymbol{\\theta}} \\frac{1}{r} \\frac{\\partial}{\\partial \\theta}+\\hat{\\boldsymbol{\\phi}} \\frac{1}{r \\sin \\theta} \\frac{\\partial}{\\partial \\phi}$\n\n    -   梯度：$\\nabla u=\\hat{\\boldsymbol{r}}\\frac{\\partial u}{\\partial r}+\\hat{\\boldsymbol{\\theta}}\\frac{1}{r}\\frac{\\partial u}{\\partial \\theta}+\\hat{\\boldsymbol{\\phi}}\\frac{1}{r\\sin \\theta}\\frac{\\partial u}{\\partial \\phi}$\n\n    -   散度：$\\nabla\\cdot \\boldsymbol{A} =\\frac{1}{r^2}\\frac{\\partial(r^2 A_r)}{\\partial r}+\\frac{1}{r\\sin\\theta}\\frac{\\partial(\\sin \\theta A_\\theta)}{\\partial \\theta}+\\frac{1}{r\\sin\\theta}\\frac{\\partial(A_\\phi)}{\\partial \\phi}$\n\n    -   旋度：$\\nabla\\times\\boldsymbol{A}=\\frac{1}{r^{2} \\sin \\theta}\\left|\\begin{array}{ccc}\\hat{\\boldsymbol{r}} & r \\hat{\\boldsymbol{\\theta}} & r \\sin \\theta \\hat{\\boldsymbol{\\phi}} \\\\ \\frac{\\partial}{\\partial r} & \\frac{\\partial}{\\partial \\theta} & \\frac{\\partial}{\\partial \\phi} \\\\ A_{r} & r A_{\\theta} & r \\sin \\theta A_{\\phi}\\end{array}\\right|$\n\n    -   拉普拉斯算子：$\\nabla^{2} u=\\frac{1}{r^{2} \\sin \\theta}\\left[\\sin \\theta \\frac{\\partial}{\\partial r}\\left(r^{2} \\frac{\\partial u}{\\partial r}\\right)+\\frac{\\partial}{\\partial \\theta}\\left(\\sin \\theta \\frac{\\partial u}{\\partial \\theta}\\right)+\\frac{1}{r^{2} \\sin \\theta} \\frac{\\partial^{2} u}{\\partial \\phi^{2}}\\right]$\n5.  圆柱坐标\n\n    -   哈密尔顿算子：$\\nabla=\\hat{\\boldsymbol{\\rho}} \\frac{\\partial}{\\partial \\rho}+\\hat{\\boldsymbol{\\phi}} \\frac{1}{\\rho} \\frac{\\partial}{\\partial \\phi}+\\hat{\\boldsymbol{z}} \\frac{1}{r \\sin \\theta} \\frac{\\partial}{\\partial z}$\n\n    -   梯度：$\\nabla u=\\hat{\\boldsymbol{\\rho}} \\frac{\\partial u}{\\partial \\rho}+\\hat{\\boldsymbol{\\phi}} \\frac{1}{\\rho} \\frac{\\partial u}{\\partial \\phi}+\\hat{\\boldsymbol{z}} \\frac{1}{r \\sin \\theta} \\frac{\\partial u}{\\partial z}$\n\n    -   散度：$\\nabla\\cdot \\boldsymbol{A} =\\frac{1}{\\rho} \\frac{\\partial\\left(\\rho A_{\\rho}\\right)}{\\partial \\rho}+\\frac{1}{\\rho} \\frac{\\partial A_{\\phi}}{\\partial \\phi}+\\frac{\\partial A_{z}}{\\partial z}$\n\n    -   旋度：$\\nabla\\times\\boldsymbol{A}=\\frac{1}{\\rho}\\left|\\begin{array}{ccc}\n                \\hat{\\boldsymbol{\\rho}} & \\rho \\hat{\\boldsymbol{\\phi}} & \\hat{\\boldsymbol{z}} \\\\\n                \\frac{\\partial}{\\partial \\rho} & \\frac{\\partial}{\\partial \\phi} & \\frac{\\partial}{\\partial z} \\\\\n                A_{\\rho} & \\rho A_{\\phi} & A_{z}\n                \\end{array}\\right|$\n\n    -   拉普拉斯算子：$\\nabla^{2} u=\\frac{1}{\\rho} \\frac{\\partial}{\\partial \\rho}\\left(\\rho \\frac{\\partial u}{\\partial \\rho}\\right)+\\frac{1}{\\rho^{2}} \\frac{\\partial^{2} u}{\\partial \\phi^{2}}+\\frac{\\partial^{2} u}{\\partial z^{2}}$\n6.  本构参数\n\n    -   真空中磁导率　 $\\mu_0$：$4\\pi \\times 10^{-7}$ (H/m)\n\n    -   真空中的介电常数$\\varepsilon_0$：$\\frac{1}{36\\pi}\\times 10^{-9}=8.854\\times 10^{-12}$ (F/m)\n7.  光是电磁波（光速）：$c=\\frac{1}{\\sqrt{\\varepsilon_0 \\mu_0}}=3\\times 10^8$ (m/s)\n\n\n\n## 静电场\n\n1. 散度定理 \n$$ \\int_v \\nabla\\cdot \\boldsymbol{A} \\mathrm{d}v=\\oint_S \\boldsymbol{A}\\cdot \\mathrm{d}\\boldsymbol{s} $$\n\n2. 斯托克斯定理\n$$ \\int_S \\nabla \\times \\boldsymbol{A} \\cdot \\mathrm{d}\\boldsymbol{s}=\\oint_C \\boldsymbol{A}\\cdot \\mathrm{d}\\boldsymbol{l} $$\n\n3. 静电学基本公理\n\n   微分形式： \n $$               \\nabla \\cdot \\boldsymbol{E}=\\frac{\\rho}{\\varepsilon_0}$$\n$$               \\nabla \\times \\boldsymbol{E}=0 $$ \n 积分形式： \n $$               \\oint_S \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{s}=\\frac{Q}{\\varepsilon_0}$$\n $$               \\oint_C \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}=0$$\n4. 圆环轴线上的电场强度\n$$\n\\boldsymbol{E}=\\hat{z}\\frac{Qz}{4\\pi \\varepsilon_0(z^2+a^2)^{3/2}}\n$$\n5. 无限长线电荷的电场强度\n$$\n               \\boldsymbol{E}=\\boldsymbol{a}_r\\frac{\\rho_l}{2\\pi \\varepsilon_0r}\n$$\n6. 电场强度与电位的关系 \n$$\n               \\boldsymbol{E}=-\\nabla V\n$$\n7. 分布电荷的电位 \n$$\n               V=\\frac{q}{4\\pi \\varepsilon_0R}\n$$\n8. 多电荷产生的电位 \n$$ V=\\frac{1}{4\\pi \\varepsilon_0}\\sum_{k=1}^n \\frac{q_k}{|\\boldsymbol{R}-\\boldsymbol{R}'_k|} $$\n9. 导体表面的边界条件 \n$$\n               E_t=0\n$$\n\n$$\n               E_n=\\frac{\\rho_s}{\\varepsilon_0}\n$$\n10. 极化电荷密度\n    -   束缚电荷面密度：$\\rho_{ps}=\\boldsymbol{P}\\cdot \\boldsymbol{a}_n$\n\n    -   束缚电荷体密度：$\\rho_p=-\\nabla\\cdot \\boldsymbol{P}$\n11. 电通密度（电位移） \n$$\n                \\boldsymbol{D}=\\varepsilon_0\\boldsymbol{E}+\\boldsymbol{P}\n$$\n12. 静电场的边界条件\n\n    切向分量 \n $$ E_{1t}=E_{2t}  $$ \n 法向分量 \n $$ \\boldsymbol{a}_{n2}\\cdot(\\boldsymbol{D}_1-\\boldsymbol{D}_2)=\\rho_s $$\n13. 电容器 \n $$ C=\\frac{Q}{V} $$\n14. 同轴线电缆的电容 \n $$C=\\frac{Q}{V}=\\frac{2\\pi \\varepsilon L}{ln\\left(\\frac{b}{a}\\right)}$$\n15. 部分电容 \n $$C_{ii}=\\sum_{j=1}^{n}\\beta_{ij}$$\n $$C_{ij}=-\\beta_{ij},\\,i\\not=j$$\n16. 静电场的能量 \n $$            W_e=\\frac{1}{2}\\sum_{k=1}^N Q_k V_k$$\n $$ W_e=\\frac{1}{2}\\int_{V'}\\rho V \\mathrm{d}v $$ \n 场量表示： \n $$  W_e=\\frac{1}{2}\\int_{V'}\\boldsymbol{D}\\cdot\\boldsymbol{E}\\mathrm{d}v$$\n17. 能量密度 \n $$ w_e=\\frac{1}{2}\\boldsymbol{D}\\cdot\\boldsymbol{E}=\\frac{1}{2}\\varepsilon E^2 $$\n\n## 静电场问题的解\n\n1. 泊松方程 \n$$\n               \\nabla^2=-\\frac{\\rho}{\\varepsilon}\n$$\n\n$$\n               \\frac{\\partial^2 V}{\\partial x^2}+\\frac{\\partial^2 V}{\\partial y^2}+\\frac{\\partial^2 V}{\\partial z^2}=\\frac{\\rho}{\\varepsilon} (\\mathrm{V/m}^2)\n$$\n2. 拉普拉斯方程 \n$$\n               \\nabla^2 V=0\n$$\n3. 唯一性定理：满足给定*边界条件*的*泊松方程*(拉普拉斯方程是特例)的解唯一\n\n4. 镜像法：这种利用合适的镜像电荷代替边界面,代替正规的求解泊松方程和拉普拉斯方程的方法叫做镜像法。\n\n5. 分离变量法\n\n   \\(1\\) 边界条件\n\n   \\(2\\) 色散条件：$k_x^2+k_y^2+k_z^2=0$\n\n   \\(3\\) 方程$X''(x)+k_x^2X(x)=0$的解\n\n   ![方程的解](/方程的解.png)\n\n\n\n## 稳恒电流与静磁场\n\n1. （体）电流密度 \n$$\n               \\boldsymbol{J}=Nq\\boldsymbol{v}=\\rho \\boldsymbol{v}\n$$\n2. 总电流 \n$$\n               I=\\int_S \\boldsymbol{J}\\cdot \\mathrm{d}\\boldsymbol{s}=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}\n$$\n3. 欧姆定律（本构关系2） \n    $$\\boldsymbol{J}=\\sigma \\boldsymbol{E}$$\n\n4. 电阻 \n    $$R=\\frac{l}{\\sigma S}$$\n\n5. 静磁学的两个基本公理\n   \n|                | 微分形式                                           | 积分形式                                                     |\n| -------------- | -------------------------------------------------- | ------------------------------------------------------------ |\n| 磁通连续性原理 | $\\nabla\\cdot \\boldsymbol{B}=0$                     | $\\oint_S \\boldsymbol{B}\\cdot \\mathrm{d}\\boldsymbol{s}=0$     |\n| 安培环路定律   | $\\nabla\\times \\boldsymbol{B}=\\mu_0 \\boldsymbol{J}$ | $\\oint_S \\boldsymbol{B}\\cdot \\mathrm{d}\\boldsymbol{l}=\\mu_0$ |\n\n   \n\n6. 矢量磁位与磁通密度的关系\n$$\n               \\boldsymbol{B}=\\nabla\\times \\boldsymbol{A}\n$$\n7. 矢量旋度的旋度公式 \n$$\n               \\nabla \\times\\nabla\\times \\boldsymbol{A}=\\nabla(\\nabla\\cdot\\boldsymbol{A})-\\nabla^2\\boldsymbol{A}\n$$\n8. 矢量泊松方程 \n$$\n               \\nabla^2\\boldsymbol{A}=-\\mu_0\\boldsymbol{J}\n$$\n9. 矢量磁位 \n$$\n               \\boldsymbol{A}=\\frac{\\mu_0}{4\\pi}\\int_{V'}\\frac{\\boldsymbol{J}}{R}\\mathrm{d}v'\n$$\n10. 磁通量 \n $$\\begin{aligned}                \\varPhi=&\\int_S \\boldsymbol{B}\\cdot \\mathrm{d}\\boldsymbol{s}\\\\                \\varPhi=&\\int_S(\\nabla\\times \\boldsymbol{A})\\cdot \\mathrm{d}\\boldsymbol{s}=\\oint_C \\boldsymbol{A}\\cdot \\mathrm{d}\\boldsymbol{l}           \\end{aligned}$$\n11. 毕奥-萨伐尔定律 \n $$\\begin{aligned}                \\boldsymbol{B}&=\\frac{\\mu_0}{4\\pi}\\int_{V'}\\frac{\\boldsymbol{J}'\\times \\hat{R}}{R^2}\\mathrm{d}v'\\\\                &=\\frac{\\mu_0I}{4\\pi}\\oint_{C'}\\frac{\\mathrm{d}\\boldsymbol{l}'\\times \\hat{R}}{R^2}\\text{（线电流）}\\\\                 &=\\frac{\\mu_0}{4\\pi}\\int_{S}\\frac{\\boldsymbol{J}'_s\\times \\hat{R}}{R^2}\\mathrm{d}s\\text{（面电流）}           \\end{aligned}$$\n12. 磁偶极子 \n $$ \\boldsymbol{A}=\\hat{\\phi}\\frac{\\mu_0Ib^2}{4R^2}\\sin \\theta\n                =\\frac{\\mu_0\\boldsymbol{m}\\times\\hat{R}}{4\\pi R^2}$$\n13. 磁场强度 \n $$ \\boldsymbol{H}=\\frac{\\boldsymbol{B}}{\\mu_0}-\\boldsymbol{M}\n                =\\frac{1}{\\mu}{\\boldsymbol{B}}$$\n14. 安培环路定律 \n $$ \\begin{aligned}                \\text{积分形式：}&\\oint_C \\boldsymbol{H}\\cdot \\mathrm{d}\\boldsymbol{l}=I\\\\                \\text{微分形式：}&\\nabla\\times \\boldsymbol{H}=\\boldsymbol{J}         \\end{aligned} $$\n15. 本构关系3 \n $$ \\boldsymbol{B}=\\mu_0(1+\\chi_m)\\boldsymbol{H}=\\mu_0\\mu_r\\boldsymbol{H}=\\mu\\boldsymbol{H} $$\n16. 静磁场的边界条件 \n $$\\begin{aligned}                \\text{$\\boldsymbol{B}$法向连续：}&B_{1n}=B_{2n}\\\\                \\text{$\\boldsymbol{H}$切向不连续：}&\\hat{n}\\times(\\boldsymbol{H}_1-\\boldsymbol{H}_2)=\\boldsymbol{J}_s            \\end{aligned}$$\n17. 自感\n\n    (1) 对于给定的几何形状选择适当的坐标系。\n\n    (2) 假设导线中的电流为$I$。\n\n    (3) 如果存在对称性，就根据安培环路定理，由$I$求$\\boldsymbol{B}$; 如果不存在对称性，就必须用毕奥－萨伐定律求$\\boldsymbol{B}$。\n\n    (4) 用积分方法，由$\\boldsymbol{B}$求出每一圈所交链的磁通中$\\varPhi=\\int_S \\boldsymbol{B}\\cdot\\mathrm{d}\\boldsymbol{s}$。其中$S$为面积，在该面积上$\\boldsymbol{B}$存在且与假设的电流交链。\n\n    (5) 用磁通量$\\varPhi$中乘以匝数，得到回路的磁链$\\varLambda$。\n\n    (6) 通过求比率$L=\\frac{\\varLambda}{I}$, 从而求出自感$L$。\n\n18. 静磁场的能量 \n $$ W_m=\\frac{1}{2}\\sum_{j=1}^{N}\\sum_{k=1}^{N}L_{jk}I_jI_k=\\frac{1}{2}\\sum_{k=1}^{N}I_k\\varPhi_k $$ \n\n 场量表示： \n $$ W_m=\\frac{1}{2}\\int_{V'}\\boldsymbol{A}\\cdot\\boldsymbol{J}\\mathrm{d}v'=\\frac{1}{2}\\int_{V'}\\boldsymbol{H}\\cdot\\boldsymbol{B}\\mathrm{d}v' $$\n\n19. 磁能密度 \n $$ w_m=\\frac{1}{2}\\boldsymbol{H}\\cdot \\boldsymbol{B}=\\frac{B^2}{2\\mu}=\\frac{1}{2}\\mu H^2 $$\n## 时变电磁场\n\n1. 法拉第电磁感应定律 \n $$\\begin{aligned}\n               \\text{积分形式：}&\\oint_C \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}=-\\int_s \\frac{\\partial \\boldsymbol{B}}{\\partial t}\\cdot \\mathrm{d}\\boldsymbol{s}\\\\\n               \\text{微分形式：}&\\nabla\\times\\boldsymbol{E}=-\\frac{\\partial \\boldsymbol{B}}{\\partial t}\n           \\end{aligned}$$\n    \n2. 连续性方程 \n $$\\nabla\\cdot \\boldsymbol{J}=-\\frac{\\partial \\rho}{\\partial t}$$\n\n3. 麦克斯韦方程\n\n   | 意义                 | 微分形式                                                     | 积分形式                                                     |\n   | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n   | 法拉第定律           | $\\displaystyle\\nabla\\times \\boldsymbol{E}=-\\frac{\\partial \\boldsymbol{B}}{\\partial t}$ | $\\displaystyle\\oint_C \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}=-\\frac{\\partial \\Phi}{\\partial t}=-\\int_s \\frac{\\partial \\boldsymbol{B}}{\\partial t}\\cdot \\mathrm{d}\\boldsymbol{s}$ |\n   | 安培环路定律         | $\\displaystyle\\nabla\\times \\boldsymbol{H}=\\boldsymbol{J}+\\frac{\\partial \\boldsymbol{D}}{\\partial t}$ | $\\displaystyle\\oint_C \\boldsymbol{H}\\cdot \\mathrm{d}\\boldsymbol{l}=\\int_s \\left(\\boldsymbol{J}+\\frac{\\partial \\boldsymbol{D}}{\\partial t}\\right)\\cdot \\mathrm{d}\\boldsymbol{s}$ |\n   | 高斯定理(导出)       | $\\nabla\\cdot \\boldsymbol{D}=\\rho$                            | $\\displaystyle\\oint_s \\boldsymbol{D}\\cdot \\mathrm{d}\\boldsymbol{s} =\\int_V \\rho \\mathrm{d}V =Q$ |\n   | 磁通连续性原理(导出) | $\\nabla\\cdot \\boldsymbol{B}=0$                               | $\\displaystyle\\oint_S \\boldsymbol{B}\\cdot \\mathrm{d}\\boldsymbol{s}=0$ |\n   | 电流连续性方程       | $\\displaystyle\\nabla\\cdot \\boldsymbol{J}=-\\frac{\\partial \\rho}{\\partial t}$ | $\\displaystyle\\oint_s \\boldsymbol{J}\\cdot \\boldsymbol{s}=-\\int_V\\frac{\\partial \\rho}{\\partial t} \\mathrm{d}V$ |\n   | 洛伦兹力方程         | $\\boldsymbol{F}=q \\boldsymbol{v} \\times \\boldsymbol{B}$      |                                                              |\n   \n   \n\n4. 本构关系 \n $$\\begin{aligned}\n               \\boldsymbol{D}&=\\varepsilon\\boldsymbol{E}\\\\\n               \\boldsymbol{B}&=\\mu\\boldsymbol{H}\\\\\n               \\boldsymbol{J}&=\\sigma \\boldsymbol{E}\n           \\end{aligned}$$\n    \n5. 限定形式的麦克斯韦方程组 \n $$\\begin{aligned}\n                   &\\nabla \\times \\boldsymbol{E}=-\\mu \\frac{\\partial \\boldsymbol{H}}{\\partial t} \\\\\n                   &\\nabla \\times \\boldsymbol{H}=\\boldsymbol{J}+\\varepsilon \\frac{\\partial \\boldsymbol{E}}{\\partial t} \\\\\n                   &\\nabla \\cdot \\boldsymbol{E}=\\frac{\\rho}{\\varepsilon} \\\\\n                   &\\nabla \\cdot \\boldsymbol{H}=0\n           \\end{aligned}$$\n    \n6. 电磁边界条件\n\n   切向分量（分界面上$\\boldsymbol{E}$的切向分量连续；有面电流时，$\\boldsymbol{H}$的切向分量不连续） \n $$\\begin{aligned}\n               \\hat{\\boldsymbol{n}}\\times (\\boldsymbol{E}_1-\\boldsymbol{E}_2)&=\\boldsymbol{0}\\\\ \n               \\hat{\\boldsymbol{n}}\\times (\\boldsymbol{H}_1-\\boldsymbol{H}_2)&=\\boldsymbol{J}_s\n           \\end{aligned} $$ \n   法向分量 \n $$\\begin{aligned}\n               \\hat{\\boldsymbol{n}}\\cdot (\\boldsymbol{D}_1-\\boldsymbol{D}_2)&=\\rho_s\\\\\n               \\hat{\\boldsymbol{n}}\\cdot (\\boldsymbol{B}_1-\\boldsymbol{B}_2)&=0\n           \\end{aligned}$$\n   \n7. 坡印廷定理------在任意时刻流入闭合面的总功率，等于由这个闭合面所包围的体积内电场储能和磁场储能的增加率与损耗的欧姆功率之和。 \n $$\\begin{aligned}\n               -\\oint_{s}(\\boldsymbol{E} \\times \\boldsymbol{H}) \\cdot \\mathrm{d} \\boldsymbol{S} &=\\int_{V}\\left[\\frac{\\partial}{\\partial t}\\left(\\frac{1}{2} \\boldsymbol{B} \\cdot \\boldsymbol{H}\\right)+\\frac{\\partial}{\\partial t}\\left(\\frac{1}{2} \\boldsymbol{D} \\cdot \\boldsymbol{E}\\right)+\\boldsymbol{J} \\cdot \\boldsymbol{E}\\right] \\mathrm{d} V \\\\\n               &=\\frac{\\partial}{\\partial t} \\int_{V}\\left(\\frac{1}{2} \\boldsymbol{B} \\cdot \\boldsymbol{H}+\\frac{1}{2} \\boldsymbol{D} \\cdot \\boldsymbol{E}\\right) \\mathrm{d} V+\\int_{V} \\boldsymbol{J} \\cdot \\boldsymbol{E} \\mathrm{d} V\n               \\end{aligned} $$ \n 一般介质的坡印廷定理 \n $$-\\oint_{s}(\\boldsymbol{E} \\times \\boldsymbol{H}) \\cdot \\mathrm{d} \\boldsymbol{S} =\\int_V \\left(\\boldsymbol{H}\\cdot\\frac{\\partial \\boldsymbol{B}}{\\partial t}+\\boldsymbol{E}\\cdot\\frac{\\partial \\boldsymbol{D}}{\\partial t}+\\boldsymbol{J} \\cdot \\boldsymbol{E}\\right)\\mathrm{d}V $$ \n 对于电场和磁场能量不增加的系统，即 \n $$-\\oint_s \\boldsymbol{S}\\cdot \\mathrm{d}\\boldsymbol{s}=P=I^2R$$\n8. 坡印廷矢量 \n $$\\boldsymbol{S}=\\boldsymbol{E}\\times \\boldsymbol{H}$$\n\n9. 场量复数形式$\\dot{\\boldsymbol{E}}(x,y,z)$与瞬时值$\\boldsymbol{E}(x,y,z,t)$的互转 \n $$\\boldsymbol{E}(x,y,z,t)=\\Re\\left[\\dot{\\boldsymbol{E}}(x,y,z)\\mathrm{e}^{\\mathrm{j}\\omega t}\\right]$$\n\n10. 时谐麦克斯韦方程组 \n $$\\begin{aligned}\n                    &\\nabla \\times \\boldsymbol{E}=-\\mathrm{j} \\omega \\mu \\boldsymbol{H} \\\\\n                    &\\nabla \\times \\boldsymbol{H}=\\boldsymbol{J}+\\mathrm{j} \\omega \\varepsilon \\boldsymbol{E} \\\\\n                    &\\nabla \\cdot \\boldsymbol{E}=\\frac{\\rho}{\\varepsilon} \\\\\n                    &\\nabla \\cdot \\boldsymbol{H}=0 \\\\ \n                    &\\nabla \\cdot \\boldsymbol{J}=-\\mathrm{j}\\omega \\rho\n            \\end{aligned}$$\n    \n11. 亥姆霍兹方程（波数$k=\\omega\\sqrt{\\mu\\varepsilon}$） \n $$\\nabla^2\\boldsymbol{E}+\\omega^2\\mu\\varepsilon\\boldsymbol{E}=0$$\n## 平面电磁波\n\n1. 无源波动方程 \n $$\\begin{aligned}\n               &\\nabla^2\\boldsymbol{E}-\\mu\\varepsilon\\frac{\\partial^2 \\boldsymbol{E}}{\\partial t^2}=0\\\\\n               &\\nabla^2\\boldsymbol{H}-\\mu\\varepsilon\\frac{\\partial^2 \\boldsymbol{H}}{\\partial t^2}=0\n           \\end{aligned}$$\n2. 平面电磁波基本概念\n\n   -   波阻抗：$\\eta=\\sqrt{\\frac{\\mu}{\\varepsilon}}=\\frac{\\omega\\mu}{k}=\\eta_0 \\sqrt{\\frac{\\mu_r}{\\varepsilon_r}}$（本征阻抗$\\eta_0=\\sqrt{\\frac{\\mu_0}{\\varepsilon_0}}=120\\pi$）\n\n   -   相速：$v_p=\\frac{\\omega}{k}=\\frac{1}{\\sqrt{\\mu\\varepsilon}}=\\lambda f$\n\n   -   波长：$\\lambda=\\frac{2\\pi}{k}$\n\n   -   波数：$k=\\omega\\sqrt{\\mu\\varepsilon}=\\frac{2\\pi}{\\lambda}$\n\n   -   频率：$f=\\frac{1}{T}=\\frac{\\omega}{2\\pi}$\n\n3. 复坡印廷矢量 \n $$ \\boldsymbol{S}=\\dfrac{1}{2} \\boldsymbol{E} \\!\\times\\! \\boldsymbol{H}^*   =\\dfrac{1}{2} \\hat{\\boldsymbol{x}} E_0 \\text{e}^{-jkz}  \\!\\times\\! \\hat{\\boldsymbol{y}} H_0^* \\text{e}^{jkz}   =\\dfrac{1}{2} \\hat{\\boldsymbol{z}} \\dfrac{|{E_0}|^2}{\\eta}   =\\hat{\\boldsymbol{z}} \\dfrac{E_{0m}^2}{2\\eta} $$ \n\n 对于无耗介质，它的实部为一周期内坡印廷矢量的平均值；如果媒质有损耗，复波印廷矢量将会是一个复数矢量，它的实部恰好等于电磁波在一个周期内的平均功率 \n $$\\boldsymbol{S}_{av}=\\Re\\left[\\frac{1}{2}\\boldsymbol{E}\\times \\boldsymbol{H}^*\\right]$$\n4. 任意方向传播的均匀电磁波 \n $$\\begin{aligned}\n               &\\boldsymbol{E}=\\boldsymbol{E}_0 \\text{e}^{-j \\boldsymbol{k}\\cdot \\boldsymbol{r}}\\\\ \n               &\\boldsymbol{H}=\\dfrac{1}{\\eta}\\hat{\\boldsymbol{k}}\\!\\times\\!\\boldsymbol{E} \\\\ \n               &\\hat{\\boldsymbol{k}}\\!\\cdot\\!\\boldsymbol{E}=0\\\\ \n               &\\hat{\\boldsymbol{k}}\\!\\cdot\\!\\boldsymbol{H}=0\n           \\end{aligned}$$\n    \n5. 导电介质中平面电磁波的基本概念\n\n   -   复介电常数：$\\varepsilon_c=\\varepsilon-j\\dfrac{\\sigma}{\\omega}=\\varepsilon(1-j\\dfrac{\\sigma}{\\omega\\varepsilon})$（损耗角正切：$\\dfrac{\\sigma}{\\omega\\varepsilon}$）\n\n   -   衰减常数：$\\alpha=\\omega \\sqrt{\\dfrac{\\mu\\varepsilon}{2}\\bigg(\\sqrt{1+\\Big(\\dfrac{\\sigma}{\\omega\\varepsilon}\\Big)^2}-1\\bigg)}$\n\n   -   相位常数：$\\beta= \\omega \\sqrt{\\dfrac{\\mu\\varepsilon}{2}\\bigg(\\sqrt{1+\\Big(\\dfrac{\\sigma}{\\omega\\varepsilon}\\Big)^2}+1\\bigg)}$\n\n   -   波阻抗：$\\eta_c \n                   = \\sqrt{\\dfrac{\\mu}{\\varepsilon_c}} \n                   = \\sqrt{\\dfrac{\\mu}{\\varepsilon}}\\bigg(1-j\\dfrac{\\sigma}{\\omega\\varepsilon}\\bigg)^{-1/2}\n                   = |{\\eta_c}| \\text{e}^{j\\theta}$\n\n6. 介质及其常数\n\n   | 介质类型                                      | 良电介质                                            | 不良导体                                                     | 良导体                                                       |\n   | --------------------------------------------- | --------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n   | 损耗角正切$\\dfrac{\\sigma}{\\omega\\varepsilon}$ | $\\approx 0$                                         | $\\approx 1$                                                  | $\\gg 1$                                                      |\n   | 衰减常数$\\alpha$                              | $\\dfrac{\\sigma}{2} \\sqrt{\\dfrac{\\mu}{\\varepsilon}}$ | $\\alpha=\\omega \\sqrt{\\dfrac{\\mu\\varepsilon}{2}\\bigg(\\sqrt{1+\\Big(\\dfrac{\\sigma}{\\omega\\varepsilon}\\Big)^2}-1\\bigg)}$ | $\\sqrt{\\dfrac{\\omega \\mu \\sigma}{2}}$                        |\n   | 相位常数$\\beta$                               | $\\omega \\sqrt{\\mu\\varepsilon}$                      | $\\beta= \\omega \\sqrt{\\dfrac{\\mu\\varepsilon}{2}\\bigg(\\sqrt{1+\\Big(\\dfrac{\\sigma}{\\omega\\varepsilon}\\Big)^2}+1\\bigg)}$ | $\\sqrt{\\dfrac{\\omega \\mu \\sigma}{2}}$                        |\n   | 波阻抗$\\eta$                                  | $\\sqrt{\\dfrac{\\mu}{\\varepsilon}}$                   | $\\eta_c     = \\sqrt{\\dfrac{\\mu}{\\varepsilon_c}}$             | $\\sqrt{\\dfrac{\\omega\\mu}{\\sigma}} \\text{e}^{\\text{j}\\pi/4}=     \\sqrt{\\dfrac{\\omega\\mu}{2\\sigma}} (1+\\text{j})$ |\n\n   \n\n   \n\n7. 集肤深度（振幅衰减到表面处的$\\frac{1}{e}$） \n    $$\\delta = \\dfrac{1}{\\alpha}=\\sqrt{\\dfrac{2}{\\omega\\mu\\sigma}}$$ \n     由振幅比例计算深度 \n     $$l=\\frac{1}{\\alpha}\\ln\\frac{|E_0|}{|E|}$$\n\n8. 良导体中的复坡印廷矢量 \n   $$\\boldsymbol{S}\n   =\\dfrac{1}{2} \\boldsymbol{E}\\!\\times\\boldsymbol{H}^{*} \n   = \\hat{\\boldsymbol{z}} \\,\\dfrac{1}{2} |{E_0}|^2 \\sqrt{\\dfrac{\\sigma}{\\omega\\mu}} \\,\\text{e}^{\\text{j}\\frac{\\pi}{4}} \\,\\text{e}^{-2\\alpha z} $$\n\n $z=0$此处的平均电磁功率密度，即导体内的传导电流造成的热损耗的时间平均值 \n $$\\boldsymbol{S}_\\text{av}|_{z=0} =P= \\hat{\\boldsymbol{z}} \\,\\dfrac{1}{2} |{E_0}|^2 \\sqrt{\\dfrac{\\sigma}{2\\omega\\mu}}$$\n\n9. 极化类型\n\n   -   线极化：$\\phi_x-\\phi_y=k\\pi$\n\n   -   圆极化：$E_{xm}=E_{ym}=E_m,\\ \\phi_x-\\phi_y=\\pm\\frac{\\pi}{2}$\n\n   -   椭圆极化：$E_x$和$E_y$及$\\phi_x$和$\\phi_y$为任意关系\n\n10. 极化旋向（迎着来波方向用X手螺旋）\n\n    -   $\\phi_x-\\phi_y>0$：逆时针-右旋\n\n    -   $\\phi_x-\\phi_y<0$：顺时针-左旋\n\n11. 理想导体垂直入射------驻波\n\n    入射波、反射波、合成波 \n\n     $$\\begin{gathered}\n                \\boldsymbol{E}_{i}=\\hat{\\boldsymbol{x}}E_{io}\\mathrm{e}^{-\\mathrm{j}kz}\\\\\n                \\boldsymbol{E}_{r}=-\\hat{\\boldsymbol{x}}E_{io}\\mathrm{e}^{\\mathrm{j}kz}\\\\\n                \\boldsymbol{E}_1=-\\hat{\\boldsymbol{x}}2\\mathrm{j}E_{io}\\sin(k_1z)\n            \\end{gathered} $$ \n\n    理想导体垂直入射参数与性质 \n     $$\\begin{gathered}\n                E_{io}+E_{ro}=0\\\\ \n                \\Gamma=\\frac{E_{ro}}{E_{io}}=-1\n            \\end{gathered}$$\n    \n12. 理想介质垂直入射------行驻波\n    入射波、反射波、透射波、合成波 \n\n     $$\\begin{gathered}\n                \\boldsymbol{E}_{i}=\\hat{\\boldsymbol{x}}E_{io}\\mathrm{e}^{-\\mathrm{j}k_1z}\\\\\n                \\boldsymbol{E}_{r}=\\hat{\\boldsymbol{x}}\\Gamma E_{io}\\mathrm{e}^{\\mathrm{j}k_1z}\\\\\n                \\boldsymbol{E}_{t}=\\hat{\\boldsymbol{x}}T E_{io}\\mathrm{e}^{-\\mathrm{j}k_2z}\\\\\n                \\boldsymbol{E}_1=\\hat{\\boldsymbol{x}} E_{io}(T\\ \\mathrm{e}^{-\\mathrm{j}k_z}+\\mathrm{j}2\\Gamma\\sin(k_1z))\\\\\n            \\end{gathered} $$ \n\n    理想介质垂直入射参数与性质 \n    \n     $$\\begin{gathered}\n                \\Gamma=\\frac{E_{ro}}{E_{io}}=\\frac{\\eta_2-\\eta_1}{\\eta_2+\\eta_1}\\\\\n            T=\\frac{E_{to}}{E_{io}}=\\frac{2\\eta_2}{\\eta_2+\\eta_1}\n            \\end{gathered} $$ \n\n    驻波比 \n     $$S=\\frac{E_{\\max}}{E_{\\min}}=\\frac{1+|\\Gamma|}{1-|\\Gamma|} $$ \n    \n    平均功率密度矢量 \n     $$\\begin{aligned}\n            &\\boldsymbol{S}_{av,i}=\\hat{\\boldsymbol{z}}\\frac{E_{io}^2}{2\\eta_1}\\\\ \n                &\\boldsymbol{S}_{av,r}=-|\\Gamma|^2\\cdot\\boldsymbol{S}_{av,i}\\\\\n                &\\boldsymbol{S}_{av,1}=(1-|\\Gamma|^2)\\cdot\\boldsymbol{S}_{av,i}\\\\ \n                &\\boldsymbol{S}_{av,t}=\\frac{\\eta_1}{\\eta_2}\\cdot|T|^2\\boldsymbol{S}_{av,i}\n            \\end{aligned}$$\n    \n13. 平面电磁波的斜入射（暂略）\n","tags":["电磁场与电磁波"],"categories":["课程向"]},{"title":"如何优雅的书写LaTeX论文","url":"/2020/07/21/latex-vscode/","content":"\n\n\n# TeX Live+VSCode+Sumatra PDF书写你的LaTeX论文\n\n> 📝更新：\n>\n> + 反向传播失败的问题见Polarnova同学在评论区的方法。(2021-12-21)，具体说明见[VScode+Latex+SumatraPDF反向搜索失败解决办法（Version 1.63） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/434142338)\n> + 【2025年3月】该方案现在已经太过时，已经不需要Sumatra PDF即可反向传播，可以直接将配置外置pdf阅读器的部分跳过，相关代码注释掉。直接采用vscode内置的pdf阅读器，采用ctrl/cmd+鼠标左键即可反向跳转。\n\nLaTeX是一个非常强大的文本排版软件，在科研论文中使用的尤其多。数模美赛最推荐的也是使用LaTeX编辑，有的出版社甚至只接受LaTeX的论文。最早我用的是CTEX套装，后来改到了TeX Live，但是LaTeX自带的各种编辑器真的丑到爆炸，作为一个”颜控“，不能该背景颜色，没有各种方便的提示，完全没法接受。后来我在网上看到，VSCode居然也可以作为LaTeX的编译器呃，然后我就心动了😜。经过各种磨难（包括但不限于外部阅读器失效，找不到开关，工作区设置每次打开文件都要修改……），我终于搭出了一个大致能用的LaTeX编辑环境。下面呢就把这个过程分享给大家。\n\n>**前提准备：**\n>\n>+ 安装好了VSCode。 *（这不用我教了吧）* 一个光秃秃的VSCode就可以了。\n\n\n\n## Step 1：安装$\\TeX\\ \\text{Live}$\n\n**书写LaTeX，我们当然需要一个编译环境，这里推荐TeX Live。这也是lshort里面推荐的TeX排版引擎。**\n\n> 选择那种TeX开发版？\n>\n> + 为什么不推荐CTEX套装呢？原因是CTEX已经过时了，他使用的是MikiTeX，但CTEX已经已经断更很久了，没能兼容一些新的特性。\n> + 至于TeX Live的下载当然是版本越新越好咯，这里我们以TeX Live 2020为例来演示其安装过程。\n\n至于TeX Live的下载我们可以在**CTAN**上下载，为了获取更快的下载速度，我们可以选择在[清华的开源镜像](https://mirrors.tuna.tsinghua.edu.cn/CTAN/systems/texlive/Images/)上下载。我们这里下载iso镜像文件。清华的镜像还是很快的，我在家差不多能跑到5 M/s的样子。\n\n![清华镜像](/清华镜像.png)\n\n下面开始正式安装TeX Live。\n\n1. 双击加载iso光盘文件，进入虚拟光盘。\n\n2. 右击`install-tl-windows`，并以管理员身份运行安装程序\n\n   ![texlive安装1](/texlive安装1.png)\n\n3. 进入TeX Live安装界面，我们可以选择安装的位置，我选择在D盘。该软件体积比较大，大约要6个GB左右。\n\n   ![texlive安装2-1](/texlive安装2-1.png)\n   \n   *（可选）* 我们可以点击下方的`Advanced`按钮，进入高级设置，选择我们需要的应用。我们可以`Customize`选项下来取消勾选不需要的宏包。**在电脑空间充足的前提下，推荐安装所有的宏包。**\n   \n   ![texlive安装2-2](/texlive安装2-2.png)\n   \n4. 多等一会，静候佳音。这个安装过程是很漫长的，大致需要一小时左右。\n\n\n\n## Step 2：安装Sumatra PDF\n\n在等待的过程中，我们不妨下载Sumatra PDF，这是一个很轻量的的PDF阅读器，但是它支持通过命令行代码**实现反向搜索**。\n\n我们可以在[官网](https://www.sumatrapdfreader.org/prerelease.html)下载这个软件，不推荐在微软商店下载。（这个下载可能需要科学上网）这个软件更新版本很多，这里提供一个在2020年7月21日最新的版本（v3.3.13082版本）的[下载地址](https://levitate.lanzous.com/iGnjQetdvvi)，大家可以有选择性地选择是否更新。安装时记得记住**安装路径**哦！\n\n> 突然发现我一直用的是预览版，难怪更新这么勤快，这里再给一个普通版的[网址](https://www.sumatrapdfreader.org/download-free-pdf-viewer.html)。\n\nSumatra软件的界面大致如下。\n\n![sumatra界面](/sumatra界面.png)\n\n下面我们来配置反向搜索的命令行。\n\n1. 看到左上方三横的菜单栏了吗，依次选择里面的`设置`->`选项`。也许我们能够看到下面的页面，当然设置反向搜索命令行的内容肯定是空的，但是如果出现了**设置反向搜索命令行**，那恭喜你，很方便的就能设置反向搜索。\n\n   ![sumatra选项1](/sumatra选项1.png)\n\n   你只需要在文本框中输入以下内容\n\n   ```\n   \"C:\\Users\\qcl\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\" \"C:\\Users\\qcl\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js\" -r -g \"%f:%l\"\n   ```\n\n   当然这两句代码要根据你VSCode的安装路径决定，如果你没有动过的话大致就是这样的路径。\n\n2. 如果你的软件没有出现**设置反向搜索命令行**，甚至没有出现`选项`，甚至没有出现`高级选项`，更甚至没有出现`设置`。别担心，不是软件出了问题，我们可以通过修改文本内容来解决。\n\n   + 我们在Sumatra PDF的安装路径下，应该能够找到名为”SumatraPDF-settings“的文本文档。（如果能找到高级选项，在高级选项中打开也就是这个文本文档。）\n\n     ![sumatra选项2-1](/sumatra选项2-1.png)\n\n   + 进入这个文档，在里面加入以下文字：\n\n     ```\n     InverseSearchCmdLine = \"C:\\Users\\qcl\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\" \"C:\\Users\\qcl\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\out\\cli.js\" -r -g \"%f:%l\"\n     EnableTeXEnhancements = true\n     ```\n\n这样反向搜索就配置完了。\n\n\n\n## Step 3：VSCode的加持\n\n前面的都是小case啦，真正的重头戏来了，那就是**VSCode**。\n\nVSCode是一款优质的轻量的编辑器，它的界面美观，插件丰富，可以应用于编写各种代码。我还配置过C语言环境、Python环境等等。我比较建议的是将每种语言放在一个工作区内，互不干扰，也能在不同时候编译不同的语言。\n\n### 3.1 安装LaTeX Workshop插件\n\n我们在VSCode的扩展商店中安装**LaTeX Workshop插件**，这差不多算是一个All-in-one插件了，它的功能非常丰富。\n\n![VSC-2](/VSC-2.png)\n\n安装完成后，随便打开一个 tex 源文件，代码已经可以高亮了。\n\n\n\n### 3.2 创建LaTeX工作区\n\n首先，我们先创建一个空文件夹。名称可以自己命名，**要求最好不含中文、空格**，分词可以使用下划线`_`来分词。（这点很重要，也是一个比较好的习惯吧）\n\n在VSCode中打开创建的文件夹，接着选择`文件`->`将工作区另存为`。\n\n![VSC](/VSC.png)\n\n我们把工作区保存在该文件夹目录下即可。\n\n\n\n### 3.3 配置工作区\n\n创建完工作区，我们就需要配置工作区，记住既然我们创建了工作区，那么所有的操作都在工作区内进行就可以了，切记不要去别的地方操作，那是没用的。\n\n我们将下述代码直接贴入`.code-workspace`文件中，下面我们再来谈谈这些代码的具体作用。（**记得修改路径哦！**）\n\n![VSC-3](/VSC-3.png)\n\n```json\n{\n\t\"folders\": [\n\t\t{\n\t\t\t\"path\": \".\"\n\t\t}\n\t],\n\t\"settings\": {\n\t\t\"latex-workshop.latex.tools\": [\n\t\t\t{\n\t\t\t\t\"name\": \"xelatex\",\n\t\t\t\t\"command\": \"xelatex\",\n\t\t\t\t\"args\": [\n\t\t\t\t\t\"-synctex=1\",\n\t\t\t\t\t\"-interaction=nonstopmode\",\n\t\t\t\t\t\"-file-line-error\",\n\t\t\t\t\t\"-pdf\",\n\t\t\t\t\t\"%DOCFILE%\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"pdflatex\",\n\t\t\t\t\"command\": \"pdflatex\",\n\t\t\t\t\"args\": [\n\t\t\t\t\t\"-synctex=1\",\n\t\t\t\t\t\"-interaction=nonstopmode\",\n\t\t\t\t\t\"-file-line-error\",\n\t\t\t\t\t\"%DOCFILE%\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"makeindex\",\n\t\t\t\t\"command\": \"makeindex\",\n\t\t\t\t\"args\": [\n\t\t\t\t\t\"%DOCFILE%.nlo\",\n\t\t\t\t\t\"-s\",\n\t\t\t\t\t\"nomencl.ist\",\n\t\t\t\t\t\"-o\",\n\t\t\t\t\t\"%DOCFILE%.nls\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"biber\",\n\t\t\t\t\"command\": \"biber\",\n\t\t\t\t\"args\": [\n\t\t\t\t\t\"%DOCFILE%\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"bibtex\",\n\t\t\t\t\"command\": \"bibtex\",\n\t\t\t\t\"args\": [\n\t\t\t\t  \"%DOCFILE%\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n\t\t\"latex-workshop.latex.recipes\": [\n\t\t\t{\n\t\t\t\t\"name\": \"xelatex🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"xelatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"xe->mkind->bib->xe*2🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"xelatex\",\n\t\t\t\t\t\"makeindex\",\n\t\t\t\t\t\"biber\",\n\t\t\t\t\t\"xelatex\",\n\t\t\t\t\t\"xelatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"pdf->mkind->bib->pdf*2🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"pdflatex\",\n\t\t\t\t\t\"makeindex\",\n\t\t\t\t\t\"biber\",\n\t\t\t\t\t\"pdflatex\",\n\t\t\t\t\t\"pdflatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"xe->bib->xe->xe🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"xelatex\",\n\t\t\t\t\t\"bibtex\",\n\t\t\t\t\t\"xelatex\",\n\t\t\t\t\t\"xelatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"biber🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"biber\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"pdflatex🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"pdflatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"pdf->bib->pdf->pdf🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"pdflatex\",\n\t\t\t\t\t\"bibtex\",\n\t\t\t\t\t\"pdflatex\",\n\t\t\t\t\t\"pdflatex\"\n\t\t\t\t]\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"name\": \"BibTeX🔃\",\n\t\t\t\t\"tools\": [\n\t\t\t\t\t\"bibtex\"\n\t\t\t\t]\n\t\t\t}\n\t\t],\n        \"latex-workshop.view.pdf.viewer\": \"external\",\n\t\t\"latex-workshop.view.pdf.ref.viewer\":\"external\", \n\t\t\"latex-workshop.showContextMenu\":true,\n\t\t\"latex-workshop.view.pdf.external.command\":{\n\t\t\t\"command\": \"C:/Users/qcl/AppData/Local/SumatraPDF/SumatraPDF.exe\",\n\t\t\t\"args\": [\n\t\t\t\t\"%PDF%\"\n\t\t\t]\n\t\t},\n        \"latex-workshop.view.pdf.external.viewer.command\": \"C:/Users/qcl/AppData/Local/SumatraPDF/SumatraPDF.exe\", \n        \"latex-workshop.view.pdf.external.viewer.args\": [\n\t\t\t\"%PDF%\"\n\t\t],\n\t\t\"latex-workshop.view.pdf.external.synctex.command\": \"C:/Users/qcl/AppData/Local/SumatraPDF/SumatraPDF.exe\", // 注意修改路径\n\t\t\"latex-workshop.view.pdf.external.synctex.args\": [\n\t\t\t\"-forward-search\",\n\t\t\t\"%TEX%\",\n\t\t\t\"%LINE%\",\n\t\t\t\"%PDF%\"\n\t\t],\n\t\t\"latex-workshop.latex.recipe.default\": \"lastUsed\",\n\t\t\"editor.wordWrap\": \"on\",\n\t\t\"latex-workshop.synctex.synctexjs.enabled\": false,\n\t\t\"latex-workshop.synctex.afterBuild.enabled\": true,\n\t\t\"latex-snippets.autoSuggestionOn\": true,\n\t}\n}\n```\n\n上述部分的代码呢，其实也来源于网络，但是用谁的都会出错，所以就被我改了一部分，下面讲讲具体的。\n\n1. `latex-workshop.latex.tools`这里面主要配置的就是各种编译方式，我们最常用到的就两种`xelatex`和`bibtex`（注意不是`biber`），有时候也会用到`pdflatex`。一开始，我一直都无法编译`.bib`的参考文献，原因就出在编译链使用的是`biber`，而非`bibtex`，所以我就改了。\n\n2. `latex-workshop.latex.recipes`这里面就是所谓的编译链了。我们知道LaTeX生成PDF的原理就是使用编译器进行编译。一般的文件我们只需要使用一次或两次`xelatex`即可编译成功；而当我们有含`.bib`的参考文献时，一般的编译链就变成，编译一次`xelatex`，一次`bibtex`，两次`xelatex`，也就是上述编译链中的`\"xe->bib->xe->xe🔃\"`。其他还给了一些编译链，大家可以按需取舍。值得注意的是，默认的编译链时最上面一条，所以我一般放的是单次执行`xelatex`编译。\n\n3. 下面主要的代码处理的就是利用外部PDF阅读器Sumatra所需要的代码了。**需要注意修改部分的路径**。\n   ❗值得注意的是：这个代码**可能会报错**，显示未使用最新的语法，但是使用最新语法后，每次重开一个文件都需要修改该工作区配置文件，不知道bug在哪里，所以我就保留了一条老的语法。具体的错误说明如下：\n\n   ![错误](/错误.png)\n   \n4. 还有一些别的我也不记得是什么了，就不解释了。(¬‿¬)略略略\n\n5. 还有一些其他设置，来自[参考文献1](https://zhuanlan.zhihu.com/p/38178015)\n\n   + LaTeX Workshop 默认保存的时候自动编译，如果不喜欢这个设置，可以添加以下代码进入设置区：\n   ```json\n    \"latex-workshop.latex.autoBuild.run\": \"never\",\n   ```\n   + 如果编译出错，插件会弹出两个很烦人的气泡，不喜欢的话可以在设置中添加以下代码：\n   ```json\n   \"latex-workshop.message.error.show\": false,\n   \"latex-workshop.message.warning.show\": false,\n   ```\n\n\n\n## Step 4：使用上述工具来书写你的文章吧(●'◡'●)\n\n首先，介绍一下LaTeX Workshop提供的常用工具吧！\n\n![VSC-4](/VSC-4.png)\n\n我常用的也就上面这几个\n\n+ 编译常用的两个编译链，我们可以直接单击`Bulid LaTeX Project`也是生成LaTeX文件啊！生成后会自动打开Sumatra PDF，我一般就让VSCode和Sumatra分布在屏幕的左右，方便工作。当然，我一般是ctrl+S保存就编译的，这个就看个人习惯了。\n+ 正向搜索使用synctex命令。我们选中LaTeX代码中的位置，再选择`SyncTeX from cursor`即可实现文章的正向搜索\n+ 在Sumatra PDF中双击文字，即可定位到tex代码中的相应段落。\n\n下图就是我一般的写LaTeX文章的桌面环境。\n\n![样例](/样例.png)\n\n\n\n## 后记\n\n> 这篇博客的内容想写了很久了，但是迟迟没有动笔，因为怕重装又配错了环境，导致直接没法用。今天也是鼓起勇气重装了一遍，也借此机会把电脑里的TeX Live 2019换成了2020版本，也把Sumatra从很老的版本更新到了13082版本。\n>\n> 如果大家还有什么问题的话，欢迎在评论区指出。我会尽我所能解答大家的问题，但我也是勉勉强强写出这篇博客，可能有很多不太清楚的地方。不足之处还有很多，希望大家见谅。\n\n\n\n## 参考文献\n\n1. Marvey.使用VSCode编写LaTeX[EB/OL].https://zhuanlan.zhihu.com/p/38178015\n\n\n\n\n\n","tags":["Vscode"],"categories":["LaTeX and ..."]},{"title":"LaTeX札记（三）：公式","url":"/2020/07/12/latex-note-03/","content":"\n# $\\LaTeX$札记（三）——公式\n\nLaTeX是使用写代码的方式来排版的，而这恰恰就是让我们写文章时候一心一意只关注文章内容的绝佳方法。LaTeX比起其他排版软件最大的优势就是它的**公式编辑**功能。它的公式同样是通过代码来编写的，使用起来比起Word里面的通过上下间距调，通过文本框和直线调、MathType（不用TeX的情况下）优雅好多。\n\n现在越来越多的公式编辑软件也加入了对于部分$\\TeX$的支持，例如\n\n+ MathType可以输入LaTeX代码啦，但是还是不能宏定义什么的；\n+ Word自带的公式也可以编辑LaTeX数学代码啦，就是在不改变原始Cambria Math的前提下，奇丑无比，但是大部分人不会改字体；\n+ 甚至网站也开始支持数学公式了，但是实现途径有所不同，网页上主要通过MathJax来实现，但是在代码方面是与LaTeX基本兼容的；\n\n但是即使这些其他的工具能够兼容LaTeX，但仅仅是兼容而已，LaTeX的数学公式编辑功能可不仅仅是编辑，它的**公式编号和对齐功能**也十分强大，具体的我会在下面的文章中谈到。\n\n> 文章主要包括两部分：\n>\n> + 正统的LaTeX公式编辑\n> + 奇奇怪怪LaTeX公式相关的工具和技巧\n\n\n\nLaTeX公式编辑其实只需要自己动手排版一篇文章，在排版的过程中，去不断的充实自己的代码库就可以啦！针对这个公式编辑，我还是只推荐lshort这份文档，基本上把最基础的公式编辑都讲到了，具体更复杂的bing一下，404一下就可以了。这里呢主要提的还是些奇淫技巧，一些平常不一定会碰到，但是遇到就很棘手的问题。\n\n公式编辑呢还是**熟能生巧的问题**，但是有些内容也不需要特别去背。那我手头的中文6.0版lshort来说，我觉得第四章别的部分看看就可，第52到55页（ 表4.4-表4.14）建议大家可以打下来放在手边，用到可以看看，用着用着就熟悉了。表4.2的内容（数学字母字体）其实有时候也是挺常用的。\n\n下面呢就来谈谈可能遇到的问题。\n\n\n\n## Part 0 准备\n\n首先在写作之前我们需要引用相关的宏包，最著名的当然就是AMS宏集。AMS 宏集合是美国数学学会(American Mathematical Society) 提供的对LATEX 原生的数学公式排版的扩展，其核心是amsmath 宏包，对多行公式的排版提供了有力的支持。此外，amsfonts 宏包以及基于它的amssymb 宏包提供了丰富的数学符号；amsthm 宏包扩展了LATEX 定理证明格式。这里介绍的许多命令和环境依赖于amsmath 宏包。\n\n（注意这边的引用是在sty文件中的引用，当放置到文中引用则应该改成`\\usepackage`）\n\n```tex\n\\RequirePackage{amsfonts,amsmath,amssymb} % AMS-LaTeX 符号、公式\n\\RequirePackage{amsthm}\n```\n\n\n\n## Part 1 公式的编写\n\n能够掌握lshort中的公式编辑其实已经完全足够了，这里只是提示几个杂项。\n\n### 粗斜体\n\n在国内，我们一般使用粗斜体表示向量、矩阵等，但是这个非常难打出来。\n\namsmath 提供了一个`\\boldsymbol `命令（由调用的amsbsy 宏包提供，这个宏包已经包括在上述package中了），在公式内部将一部分符号切换为粗体。\n\n```tex\n\\begin{align}\n    \\min &\\,J(\\hat{\\boldsymbol{u}})=\\left(\\boldsymbol{Y}_1-\\boldsymbol{B}\\hat{\\boldsymbol{u}}\\right)^T\\left(\\boldsymbol{Y}_1-\\boldsymbol{B}\\hat{\\boldsymbol{u}}\\right)\\\\\n    \\mathrm{s.t.} &\\,\\hat{\\boldsymbol{u}}=\\left(\\hat{a},\\hat{b}\\right)^T=\\left(\\boldsymbol{B}^T\\boldsymbol{B}\\right)^{-1}\\boldsymbol{B}^T\\boldsymbol{Y}_1\n\\end{align}\n```\n\n<img src=\"/粗斜体.png\" alt=\"粗斜体\" style=\"zoom:60%;\" />\n\n### 算符的使用\n\nLaTeX中的算符大多数是二元算符，除了直接用键盘可以输入的+、−、`*`、/，其它符号用命令输入，常用的有乘号× (`\\times`)、除号÷ (`\\div`)、点乘· (`\\cdot`)、加减号± (`\\pm`) / ∓(`\\mp`) 等等。更多的见表格。\n\n在LaTeX中，有部分函数是不需要通过例如`\\mathrm{}`来使其直立的，这些也被称为**算符**符号。LaTeX将数学函数的名称作为一个算符排版，字体为直立字体。其中有一部分符号在上下位置可以书写一些内容作为条件，类似于巨算符。不带上下限的算符最常见的就是三角函数、双曲三角函数等。带上下限的常用的有求极限、求确界、求最值等。利用算符`\\arg`和`\\min`或者`\\max`，就是我们熟悉的$\\arg \\min$等。\n\n![算符](/算符.png)\n\n\n\n### 行内公式中分数、巨算符的缩放\n\n在行内公式中，巨算符的上下标往往会被放置到右侧，同时分数（fraction）也会变小，那么如何来让巨算符显示其原来的大小呢？这里有两种方法。\n\n+ **利用巨算符、分数本身的缩放**\n\n  + 一般地，巨算符在行间公式显示成正常大小（求和Σ和求积Π的上下标显示在上下侧），而在行内公式则显示成缩小大小（求和Σ和求积Π的上下标显示在右侧）。我们可以通过巨算符本身就带有的`\\limits`（上下方）和`\\nolimits`（右方）来控制；\n  + 同时，分数也提供了比较方便的命令`\\dfrac`（正常大小），和`\\tfrac`（行内缩小版）。\n\n  我们可以使用这些限制字符来使得巨算符和分数在公式中也能显示正常大小。\n\n  这里给出一个例子\n\n  ```tex\n  \\begin{align}\n  \t\\min &\\,Z=\\sum_{i \\in \\mathbb{I}} \\sum_{j} \\in B(j)\\\\\n  \t\\mathrm{s.t.} &\\left\\{\\begin{array}{llll}\n  \t\t\\sum\\limits_{i \\in A(i)} V_i y_{ij} \\le \\sum\\limits_{j \\in A(i)} E_j x_j,\\\\\n  \t\t\\sum\\limits_{j \\in B(i)} y_{ij} \\ge 1, \\forall i\\in \\mathbb{I}, \\forall j \\in B(j), \\\\\n  \t\t\\sum\\limits_{i \\in A(i)} x_j \\ge 1, \\forall i \\in \\mathbb{I}, \\\\\n  \t\ty_{ij}\\le x_j, \\forall i\\in \\mathbb{I}, j\\in \\mathbb{J}. \\\\\n  \t\\end{array}\\right.\n  \\end{align}\n  ```\n\n  ![巨算符2](/巨算符2.png)\n\n+ **使用万能的`\\displaystyle`命令**\n\n  在行内公式出现前使用`\\displaystyle`命令，即可将行内公式完全转化为行间公式，不需要单独调整巨算符和分数的大小，但是行间距会有一定的问题，显得比较局促。\n  \n\n  ```tex\n  \\begin{equation}\\left\\{\\begin{array}{l}\n      \\theta_{1}=\\displaystyle\\frac{1}{L-2} \\sum_{i=1}^{L-2} \\Theta\\left(D_{i}, D_{i+1}\\right) \\\\\n      \\theta_{2}=\\displaystyle\\frac{1}{L-3} \\sum_{i=1}^{L-3} \\Theta\\left(D_{i}, D_{i+2}\\right) \\\\\n      \\theta_{3}=\\displaystyle\\frac{1}{L-4} \\sum_{i=1}^{L-4} \\Theta\\left(D_{i}, D_{i+3}\\right) \\\\\n      \\dots  \\\\\n      \\dots  \\\\\n      \\theta_{\\lambda}=\\displaystyle\\frac{1}{L-1-\\lambda} \\sum_{i=1}^{L-1-\\lambda} \\Theta\\left(D_{i}, D_{i+\\lambda}\\right)\n      \\end{array}\\right.\n      \\quad (\\lambda<L-1)\n  \\end{equation}\n  ```\n\n  ![巨算符3](/巨算符3.png)\n\n> ❗值得注意的是\n>\n> 1. 在array、cases等环境内同样被认为是行内公式\n>\n> 2. 这两者看似都是转化为行间公式其实是有所不同的，他们巨算符的大小是有区别的。\n>\n>    ![巨算符4](/巨算符4.png)\n>\n>    在文章中其实更加明显，使用`\\displaystyle`命令的巨算符完全是行间公式大小的，而使用`\\limits`命令的还是会比行间公式的略小一点。\n\n### 矩阵、数组\n\n#### 矩阵\n\n矩阵的类型有很多这里就不多加赘述的给出常见的矩阵类型了。amsmath 宏包还直接提供了多种排版矩阵的环境，包括不带定界符的matrix，以及带各种定界符的矩阵pmatrix（**(**）、bmatrix（**[**）、Bmatrix（**{**）、vmatrix（**|**）、Vmatrix（**||**）。\n\n这里再给出一种比较特别的矩阵，它的行列分别有行标和列标。\n\n```tex\n\\begin{equation}\\label{Eq:matrix}\n    \\bordermatrix{%\n           \t  & _{C_1}       & _{C_2}       & _{C_3}     &_{C_4}\\cr\n    _{C_1}    & 1            & \\frac{1}{2}  &3           & \\frac{1}{2}\\cr\n    _{C_2}    & 2            & 1            &4           & 1\\cr\n    _{C_3}    & \\frac{1}{3}  &\\frac{1}{4}   &1           &\\frac{1}{5}\\cr\n    _{C_4}    & 2            & 1            &5           & 1\n    },\\qquad\n    \\bordermatrix{%\n              & _{C_5}       & _{C_6}       & _{C_7}     &_{C_8}\\cr\n    _{C_5}    & 1            & \\frac{1}{5}  &2           & 2\\cr\n    _{C_6}    & 5            & 1            &4           & 4\\cr\n    _{C_7}    & \\frac{1}{2}  &\\frac{1}{4}   &1           & 1\\cr\n    _{C_8}    & \\frac{1}{2}  & \\frac{1}{4}  &1           & 1\n    }.\n\\end{equation}\n```\n\n![矩阵](/矩阵.png)\n\n#### 数组\n\n数组最常用的其实也就是一个构建大括号条件格式。基本格式再lshort上也有，摘录在这里。\n\n```tex\n\\[ |x| = \\left\\{\n\\begin{array}{rl}\n-x & \\text{if } x < 0,\\\\\n0 & \\text{if } x = 0,\\\\\nx & \\text{if } x > 0.\n\\end{array} \\right. \\]\n```\n\n![array](/array.png)\n\n```tex\n\\[ |x| =\n\\begin{cases}\n-x & \\text{if } x < 0,\\\\\n0 & \\text{if } x = 0,\\\\\nx & \\text{if } x > 0.\n\\end{cases} \\]\n```\n\n![cases](/cases.png)\n\n\n\n## Part 2 公式的对齐与编号\n\n公式的编号是针对行间公式来说的，在科技论文和相关书籍中，编号能我们快速找到上下文需要对应的公式，在LaTeX制作的PDF版文档中则更胜一筹，你要你正确使用交叉引用，轻轻一点你就找到需要的公式啦！\n\n### 基础中的基础\n\n行内公式一般利用`$`包裹即可。比如这个例子`$\\Delta=b^2-4ac$`，即$\\Delta=b^2-4ac$。\n\n单独成行的行间公式在LaTeX里由equation 环境包裹。equation 环境为公式自动生成一个编号，这个编号可以用`\\label `和`\\ref `生成交叉引用，amsmath 的`\\eqref `命令甚至为引用自动加上圆括号；还可以用`\\tag `命令手动修改公式的编号，或者用`\\notag `命令取消为公式编号（与之基本等效的命令是\\nonumber）。\n\n不带编号的行间公式有以下几种方式生成：\n\n+ 用`\\[`和`\\]`包裹\n+ 用双美元符号包裹，即`$$`和`$$`，这种在Markdown中是最常用的（Markdown仅支持采用美元符号引出LaTeX数学公式，使用单、双来区分行内和行间公式）\n+ 使用displaymath环境\n+ 使用`equation*`环境\n\n### 对齐与编号\n\n谈到对齐不得不说的就是align和gather两大家族环境（姑且成为家族）。align这类环境重点就是**按符号&对齐**，gather这类环境重要的就是**居中对齐**。说到这里大家可能还无法理解，看了后续的例子就懂啦。\n\n#### 基础例子\n\n基本的例子就是下面这两个\n\n1. **利用align环境使两个符号处对齐。**我们注意到公式在`&`符号处对齐了，而公示的换行则使用与表格类似`\\\\`换行。\n\n```tex\n\\begin{align}\na & = b + c \\\\\n  & = d + e\n\\end{align}\n```\n\n![align1](/align1.png)\n\n2. **利用gather环境进行公式的简单罗列。**有时候我们不需要按照等号或其他符号进行对齐，或者对齐后反而会使部分公式超出边距。（由于我不需要编号这里用的是gathered环境，其实也可以用`gather*`环境）\n\n```tex\n    \\[\\begin{gathered}\n        f(t-t_0)\\varepsilon(t-t_0)\\llra \\mathrm{e}^{-st_0}F(s)\\\\\n        (\\Re[s]>\\sigma_0)\n    \\end{gathered}\\]\n   % 下面这个形式与之等价\n    \\begin{gather*}\n        f(t-t_0)\\varepsilon(t-t_0)\\llra \\mathrm{e}^{-st_0}F(s)\\\\\n        (\\Re[s]>\\sigma_0)\n    \\end{gather*}\n```\n\n![gather1](/gather1.png)\n\n#### 2×3=6种派生环境\n\n他们两个分别可以派生出三种环境\n\n+ 不加任何后缀，即align环境和gather环境。\n  \n  + 已经囊括了数学环境，不需要在外层进一步添加类似equation环境等数学环境。\n  \n+ 加`*`后缀，即`align*`和`gather*`环境\n  \n  + 同样已经囊括数学环境，但是他不会对公式进行编号，即带`*`环境的最常见用法。\n  \n+ 加`ed`后缀，即aligned和gathered环境\n  \n  + **不包括数学环境**，需要在外面再套一层数学环境的壳。\n  \n  + 如果使用带编号的如equation环境，则变为多个公式共用一个编号。\n  \n    ```tex\n    \\begin{equation}\n    \\begin{aligned}\n    a &= b + c \\\\\n    d &= e + f + g \\\\\n    h + i &= j + k \\\\\n    l + m &= n\n    \\end{aligned}\n    \\end{equation}\n    ```\n  \n    ![align2](/align2.png)\n  \n  + 如果使用不带编号的如`\\[`和`\\]`包裹，则和带`*`环境完全一致。也就是上面我举得那个例子。\n  \n\n#### 归纳总结\n\n以下有部分摘自lshort。\n\n1. align 环境会给每行公式都编号。我们仍然可以用`\\notag `去掉某行的编号。在以下的例子，为了对齐加号，我们将分隔符放在等号右边，这时需要给等号后添加一对括号{} 以产生正常的间距：\n\n   ```tex\n   \\begin{align}\n   a ={} & b + c \\\\\n   ={} & d + e + f + g + h + i\n   + j + k + l \\notag \\\\\n   & + m + n + o \\\\\n   ={} & p + q + r + s\n   \\end{align}\n   ```\n\n   ![align3](/align3.png)\n\n2. align 还能够对齐多组公式，除等号前的`& `之外，公式之间也用`& `分隔：\n\n   ```tex\n   \\begin{align}\n   a &=1 & b &=2 & c &=3 \\\\\n   d &=-1 & e &=-2 & f &=-5\n   \\end{align}\n   ```\n\n   ![align4](/align4.png)\n   \n3. 多行对齐的且不需要编号的情况下，`\\[`+aligned环境和`align*`环境完全一致。\n\n4. 多行对齐带编号的情况\n\n   + 在使用多行公式**每行都需要编号时**使用基础的不加后缀的align和gather环境；\n   + 在多行公式**只有最后一行公式需要编号**时使用基础的不加后缀的align和gather环境，并使用`\\notag `去掉某行的编号；当然这种情况也可以使用multline环境（详情请参考刘海洋老师的《LaTeX入门》）\n   + 在**多行公式共用编号**的情况下，使用后缀`ed`环境辅以外部包裹equation环境。\n\n### 其他杂类\n\n此外我还遇到过的一些公式编号相关的内容在这边一并写一下。\n\n#### 共用主编号的子公式编号\n\n在电磁场中，电位函数的边界条件常常需要用到子公式这一概念，即(6a)，(6b)……。这里给出一个案例：\n\n```tex\n    \\begin{subequations}\n        \\begin{alignat}{1}\n            V(x,y,z)&=V(x,y),\\label{subeq:8a}\\\\\n            V(x,0)&=V_0 \\sin \\frac{3\\pi x}{a},\\label{subeq:8b}\\\\\n            V(x,\\infty)&=0,\\label{subeq:8c}\\\\\n            V(0,y)&=0,\\label{subeq:8d}\\\\\n            V(a,y)&=0.\\label{subeq:8e}\n        \\end{alignat}\n    \\end{subequations}\n```\n\n<img src=\"/subequations.png\" alt=\"subequations\" style=\"zoom:50%;\" />\n\n这里使用到的是subequations环境，他同样已经包括了数学环境，不需要在外面再套equation环境。同时我们还初次碰到了alignat环境，它的参数表示的是几栏的意思。\n\n> 这里写的内容都是我亲身碰到，并尝试过正确的方法。部分代码需要引用宏包，这里也不多说了。如果遇到其他的问题，不妨去刘海洋老师的《LaTeX入门》上找找，也可以在网络上找一找，这里不再多加赘述。\n\n\n\n---\n\n\n\n\n## Part 3 奇奇怪怪LaTeX公式相关的工具和技巧\n\n### 懒人工具、小白助手——Mathpix Snip\n\n同样地，在文章的最前面推荐一个工具，那就是大名鼎鼎的Mathpix Snip（👉[戳这边去官网](https://mathpix.com/)）。这个小软件可以实现截图转LaTeX公式，甚至它能够生成内联公式、行间公式等不同格式供你选择。\n\n使用方法如下：\n\n![mathpix1](/mathpix1.png)\n\n同时最近它还支持了许多新特性，比如\n\n![mathpix2](/mathpix2.png)\n\n但是美中不足的是，现在这个软件免费版每月只能识别50次，学生版凭学生邮箱可以识别100次。虽然有所限制，但是这个数量对于大部分不算特别常用人还是够用了。一般我只会在一些比较复杂的公式才用这个软件，简单的不如手撸代码😏。国产的部分OCR软件据说也有这样的功能了，我没用过，需要的同学可以到网上找找。\n\n\n\n### 好用的技能——MathType公式与LaTeX代码的互转\n\n有时候我们需要把别人在Word中写好的带有LaTeX公式文章贴到LaTeX里面，这就遇到了一个问题。MathType编辑的公式怎么贴过去呢。\n\n#### 笨办法\n\n一种比较笨的办法就是先在MathType里面设置好粘贴的选项，然后一个一个贴。具体操作就是\n\n+ 打开公式编辑器\n\n+ “预置”菜单中选择“剪切和复制预置“\n\n+ 在弹出的对话框中将对象选为”MathML或TeX“里面随便选一个就好\n\n  <img src=\"/mathtype1.png\" alt=\"mathtype1\" style=\"zoom:60%;\" />\n\n#### 好办法\n\n当然，我写博客怎么会就写这么一个本办法就出来招摇混骗呢，当然是有别的好办法咯。具体方法就是\n\n+ 选中需要转换的段落\n+ 按下键盘上的“Alt+\\\\”\n+ 奇迹发生了，一段可以直接贴到LaTeX里面的文章出现啦！\n\n<img src=\"/mathtype2.png\" alt=\"mathtype2\" style=\"zoom:60%;\" />\n\n### 奇怪的知识增加啦！——那么微信公众号里面能打LaTeX公式嘛\n\n<img src=\"/正经的知识.jpg\" alt=\"正经的知识\" style=\"zoom:67%;\" />\n\n> 众所周知，生活在蓝星的微信公众平台是一种很奇特的编辑器，他啥排版、美化功能都没有，只能靠排版功能孱弱的秀米、135编辑器加持，更不要说加上对于数学公式的支持了。微信公众号，性格强硬，谁都不能驯服它。不过，记录历史我们是专业的。冒着生命危险，我们有幸记录下了，人类早期驯服野生微信公众平台的珍贵影像。哦，看呀，这个编辑器正在想尽办法，加入微信公众平台对数学公式的支持呢！……这就是大自然的力量，这就是人类的伟大。\n>\n> ——人类早期驯服之微信公众平台（灵感来源：b站up主人类早期驯服）\n\n以上纯属胡扯，但是确实有一个编辑器在与微信公众平台的“不争”做着斗争，他就是Mdnice（👉[戳这边去看看](https://mdnice.com/)），他将数学公式转为矢量图放在微信公众平台中，比较好的解决了公众号的公式编辑问题。他还支持导出到知乎等平台。而且这个编辑器还有一个插件支持直接在微信平台编辑，保证公式的完整性。\n\n![mdnice](/mdnice.png)\n\n同时，mdnice的开始文档还是一个非常好的Markdown教学文案，想学Markdown的同学也可以看着那个文档学。一不小心关掉了，还可以再开哦。\n\n![mdnice2](/mdnice2.png)\n\n这边另外给出两篇使用mdnice编辑的公众号推文。是不是感觉很惊艳呢！我觉得全栈蓝这个主题真的很对我胃口。\n\n+ [书院小课堂 | 模电例题](https://mp.weixin.qq.com/s/Huf5XjPxiea7rtQNShJWoA)\n+ [书院小课堂 | 电磁场例题](https://mp.weixin.qq.com/s/mAFWPFsGrWyElko3L4vfjA)\n\n### 最后一个——在线LaTeX数学公式编辑器\n\n这是我在b站上看到的一个up主的在线LaTeX公式编辑器（👉[戳这边看](https://www.texlive.com/)），还有好多别的up主也安利过这个网站。没有具体用过，但觉得还是挺不错的。\n\n<iframe width=\"800\" height=\"450\" src=\"//player.bilibili.com/player.html?aid=838558395&bvid=BV14g4y1q7pb&cid=203131698&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n\n主界面是这样的\n\n![latexlive](/latexlive.png)\n\n## 参考资料\n\n1. CTEX 开发小组.一份（不太）简短的$\\LaTeX2\\varepsilon$介绍(中文版本：6.0)[EB/OL].https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf. 2018-09（最新的是2019-04的6.0.1版本）\n2. 刘海洋.LaTeX入门[M].北京：电子工业出版社.2013.\n3. Mathpix. https://mathpix.com/\n4. Mdnice. https://mdnice.com/\n5. 妈咪说MommyTalk. 如何优雅的编辑数学公式？LaTeX公式入门[V/OL].https://www.bilibili.com/video/BV14g4y1q7pb?from=search&seid=3393676273831028218. 2020-06-18/2020-07-12\n6. 在线LaTeX公式编辑器. https://www.texlive.com/","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"LaTeX札记（二）：表格","url":"/2020/07/06/latex-note-02/","content":"\n# $\\LaTeX$札记（二）——表格\n\n> $\\LaTeX$里排版表格不如Word等所见即所得的工具简便和自由，不过对于不太复杂的表格来讲，完全能够胜任。\n\n上述这句话来自lshort，确实如此，LaTeX的表格需要用比较复杂的代码来书写，这是很困难的。但是如果我们能学会几个宏包的基本用法，画画基础的三线表等还是问题不大的。所以，这边文章就来谈谈我目前遇到的各类表格和相应的解决方式。\n\n\n\n\n\n## 懒人工具、小白入门LaTeX表格的好帮手——Tables Generator\n\n首先， **在最前面推荐一个网址👉[Tables Generator](https://www.tablesgenerator.com/latex_tables)，用了它至少能节省你90%写表格的时间，也能解决90%左右的问题。** 这是一个通过Excel和Markdown自动生成LaTeX表格的工具，他很强大。\n\n![tablegenerator](/tablegenerator.png)\n\n\n\n但是为什么说只能解决90%的问题呢，因为这个表格的一些功能还是不够完善的。\n\n1. 它的caption和label需要单独调出并使用。\n2. 同时针对一些最基本的三线表，他表现得没有这么出彩，有时候间隔会比较混乱。\n3. 需要先手动调整文本的对齐方式，不想直接撸代码，cccc就四列居中了。\n4. 毕竟是网络上的资源，所以表格的操作还是没有Word好用。\n\n当然以上这些只是吐槽，对于没有基础的小白来说，这个工具比直接写代码要好太多了。\n\n\n\n## 数据处理\n\n在LaTeX中，一般的我们用`&`作为间隔符号，用`\\\\`作为换行符，但是对于大批量的数据这样一个一个调整显然是很浪费时间的。所以这里有两个方法。我们可以利用Tables Generator或者Word来实现。\n\n### Tables Generator\n\n针对Tables Generator，我更倾向于把它作为一个**数据转换器**，把它当作一个将Excel和Markdown中表格数据转化为$\\LaTeX$中“&间隔”样式的转换器。它的优点很明显，它可以转化数据的同时，直接生成表格的LaTeX代码，虽然不完美，但能用。同时，它还支持从Markdown表格的转换。但是缺点也不是没有，由于服务器在国外，速度比较慢；同时只有英文界面，对英语渣不是很友好。\n\n### Word中的表格转文本功能\n\n这个方法在我们有Excel或者Word表格时非常好用。这里做一个简单的介绍。\n\n假设有如图所示的一张表格。\n\n![例子](/例子.png)\n\n**Step 1：将表格的间隔转化为&间隔。**\n\n+ 全选整张表格\n+ 选择“布局”工具栏\n+ 选择“转化为文本”\n+ 表格转化为其他字符，设置为`&`\n\n![Word数据处理1](/Word数据处理1.png)\n\n**Step 2：换行字符`\\\\`的处理**\n\n+ 开始菜单选择“替换”\n\n+ 查找内容和替换内容分别改为换行符`^p`和`\\\\^p`\n+ 选择全部替换\n+ 如果不嫌烦的话还可以把`&`替换为`（空格）&（空格）`这样能够方便后续的部分操作\n\n![Word数据处理2](/Word数据处理2.png)\n\n最后获得的LaTeX的&间隔的数据如下\n\n![Word数据处理3](/Word数据处理3.png)\n\n当部分情况下，最后一行不需要`\\\\`，这个可以视情况确定。\n\n\n\n## 表格基础\n\n终于讲到关键的表格类型部分了。比较全面的表格操作可以查看lshort，这里只讲几类常用的表格。\n\n### 预备\n\n在使用LaTeX的表格前我们当然需要先引入相应的宏包。这里给出我们美赛论文模板中（注意这边的引用是在sty文件中的引用，当放置到文中引用则应该改成`\\usepackage`）引用的表格相关的宏包。\n\n```tex\n\\RequirePackage{multirow}  % 列合并需要的宏包\n\\RequirePackage{array}\t   % 对齐相关的宏包\n\\RequirePackage{booktabs}  % 三线表宏包\n\\RequirePackage{tabularx}  % 自动平均分配列宽的宏包\n\\RequirePackage{longtable} % 跨页表格需要的宏包\n\\RequirePackage{tabu}      % 大表格需要的宏包\n\\RequirePackage{threeparttable} % 三段式表格，主要用于表格内引用\n```\n\n\n\n### 基础三线表\n\n在科研论文中最常用的还是三线表，这里给出一个简单的例子。\n\n![例子1](/例子1.png)\n\n```tex\n\\begin{table}[!htbp]\n    \\begin{center}\n    \\caption{Fitness of the three formations for the Huskies}\n    \\begin{tabular}{cccc}\n        \\toprule\n        Formation  & Coordination & Flexibility & Pressing\\\\\n        \\midrule\n        \\textsf{4-3-3}\t&5.1043\t&32.42\t&42.37\\\\\n        \\textsf{4-4-2}\t&6.0104\t&40.88\t&43.58\\\\\n        \\textsf{5-3-2}\t&7.5032\t&23.50\t&49.67\\\\\n        \\bottomrule\n    \\end{tabular}\\label{tb:Fitness_formations}\n    \\end{center}\n\\end{table}\n```\n\n首先，开启`table`环境，并将浮动体结构进行一定的设定，我一边选择的都是`！htbp`随便表格怎么浮动，但是有时候为了固定位置可以会引用float宏包中的浮动体设置`H`强制放置。\n\n接着，开启`center`环境，使表格居中。\n\n利用`\\caption`语句添加表头。`\\label`语句可以加在`\\caption`后面也可以跟在表格后面。\n\n接着，使用最基础的`tabular`环境制表，具体`tabular`的用法可以看lshort，在此不表。`tabular`环境使用*⟨column-spec⟩* 参数指定表格的列数以及每列的格式。基本的列格式见下表。\n\n![列格式](/列格式.png)\n\n由于我们已经引用过booktabs宏包，所以可以使用其中三线，即顶端的`\\toprule`，标题行和内容间的`\\midrule`，表格结束的`\\bottomrule`。值得注意的是，在这种表述情况下最后一行结束的地方务必出现`\\\\`，否则底端线的位置就在最后一行内容的后面了。\n\n这就是最基本的三线表的操作。\n\n### 关于列格式的其他操作\n\n列格式是一个比较重要的东西，这里我把lshort的部分内容附在这边，读者们可以参考。\n\n1. 表格中每行的单元格数目不能多于列格式里`l`/`c`/`r`/`p` 的总数（可以少于这个总数），否则出错。`@ `格式可在单元格前后插入任意的文本，但同时它也消除了单元格前后额外添加的间距。@格式可以适当使用以充当“竖线”。特别地，`@{} `可直接用来消除单元格前后的间距：\n\n   ![lshort1](/lshort1.png)\n\n   ```tex\n   \\begin{tabular}{@{} r@{:}lr @{}}\n   \\hline\n   1 & 1 & one \\\\\n   11 & 3 & eleven \\\\\n   \\hline\n   \\end{tabular}\n   ```\n\n2. 另外LaTeX还提供了简便的将格式参数重复的写法`*{⟨n⟩}{⟨column-spec⟩}`，比如以下两种写法是等效的：\n\n   ``` tex\n   \\begin{tabular}{|c|c|c|c|c|p{4em}|p{4em}|}\n   \\begin{tabular}{|{5}{c|}{2}{p{4em}|}}\n   ```\n\n3. 有时需要为整列修饰格式，比如整列改变为粗体，如果每个单元格都加上`\\bfseries `命令会比较麻烦。array 宏包提供了辅助格式`> `和`<`，用于给列格式前后加上修饰命令：\n\n   ![lshort2](/lshort2.png)\n\n   ```tex\n   \\begin{tabular}{>{\\itshape}r<{*}l}\n   \\hline\n   italic & normal \\\\\n   column & column \\\\\n   \\hline\n   \\end{tabular}\n   ```\n\n4. 辅助格式甚至支持插入`\\centering` 等命令改变`p `列格式的对齐方式，一般还要加额外的命令`\\arraybackslash` 以免出错。\n\n   ![lshort3](/lshort3.png)\n\n   ```tex\n   \\begin{tabular}\n   {>{\\centering\\arraybackslash}p{9em}}\n   \\hline\n   Some center-aligned long text. \\\\\n   \\hline\n   \\end{tabular}\n   ```\n\n5. array 宏包还提供了类似`p `格式的`m `格式和`b `格式，三者分别在垂直方向上靠顶端对齐、居中以及底端对齐。\n\n   ![lshort4](/lshort4.png)\n\n   ```tex\n   \\newcommand\\txt\n   {a b c d e f g h i}\n   \\begin{tabular}{cp{2em}m{2em}b{2em}}\n   \\hline\n   pos & \\txt & \\txt & \\txt \\\\\n   \\hline\n   \\end{tabular}\n   ```\n\n   \n\n\n\n## 表格进阶\n\n### 标题行分两类的三线表\n\n我们还经常会遇到标题内还有分类的三线表，比如下面这个例子。\n\n![例子2](/例子2.png)\n\n```tex\n% 需要引用需要用到multirow宏包\n\\begin{table}[!htbp]\n    \\begin{center}\n    \\caption{Metabolic rate of different Flying creatures in Static and Dynamic}\n    \\begin{tabular}{cccc}\n        \\toprule\n         \\multirow{2}{*}{Flying creatures} & \\multirow{2}{*}{Body weight (g)} &\\multicolumn{2}{c}{Metabolic rate (cal$\\cdot\\text{g}^{-1}\\cdot\\text{hr}^{-1}$)}\\\\\n         \\cmidrule{3-4}\n            & & Dynamic & Static\\\\\n        \\midrule\n        \\textbf{Parrot}    &    42&     106 &       15.4\\\\\n        \\textbf{Gull} &         345     &56      &  7.2\\\\\n        \\textbf{Bat} &          512&    60 &        6.9\\\\\n        \\textbf{Eagle} &        2117&   36 &        4.5\\\\\n        \\bottomrule\n    \\end{tabular}\\label{tb:Metabolic_rate}\n    \\end{center}\n\\end{table}\n```\n\n这张表格和普通三线表有一大重要区别，这张表的标题行跨行了。这就导致了两个问题\n\n+ 跨行后跨越部分单元格的横线怎么画？\n+ 其余的标题文字怎么对齐？\n\n由上述两个问题，这张表格比起基础三线表主要多了两个重要的语句。\n\n+ **合并单元格**，包括行合并和列合并。\n\n  在LaTeX中横向合并单元格较为容易，直接使用`\\multicolumn{列数}{对齐方式}{内容}`即可。而纵向合并单元格则需要用到multirow宏包，然后采用`\\multirow{列数}{宽度}{内容}`。这两个语句仅在第二个命令有所区别。在`\\multirow`中的宽度可以填`*`以使用自然宽度。\n\n+ **跨越部分单元格的横线**（在普通表格中一般采用`\\cline{⟨i⟩-⟨j⟩}`实现，而在三线表中则利用`\\cmidrule{⟨i⟩-⟨j⟩}`实现）\n\n  我们在标题行第一行结束后使用该语句即可画出相应的中间框线。\n\n> ❗值得我们注意的是，虽然我们使第一行前两个单元格实现了行合并的操作，但是LaTeX的编译逻辑是一行一行编辑的，所以标题行一行行我们仍然需要四个数据3个&，即使前两个为空。`   & & Dynamic & Static\\\\`\n\n\n\n### 三线表中添加其他框线\n\n在lshort是不建议在三线表中添加其他框线的，但是有时候我们为了表明第一列和其他列的不同或是表明列与列之间的关系又不得不添加一条框线，所以我们在三线表的列格式中还是可能会使用到竖线`|`。最常见的当然就是在数模论文的符号说明中需要添加框线咯！比如下面这个例子。\n\n![例子3](/例子3.png)\n\n```tex\n\\begin{table}[!htbp]\n\\begin{center}\n\\caption{Notations}\n\\begin{tabular}{c|l}\n\t\\toprule\n\t\\multicolumn{1}{m{3cm}}{\\centering Symbol}\n\t&\\multicolumn{1}{m{8cm}}{\\centering Definition}\\\\\n\t\\midrule\n    $L$& Total links of network \\\\\n    $\\rho$& Network Density \\\\\n    $w_{ij}$& Number of passes\\\\\n    $d_{ij}$& topological distance \\\\\n    $D$ & Network Diameter \\\\\n    $C(i)$& Clustering Coefficient\\\\\n    $f$ & ratio of goals to shots\\\\\n    $d$ & ratio of defenses to losses\\\\\n    $\\varphi$& Distribution of contributes\\\\\n    $t_b$&50-ball Passing Time\\\\\n    $\\mu_i$& Number of shots\\\\\n    $\\nu_i$& Number of defenses\\\\    \n    $S$ & Score of teamwork\\\\\n    $\\beta_i$ & Weight of indicators \\\\\n    $\\gamma$& Coordination among players\\\\\n    \\bottomrule\n\\end{tabular}\\label{tb:notation}\n\\end{center}\n\\end{table}\n```\n\n> ❗针对带竖框线的三线表我们一般会遇到两个问题\n>\n> 1. **竖线断了。**在使用三线表时，添加的竖框线确实会在标题行和内容之间断开.如果不想断开，不妨不使用三线表的语句，转而使用最为普通的`\\hline`。\n> 2. **竖线不见了**。由于这个竖框线是在列格式时候对于整个表格统一调整的，所以针对下面再次调整的表格样式，自然不会保留竖线。（这点也是我写这篇文章时候才想到的，美赛论文里搞得好丑的），比如我们可以把`\\multicolumn{1}{m{3cm}}{\\centering Symbol}`修订为`\\multicolumn{1}{m{3cm}|}{\\centering Symbol}`，竖线就出现了。\n\n\n\n### 定宽表格（总宽）\n\n在论文中我们还经常会遇到固定列宽的表格。有时候各个参数的关系确定的，但是他们的数据位数是不同的，这就导致自动匹配的表格列宽出现不一样的情况。那么如何来固定表格的列宽呢？在lshort中是这么说的：\n\n> 在控制列宽方面，$\\LaTeX$表格有着明显的不足：`l`/`c`/`r` 格式的列宽是由文字内容的自然宽度决定的，而`p`格式给定了列宽却不好控制对齐（可用array 宏包的辅助格式），更何况列与列之间通常还有间距，所以直接生成给定总宽度的表格并不容易。\n\n在书中也告诉了我们解决的办法，那就是使用tabularx 宏包。书上给的例子是排版一个定宽的全框线表格。\n\n![例子4.1](/例子4.1.png)\n\n```tex\n\\begin{tabularx}{14em}%\n{|*{4}{>{\\centering\\arraybackslash}X|}}\n\\hline\nA & B & C & D \\\\ \\hline\na & b & c & d \\\\ \\hline\n\\end{tabularx}\n```\n\n它引入了一个`X`列格式，类似`p`列格式，不过会根据表格**总**宽度自动计算列宽，多个X列格式平均分配列宽。X列格式也可以用array 里的辅助格式修饰对齐方式，例如`\\centering`（居中）、`\\raggedright` （右对齐）、`\\raggedleft`（左对齐）等。\n\n在看一个例子，就是位数不同导致文字内容的自然宽度不同的例子。\n\n![例子4.2](/例子4.2.png)\n\n```tex\n\\begin{table}[!htbp]\n    \\begin{center}\n    \\caption{Normalized results of raw data for each indicator}\n    \\begin{tabularx}{32em}\t\t\t\t\t\t% 控制固定总列宽32em\n    {*{8}{>{\\centering\\arraybackslash}X}}\t\t% 8栏每栏表格居中\n        \\toprule\n        \\textit{C}\\textsubscript{1}  &\\textit{C}\\textsubscript{2} &\\textit{C}\\textsubscript{3}  &\\textit{C}\\textsubscript{4} &\\textit{C}\\textsubscript{5} &\\textit{C}\\textsubscript{6} &\\textit{C}\\textsubscript{7} &\\textit{C}\\textsubscript{8}\\\\\n        \\midrule\n        0.0833& 1.0& 0 &0.375& 1 &0.9326 &0.9067 &0 \\\\\n        \\bottomrule\n    \\end{tabularx}\\label{tb:Normalized_results}\n    \\end{center}\n\\end{table}\n```\n\n这给出的就是一个完整的固定总宽三线表代码。\n\n> ❗值得注意的是\n>\n> 1. `\\centering`等对齐命令会破坏表格环境里\\\\ 换行命令的定义，`\\arraybackslash`用来恢复之。\n> 2. 表格总宽一般设的不能太大，40em已经超出页边距了\n\n\n\n### 长表格\n\n在部分论文中我们也不乏会出现跨多页的表格，我们通常把他放在附录中。这个例子，我们使用的是longtable环境。\n\n![跨多页表格](/跨多页表格.png)\n\n```tex\n   % 该表删除了部分内容\n   \\begin{center}\n        \\begin{longtable}{cccccc}\n            \\caption{The complete results of \\textbf{Task 1}}\n            \\label{tab:xxx} \\\\\n            \\toprule\n            DrugName&OH&WV&VA&KY&PA\\\\\n            \\midrule\n            \\tiny MT-45&\\tiny /&\\tiny /&\\tiny /&\\tiny /&\\tiny 42081\\\\\n            \\tiny Oxymorphone&\\tiny 39001, 39005, 39009&\\tiny 21015, 54039, 39107&\\tiny 21037, 51047, 51051&\\tiny 21009, 21015, 21029&\\tiny 42003, 42005, 42007\\\\\n            \\tiny o-Fluorofentanyl&\\tiny 39057, 39071, 39101&\\tiny /&\\tiny 51125, 51179&\\tiny /&\\tiny /\\\\\n            \\tiny 3-Fluorofentanyl&\\tiny /&\\tiny /&\\tiny 21073&\\tiny /&\\tiny /\\\\\n            \\bottomrule\n        \\end{longtable}\n     \\end{center}\n```\n\n\n\n\n\n## 综合应用\n\n这里给出我们美赛论文中的一张表作为结尾。这张表基本包含了上述讲到的大部分知识点。还在表格中加入了注释部分。\n\n![例子5](/例子5.png)\n\n```tex\n\\begin{table}[!htbp]\n    \\begin{center}\n    \\caption{Identification of performance indicators in 33 matches}\n    \\begin{threeparttable}\n    \\begin{tabularx}{40em}{p{1em}|*{2}{>{\\centering\\arraybackslash}X}|*{2}{>{\\centering\\arraybackslash}X}|*{2}{>{\\centering\\arraybackslash}X}|*{2}{>{\\centering\\arraybackslash}X}|*{2}{>{\\centering\\arraybackslash}X}|p{2em}}\n            \\toprule\n             \\multirow{2}{*}{ID}  &\\multicolumn{2}{c|}{Coordination}&\\multicolumn{2}{c|}{Distribution}&\\multicolumn{2}{c|}{Tempo}&\\multicolumn{2}{c|}{Flexibilty}&\\multicolumn{2}{c|}{Pressing}&\\multirow{2}{*}{\\small Result}\\\\\n             \\cmidrule{2-11}\n             &H\\tnote{***}&O&H&O&H&O&H&O&H&O&\\\\\n            \\midrule\n            1&7.61 &4.00 &62.25 &12.60 &539.50 &\\small 1476.57 &32.42 &28.58 &42.37 &51.23 &\\multicolumn{1}{c}{\\centering win}\\\\\n            2&2.88 &8.25 &28.71 &11.17 &\\small 1019.95 &692.49 &29.30 &27.34 &46.36 &49.81 &\\multicolumn{1}{c}{\\centering tie}\\\\\n            3&5.10 &9.00 &8.43 &34.17 &634.78 &596.98 &27.77 &27.03 &40.43 &52.02 &\\multicolumn{1}{c}{\\centering loss}\\\\\n            4&6.01 &5.66 &6.14 &62.40 &760.01 &934.64 &32.74 &31.94 &44.14 &51.62 &\\multicolumn{1}{c}{\\centering loss}\\\\\n            $\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&$\\vdots$&\\multicolumn{1}{c}{\\centering $\\vdots$}\\\\\n            30&5.61 &3.00 &62.25 &7.13 &707.96 &\\small 2018.52 &30.94 &30.18 &50.75 &58.75 &\\multicolumn{1}{c}{\\centering win}\\\\\n            31&\\textit{6.58}\\tnote{*} &4.21 &20.10 &13.87 &986.98 &\\small 1014.37 &32.53 &26.66 &44.20 &50.13 &\\multicolumn{1}{c}{\\centering win}\\\\\n            32\\tnote{**}&/&/&/&/&/&/&/&/&/&/&\\multicolumn{1}{c}{\\centering /}\\\\\n            33&\\textit{3.75}\\tnote{*} &3.35 &39.83 &21.90 &\\small 1159.30 &479.62 &29.43 &27.61 &51.34 &51.20 &\\multicolumn{1}{c}{\\centering tie}\\\\\n            \\bottomrule\n    \\end{tabularx}\n    \\begin{tablenotes}\n        \\footnotesize\n        \\item[*] We artificially adjusted the parameter value which the value is \\textit{italic}. %此处加入注释*信息\n        \\item[**] For too large deviation, we discard the 32\\textsuperscript{nd} match's data. %此处加入注释**信息\n        \\item[***] `H' for the Huskies, and `O' for the opponent. \n      \\end{tablenotes}\n    \\end{threeparttable}\\label{tb:performance_indicators}\n    \\end{center}\n\\end{table}\n```\n\n为了加入表格注释部分，这里我们使用了一个threeparttable宏包。\n\n+ `\\tnote`用于表格中注释；\n+ tablenotes环境中使用带标签的有序列表表示注释。\n\n我们可以通过下图看出其层次结构（画的很草率啊）\n\n```\ntable环境（表格环境）\n│\n└───center环境（整体居中）\n│   │   \\caption{}（表格名称）\n│   │   \\label{}（标签名称，用于引用）\n│   │\n│   └───threeparttable环境（三段表，可以使用表格注释）\n│       │\n│       └───tabularx环境（编辑定宽表格）\n|       |\n│       └───tablenotes环境（编辑注释信息）\nend\n```\n\n\n\n\n\n## 参考文献\n\n1.  CTEX 开发小组.一份（不太）简短的$\\LaTeX2\\varepsilon$介绍(中文版本：6.0)[EB/OL].https://mirrors.tuna.tsinghua.edu.cn/CTAN/info/lshort/chinese/lshort-zh-cn.pdf. 2018-09（最新的是2019-04的6.0.1版本）","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"MATLAB札记（一）：让图像动起来","url":"/2020/06/27/matlab-note-01/","content":"\n# MATLAB札记（一）——让图像动起来\n\n既然在$\\LaTeX$札记第一篇中谈到了在$\\TeX$文档中插入动图，我们就势必要先获取一组动图，当然格式可以有许多种，可以是有软件生成的GIF，也可以是录屏，或者是生成的视频。这篇文章主要讲的是如何在MATLAB中使用自带的库函数获取GIF。\n\n\n\n## 引入\n\n>众所周知，一般来说，我们在MATLAB中获得的图片是静态的。MATLAB能生成动态的图片是怎么回事呢？MATLAB相信大家都很熟悉，但是MATLAB能生成动态的图片是怎么回事呢，下面就让小编带大家一起了解吧。\n>\n>MATLAB能生成动态的图片，其实就是MATLAB能利用一些自带的库函数生成并保存为动态GIF图片，大家可能会很惊讶MATLAB怎么会能生成动态的图片呢？但事实就是这样，小编也感到非常惊讶。\n>\n>~~这就是关于MATLAB能生成动态的图片的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！（没有评论区）~~\n\n在使用MATLAB这个功能的过程中，找到的比较好的一篇博客是[参考文献1](https://www.jianshu.com/p/cd9501bc810a)，这篇文章写的不是特别细，但是一贴就能上手，挺好用的。也是因为讲解不是特别细，所以我做出来的图有点小问题。这里我会把我使用过程中发现的一些小问题，放在一起说。按照这篇文章的说法MATLAB绘制动态图主要用两种作用：\n\n+ 表现绘图过程，即图形的增长过程\n+ 表示一个参数对图形的影响\n\n我在电磁场实验中主要用到的是第一种，即表现绘图效果（图形增长过程的）。\n\n>+ Step 0：确定好绘图的函数\n>+ Step 1：让静态的变成动态的\n>+ Step 2：获得首帧画面\n>+ Step 3：绘图过程——循环\n>+ Step 4：将图像序列反向写入GIF文件中（可选）\n\n\n\n## 前期准备——原理\n\n在使用MATLAB制作动图的过程中，主要有两道工序：让图像动起来并让它延续不断、获取连续图像生成GIF文件。主要使用的函数有\n\n+ 让图像动起来并让它延续不断\n  + `getframe`和`moive`两个函数\n+ 获取连续图像生成GIF文件\n  + `frame2im`和`imwrite`\n\n当然以上的四个函数是我在电磁场实验3中使用的。\n\n### Step 0：确定好绘图的函数\n\n首先我们要确定好绘图函数，以及一些变量的初始化。\n\n比如在电磁场实验1B——磁聚焦实验中，我们需要有磁聚焦的函数。\n\n```matlab\ncos(theta).*t,sin(theta).*(cos(t-pi)+1),sin(theta).*sin(t-pi)\n```\n\n而在电磁场实验3——平面电磁波的反射和干涉实验中，我们先需要确定入射波和反射波的各项参数，并知晓入射波、反射波、合成波、透射波的方程。我们甚至可以画一个透明平面来表示介质分界面。下面是平面电磁波向理想介质垂直入射的相关前期准备。\n\n```matlab\n%% 初始参数设定\nE0=1;\t\t% The amplitude of the incident wave at z = 0\nk1=pi/2;\t% phase\n\n%% 波函数\nEi=E0.*cos( -k1.*z+(j./90).*pi);\t\t%入射波\nEr=-E0.*cos(k1.*z+(j./90).*pi)./3;\t\t%反射波\nEt=2*E0.*cos( -k2.*zt+(j./90).*pi)./3; \t%透射波\n```\n\n\n\n### Step 1：让静态的变成动态的\n\n首先，最关键的是我们要获得动图。获取动图我了解到的有两个办法：\n\n#### 法Ⅰ：不考虑生成GIF，只要求能在MATLAB中看到动效。\n\n比如在电磁场实验1中使用的彗星图`comet3`函数。彗星图是动画图，其中一个圆（彗星头部）跟踪屏幕上的数据点。彗星主体是位于头部之后的尾部。尾巴是跟踪整个函数的实线。`comet3(x,y,z)` 显示经过点 $[x(i),y(i),z(i)]$ 曲线的彗星图。但这个`comet3`函数暂没有找到什么比较好的获取GIF办法。下图时使用`comet3`函数获得的一个磁聚焦实验的图像。其基本动画函数为\n```matlab\nt=0:0.01:2*pi;\nfor theta=[-10:2:10]*pi/180;\ngrid on;\nhold on;\ncomet3(cos(theta).*t,sin(theta).*(cos(t-pi)+1),sin(theta).*sin(t-pi)); % 获得动态效果\nplot3(cos(theta).*t,sin(theta).*(cos(t-pi)+1),sin(theta).*sin(t-pi)); % 获得全图\nend\n```\n\n![lab01-2a](/lab01-2a.png)\n\n这种方法有利有弊，但弊大于利。主要问题就是他没法导出成比较有效果的GIF，导出成GIF需要获取动作每一帧的图像，而这个函数在绘制每一条线的时候的中间帧我们是无法获得的，硬性去套用获取GIF的函数，只能画出这样的图。\n\n![lab012](/lab012.gif)\n\n#### 法Ⅱ：利用堆叠关系，或者有动态效果的图。\n\n如果我们把曲线分成很多小段，让每个小段依次显示，我们是不是也能获得动态的图片呢？答案是肯定的，但是我们无法让图片一起显示*之前显示过的小段*和*当前我们所需要出现的小段*，所以这里我们不妨采用堆叠的关系，这是什么意思呢？请看下面的图片我们就能大致知道意思了（*第一次画这样的图，画的效果并不好*）\n\n![幻灯片1](/幻灯片1.PNG)\n\n**❗值得注意的是**：这里的小段只是我形象化的表现，而到对这些小段取极限，取到无穷小时，小段就变成了一个个的点。\n\n![幻灯片2](/幻灯片2.PNG)\n\n同理，我们的堆叠操作也是每次在前一张画面上生成一个点。\n\n这里我们选用的就是**法Ⅱ**。但是很显然法Ⅱ也会有一定的问题，我们最终得到的线其实是这么多线堆叠而成的，我们要对线条进行操作就会变得异常复杂。**尤其当我们需要导出最终图像的矢量格式时，甚至会出现断点问题，这点在有两条重叠线的情况下最甚。**请看下图“平面电磁波向理想导体垂直入射的仿真结果”。\n\n![黄蓝](/黄蓝.png)\n\n从图中我们显然能够发现，入射波和反射波的曲线重叠在了一起，而橙色的反射波点被掩盖在蓝色的入射波点下，但又有时会隐隐约约的透出来。\n\n\n\n## 关键步骤——利用函数写进GIF中\n\n### Step 2：获得首帧画面\n\n首先，根据需要，我们需要确定首幅图的样式，并指定标题，坐标轴标题等样式。（*这步可以省略*）\n\n接着，为确保图像在采集的过程中包括坐标轴及标题，并在在指定的范围内获得图像文件，我们需要下列代码。（*这段代码可以直接使用，不需要改动*）\n\n```matlab\n%确保图像在采集的过程中包括坐标轴及标题\nax = gca;\nax.Units = 'pixels';\npos = ax.Position;\nti = ax.TightInset;\nrect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n\n%在指定的范围内获得图像文件\nframe = getframe(ax,rect);\nim=frame2im(frame);\n```\n\n然后，创建gif文件，指定其样式，写入首帧图像。这里的`lab032.gif`就是我们生成GIF图片的名称，**注意下面和这个名称要对应哦**！\n\n```matlab\n%创建gif文件，指定其样式，写入首帧图像\nk = 1;\n%用胞元存储采集到的图像，方便后面反转图像用\n[I{k},map{k}]=rgb2ind(im,256);\nimwrite(I{k},map{k,1},'lab032.gif','gif','Loopcount',Inf,'DelayTime',0.2);\n k = k + 1;\n```\n\n> ❗值得注意的是\n>\n> + 一般的，如果你把Step 2写在循环中，就会循环往复的生成第一帧，而你的GIF就只剩两帧了。但是我们可以通过条件语句`if`去判定，当前处在哪一帧，`if(j==1)` 那么我们将运行绘制首帧的代码。同理，我们可以还可以在`if(j==1)` 中放置一些初始化的语句。\n> + 如果我们将上述代码放置在循环外，我们则需要注意考虑图像的持续显示，即`hold on`函数的使用。\n\n\n\n### Step 3：绘图过程——循环\n\n绘图过程我们可以把它放在一个`for`循环中。根据Step 1中所讲的，我们采用堆叠的方式去生成动态图像，，每一帧也就对应`for`循环中的一步，所以我们在`for`循环中每一步就需要生成从最原始点到目前帧需要出现画面的整条曲线。\n\n在循环中，我们首先绘制我们的图像，例如平面电磁波向理想介质垂直入射一些绘图函数代码的书写。（**程序的核心**）\n\n```matlab\n    % 绘图前预备\n    z=linspace ( -15 ,0 ,1000);\n    zt=linspace (0 ,15,1000);\n    y=zeros (1 ,1000);\n    \n    % 电场的入射波\n    \n    Ei=E0.*cos( -k1.*z+(j./90).*pi);\n    plot3(z,y,Ei ,'Color' ,[0.00,0.45,0.74],'LineWidth' ,1.5);\n    grid on\n    \n    % 电场的反射波\n    Er=-E0.*cos(k1.*z+(j./90).*pi)./3;\n    plot3(z,y,Er ,'Color' ,[0.85,0.33,0.10],'LineWidth' ,1);\n    \n    % 电场的透射波\n    Et=2*E0.*cos( -k2.*zt+(j./90).*pi)./3;;\n    plot3(zt ,y,Et ,'Color' ,[0.47,0.67,0.19],'LineWidth' ,1);\n    hold off\n```\n\n接着，我们再次获取该帧的GIF图像。（**获取GIF的核心**，*这段代码可以直接使用，不需要改动*）\n\n```matlab\n    %下面是制作gif的主要代码，除了调节间隔时间外，一般不需要改动 \n    ax = gca;\n    ax.Units = 'pixels';\n    pos = ax.Position;\n    ti = ax.TightInset;\n    rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n    frame = getframe(ax,rect);\n    im=frame2im(frame);\n    [I{k},map{k}]=rgb2ind(im,256);\n    %写入模式为“追加”模式\n    imwrite(I{k},map{k},'mygif.gif','gif','WriteMode','append','DelayTime',0.1);  \n    k = k + 1;\n```\n\n最后，我们对`for`循环进行+1操作，进入下一次循环。\n\n\n\n### Step 4：将图像序列反向写入GIF文件中（可选）\n\n这个就是坑到我的地方了。其实我的平面电磁波向理想介质垂直入射并不需要反向写入的过程。如果反向写入后，Step 2中法Ⅱ所对应GIF所表现出的时序就是下图这样的。\n\n![演示](/演示.png)\n\n有需要的读者可以使用下列代码。\n\n```matlab\n%将图像按相反的顺序再写入到gif中\nfor i = (k-1):-1:1\nimwrite(I{i},map{i},'mygif.gif','gif','WriteMode','append','DelayTime',0.1);  \nend\n```\n\n\n\n### 例子\n\n#### 〔案例1〕平面电磁波向理想介质垂直入射的仿真结果\n\n```matlab\n%% Normal incidence to ideal medium\nclear ,clc\nE0=1; % The amplitude of the incident wave at z = 0\nk1=pi/2;% phase\nk2=pi;% phase\n\n\n%% Draw the interface between lossless medium and conductor\nfor j=1:180\n    display(j);\n    z = linspace(-1.5,1.5,100);\n    y = linspace(-1.5,1.5,100);\n    x = 0.*repmat(z,100,1) + 10000.*repmat(y,100,1);\n    surf(z,y,x);\n    alpha(.3);\n    shading interp\n    hold on\n    plot3 ([-15 15],[0 0],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[-1.5 1.5],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[0 0],[-1.5 1.5],'k','LineWidth' ,1);\n    hold on\n    xlabel('$z$','FontSize',14,'Interpreter','latex');ylabel('$y$','FontSize',14,'Interpreter','latex');zlabel('$x$','FontSize',14,'Interpreter','latex');\n    grid on\n    set(gca ,'XLim' ,[-15 15]);\n    set(gca ,'YLim',[-1.5 1.5]);\n    set(gca ,'ZLim',[-1.5 1.5]);\n    if j==1\n        annotation('textbox',...\n            [0.433214285714286 0.278523812884377 0.17979066144921 0.0733333299727666],...\n            'String',{'$\\varepsilon_1,\\mu_1,\\sigma_1=0$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        annotation('textbox',...\n            [0.70 0.393761908122476 0.195266855927426 0.0733333299727666],...\n            'String',{'$\\varepsilon_2,\\mu_2,\\sigma_2=0$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        \n        annotation('textbox',[0.45 0.65 0.07 0.09],...\n            'Color',[0.00,0.45,0.74],...\n            'String',{'${\\vec E_i}$'},...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.23 0.43 0.07 0.09],...\n            'Color',[0.85,0.33,0.10],...\n            'String','${\\vec E_r}$',...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.73 0.45 0.07 0.09],...\n            'Color',[0.47,0.67,0.19],...\n            'String','${\\vec E_t}$',....\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        \n        % Preperation of gif\n        ax = gca;\n        ax.Units = 'pixels';\n        pos = ax.Position;\n        ti = ax.TightInset;\n        rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n        frame = getframe(ax,rect);\n        im=frame2im(frame);\n        k = 1;\n        [I{k},map{k}]=rgb2ind(im,256);\n        imwrite(I{k},map{k,1},'lab032.gif','gif','Loopcount',Inf,'DelayTime',0.1);\n        k = k + 1;\n    end\n    \n    % Preperation of drawing\n    z=linspace ( -15 ,0 ,1000);\n    zt=linspace (0 ,15,1000);\n    y=zeros (1 ,1000);\n    \n    % Electric field of incident wave\n    \n    Ei=E0.*cos( -k1.*z+(j./90).*pi);\n    plot3(z,y,Ei ,'Color' ,[0.00,0.45,0.74],'LineWidth' ,1.5);\n    grid on\n    \n    % Electric field of reflected waves\n    Er=-E0.*cos(k1.*z+(j./90).*pi)./3;\n    plot3(z,y,Er ,'Color' ,[0.85,0.33,0.10],'LineWidth' ,1);\n    \n    % Electric field of transmitted waves\n    Et=2*E0.*cos( -k2.*zt+(j./90).*pi)./3;;\n    plot3(zt ,y,Et ,'Color' ,[0.47,0.67,0.19],'LineWidth' ,1);\n    hold off\n%     N(j) = getframe;\n    \n    % Get GIF\n    ax = gca;\n    ax.Units = 'pixels';\n    pos = ax.Position;\n    ti = ax.TightInset;\n    rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n    frame = getframe(ax,rect);\n    im=frame2im(frame);\n    [I{k},map{k}]=rgb2ind(im,256);\n    imwrite(I{k},map{k},'lab032.gif','gif','WriteMode','append','DelayTime',0.1);\n    k = k + 1;\nend\n\n%% Write the image to the GIF in reverse order\nfor i = (k-1):-1:1\n    imwrite(I{i},map{i},'lab032.gif','gif','WriteMode','append','DelayTime',0.1);\nend\n\n%% Function to play animation\n% for i=1:2\n%     movie(N,1,30);\n% end\n```\n\n![lab032](/lab032.gif)\n\n>❗值得注意的是\n>\n>如果我们将制作GIF的代码注释掉转而保留\n>\n>```\n> N(j) = getframe;\n> %% Function to play animation\n> for i=1:10\n>     movie(N,1,30);\n> end\n>```\n>\n>我们就可让这个动画效果播放10遍。利用的就是`getframe`获取帧函数和`moive`播放函数了。\n\n\n\n#### 〔案例2〕$e^{it}=\\cos t+i\\sin t$\n\n来自[参考文献1](https://www.jianshu.com/p/cd9501bc810a)\n\n```matlab\n%适用于在一幅图中表现给图过程，即图形的增长过程\n\n%主要用来绘制三维的欧拉公式\nclc;clear;clf;close all;\n\n%获得数据\ntmax = 4*pi;\nt = 0:0.01:tmax;\ntmp = exp(1i*t);\nx = real(tmp);\ny = imag(tmp);\n[a,b] = size(x);\ny1 = zeros(a,b) ;\nx1 = zeros(a,b);\n\n%确定首幅图的样式，并指定标题，坐标轴标题等样式\nplot3(x(1,1),t(1,1),y(1,1),'black');\nhold on\nplot3(x(1,1),t(1,1),y1(1,1),'blue');\nplot3(x1(1,1),t(1,1),y(1,1),'r');\naxis([-1,1,0,tmax,-1,1])\nstr = ['$${e^{it}} = \\cos t + i\\sin t $$',char(13,10)','created by Lijunjie!'];\ntitle({str},'interpreter','latex')\nxlabel('实轴');\nylabel('时间轴');\nzlabel('虚轴');\ngrid on;\nset(gcf,'Position',[0,0,600,600], 'color','w');\nset(gca,'ydir','reverse')   %反转坐标轴\n\n%确保图像在采集的过程中包括坐标轴及标题\nax = gca;\nax.Units = 'pixels';\npos = ax.Position;\nti = ax.TightInset;\nrect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n\n%在指定的范围内获得图像文件\nframe = getframe(ax,rect);\nim=frame2im(frame);\n\n%创建gif文件，指定其样式，写入首帧图像\nk = 1;\n%用胞元存储采集到的图像，方便后面反转图像用\n[I{k},map{k}]=rgb2ind(im,256);\nimwrite(I{k},map{k,1},'mygif.gif','gif','Loopcount',Inf,'DelayTime',0.2);\n k = k + 1;\n \n %画图并采集到gif中\nsteptmp = 20;   %每幅图要画的点数\ni = steptmp;\nwhile i < (b-1)\n    x_1 = x(1,(i-steptmp+1):i+1);\n    t_1 = t(1,(i-steptmp+1):i+1);\n    y_1 = y(1,(i-steptmp+1):i+1);\n    y1_1 = y1(1,(i-steptmp+1):i+1);\n    x1_1 = x1(1,(i-steptmp+1):i+1);\n    plot3(x_1,t_1,y_1,'black');\n    hold on\n    plot3(x_1,t_1,y1_1,'blue');\n    plot3(x1_1,t_1,y_1,'r');\n    \n    %下面是制作gif的主要代码，除了调节间隔时间外，一般不需要改动 \n    ax = gca;\n    ax.Units = 'pixels';\n    pos = ax.Position;\n    ti = ax.TightInset;\n    rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n    frame = getframe(ax,rect);\n    im=frame2im(frame);\n    [I{k},map{k}]=rgb2ind(im,256);\n    %写入模式为“追加”模式\n    imwrite(I{k},map{k},'mygif.gif','gif','WriteMode','append','DelayTime',0.1);  \n    k = k + 1;\n    \n    i = i + steptmp;\nend\n\n%将图像按相反的顺序再写入到gif中\nfor i = (k-1):-1:1\nimwrite(I{i},map{i},'mygif.gif','gif','WriteMode','append','DelayTime',0.1);  \nend\n```\n\n![mygif](/mygif.gif)\n\n#### 〔案例3〕二阶系统的极点、频率特性\n\n来自[参考文献1](https://www.jianshu.com/p/cd9501bc810a)\n\n```matlab\nfunction second_order_system_gif_1()\n    %此种情况用来表示某个参数变化时，对相关图形的影响\n    %此函数用来表示当二阶系统的共轭极点的虚部变化时对系统的\n    %频率响应和阶跃响应的影响\n    %后期可以通过Ulead GIF Animator软件将这4张gif合并在一起\n    %问题：图像大小设置为某些值时，可能会出错，需要重新调整\n    \n    clc;clear;close all;\n    %初始化数据\n    b = 2;\n    a = 0:0.5:20;\n    [~,size_a] = size(a);\n    num = b.^2 + a.^2;\n    for i = 1:size_a\n        den{i} = conv([1 b + a(i) * 1i],[1  b - a(i) * 1i]);\n    end\n    w = 0:0.01:30;\n    k = 1;\n    %有多幅图，用胞元数组来指定文件名，从而方便在循环中使用\n    fieldnames = {'1.gif','2.gif','3.gif','4.gif'};\n\n    %画图，并制作gif\n    %由于每次画图都要擦掉上一次画的图，所以图形不能一直用hold on\n     for i = 1:1:size_a\n        %完成图像的绘制，为了保证效果，要保证图像大小以及\n        %坐标轴的范围不变\n        figure(1);\n         set(gcf,'Position',[0,0,300,400], 'color','w'); \n         \n         [hz,hp,ht] = zplane(num(i),den{i});\n         hold on;\n         x_data = [0 hp.XData 0];\n         y_data = [0 hp.YData 0];\n         plot(x_data,y_data,'--');\n         ylim([-22,22]);\n         xlim([-6,6]);\n         title(['二阶系统的极点',char(10,13)',...\n             'Created by Lijunjie']);\n         set(gca,'XTick',[-6:2:6]);\n         hold off\n        \n        %采集绘制频率响应的数据\n        h = freqs(num(i), den{i},w);\n        mag = abs(h);\n        phase = angle(h);\n        phasedeg = phase*180/pi;\n\n        figure(2)\n        picture_positon;\n        plot(w,mag);\n        grid on;\n        xlabel 'Frequency (rad/s)', ylabel Magnitude\n        ylim([0 5.5]);\n        xlim([0 30]);\n        title(['二阶系统的幅频特性',char(10,13)',...\n             'Created by Lijunjie']);\n        figure(3);\n        picture_positon;\n        plot(w,phasedeg);\n        xlabel 'Frequency (rad/s)', ylabel 'Phase (degrees)';\n        ylim([-200,0]);\n        xlim([0 30]);\n        title(['二阶系统的相频特性',char(10,13)',...\n             'Created by Lijunjie']); \n         \n         sys = tf(num(i),den{i});\n         figure(4)\n         [y_tmp,t_tmp] = step(sys,3.5);\n         plot(t_tmp,y_tmp);\n         picture_positon;\n         title(['二阶系统的阶跃响应',char(10,13)',...\n             'Created by Lijunjie']); \n         xlabel('Time(seconds)');\n         ylabel('Amplitude');\n         axis([0 3.5 0 2]);\n         \n        %制作pdf\n        if  i == 1\n            %采集到首帧，需要设置gif的样式，以及确定图像的大小\n            for j = 1:4\n                figure(j)\n                frame = getframe(gcf); % 获取整个窗口内容的图像\n                im=frame2im(frame);\n                [I{j,k},map{j,k}]=rgb2ind(im,256);\n                imwrite(I{j,k},map{j,k},fieldnames{j},'gif','Loopcount',Inf,'DelayTime',0.2);\n            end\n        else\n            for j = 1:4\n                figure(j)\n                frame = getframe(gcf);% 获取整个窗口内容的图像\n                im=frame2im(frame);\n                [I{j,k},map{j,k}]=rgb2ind(im,256);\n                %追加模式\n                imwrite(I{j,k},map{j,k},fieldnames{j},'gif','WriteMode','append','DelayTime',0.1);  \n            end\n        end\n        k = k + 1;\n     end\n     \n     %将采集到的图像以相反的顺序写入\n     for i = (k-1):-1:1\n         for j = 1:4\n             imwrite(I{j,i},map{j,i},fieldnames{j},'gif','WriteMode','append','DelayTime',0.1); \n         end\n     end\n \n    function picture_positon\n        %设置图像的大小\n       set(gcf,'Position',[0,0,600,400], 'color','w'); \n    end\n end\n```\n\n<img src=\"/1.gif\" alt=\"1\" style=\"zoom:67%;\" /><img src=\"/2.gif\" alt=\"2\" style=\"zoom:67%;\" />\n\n<img src=\"/3.gif\" alt=\"3\" style=\"zoom:50%;\" /><img src=\"/4.gif\" alt=\"4\" style=\"zoom:50%;\" />\n\n\n\n### 一些注意事项\n\n1. 这个功能搭配$\\LaTeX$札记第一篇，即可在$\\LaTeX$制作的PDF中播放动画效果了，还是很炫酷。\n2. 这样制作的图片清晰度还可以，但是还是图片质量存在一定的损失的，但是看上去还可以。\n3. 这样制作的图像最后获得矢量图，可能会存在一定的小问题：尤其当我们需要导出最终图像的矢量格式时，甚至会出现断点问题，这点在有两条重叠线的情况下最甚。\n4. 代码基本可以直接套用，需要更改的地方不是很多，建议看懂Step 4，再去使用反向写入功能，其实大部分情况下，我们是不需要反向写入的。\n\n\n\n## 参考文献\n\n1. 木子识时务.Matlab绘制动态 .gif 图\\[EB/OL\\].<https://www.jianshu.com/p/cd9501bc810a>.2017-08-20/2020-06-27. \n\n\n\n\n\n","tags":["MATLAB"],"categories":["LaTeX and ..."]},{"title":"【转】数学建模竞赛经验分享","url":"/2020/06/18/MCM-experience-sharing/","content":"\n# 数学建模竞赛经验分享\n\n> 由于双创周最后还是选了一门课，也比较有趣，所以别的文章啊之类的可能暂时咕咕咕了！等下周二以后咯！\n>\n> 这篇文章来源杨文昊，所以**第一视角是杨文昊（编程队友）**，有一定的改动。文章比较长，原来考虑分几篇，后来想想还是放在一起吧。下面贴上原文链接：\n>\n> + 👉[入门参与数学建模竞赛](https://www.alpha-yang.cn/2020/02/13/%E5%85%A5%E9%97%A8%E5%8F%82%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/)\n> + 👉[如何写出一篇高质量的数模竞赛答卷](https://www.alpha-yang.cn/2020/06/02/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AD%94%E5%8D%B7/)\n> + 👉[西电数模竞赛面试培训参赛经验汇总](https://www.alpha-yang.cn/2020/06/11/%E8%A5%BF%E7%94%B5%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E9%9D%A2%E8%AF%95%E5%9F%B9%E8%AE%AD%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/)\n> + 👉[数模竞赛备赛常用模型与算法](https://www.alpha-yang.cn/2020/06/13/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%A4%87%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/)\n\n![](https://s1.ax1x.com/2020/08/09/a7y0Xj.png)\n\n## 目录\n\n![目录](/目录.png)\n\n（最后有**西电数模竞赛国赛面试培训参赛经验**）\n\n\n\n## 前言：数模竞赛给我带来了什么？\n\n### 1.1 简历上的荣誉\n\n首先肯定是简历上的荣誉，大学生数模竞赛主要有两个认可度比较高的比赛，一是每年9月的国赛(全国大学生数学建模竞赛)，二是美赛(国际大学生数学建模竞赛)。各有各的专攻方向，之后也会详细说这两个比赛的区别。\n\n### 1.2 个人技能的提升\n\n在美赛培训当中，我们学习了许多对于科研非常有用但我原来懒得学的东西。如果不是数学建模，我们可能到现在也只能面向Bing和CSDN使用MATLAB，更不会使用像LaTeX这样的偏科研写作的专业排版软件。其实整个数模比赛3~4天的过程就是压缩了的科研经历，在这里我学会了大量英文文献的阅读和写作，快速学习模型与算法并应用的能力等等。确实数模真的给我能力的提升太多太多了，'*Math is always dependable*'。多学数学，不管你以后从事什么，你都不会吃亏。\n\n### 1.3 对于科研心态的转变\n\n数模比赛就是一次科研经历。在科研的道路上，遇到挫折几乎是绝对的事情，不可能有人说他的科研生涯都能顺风顺水，所有idea都能实现。在比赛的时候，对于模型无法实现，结果无法导出，你是否能以平和的心态去面对，确实是件需要锻炼的事情。除此之外，我相信大部分同学都一样，比赛的几天非常辛苦，于是就希望能拿到一个匹配甚至超过自己努力结果的成绩，这可没有因果关系。患得患失的心态就是很多大一同学的常态，不得不说这让人心很累，想得越多对自己的生活学习影响越大，你是否能以坦然的心态来面对呢？\n\n\n\n## 队伍组建：最最最重要的事情\n\n### 2.1 为什么重要？\n\n道理很简单，你的队友不一定要是一位大佬，但他需要愿意去学习，数模比赛最重要的东西就是**愿意去学习新的或者是你根本看不懂的知识**。初等模型，初等算法，论文写作架构，我相信这些是大家入门时必看的东西，然而三人一起学习的效果一定强于一个人学习。\n\n另外，你们的团队需要**早早地磨合好**，尽量不要中途有人退出，然后又找人进来。我打数模以来也接触了许多支队伍，能拿大奖的不一定要是三位大佬，有时候一个团结的队伍能爆发出更大的能量，我很幸运我能遇到两位志同道合的朋友，陪我一直坚持到了今天。\n\n### 2.2 专业可以适当考虑，但并不是决定性因素\n\n关于第二点，很多人在组队上都有一定的执念，希望建模队友是数统院的，编程队友是计算机院的，论文队友是经管学院的，而且团队最好男女搭配等等。个人觉得这些因素确实可以考虑，但不应该是你们的首要决定因素。我们的队伍三人均来自于电子工程学院，但是你在电院并不代表你不擅长计算机或者论文写作啊，这并没有必然联系。\n\n我认为还是**以愿意努力学习作为选队友的第一标准**。\n\n### 2.3 分工：建模、实现、写作\n\n数模比赛说到底就是让你解决一个实际问题，**建立模型、实现模型、论文写作**这就是比赛的流程，队友的职能也分为**建模、编程、论文**三个方向。简而言之，建模队友主要的工作是对于比赛的实际问题建立模型，将实际问题转化为数学问题。编程队友主要的工作是利用计算机软件求解建模队友转化的数字问题，例如方程等其他任何形式。而论文队友主要的工作是将建模与算法的过程与结果记录下来。三个方向缺一不可，个人觉得都十分重要。\n\n需要注意的是，各队友之间的职能其实也并没有那么明确的界限，比如编程论文队友也可以参与建模，建模队友也可以辅助编程查错或者完成指定模块任务，建模编程队友最后也一定会参与审稿写作修改等。你可以专精一个方向，但其他的方向你最好也要会，这么复杂的工作流程，更加说明了前期找队友的重要性，**认真努力才是你们找队友的第一指导性因素**。\n\n\n\n## 前期准备：完成一篇数模论文你需要知道…\n\n### 3.1 阅读优秀论文的重要性\n\n当大家把基础的模型算法(高级的需要靠自己不断积累，但是比赛现学完全来得及)都掌握的差不多的时候，真正能让大家脱颖而出的是，写作的成熟度。我们在看论文的时候，大多可以把论文分为两类。![论文的分类](/论文的分类.png)\n\n我们队伍在美赛和国赛培训的时候都会做的一件事情就是，大量阅读优秀论文，并将论文分类，将B类论文整理出来，把它们横向对比总结一遍，再和我们的对比总结一遍。虽然这次我们团队的大奖有运气成分，但我一定敢说，**阅读了大量美赛优秀论文，我们做了许多总结和整理**，是我们这次能得奖的重要前提。那下面我就来说说，我们团队对于数模比赛论文写作的目前可以提供给大家分享的经验。\n\n> 数模国赛、美赛部分优秀论文资源（👉[戳这边](https://levitate.lanzoux.com/b0de3dx0h)　密码:1yj6）\n\n### 3.2 论文架构\n\n所有数模论文都有它的套路和最基本的格式，问题分析，模型建立，结果分析，灵敏性分析等等文章必须按照这个来。以及各个部分应该**写什么，不能写什么**，论文长度的限制。\n\n当然可能你看个几篇文章就会发现一个问题，大家的结构怎么都不一样？确实有这个问题。产生这个问题的原因一般有两个方面：\n\n1. 大家整体思路框架是差不多的，只不过有些队伍进行了*微调*。\n\n2. 受*题目限制*，例如2018年国赛B题，注定了传统论文框架无法去写(这是个很烦的问题，清晰的论文逻辑思路是论文写作最关键的一点，遇到这种情况只能自己定合理的框架)。\n\n有时候我和学弟交流时也会发现，有些学弟的写作故意不按照套路来，想显得与众不同。关于这个想法，我想说是有极大的风险的。当然，在阅读优秀论文的过程中，确实也出现过这种情况，有些文章的结构其实我自己看都乱的快看不下去了，但是请大家注意一般这类文章能成为优秀论文可不是因为他的结构出彩，而是多半由于它的模型算法，也就是上文所提到的A类文章。对于大多数同学而言，还是老老实实按照思维的连贯性来吧，现在的比赛包括美赛在内，基本都是以四五个问题或四五个task的形式出现的，一个问题一个task对应一种模型算法，有时候可以连在一起解决。\n\n![论文架构](/论文架构.png)\n\n架构可以根据题目灵活调整，主要是调整模型的建立、求解、分析这块部分。这部分通常有两种情况：\n\n1. 一问一问分析，模型建立，算法求解，结果分析，如果嫌长也可以另起大标题。\n2. 先建立好几问模型，再算法，最后一起分析。\n\n再次强调，建议初次参加数模竞赛的同学们不要随便更改架构，在你的内容不突出的情况下，架构还十分乱，进而容易引起逻辑不清晰，是件糟糕的事情。\n\n### 3.3 文章篇幅\n\n+ 我这里先说说整篇文章的篇幅，论文页面控制在20页左右，不超过25页，不少于19页为好。（从摘要到参考文献）附录和代码不算在总页数中。20-23 页极佳。模型和算法的篇幅一定是大头，不要主次颠倒。\n  + 国赛一般可以23~25页左右。\n  + 美赛会有页数限制，一般是正文不超过20页，但最好不要少于19页。（*书信一般会给额外的两页，可以美观一些*）\n\n### 3.4 论文写作\n\n+ **摘要**一定一定要好好写，摘要直接影响老师给你论文的总分，摘要可以多读优秀论文来达到提高水平的目的。\n\n+ 问题背景，问题重述可以在选定题目后就完成，不必浪费太多时间。模型假设以及符号说明最后一天稍微整理一下就可以完成。\n\n+ 模型算法描述一定需要完整，且结合题目本身来进行建立与实现。千万不可脱离题目本身对模型算法进行具体的描述。\n\n+ **结果分析**需要特别重视结果图周围的结果分析，因为结果图是阅卷老师重点看的部分，如果这部分的分析很少或者不到位，会减去相当多的印象分。\n\n\n\n\n\n## 实战演练：从各种论文看注意事项\n\n### 4.1 摘要\n\n摘要当真是重中之重。老师看论文3 min能看什么呢？看摘要，看图，看结果分析。其他什么问题重述，背景，优缺点，推广，参考文献是很少有人看的。摘要一定是重中之重，建议对照往年优秀论文来写摘要。优秀论文的模型算法学不来，摘要还是一定要学的。由于时间原因，每次写摘要一般都是建模队友主笔，我们团队三个人一起修改一起写，并最终修订了十几遍的版本。\n\n---\n\n### 4.2 模型的建立\n\n+ 建立模型是数学建模比赛最重要的一个部分，在建立模型之前一定要多阅读相关文献以及相关书籍，所谓好事多磨，模型的建立在比赛中值得去花更多的时间。一般而言，很少存在题目可以直接套用初等模型的情况，基本上都要加以改变或者变化。\n\n#### 〔案例1〕模型建立\n\n+ 例如本次美赛我们D题的论文，对于四个任务我们建立了两个模型，分别是基于多指标的传球网络模型和基于对抗回归的评价模型。\n\n  ![模型建立案例](/模型建立案例.png)\n\n\n\n#### 4.2.1 优秀的模型具有怎样的特质\n\n+ 首先我们需要确认的是，国赛和美赛的模型都是可以简单的，可以不用那么复杂，比如2019美赛A题的优秀论文，就是用简单的模型去解决问题，并没有任何问题。但是即使简单的模型，也要考虑多方的因素，并不能简单到只考虑问题的一个方面。\n\n+ 比赛的时候一定可以查阅文献，注意不管是什么比赛，真的很少用书上的基础模型，如果你用了说明你的模型不够具有创新性。大家可以用搜索引擎根据问题去找更实用的模型，或者队伍水平高，可以自制创新想法的模型。\n\n+ 注意细节——细节能突出针对特定问题本质的数学的分析。\n\n#### 4.2.2 不同模型的关系应当如何处理\n\n+ 其次模型的复杂度采用**层层递进**的方法，逐一体现。比如我们Task1的模型，之后也能继续用，不过需要我们的继续改进。采用此方法，既能使文章循序渐进，也能更加合理地安排文章结构。\n\n+ 不要仅仅描述自己做了什么工作、怎么解决这个问题，而要升华一下：描述这个方法或结果说明什么问题、发现什么现象。总之要有自己的观点。模型不断改进，逐级推进，即**Basic model→Normal model → Extended model**。\n\n#### 4.2.3 模型应该如何描述\n\n+ 最后就是模型描述必须具体，即使再简单的模型，也需要结合你的具体问题来描述分析。建立模型可以大致分为几个重要步骤，问题分析即题目需要什么，模型描述即为什么这个模型可以解决此问题，模型量化建立即程式具体化的模型。\n\n  ![模型描述](/模型描述.png)\n\n+ 配合一些设计精巧的示意图等说明自己的建模动机、方法的原理等。有时这些idea用语言写出来不一定读者能真正理解。\n\n---\n\n### 4.3 算法的实现\n\n+ 我们首先明确算法的目的是为了求解模型，有的时候他也可以成为模型的重要组成部分。在赛前，我们需要整理各个题目常用算法的实现，这样可以节约比赛的时间，特别是像D题这样网络类的题目，从无到有的编程还是需要挺多时间的。\n\n+ 另外就是，好的算法可以直接提高模型和答卷的质量，例如国赛2018B题优秀论文的模型就是基于蒙特卡洛算法的。\n\n#### 〔案例2〕算法实现的反面案例\n\n+ 给大家举个例子，比如我们培训时国赛2018年A题练习训练，用来求解微分方程的一个算法*Crank-Nicholson*，我大概花了一个中午的时间，看懂了这个算法的意思(好像就是有限差分的变形)，然后我们写了文章。\n\n  ![算法实现反面案例](/算法实现反面案例.png)\n\n+ 如你们所见，对于微分方程模型的数值求解算法，我们就一句话就带过去了，这现在让我看来，可以直接说这个论文表述非常非常糟糕。这种情况下，一定要结合你本来的题目内容把这个算法怎么求解的过程给写清楚！\n\n#### 4.3.1 针对智能算法的一些看法\n\n+ 尽量不要使用遗传退火这些神棍算法，用不好也不一定好用，算法的话可以自己查找其他的算法，也可以平时看看非常经典以及常用的算法。\n\n+ 算法方面以模型求解的精确度为主，毕竟是数模建模竞赛，算法是用来解决模型求解的，当然有的时候算法也能直接充当模型构建的重要组成部分。还是那句话，数学这种东西，多学永远没坏处。\n\n#### 4.3.2 超重要：模型和算法的表述\n\n+ 这点我认为是数模比赛中最重要的一点，也是所有队伍包括大二大三都做不好的一点。就是模型和算法的表述，如果是别人的模型算法，千万不要直接搬到自己的论文里面来。我们要做的就是，模型和算法一定要结合我们的实际问题来叙述，要求较高，但是一定要注意。\n\n---\n\n### 4.4 插图以及结果图\n\n+ 这点就不用多说了吧，参加过数模竞赛的都知道，老师没有大家想的那么细致的去审阅你的文章，我们教练说看论文一共就3 min时间(可能还是多的，要是你们队伍写的论文不忍卒读，可能都没这个时间，直接低分看下一篇)，在这个情况下你如果全是大段文字叙述而没有图的话是一件非常吃力不讨好的事情，不光要有图，还要尽量做的丰富以及质量高。\n\n+ 结果图，可以用Matlab、Python 、PowerPoint和Excel 等来制作，请展开想象力，让结果图丰富以及好看起来。图表，折线图，柱状图，连续图谱都可以画一画。文字不够，图表来凑。插图，插图包括很多，热传导示意图，受力分析图，复杂算法流程图等。如果只有图片没有文字，那当然也是不行的，所以如何在25页内控制好比例，在有限的图表个数内让图表丰富以来，这些真的需要大家多看论文积累经验了。*关于制图方面有👉[单独的报告](https://levitate-qian.github.io/2020/05/04/10%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/)进行分析。*\n\n---\n\n### 4.5 结果分析\n\n+ 结果分析一定一定要到位，还记得我上面说的优秀论文的分类吗？所有优秀论文都逃不出一个共性，就是分析到位。这听上去很简单，不过能将这点做好的人并不多，包括在我后来参与的科研中。所以请大家记住论文的一个关键点，每当老师看到一张结果图的时候，他是看不明白的。这时候你一定要把你的分析写在结果图的上下，而且越多越详细越好。千万不要只有一张图和一行分析就了事了，此是论文大忌。\n\n#### 〔案例3〕结果分析的反面案例\n\n+ 再给大家举一个反例，例如2018A 结果分析，当时实在太年轻，一行字解决。\n\n  ![算法实现反面案例](/算法实现反面案例.png)\n\n+ 我们就画了一张图，然后一行字解决了分析，这让老师看到是非常糟糕的结果，老师会直接不知道你在干什么。对于本题，不光要画出温度分布图，还要分析变化的趋势，以及该分布图的特点。\n\n### 4.5.1结果分析的一些技巧\n\n1. 图表\n   + 建议使用三线表，这是科研论文中常用的一种表格。\n   + 图表建议多样、丰富。\n   + 同时切记要对你做的图表进行分析。\n>   + 【论文写作】去口语化与精准表达，审稿人看了都流泪　[BV1R7411279A](https://www.bilibili.com/video/BV1R7411279A)\n>   + 【论文排面】三种实验图对比法，博士看了都流泪　[BV1m64y1u73U](https://www.bilibili.com/video/BV1m64y1u73U)\n\n2. 论文中避免口语化的表述。\n>   + 【毕导】学渣的绝地求生！如何快速肝出一篇优秀的学术论文？[BV1Sg4y1q79G](https://www.bilibili.com/video/BV1Sg4y1q79G)\n\n---\n\n### 4.6 模型分析\n\n+ 灵敏性分析一般在论文结尾，也就是模型的分析那块，最好有，这绝对是加分项，需要有图有分析。图在美赛中可以稍微做的好看一点。\n  + 此外还有模型检验、误差分析、有效性分析、灵敏性分析、适用条件分析、横纵向对比等。\n\n+ 灵敏性分析是国赛美赛的加分项，使得文章论述更加严谨。经过我们分析多篇优秀论文，大家的灵敏性分析可不是随意写的部分，基本都是配合图表来体现的，也建议大家采用这样的方法。例如我们美赛的灵敏性分析，对两个因素分别进行了分析，制作了两张曲线图来表达可视化结果。\n\n#### 〔案例4〕灵敏性分析\n\n![灵敏性分析](/灵敏性分析.png)\n\n\n\n## 知根知底：美赛与国赛的异同点\n\n### 5.1 美赛竞赛题目\n\n3道MCM（数学类），3道ICM（交叉学科），每队6选1。\n\n<img src=\"/mcm_icm.png\" alt=\"mcm_icm\" style=\"zoom: 33%;\" />\n\n### 5.2 美赛写作排版\n\n1. 写作\n   + 应简洁扼要、条理清晰、流畅易读，将主要结果以最明显的方式表达出来。\n   + 多用短句，客观性描述，避免超长句、文学化。\n\n2. 排版\n   + 突出结构，美观合理，符合习惯。\n   + 详读5篇以上的不同类型的O奖论文，思考推进思路和行文结构，用排版突出论文结构以及模型框架，弥补语言写作方面的不足。\n\n### 5.3 摘要是重中之重\n\n+ 摘要——重中之重，决定能否进入第二轮评审。\n\n+ 突出亮点：论文能否获得最高奖的关键。\n\n+ 开篇第一句话（尤其重要）可以就问题本身出发，比如一句话概括问题的起因、发展趋势等，而不是直接以This paper或In this paper开头。\n\n+ 简明扼要描述解题方法，包括全部要点及主要思路，并阐明所得结论。不能有公式和表格。\n\n+ 无一句废话，每个词都要经历最仔细的斟酌；没有任何错别词或者语病；表达尽可能的地道；\n\n+ 摘要长度一般占大半页。\n\n### 5.4 美赛评审主要标准\n\n1. **摘要**的要素是否全面，是否符合要求。\n\n2. 对**赛题的解读**是否正确，是否澄清了问题中可能的模糊概念。\n\n3. 是否清晰地列出了建模所需要的**前提条件和假设**，对其**合理性**是否给出了令人满意的分析与论证。\n\n4. 是否分析给出了**建模动机和对模型的合理性**做了详实的论证。\n\n5. 是否设计出了能**有效解决**问題的**模型**。\n\n6. 是否模型的**稳定性和敏感性**做了分析检验。\n\n7. 是否讨论了模型的**优缺点**，并给出了明确的**结论**。\n\n### 5.5 国赛VS美赛\n\n1. 最大区别\n   + **国赛重结果，美赛重创新**\n   + 国赛不管怎么样你都要做出一个解答，有了解答什么都好说，心里也比较踏实，而美赛对于结果没有国赛那么看重，只要你的想法够创新，有依据，哪怕没有做出最后的结果，也是很有希望获奖的。\n\n2. 写作语言\n\n   + 美赛的论文是需要用英文写作的，所以怎么样把自己的论文写的尽量地道让评委看得懂，这点很重要。\n\n3. 数据处理\n\n   + 美赛相比国赛对于数据处理的能力要求更高，题目很少能够给出现成数据，大多数据都是要靠网上搜索得到。\n\n4. 图表界面\n\n   + 国赛一般我们程序的界面都是代码的原始界面，但是美赛的时候可用相关软件对界面做相关处理，做得更美观一点、花哨一点，对于美赛而言，不会认为你弄虚作假，只要程序的结果正确，界面的美观只是时间问题，这么做反而会使人认为你们更有能力。\n\n\n\n## 备赛经验：你可以在培训期间准备什么？\n\n### 6.1 数学模型的分类\n\n![模型分类](/模型分类.png)\n\n### 6.2 备赛：常用的模型与算法\n\n* **评价模型：** 层次分析、Topsis(优劣解距离法)、数据包络分析(DEA)、模糊综合评价、秩和比综合评价、主成分分析、灰色关联分析法\n* **预测分析模型：** 微分方程模型、差分方程模型、回归分析、时间序列、马尔可夫、神经网络、插值拟合、混沌序列预测、小波分析预测、灰色预测模型\n* **优化模型：** 数学规划模型（多目标、单目标、0-1整数规划等）、复杂网络优化、排队论与计算机仿真、图论、博弈论\n* **数理统计模型：** 多元分析（主成分分析、聚类分析、因子分析、判别分析、典型相关性分析等）、相关回归分析、假设检验、方差检验、贝叶斯统计\n* **分类与判别算法：** 距离聚类(系统聚类)、关联性聚类，层次聚类、贝叶斯分类与判别、SVM支持向量机、决策树、极限学习机\n* **重要的算法：** 蒙特卡罗算法、数据处理算法(数据拟合、参数估计、插值等)、规划算法(线性规划、整数规划、多元规划、二次规划等)、图论算法、计算机经典算法(动态规划、回溯搜索、分治算法、分支定界等)、最优化理论的三大非经典算法(模拟退火法、神经网络、遗传算法)、网格算法和穷举法、元胞自动机\n\n### 6.3 备赛：针对性训练\n\n+ 无论是国赛还是美赛，比赛前要确定大概的选题范围。比如这次美赛，我们赛前训练了2道D题，1道A题，1道C题，当然我们学校最擅长的也是C、D题。所以这次美赛前我们便确定了选题。\n\n+ 选定题目后，阅读往年优秀论文，可以是这个题目的也可以不是。请尽可能多地阅读，并且总结分析以及比较，人家能得大奖一定有他的原因，每阅读一篇优秀论文就把人家优秀的地方学过来，不断总结积累。\n\n+ 经过多次真题训练，比赛前整理一套属于自己队伍的LaTeX或者Word模板，比赛时候方便使用。\n\n+ 熟练使用各种查找文献，下载文献的办法，知网、谷歌学术、Sci-hub等等。\n\n\n\n## 备赛经验：软件学习与书籍推荐\n\n### 7.1 编程工具\n\n![编程](/编程.png)\n\n+ 不管是数模比赛还是以后做科研，MATLAB几乎是各专业必会的软件，提前学习总是没错的，我大一上花一周时间就学完了各种基本的操作，如矩阵命令，语法，解方程，画图等。对于比赛而言，大部分的方程求解，数据导出，结果图绘制都要靠MATLAB。这里我给大家推荐b站搜索MATLAB郭彦甫教程([av68228488](https://www.bilibili.com/video/av68228488/))，当年我就是看着这个教程入门的，很适合新手非常快。Python和C/C\\+\\+我就不多说了，在特定的时候，MATLAB的求解并不如Python和C\\+\\+这种语言方便，这次美赛我们的主代码就是靠的Python求解模型的。SPSS、Mathematics和Lingo我对于这三个软件的使用也只是轻度的，可能在特定的时候，比如规划我可能会使用Lingo，但三个软件并不作为你主要学习的东西，比赛的时候需要解决什么问题，直接搜索对应命令即可。\n\n### 7.2 写作工具\n\n+ 主流的写作软件就是这两个，国赛我们用的是Word，美赛是LaTeX，官方都认可。 LaTeX是需要学习成本的，如果你参加了几次培训和比赛并准备参加美赛，我会建议你去学习它，因为LaTeX使用起来确实方便很多，包括你以后写毕设和研究生文章都能给你许多便利。写作工具的使用我不多说了，这方面我也只会一些简单的，不过完成一篇论文基本也没问题，很快就能上手。\n\n### 7.3 绘图工具\n\n![绘图](/绘图.png)\n\n图形的绘制在比赛中的重要性不言而喻，美赛更是极为看重。\n\n### 7.4 书籍推荐：必不可少\n\n终于讲到了最后一个部分，那就是你需要看哪儿些书。我把我的书单整理了一下，因为我才参与数模比赛其实满打满算一年的时间，我选取了与数模有关的书籍，不包括我们课外看的书。\n\n>1. 数学模型（第五版）姜启源高教社\n>2. 数学建模方法及其应用（第三版）韩中庚高教社\n>3. MATLAB 数学建模方法与实践（第3 版）北京航空航天大学出版社\n>4. 数学建模算法与应用（第2 版）国防工业出版社\n>5. 数学建模方法与分析（第4 版）机械工业出版社\n>6. MATLAB 智能算法30个案例分析（第2 版）北京航空航天大学出版社\n\n大概就是这六本书了，不过只能遗憾的告诉你们，这些书你们是无法看完或者说吃透的，即使你们半懵半懂翻完了一遍，也只是入门了，离做题还有距离。不过没有关系，即使我到现在也不敢说全部能够理解了。首先是姜启源老师的数学模型比较经典，基本初等模型都讲完了，这里希望大家注意，比赛并不会让你直接使用初等模型，一般没这个可能性。韩老师的数学模型书是我最喜欢的一本，给我更贴近数模比赛的感觉。\n\n3\\~6主要是我这个编程队友看的了，3\\~5我觉得大家可以将它们作为工具书来翻找，当然你不可能能全部记下来，但是想要熟练使用工具书，能理解所有算法的意义与功能是前提。最后一本书大家也可以作为工具书，智能算法包括了遗传算法和退火蚁群这些，一般不建议使用这些神棍算法，但是也要视情况而定，多学习总没有坏处。\n\n最后还有其他的各种课外书籍，举个例子，我大一下在研究周老师的《机器学习》，这次美赛我有个算法就用到了Lasso回归的思想，多看书积累，总是无害的。\n\n\n\n## 对西电的同学的建议：西电数模竞赛国赛面试培训参赛经验\n\n### 8.1 国赛校队选拔\n\n首先，大家在五一期间刚刚参加完了校赛，校赛的主要参加队员是大一和大二的同学，大三同学很少参加的原因是，国赛在9月份的中秋节举办，成绩要到11月份才能出来，而那时候的大三也就是大四的学长学姐们早就要么完成了保研要么就是考研的最后冲刺阶段，所以校赛的主力基本是大一和大二的同学们，这些同学参与9月国赛的时候就是大二和大三了。而7月到8月的国赛培训一般是按照校赛的成绩来选拔的，选拔的标准一般而言是校一等奖加上排名靠前的校二等奖(对于大一的要求会相对宽松一点)，这些同学会被选拔出来作为校赛的培训队员。\n\n当然不是说，没有过面试的同学就没有参加国赛的机会了，每年暑假的国赛培训都可以让同学们旁听的。一般国赛培训好好参加，作业认真完成，总教练都会同意进入校队参加比赛的。去年的校队后来旁听队伍加了十几支的队伍，再加上学校越来越重视数模竞赛(这次美赛就可以看出)，数模校队名额会越来越多，鼓励同学们不要放弃，跟着校队培训来，还是有很大的参赛的可能的。\n\n\n\n### 8.2 面试建议\n\n其次就是关于面试的事情，大家不必有太多的心理负担，一般而言大一和大二是分开面试的，主要就是问问校赛的论文以及对着简历问一些简单的问题，简历上面写一些自己擅长的技能，获得的奖项，以及自己专业课的均分及排名(数学类课程尤为重要)。面试的一般都是学校的数模教练，老师一定不会为难大家，所以调整好心态认真回答即可。\n\n\n\n### 8.3国赛系统课程培训(暑假一轮培训)\n\n下面我来说说国赛培训的事情吧，以下是去年国赛一轮培训的课程时间安排计划表。\n\n![](https://i.loli.net/2020/06/10/EmlYkzjo2Ar7SU9.jpg)\n\n每年的主讲老师和内容都会有一些小小的变化，主讲老师也不全是学校数模的教练。不过国赛培训大家好好听课就行了，不用考虑太多的事情，培训主要针对的是对大家水平进行更系统地提升训练。可能大家会听得一头雾水(当年大一的我反正不是很能跟上)，不过不用担心，大家下了课好好去消化尽力弄懂，即使弄不清内在原理，但是也要会灵活熟练使用的。大部分课程讲完后或者讲的过程中，都会布置作业，请参加培训的各位千万把作业记清楚，因为作业是要求之后统一上交的，会根据培训作业完成情况对校队成员进行调整，另外请不要无故缺勤培训，三个人必须到场，否则后果自己承担。\n\n### 8.4 国赛真题训练培训(二轮培训)\n\n往年上完国赛的培训课程就会放暑假了，然后会要求同学们暑假提前返校，进行真题训练，一轮培训以授课为主，二轮培训主要是队伍的真题训练，一般而言都是中秋国赛开始前，会进行四次真题模拟训练，以及不少于两次的答辩。四次真题的第一道题一般是全校队统一的，由总教练韩老师来出题，大家根据这次题目的完成情况以及暑假一轮培训作业的情况去面试导师，这个之后再详细说，二轮培训之后就是做真题了，从校赛跃迁到国赛的跨度还是很大很大的，国赛的题目会非常非常的难，不过请不要去惧怕这些东西，好好弄还是能弄出结果的，之后再进行答辩以及总结分析，再多看看优秀论文，二轮培训后的水平会有非常大幅度的提升，前提当然是你们队伍认真参加完成。\n\n\n\n### 8.5 面试导师\n\n数模校队的队伍是要求暑假提前返校的，返校后第一件事就是完成全校队统一的数模练习题，时间大概是4天，之后数模群会发今年国赛指导老师的名单以及联系的邮箱，大家把自己队伍的简历，一轮培训的作业以及二轮培训第一次完成的答卷发到老师邮箱等待回复即可，去年的二轮国赛指导老师有13个，一般而言投一个就差不多够了，一般老师们的回复都比较快，如果老师明确拒绝了你们，那你们再换个老师投简历，不必广撒网。\n\n等选择老师的最终结果确定之后，就开始以各个老师组进行二轮培训的真题训练以及答辩了。一般会再布置2~4道真题，至于具体的题目是根据各个老师来决定的，大家在规定的四天完成后发给自己的指导老师，然后由老师来组织统一的答辩，答辩就是把指导的所有队伍聚在一起，轮流上台展示本题的答卷结果(最好能做ppt)，然后指导老师对你们这次作业进行评价，最后指导老师会指出各个队伍的优缺点，别的队伍的优点大家都可以学习学习。答辩还有个重要的目的就是选拔正式队伍(之后解释)，请大家务必重视。完成真题训练后，基本就是要参赛了。\n\n\n\n### 8.6 校赛名单终确定\n\n在暑假前的面试所完成的，是一轮国赛培训的名单，并非最终校队名单。等经过两轮国赛培训，去掉一些培训缺勤以及一轮二轮培训作业不完成的队伍，加上态度良好认真完成一轮二轮培训作业的旁听队伍，最终组成校队名单。这些队伍就是能够参加中秋国赛的所有队伍。\n\n现在我来解释下正式队伍和挂名队伍，每个指导老师会让7支队伍左右参加自己的国赛二轮培训，但经过答辩以及二轮作业完成情况，会选择4支正式队伍，以及3支挂名队伍，挂名队伍由再分配新的指导老师，其实差别也不太大，大家真的不必纠结是不是正式队伍。\n\n\n\n**全文很长，感谢大家看到这边！╰(\\*°▽°\\*)╯**\n\n\n\n(文案：杨文昊　在放进博客时钱辰涞做了一定的修改)","tags":["论文","数学建模"],"categories":["总结"]},{"title":"LaTeX札记（一）：插入动画","url":"/2020/06/13/latex-note-01/","content":"\n# $\\LaTeX$札记（一）——插入动画\n\n> ⚠新坑警告\n>\n> 准备把学习LaTeX过程中探索到的一些有用的、好玩的方法都记录下来。\n>\n> 同时还有新坑：“MATLAB札记”\n\n\n\n\n\n## 引入\n\n记得在刚开学的时候，看到一个信号老师公众号，分享了一个其他学校的信号幻灯片。那篇文章的主旨不是讲那个幻灯片怎么样，但我一看发现是用$\\LaTeX$写的，居然还说有动画，我就在想这是怎么实现的呢？$\\LaTeX$生成的不都是PDF嘛，怎么会动呢？但是我依稀记得，Adobe Acrobat是可以导入swf动画的，所以应该是可以实现的。当时没多想，直到……\n\n做电磁场实验的时候实验3、4，其实都是动态的过程，一个是电磁波的透射与反射实验、还有一个是电磁波的极化。虽然题目要求的是截三张图即可，但是我还是想试试，在PDF里怎么搞个动画，所以就有了这篇文章。\n\n> 总体大概是这么些步骤：\n>\n> + Step 0：获得一组动画\n>\n> + Step 1：转图片格式\n>\n> + Step 2：在导言区引入`animate`\n>\n> + Step 3：在正文中使用`animate`创建动画\n\n\n\n\n\n## 前期准备——转图片格式\n\n### Step 0：获得一组动画\n\n这个前期准备可能会是**MATLAB札记**的第一篇文章，会谈谈怎么从MATLAB中导出GIF动画。\n\n**假设我们已经获得了一个GIF动画，或者获得了一组视频，这是前提条件。**\n\n### Step 1：转图片格式\n\n需要注意的是，在$\\LaTeX$中使用`animate宏包`插入的实际上是一组带编号的图像序列，而非是真正意义上的GIF动画或者视频。\n\n分不同的格式，可以用两种方法来解决。\n\n#### GIF转图片序列\n\n这里使用的软件叫做 [ImageMagick](https://www.imagemagick.org/script/index.php) ，这是一个开源软件，但是他是使用命令行指令进行操作的。\n\n安装好 `ImageMagick` 之后，我们就可以用它提供的 `convert` 命令将 GIF 格式的动图逐帧地切分成一系列图片了。假设你的目标图片是 `lab031.gif`，那么使用如下命令可以得到一系列图片：`lab031-0.png`, `lab031-1.png`, `lab031-2.png`, ...\n\n```\nmagick convert lab031.gif -coalesce lab031.png\n```\n\n*值得注意的是，在使用这条指令的时候需要先将命令行定位到GIF动画所在的文件夹目录下，不然也找不到啊。*\n\n这样我们就从GIF获得了图片序列。\n\n#### 视频转图片序列\n\n>  关于为什么会出现视频格式：在实验四中，我制作了一个GUI界面，但是GUI界面我并没有找到可以内部录制GIF动画的较好的方法，所以这里只好先录屏，再转图片序列咯。当然还可以再多一步，视频->GIF（用格式工厂）->图片序列（用上面的方法）。\n\n这里我使用的是Pr软件。虽然Pr很不稳定，但是还是能用的。这边的操作不复杂，基本不用担心电脑会不会炸。\n\n+ 菜单栏：文件->导出->`媒体`\n\n+ `格式`中选择PNG，`预设`不用管\n\n+ 下面`视频`选项中，可以在看得清画面的情况将宽，高调的尽量小，防止导出的PNG序列质量太高，导致最终整个PDF的大小太大。\n\n+ 还是`视频`选项中，把帧速率设的尽量小，比如我1分半钟的视频，帧速率为1，导出的PNG序列就是90张，过多的图片可能会使PDF中的动画变得更流畅，但是带来的问题就是它的大小会很大。（❗值得注意的是，Pr导出的图像即使画面尺寸不大，大小还是比较大的，所以需要注意一下图像质量和帧率的问题）\n\n  ![视频转序列](/视频转序列.png)\n\n当然格式工厂的方法也是可行的，但格式工厂对于视频的质量压缩的实在是太多了。\n\n<img src=\"/格式工厂1.png\" alt=\"格式工厂1\" style=\"zoom: 50%;\" />\n\n\n\n## 关键步骤——`animate宏包`的使用\n\n### Step 2：在导言区引入`animate`\n\n和其它宏包一样，在 $\\LaTeX$的导言区中使用 `\\usepackage[<options>]{animate}` 即可引入 `animate` 宏包。\n\n❗值得注意的是\n\n- 必须在引入 `animate` 宏包之前，引入 `graphicx` 宏包。\n- 使用 `animate` 宏包创建动画，也需要两次编译（第一次创建 JavaScript 内容，第二次在具体位置插入内容），这是由于交叉引用导致的。\n\n```tex\n% 在导言区插入以下代码\n\\usepackage{graphicx}\n\\usepackage{animate}\n```\n\n\n\n### Step 3：在正文中使用`animate`创建动画\n\n`animate`提供的 `\\animategraphics`语句用于在LaTeX中插入一组PNG序列。其基本应用形式为\n\n```tex\n\\animategraphics[<options>]{<frame rate>}{<file basename>}{<first>}{<last>}\n```\n\n这个命令的使用其实和普通插入图片的指令`\\includegraphics`和插入小图的`\\subfigure`的应用场景是一致的。就是嵌套在`figure`环境中使用。\n\n#### 各成分的含义：\n\n+ `<frame rate>`：帧速率，差不多就是帧率的意思，即一秒钟多少张PNG\n+ `<file basename>`：图片序列前缀\n+ `<first>`和`<last>`：图片序列序号范围\n  + ❗使用 ImageMagick和Pr导出的图片序列编号类型并不一样，但是无伤大雅。ImageMagick导出的是自然数编号（例如1-90），而Pr导出的是固定位数编号（例如00-90，或者000-121）之类的。填写这两个{}内容是尊重事实即可，不需要做出调整。\n\n+ `<options>`：可选项（摘自[参考文献2](https://liam.page/2017/08/10/importing-animate-in-LaTeX/)，见下面叙述）\n\n\n\n#### 部分可选项\n\n> + **只能用于接口的选项**\n>\n>   这里的接口指的是 `animate` 宏包提供的用户接口。例如我们已经见过的 `\\animategraphics` 命令，以及下一节会介绍的 `animateinline` 环境。\n>  + `label=<label text>`：为 `animate` 对象指定唯一的标签，可用于之后的 JavaScript 控制。\n>   + `every=<num>`：只为每个第 `<num>` 帧构建动画，而忽略剩余的帧。\n>\n> + **二者皆适用的选项**\n>   \n>   + `type=<type name>`：使用指定的图片类型（而不按照前面提到的顺序搜索）。\n>  + `poster[= first | <num> | last | none]`：指定用于打印和默认展示的动画帧，默认是第一帧。\n>   + `autopause`：当动画所在页不再呈现时，自动暂停动画。\n>   + `autoresume`：当被暂停的动画重新呈现时，自动恢复播放。\n>   + `autoplay`：当动画所在页在 PDF 阅读器中呈现时，自动播放动画。\n>   + `loop`：播放到最后一帧时，从第一帧开始继续播放；如此往复。\n>   + `palindrome`：播放到最后一帧时，逐帧倒退；如此往复。\n>   + `step`：忽略 `frame rate`，只在每次点击鼠标时播放一帧。\n>   + `width=<h-size>, height=<v-size>, totalheight=<v-size>, keepaspectratio`：按绝对长度缩放动画的大小。\n>   + `scale=<factor>`：按比例缩放动画的大小。\n>   + `controls`：展示用于控制动画的按钮。\n>   + `begin=<begin content>`\n\n\n\n## 例子（来自电磁场实验3）\n\n```tex\n% 导言区引用以下代码\n% \\usepackage{graphicx}\n% \\usepackage{animate}\n\\begin{figure}[htbp]\n    \\centering\n    \\animategraphics[autoplay,loop,controls,width=.7\\textwidth]{24}{./lab032/lab032-}{0}{361}\n    \\caption{向理想导体垂直入射随相位变化的GIF动画}\t\n    \\label{fig:gif2}\t\n\\end{figure}\n```\n\n这段代码表示帧率为24帧每秒，它的文件来源于图片目录下的lab032文件夹中`lab032-`为前缀的图片序列，共有0-361总共362张图组成。同时，它具有自动播放、重复播放、具有控制按钮这三个选项，同时所占页宽为0.7倍页宽。下面三张图体现了从GIF到PNG序列再到$\\LaTeX$中文件的变化。\n\n![lab032](/lab032.gif)\n\n![lab032图片序列](/lab032图片序列.png)\n\n![EDA_WF_03](/EDA_WF_03.gif)\n\n（这个格式工厂转的有点问题）\n\n下面这一排按钮不出意外的话，分别表示⏮回到开头，⏪上一帧，⏸暂停（长按才行，不然只会顿一下），⏩下一帧，⏭最后一帧，后三个按钮分别是➖降低帧率、🔛恢复设定的帧率、➕提高帧率。\n\n\n\n## 一些注意事项\n\n1. 这个功能稍有点复杂，但是应用起来的效果还是很不错的。但是这个功能还是很鸡肋的。这个需要支持Javascript的PDF阅读器，网上整理的有这些\n\n   + Adobe Acrobat / Reader\n\n   + PDF-XChange\n\n   + Foxit Reader\n\n   我目前主要使用的是Adobe Acrobat DC，所以打开没问题。但我vscode里$\\LaTeX$环境配套的Sumatra PDF就根本无法播放这个动画。所以很大程度上只能自娱自乐。\n   \n   还有同学指出福昕阅读器对于这个的支持也不是很好，一卡一卡的。还有人用iPad上的PDF Expert打开直接死机。所以不到迫不得已我也不会用。\n   \n2. 这个功能用在$\\LaTeX$制作Beamer过程中应该还是很不错的。可以在幻灯片中清楚的显示动画效果。\n\n3. 不是很推荐用格式工厂转，噪点奇多无比，可以试试网上的一些在线转换工具。\n\n\n\n\n\n## 参考文献\n\n1. 林特斯9527.LaTeX 中插入GIF图片\\[EB/OL\\].<https://www.cnblogs.com/LinTeX9527/p/11122268.html>.2019-07-02/2020-05-12 .\n2. 始终.LaTeX 黑魔法（四）：插入动画（animate 宏包教程）\\[EB/OL\\].<https://liam.page/2017/08/10/importing-animate-in-LaTeX/>.2017-08-10/2020-05-12.","tags":["论文"],"categories":["LaTeX and ..."]},{"title":"信号与系统3种变换性质整理","url":"/2020/05/30/Signal-and-System-3-transform/","content":"\n# 信号与系统3种变换性质整理\n\n>1. 以下是信号与系统3种重要变换的公式整理，如有错误欢迎在评论区指出。\n>2. 电子版见👉[笔记整理部分](https://levitate-qian.github.io/2020/05/01/XDU-note/)信号与系统部分03 傅里叶变换、04 Laplace变换、05 z变换， **后续增减添补仅在电子PDF版中作修改，此处不再做改动。**\n\n## Fourier变换\n\n### 傅里叶变换的表示 \n\n$$\\begin{aligned}\n    f(t)&\\longleftrightarrow F(j\\omega)\\\\\n    F(j\\omega)&=\\mathscr{F}[f(t)]=\\int_{-\\infty}^{\\infty}f(t)\\mathrm{e}^{-j\\omega t}\\mathrm{d}t\\\\ \n    f(t)&=\\mathscr{F}^{-1}[F(j\\omega)]=\\frac{1}{2\\pi}=\\int_{-\\infty}^{\\infty}F(j\\omega)\\mathrm{e}^{j\\omega t}\\mathrm{d}\\omega\n\\end{aligned}$$\n\n### 7种常用函数的傅里叶变换\n\n$$\\begin{aligned}\n    g_\\tau (t) &\\longleftrightarrow\\tau Sa(\\frac{\\omega \\tau}{2})\\\\\n    \\mathrm{e}^{-\\alpha t}\\varepsilon(t) &\\longleftrightarrow\\frac{1}{\\alpha+j\\omega}\\\\\n    \\mathrm{e}^{-\\alpha|t|}&\\longleftrightarrow\\frac{2\\alpha}{\\alpha^2+\\omega^2}\\\\\n    \\delta^{(n)}(t) &\\longleftrightarrow(j\\omega)^n\\\\\n    1&\\longleftrightarrow 2\\pi\\delta(\\omega)\\\\\n    \\mathrm{sgn}(t)&\\longleftrightarrow\\frac{2}{j\\omega}\\\\\n    \\varepsilon(t)&\\longleftrightarrow\\frac{1}{j\\omega}+\\pi \\delta(\\omega)\n\\end{aligned}$$\n\n### 傅里叶变换的性质 \n\n1. 线性性质\n\n2. 奇偶虚实性\n   $$|F(j\\omega)|=|F(-j\\omega)|,\\varphi(\\omega)=-\\varphi(-\\omega)$$\n\n   当$f(t)$为実(虚)函数，\n\n   $F(j\\omega)$ 的实部 $R(\\omega)$为偶(奇)函数\n\n   虚部$X(\\omega)$为奇(偶)函数 \n\n   $$\\begin{aligned}          f(-t)&\\longleftrightarrow F^*(j\\omega)\\\\         (f(-t)&\\longleftrightarrow-F^*(j\\omega))           \\end{aligned}$$\n\n3. 对称性\n   $$F(jt)\\longleftrightarrow 2\\pi f(-\\omega)$$\n\n4. 尺度变换\n\n      $$f(at)=\\frac{1}{|a|} F\\left(j\\frac{\\omega}{a}\\right)$$\n\n5. 时移特性\n\n      $$f(t\\pm t_0)\\longleftrightarrow F(j\\omega)\\mathrm{e}^{\\pm j\\omega t_0}$$\n\n6. 频移特性\n\n      $$F[j(\\omega\\pm \\omega_0)]\\longleftrightarrow f(t)\\mathrm{e}^{\\mp j\\omega_0 t}$$\n\n7. 卷积性质\n\n      $$\\begin{aligned}\n           f_1(t)*f_2(t) &\\longleftrightarrow F_1(j\\omega)F_2(j\\omega)\\\\\n           f_1(t) f_2(t) &\\longleftrightarrow\\frac{1}{2\\pi}F_1(j\\omega)*F_2(j\\omega)\n    \\end{aligned}$$\n\n8. 时域微积分\n    $$\\begin{aligned}\n          f^{(n)}(t)&\\longleftrightarrow(j\\omega)^n F(j\\omega)\\\\\n         \\int_{-\\infty}^t f(x)\\mathrm{d}x &\\longleftrightarrow\\pi F(0)\\delta(\\omega) +\\frac{F(j\\omega)}{j\\omega}\\\\\n           F(0)=&\\left.F(j\\omega)\\right|_{\\omega=0}=\\int_{-\\infty}^{\\infty}f(t)\\mathrm{d} t    \\end{aligned}$$\n\n9. 频域微积分\n     $$\\begin{aligned}\n          F^{(n)}(j\\omega)&\\longleftrightarrow(-jt)^n f(t)\\\\\n          \\int_{-\\infty}^\\omega F(jx)\\mathrm{d}x &\\longleftrightarrow\\pi f(0)\\delta(t) +\\frac{f(t)}{-jt}\\\\ \n          f(0)=&\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}F(j\\omega)\\mathrm{d}\\omega    \\end{aligned}$$\n\n10. 相关定理\n\n     $$\\begin{aligned}\n            \\mathscr{F}[R_{12}(\\tau)]&=F_1(j\\omega)F_2^*(j\\omega)\\\\ \n            \\mathscr{F}[R_{21}(\\tau)]&=F_1^*(j\\omega)F_2(j\\omega)\\\\\n            \\mathscr{F}[R(\\tau)]&=\\left|F(j\\omega)\\right|^2\n        \\end{aligned}$$\n\n\n\n## Laplace变换\n\n### 单边拉普拉斯变换\n\n$$\\begin{aligned}\n    f(t)&\\longleftrightarrow F(s)\\\\\n    F(s)&=\\mathcal{L}[f(t)]=\\int_{0_-}^{\\infty}f(t)\\mathrm{e}^{-st}\\mathrm{d}t\\quad(\\Re[s]>\\alpha)\\\\\n    f(t)&=\\left[\\frac{1}{2\\pi j}\\int_{\\sigma-j\\infty}^{\\sigma+j\\infty}F(s)\\mathrm{e}^{st}\\mathrm{d}s\\right]\\varepsilon(t)\n\\end{aligned}$$\n\n### 常用函数的拉普拉斯变换\n\n$$\\begin{aligned}\n    \\delta^{(n)}(t)&\\longleftrightarrow s^n (\\sigma>-\\infty)\\\\ \n    \\varepsilon(t) \\text{或}1&\\longleftrightarrow\\frac{1}{s}(\\sigma>0)\\\\ \n    \\mathrm{e}^{-s_0t}&\\longleftrightarrow\\frac{1}{s+s_0}(\\sigma>-\\Re[s_0])\\\\ \n    t&\\longleftrightarrow\\frac{1}{s^2}\\\\ \n    \\cos (\\beta t)&\\longleftrightarrow\\frac{s}{s^2+\\beta^2}\\\\ \n    \\sin (\\beta t)&\\longleftrightarrow\\frac{\\beta}{s^2+\\beta^2}\\\\ \n    f_T(t)&\\longleftrightarrow\\frac{1}{1-\\mathrm{e}^{-sT}}\\int_0^Tf_T(t)\\mathrm{e}^{-sT}\\mathrm{d}t\\\\ \n    \\delta_T(t)&\\longleftrightarrow\\frac{1}{1-\\mathrm{e}^{-sT}}\n\\end{aligned}$$\n\n### 拉普拉斯变换的性质\n\n1. 线性性质\n\n2. 尺度变换(实数$a>0$) \n   $$f(at)\\longleftrightarrow\\frac{1}{a}F\\left(\\frac{s}{a}\\right)(\\Re[s]>a\\sigma_0)$$\n\n3. 时移特性(実常数$t_0>0$)\n\n    $$\\begin{gathered}\n           f(t-t_0)\\varepsilon(t-t_0)\\longleftrightarrow\\mathrm{e}^{-st_0}F(s)\\\\(\\Re[s]>\\sigma_0)\n       \\end{gathered}$$\n\n4. 复频移特性\n    $$f(t)\\mathrm{e}^{s_at}\\longleftrightarrow F(s-s_a)(\\Re[s]>\\sigma_0+\\sigma_a)$$\n\n5. 卷积定理($s$域卷积定理不考)：\n   \n   对于因果信号$f_1(t),\\ f_2(t)$ ，$f_1(t)*f_2(t)\\longleftrightarrow F_1(s)F_2(s)$\n\n6. 时域微积分\n   $$\\begin{aligned}\n          f^{(n)}(t)&\\longleftrightarrow s^nF(s)-\\sum_{m=0}^{n-1}s^{n-1-m}f^{(m)}(0_-)\\\\ \n          f^{({-n})}(t) &\\longleftrightarrow\\frac{F(s)}{s^n}+\\sum_{r=1}^{n}\\frac{1}{s^{n-r+1}}f^{(-r)}(0_-)\n      \\end{aligned}$$ \n   若为因果信号，则有\n    $$\\begin{aligned}\n           f^{(n)}(t)&\\longleftrightarrow s^nF(s)\\\\ \n           \\left(\\int_{0_-}^{t}\\right)^nf(x)\\mathrm{d}x&\\longleftrightarrow\\frac{1}{s^n}F(s)\n       \\end{aligned}$$\n\n7. 复频域($s$域)微积分\n    $$\\begin{aligned}\n           (-t)^nf(t)&\\longleftrightarrow\\frac{\\mathrm{d}^n F(s)}{\\mathrm{d}s^n}\\\\ \n           \\frac{f(t)}{t}&\\longleftrightarrow\\int_s^{\\infty}F(\\eta)\\mathrm{d}\\eta\n       \\end{aligned}$$\n\n8. 初值定理、终值定理\n\n   初值定理(不含$\\delta(t)$及其各阶导数) \n\n   $$f(0_+)=\\lim_{t\\to 0_+}f(t)=\\lim_{s\\to\\infty}sF(s)$$ \n\n   终值定理(包含虚轴，即$j\\omega$轴)\n\n    $$f(\\infty)=\\lim_{s\\to 0}sF(s)$$\n\n### **拉普拉斯逆变换**\n\n#### 部分分式展开$\\displaystyle F(s)=\\frac{B(s)}{A(s)}$\n\n(1)求极点($A(s)=0$)\n\n(2)将$F(s)$展开为部分分式\n\n1. 单根\n\n    $$\\begin{gathered}\n           F(s)=\\sum_{i=1}^{n}\\frac{K_i}{s-p_i},\\qquad\n           K_i=\\left.(s-p_i)F(s)\\right|_{s=p_i}\\\\ \n           \\mathcal{L}^{-1}\\left[\\frac{1}{s-p_i}\\right]=\\mathrm{e}^{p_it}\\varepsilon(t)\n       \\end{gathered}$$\n\n2. 含共轭复根($p_{1,2}=-\\alpha\\pm j\\beta$)\n\n    $$\\begin{gathered}\n           F_0(s)=\\frac{K_1}{s+\\alpha-j\\beta}+\\frac{K_2}{s+\\alpha+j\\beta}\\quad\n           (K_2=K_1^*,\\ K_1=|K_1|\\mathrm{e}^{j\\theta}=A+jB)\\\\ \n           f_0=2|K_1|\\mathrm{e}^{-\\alpha t}\\cos(\\beta t+\\theta)\\varepsilon(t)=2\\mathrm{e}^{-\\alpha t}[A\\cos(\\beta t)-B\\sin{\\beta t}]\\varepsilon({t})\n       \\end{gathered}$$\n\n3. 重根($s=p_1$)\n\n    $$\\begin{gathered}F_1(s)=\\sum_{i=1}^{r}\\frac{K_{1i}}{(s-p_1)^{r-i+1}},\\qquad\n           K_{1i}=\\left.\\frac{1}{(i-1)!}\\frac{\\mathrm{d}^{i-1}}{\\mathrm{d}s^{i-1}}\\left(s-p_1\\right)^i F_1(s)\\right|_{s=p_i}\\\\ \n           \\mathcal{L}^{-1}\\left[\\frac{1}{(s-p_1)^{n+1}}\\right]=\\frac{1}{n!}t^n\\mathrm{e}^{p_1t}\\varepsilon(t)\n       \\end{gathered}$$\n\n(3)求原函数$F(s)\\longleftrightarrow f(t)$\n\n#### 留数法（反演积分）\n\n$$f(t)=\\sum_{k=1}^{n}\\mathrm{Res}[F(s)\\mathrm{e}^{st},s_k]$$ \n\n求解留数的其中3条规则：\n\n1. 1级极点\n\n    $$\\mathrm{Res}[f(z),z_0]=\\lim_{z\\to z_0}(z-z_0)f(z)$$\n\n2. $m$级极点 \n\n   $$\\mathrm{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{m-1}}{\\mathrm{d}z^{m-1}}[(z-z_0)^mf(z)]$$\n\n3. $f(z)=\\frac{P(z)}{Q(z)}$，$P(z),\\ Q(z)$均在$z=z_0$处解析，$P(z_0)\\not= 0$，$Q(z_0)=0$，$Q'(z_0)\\not= 0$，$z_0$为1级极点，$z_0$为$Q(z)$的1级零点。 \n\n\n\n## $\\boldsymbol{z}$变换\n\n### $z$变换\n\n双边$z$变换：$F(z)=\\sum_{k=-\\infty}^{\\infty}f(k)z^{-k}$\n\n单边$z$变换：$F(z)=\\sum_{k=0}^{\\infty}f(k)z^{-k}$\n\n$f(k)$因果，单边、双边$z$变换相等\n\n### 常用函数的$\\boldsymbol{z}$变换\n\n$$\\begin{aligned}\n\\delta(k)&\\longleftrightarrow 1\\text{(整个$z$平面)}\\\\\n\\varepsilon(k)&\\longleftrightarrow\\frac{z}{z-1}(|z|>1)\\\\ \n-\\varepsilon(-k-1)&\\longleftrightarrow\\frac{z}{z-1}(|z|<1)\n\\end{aligned}$$\n\n### $\\boldsymbol{z}$变换的性质 \n\n1. 线性性质(收敛域至少为相交部分)\n\n2. 尺度变换(序列乘$a^k$)\n\n    $$a^kf(k)\\longleftrightarrow F\\left(\\frac{z}{a}\\right)(|a|\\alpha<|z|<|a|\\beta)$$\n\n3. 移位（移序）特性\n\n   双边$z$变换($m>0$)\n\n    $$f(k\\pm m)\\longleftrightarrow z^{\\pm m}F(z)$$ \n\n   单边$z$变换($m>0$)\n\n    $$\\begin{aligned}\n           &f(k-m)\\longleftrightarrow z^{-m}\\left[F(z)+\\sum_{k=-m}^{-1}f(k)z^{-k}\\right]\\\\\n           &f(k+m)\\longleftrightarrow z^{m}\\left[F(z)-\\sum_{k=0}^{m-1}f(k)z^{-k}\\right]\\\\\n       \\end{aligned}$$\n\n4. 卷积定理(收敛域一般为相交部分) \n\n   单边$z$要求因果序列$f_1(t),f_2(t)$ \n\n   $$f_1(t)*f_2(t)\\longleftrightarrow F_1(z)F_2(z)$$\n\n5. $z$域微积分\n   微分(序列乘$k$)\n   $$\\begin{aligned}\n           kf(k)&\\longleftrightarrow(-z)\\frac{\\mathrm{d}}{\\mathrm{d}z}F(z)\\\\\n           k^mf(k)&\\longleftrightarrow\\left[-z\\frac{\\mathrm{d}}{\\mathrm{d}z}\\right]^mF(z)\n       \\end{aligned}$$\n\n   积分(序列除$(k+m)$)\n\n    $$\\begin{aligned}\n           &\\exists m\\in \\mathbb{Z},k+m>0\\\\ \n           &\\frac{f(k)}{k+m}\\longleftrightarrow z^m\\int_z^\\infty \\frac{F(\\eta)}{\\eta^{m+1}}\\mathrm{d}\\eta\n       \\end{aligned}$$\n\n6. $k$域反转(仅适用于双边$z$变换) \n\n   $$f(-k)\\longleftrightarrow F(z^{-1})\\ (\\frac{1}{\\beta}<|z|<\\frac{1}{\\alpha})$$\n\n7. 部分和\n\n    $$\\begin{gathered}\n           \\sum_{i=-\\infty}^kf(i)\\longleftrightarrow\\frac{z}{z-1}F(z)\n           (\\max(\\alpha,1)<|z|<\\beta)\n       \\end{gathered}$$\n\n8. 初值定理、终值定理(右边序列)\n\n   初值定理\n\n    $$f(M)=\\lim_{z\\to \\infty}z^MF(z)$$ \n\n   若因果，$f(0)=\\mathop {\\lim }\\limits_{z\\to \\infty}F(z)$\n\n   终值定理(包含单位圆$0<\\alpha<1$)\n\n    $$\\begin{aligned}\n           f(\\infty ) &= \\mathop {\\lim }\\limits_{k \\to \\infty } f(k)\\\\ \n           &= \\mathop {\\lim }\\limits_{z \\to 1} \\frac{z - 1}{z}F(z) = \\mathop {\\lim }\\limits_{z \\to 1} (z - 1)F(z)\n       \\end{aligned}$$\n\n### **逆$\\boldsymbol{z}$变换**\n\n#### 幂级数展开法\n\n因果序列和反因果序列的象函数分别是$z^{-1}$和$z$的幂级数。其系数就是相应序列值。\n\n-   因果序列：圆外展开(负幂项)\n\n-   反因果序列：圆内展开(正幂项)\n\n-   双边序列：环域展开\n\n-   唯一性定理转化为等比级数$C_n=\\displaystyle\\frac{f^{(n)}(z_0)}{n!}$\n\n原序列通常难以写成闭合形式。\n\n#### 部分分式展开$\\displaystyle F(z)=\\frac{B(z)}{A(z)}$\n\n**Case 1** 单根 \n\n$$\\begin{gathered}\n        \\frac{F(z)}{z}=\\sum_{i=0}^{n}\\frac{K_i}{z-z_i},\\\\\n        K_i=\\left.(z-z_i)\\frac{F(z)}{z}\\right|_{z=z_i},\\\\\n         F(z)=K_0+\\sum_{i=1}^nK_i\\frac{z}{z-z_i}\\\\ \n    \\end{gathered}$$\n\n 区分圆内圆外展开:\n\n$$\\begin{aligned}\n    \\delta(k)&\\longleftrightarrow 1\\\\\n         a^k\\varepsilon(k)&\\longleftrightarrow\\frac{z}{z-a}(|z|>|a|)\\\\ \n         -a^k\\varepsilon(-k-1)&\\longleftrightarrow\\frac{z}{z-a}(|z|<|a|)\n    \\end{aligned}$$\n\n**Case 2** 共轭单极点($z_{1,2}=c\\pm jd=\\alpha \\mathrm{e}^{\\pm j\\beta}$)\n\n $$\\begin{gathered}\n        \\frac{F(z)}{z}=\\frac{K_1}{z-c-jd}+\\frac{K^*_1}{z-c+jd}\\\\\n        (K_1=|K_1|\\mathrm{e}^{j\\theta})\\\\ \n        \\frac{F(z)}{z}=\\frac{|K_1|\\mathrm{e}^{j\\theta}z}{z-\\alpha \\mathrm{e}^{j\\beta}}+\\frac{|K_1|\\mathrm{e}^{-j\\theta}z}{z-\\alpha \\mathrm{e}^{-j\\beta}}\\end{gathered}$$ \n\n$$\\begin{aligned}\n    &f(k)=2|K_1|\\alpha^k\\cos(\\beta k+\\theta)\\varepsilon(k)&(|z|>\\alpha)\\\\ \n        &f(k)=-2|K_1|\\alpha^k\\cos(\\beta k+\\theta)\\varepsilon(-k-1)&(|z|<\\alpha)\n\\end{aligned}$$\n\n**Case 3** 重根($z=a$) \n\n$$\\begin{gathered}\n        F_1(z)=\\sum_{i=1}^{r}\\frac{K_{1i}z}{(z-a)^{r-i+1}},\\\\\n        K_{1i}=\\left.\\frac{1}{(i-1)!}\\frac{\\mathrm{d}^{i-1}}{\\mathrm{d}z^{i-1}}\\left(z-a\\right)^r \\frac{F(z)}{z}\\right|_{z=a}\\\\ \n        \\mathcal{Z}^{-1}\\left[\\frac{z}{(z-a)^{r}}\\right]=\\frac{\\mathbf{A}_k^{r-1}}{(r-1)!}a^{k-r+1}\\varepsilon(k)\n    \\end{gathered}$$\n\n#### 留数法（反演积分）\n\n$$f(k)=\\begin{cases}\n    \\displaystyle\\sum_{\\text{C内极点}}\\mathrm{Res}\\left[F(z)z^{k-1}\\right],&k\\ge 0\\\\ \n    \\displaystyle -\\sum_{\\text{C外极点}}\\mathrm{Res}\\left[F(z)z^{k-1}\\right],&k< 0\n\\end{cases}$$ \n\n求解$F(z)z^{k-1}$在极点处留数的2条规则：\n\n1. 1级极点 \n\n   $$\\mathrm{Res}[F(z)z^{k-1},z_i]=\\lim_{z\\to z_i}(z-z_0)F(z)z^{k-1}$$\n\n2. $r$级极点 \n\n   $$\\begin{aligned}\n           \\mathrm{Res}[F(z)z^{k-1},z_i]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{\\mathrm{d}^{r-1}}{\\mathrm{d}z^{r-1}}[(z-z_i)^rF(z)z^{k-1}]\n       \\end{aligned}$$","tags":["信号"],"categories":["课程向"]},{"title":"模拟电子线路实验","url":"/2020/05/16/AC-experiment/","content":"\n# 模拟电子线路实验\n\n碎碎念\n\n> 模电实验也做完了，先占个坑，以后慢慢填！\n>\n> 模电大作业做的差不多了，模电大作业的数显部分等数电大作业做完再想好了!\n>\n> **赶数电大作业ing...一周自学速成VHDL！！我可以的😵**\n\n\n\n模电实验其实没有电磁场实验这么复杂，不用翻太多参考文献，就模电书、电子线路实验书两本就差不多了，最多看看新概念模电里面有没有什么更好的做法。\n\n*目前先把心得体会贴在这边吧，里面大多是我遇到的坑。*别的内容慢慢增补进来。\n\n> 提供我做的模电实验报告：有点小问题，往下看吧\n>\n> https://levitate.lanzoui.com/b0dewfr6d\n> 密码:aa0u\n\n\n\n\n\n## 实验一　集成运算放大器及其应用研究实验\n\n这个实验100分，但是也有点问题，防止非线性失真可以从两方面考虑，带宽和输入信号的幅度，我最后是通过改变输入信号幅度避免的非线性失真，其实有违题意。\n\n\n\n### 心得体会\n\n模电的第一个实验前前后后做了3天左右的时间，其中也学到了很多的知识。\n\n- **课程**：通过这次的实验进一步加深了对集成运算放大器线性应用的认识，深入理解了集成运算放大器的基本运算功能，也了解并学习了增益，传输特性，频率响应，负载能力的相关知识，为模电课程的学习打下了基础。\n\n- **工程**：上周四数电课上讲了查询器件手册的一些相关内容，本次实验也算是第一次去查看器件手册，了解许多参数的英文表达，也意识到了查询期间手册的意义所在。\n\n- **实验**：在实验中多次被卡住了，但通过调试和查询解决了绝大多数的问题。主要是在：\n\n  -   电路的搭建------$U_{cc+}$和$U_{cc-}$的管脚；\n\n  -   信号发生器的接地接在`COM`口而非负极；\n\n  -   测量反相比例放大器的幅频特性出现非线性失真，了解了压摆率这一参数；\n\n  -   幅频特性曲线的横坐标是对数坐标轴。\n\n  同时也在实验中掌握了`Multisim`的基本操作，学会使用\"AC sweep\"和扫频仪测量幅频特性。\n\n\n\n## 实验二　集成运放在有源滤波器中的应用\n\n这个实验95分，里面测量截止频率的方法有待商榷。学了模电第7章频率响应我也觉得我原先做法有问题，但是好像书上确实有这么张图，emmm。\n\n> <img src=\"/2-03.png\" alt=\"2-03\" style=\"zoom: 67%;\" />\n>\n> 当$\\omega=\\omega_0$时，品质因数$Q=\\frac{|H(j\\omega_0)|}{H(0)}$，即$Q$是滤波电路在$\\omega=\\omega_0$处的电压增益与通带增益的比值。\n>\n> 来源：孙肖子. 模拟电子电路及技术基础（第三版）[M]. 西安：西安电子科技大学出版社，2017.57-61.\n\n\n\n### 心得体会\n\n本周由于原来安排了电装实习，所以没有其他课程，整整做了1天的实验。其中也学到了很多的知识，但也仍有许多不清楚的地方可能需要实际操作才能知道。\n\n-   **课程**：通过这次的实验进一步加深了对集成运算放大器和有源RC滤波器的认识。由于二阶有源滤波器的计算在模电课程中基本不要求，这次实验也好好的让我学习了二阶有源滤波器的相关计算。为我的模电学习补了一点漏洞。\n\n-   **实验**：在实验中又多次被卡住了，查阅课本和相关资料解决了绝大多数的问题，但仍有小部分问题没能解决。\n\n    -   进一步加深了对于幅频响应的截止频率与$Q$值之间关系的了解；\n\n    -   学习了低通滤波器和高通滤波器级联组成带通滤波器这一方法；\n\n    -   知道了为什么用`μA741`构成一个上限频率接近1 MHz低通滤波器是不可行的------`Sallen-key` 滤波器引入了正反馈。\n\n    -   但仍然不太清楚为何级联产生的带通滤波器通频带理论值和仿真值得误差如此之大，可能需要开学以后在实验室里实际操作才能直到最终结果了。（网上有一篇文章说实际值与理论值相接近，而与仿真值相差比较大，这就可能是仿真的问题了）\n\n同时也在实验中进一步加强了`Multisim`的基本操作。\n\n\n\n## 实验三　集成运放非线性应用及其在波形产生方面的实验\n\n这个实验99分，不会分析占空比怎么实现。做这个实验的时候，还没学第十章非线性应用，做的头破血流。欸，但是我现在学完了还是不会设计怎么实现调整占空比啊🤪！\n\n\n\n### 心得体会\n\n又做了一天的实验，这次的实验内容模电课内还没有学到，主要属于第十章的内容。\n\n-   **课程**：通过这此实验进一步巩固了对于运放和二极管的理解，同时了解了运放的非线性运用。同时，了解了文氏桥振荡器，迟滞比较器，张弛振荡器等新的概念，但至于计算还是不会。\n\n-   **实验**：在实验中又多次被卡住了，查阅课本和相关资料解决了绝大多数的问题。\n\n    -   针对信号发生器由于相关的公式没有学过，所以第二、三个实验内容的完成主要靠凑数，没能很好地理解其内涵。\n\n    -   了解了运放带宽和运算速度对电路性能的重要影响。\n\n    -   这个实验的波形产生都需要一定的时间，不知道是为什么，莫非是起振时间？\n\n\n\n## 实验四　单级共射、共集放大电路性能与研究实验\n\n这个实验还好，不难。但是只有96分，原因是我判断错了非线性失真的情况，emmm\n\n\n\n### 心得体会\n\n这次的实验内容刚好是模电前面几周学习的内容，所以做起来比较顺手。这次主要问题是在我想把该实验的各个内容整合到一个电路上，所以耽搁了不少时间。\n\n-   **课程**：通过这此实验进一步加强了对于单极共射放大电路的认识，熟悉了分压式偏置电路的计算，明确交流通路与直流通路的区别，并又练习了共射放大电路的静态和动态分析。同时通过实验认识到了失真的波形。\n\n-   **实验**：在实验中被卡住的不多，但是存在着一些问题。\n\n    -   一开始没有使用电解电容，好像对结果有一定的影响，但好像影响不大。\n\n    -   如果每个实验搭一个电路倒是不复杂，但是重复性的工作太多，所以我考虑把几个命题的电路搭在了同一个电路上，通过开关控制，为此思考了很多。\n\n    -   对于滑动变阻器的调节也很复杂，无法每次直接在示波器上看出幅值，必须要调一个参数就暂停下来，在示波器上观测，这也浪费了不少时间。\n\n\n\n## 实验五　差分放大器性能研究实验\n\n这个实验也不难，但是也99分。老师说我没分析双端输出的放大倍数，我明明在实验过程里面写了呀！！！明白了，以后不能在实验过程里面写这些东西。\n\n\n\n### 心得体会\n\n这次的实验内容和学习的时间也相差不多，所以公式什么的还是记得比较清晰的。但是由于再找三极管$r_{bb'},r_{ce}$的参数，又找不到，花费了很多时间。\n\n-   **课程**：通过这此实验进一步加强了对于差分放大器的认识，熟悉了工作点的调试和主要性能指标的测试。并且进一步的加深了对恒流源的认识。知道了具有恒流源差分放大器的工作原理及对共模抑制比的大大改善。\n\n-   **实验**：在实验中被卡住的不多，但是存在着一些问题。\n\n    -   三极管$r_{bb'},r_{ce}$的参数找不到，所以对实验结果有一定的影响，但是大体的思路还是正确的。\n\n    -   实验中，一开始通过降低`Y pos.`来获得交流电压，后来发现有直接的交流开关`AC`也是方便不少。\n\n    -   一开始没有想到有效值和峰峰值的关系，所以计算的有些困扰。\n\n-   **仍然困扰我的问题**：\n\n    -   三极管$r_{ce}$的参数究竟怎么获得，手册上和`Multisim`中都没有找到。\n\n    -   式（6）$A_{uc}\\approx \\frac{-R'_L}{2R_E}$是如何推导得到的又为何还与$R_L$有关系（这个公式在模电课本上没有找到）\n\n\n\n## 综合实验　程控放大器设计实验\n\n这是一个数模实验（嘿嘿！），糅合了数电和模电，差不多相当于期末考试了，占30%，100分！这里面我用了2-4译码器`74139`、6反相器`7404`、模拟开关`CD4066B`，也用到了集成运放`μA741`。\n\n\n\n### 心得体会\n\n这次的实验内容是这学期的最后一个电子线路实验，把数电和模电知识糅合在了一起。\n\n-   **课程**：通过这此实验将模拟电子线路和数字电路有机地结合起来。\n    -   *数字电路*：进一步加深了对于译码器的认识，强化了译码器低电平输出有效的概念。了解了模拟开关`CD4066B`的应用。\n\n    -   *模拟电路*：加深了对于同相比例放大器的认识。\n\n-   **实验**：实验内容不是很难，在幻灯片和电子线路实验教程上都有，但是如何形成一份完整的报告和误差究竟出在哪儿，困扰着我，但最后也都解决了，也和题目要求温和的不错。\n\n    -   由于这个实验没有报告的模板，所以我借用了原来模电实验的模板，针对电路设计部分借用了我模电大作业的思路，由框图谈起，介绍个部分电路的原理功能。\n    -   实验中，一开始电路出现了限幅的情况，我把输入信号的幅度调整为1 mV后就没有问题了。\n    -   针对误差的分析我一开始只想到了并接的300 kΩ引起的误差，但是该电阻引起的误差和我们要实际测量的是相反的。最后通过测量各节点电压，才找到了引起误差的关键------模拟开关的开态电阻$r_{on}$。\n\n\n\n**最后吹一句：$\\LaTeX$真香，markdown真香，pandoc天下第一（转化真方便，比word直接贴过来还要快）。**","tags":["模拟电子技术"],"categories":["课程向"]},{"title":"电磁场实验","url":"/2020/05/12/电磁场实验/","content":"\n# 电磁场实验\n\n这是电磁场实验虚拟仿真的部分内容思路，后续应该有空的时候会更新完四个实验。\n\n\n\n>  **实验四一开始左旋右旋判断错了，现在刚刚讲到。如果老师看到这里，能不能不算错啊🤣**\n>\n> ——2020年6月2日\n\n\n\n## 实验一　带电粒子在电磁场中的受力与运动特性研究实验\n这个实验说实话像是物理实验，不是很像电磁场实验🤣。物理实验貌似真的做过这个类似的。\n\n\n\n### 基础部分\n\n编写程序，用`MATLAB`数值模拟的方法，模拟带电粒子在均匀分布的正交电磁场中的螺旋运动，带电粒子进入磁场的方向与磁场方向之间的夹角为$\\theta$，（$0<\\theta<90°$）。\n\n设带电粒子的初始状态如下： \n$$\n \\begin{aligned}\n        \\text{粒子带电量$q$: } &\\quad q=1.6\\times 10^{-2} C, \\\\\n        \\text{粒子质量$m$: }&\\quad m=0.02 g.\n    \\end{aligned}\n$$\n\n\n\n根据题设，我们要模拟三种状态，分别设参数如下：\n\n-   电场强度和磁场强度都不为零，$B=2,E=2$;\n\n-   电场强度为零，磁场强度不为零，$B=2,E=0$;\n\n-   电场强度不为零，磁场强度为零，$B=0,E=2$。\n\n\n\n利用上学期在*《计算方法》*中学到的Runge-Kutta算法即可求解该问题。\n\n**odefun1.m**\n\n```matlab\nfunction dwdt = odefun1(t,w,q,B,m,E)\ndwdt = zeros(6,1);\ndwdt(1) = w(2);\ndwdt(2) = q.*B.*w(4)./m;\ndwdt(3) = w(4);\ndwdt(4) = q.*E./m-q.*B.*w(2)./m;\ndwdt(5) = w(6);\ndwdt(6) = 0;\n```\n\n\n\n针对微分方程组的初始条件`y0`，设初值条件$w_1=0$,$w_2=0.01$,$w_3=0$,$w_4=6$,$w_5=0$,$w_6=0.01$开始迭代，得到`[t,w]`的关系值。由于$w_1 = x$，$w_3 = y$，$w_5 = z$，所以我们依据不同时刻带电粒子的位置利用三维绘图函数`plot3`绘制图像。选择不同的$i$值即可绘制三种不同情况的带电粒子运动轨迹。具体程序如下：\n\n **lab011.m**\n\n```matlab\n%% The movement of charged particles in an electromagnetic field (full image)\nglobal q m B E\nq=1.6e-2;   % Charge of particle\nm=0.02;     % Mass of particle\nB=[2;2;0];  % Magnetic flux density in orthogonal electromagnetic field, single magnetic field, single electric field\nE=[2;0;2];  % Electric field strength under orthogonal electromagnetic field, single magnetic field, single electric field\nfig{1}='$E\\not= 0,B\\not= 0$';\nfig{2}='$E=0,B\\not= 0$';\nfig{3}='$E\\not= 0, B=0$';\nfor i=1:3    % Choose a different i, switch between \"orthogonal electromagnetic field\", \"single magnetic field\", \"single electric field\"\n[t,w]=ode23(@(t,w) odefun1(t,w,q,B(i),m,E(i)),[0:0.01:20],[0,0.01,0,6,0,0.01]);\nsubplot(1,3,i),plot3(w(:,1),w(:,3),w(:,5));\ngrid on\ntitle(fig{i},'fontsize',12,'Interpreter','latex');\nxlabel('x'); ylabel('y'); zlabel('z');\nend\n```\n\n![lab01-1](/lab01-1.png)\n\n\n\n### 发挥部分\n\n将$v$放到笛卡尔坐标系中讨论，则可得到带电粒子的位置方程\n\n$$\n\\left\\{\\begin{aligned}\n        x&=v_{//}t=vt\\cos \\theta ,\\\\\n        y&=v_{\\bot}\\cos{(\\omega t)}=v\\sin \\theta\\cos(\\omega t),\\\\ \n        z&=v_{\\bot}\\sin{(\\omega t)}=v\\sin \\theta\\sin(\\omega t).\n    \\end{aligned}\\right.\n$$\n\n\n为了使所有点从同一位置发射出（$t=0$时，$x=y=z=0$），并简单化初始参数（令$v=1,\\omega=1$），可以将方程改写为\n\n$$\n\\left\\{\\begin{aligned}\n        x&=t\\cos \\theta ,\\\\\n        y&=\\sin \\theta(1+\\cos(t-\\pi)),\\\\ \n        z&=\\sin \\theta\\sin(t-\\pi).\n    \\end{aligned}\\right.\n$$\n\n\n$\\theta$很小时，$v_{//}\\approx v,\\,v_{\\bot}\\approx v \\theta$。发散角不太大的带电粒子束，经一个周期后重新会聚。这里我们取出射角度$\\theta\\in[-10^\\circ,10^\\circ]$。\n\n\n\n为了进一步观察每一个带电粒子束的运动轨迹，我们选用彗星图`comet3`函数。彗星图是动画图，其中一个圆（彗星头部）跟踪屏幕上的数据点。彗星主体是位于头部之后的尾部。尾巴是跟踪整个函数的实线。`comet3(x,y,z)` 显示经过点 $[x(i),y(i),z(i)]$ 曲线的彗星图。\n\n**lab012.m**\n\n``` matlab\n%% Simulate magnetic focusing\nt=0:0.01:2*pi;\nfor theta=[-10:2:10]*pi/180;\ngrid on;\nhold on;\n%  comet3(cos(theta).*t,sin(theta).*(cos(t-pi)+1),sin(theta).*sin(t-pi));\nplot3(cos(theta).*t,sin(theta).*(cos(t-pi)+1),sin(theta).*sin(t-pi));\nend\nxlabel('x'); ylabel('y'); zlabel('z');\ntitle('Simulate magnetic focusing')\n```\n\n![lab01-2a](/lab01-2a.png)\n\n![lab01-2b](/lab01-2b.png)\n\n\n\n### 提高部分\n\n设带电粒子的初始状态如下：\n\n $$\\begin{aligned}\n        \\text{粒子带电量$q$：} &\\quad q=1.6\\times 10^{-19} C, \\\\\n        \\text{粒子质量$m$：}&\\quad m=1.67\\times 10^{-27} g,\\\\ \n        \\text{初速度$v_0$：}&\\quad v_0=1\\times 10^6 m/s,\\\\\n        \\text{初始磁场$B_0$：}&\\quad B_0=1 T,\\\\\n        \\text{磁场变化速率：}&\\quad \\frac{\\partial B_z}{\\partial z}=10 T/m.\n    \\end{aligned}$$\n\n针对\"磁镜效应\"，可以被转化为\n\n $$\\left\\{\\begin{aligned}\n        \\frac{\\mathrm{d}w_1}{\\mathrm{d}t} &= w_2;\\\\\n        \\frac{\\mathrm{d}w_2}{\\mathrm{d}t} &= \\frac{qw_4}{m}(10w_5+1)-\\frac{qw_6}{m}\\left(-5\\sqrt{w_1^2+w_3^2}\\cos\\left(\\frac{\\pi}{4}\\right)\\right);\\\\\n        \\frac{\\mathrm{d}w_3}{\\mathrm{d}t} &= w_4;\\\\\n        \\frac{\\mathrm{d}w_4}{\\mathrm{d}t} &= \\frac{qw_6}{m}\\left(-5\\sqrt{w_1^2+w_3^2}\\sin\\left(\\frac{\\pi}{4}\\right)\\right);\\\\\n        \\frac{\\mathrm{d}w_5}{\\mathrm{d}t} &= w_6;\\\\\n        \\frac{\\mathrm{d}w_6}{\\mathrm{d}t} &= -\\frac{qw_4}{m}\\left(-5\\sqrt{w_1^2+w_3^2}\\sin\\left(\\frac{\\pi}{4}\\right)\\right)\n    \\end{aligned}\\right.$$\n\n\n\n**odefun2.m**\n\n```matlab\nfunction dwdt = odefun2(t,w,q,m)\ndwdt = zeros(6,1);\ndwdt(1) = w(2);\ndwdt(2) = q*(10*w(5)+1)*w(4)/m-q*((-5*sqrt(w(1).^2+w(3).^2))*cos(pi/4))*w(6)/m;\ndwdt(3) = w(4);\ndwdt(4) = q*((-5*sqrt(w(1).^2+w(3).^2))*sin(pi/4))*w(6)/m;\ndwdt(5) = w(6);\ndwdt(6) = -q*((-5*sqrt(w(1).^2+w(3).^2))*sin(pi/4))*w(4)/m\n```\n\n\n\n **lab013.m**\n\n```matlab\n%% Magnetic mirror effect\nq=1.6e-19;      % Charge of particle\nm=1.67e-27;     % Mass of particle\nv0=1e6;         % Initial velocity\ntheta=pi/4;     % Shooting speed\nVy=0,Vz=v0*cos(theta),Vx=v0*sin(theta);\n[t,w]=ode45(@(t,w) odefun2(t,w,q,m),[0:1e-7:1.5e-6],[0,Vx,1.1,Vy,0,Vz]);\nplot3(w(:,1),w(:,3),w(:,5));    %Three-dimensional trajectory of particles\nxlabel('x');ylabel('y');zlabel('z');\ngrid on;title('Magnetic mirror effect')\n```\n\n![lab01-3](/lab01-3.png)\n\n\n\n### 参考文献\n\n1. 孙志忠,吴宏伟,袁慰平等.计算方法与实习(第5版)\\[M\\].南京：东南大学出版社,2011. \n2. 任海林.带电粒子在均匀稳定电磁场中的运动分析与编程演示\\[EB/OL\\].<https://wenku.baidu.com/view/066a56ee5ef7ba0d4a733bff.html>,2011-02-06/2020-04-07. \n3. 方瑞银,戚海洋.[MATLAB仿真带电粒子在磁场中磁镜现象](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFD2012&filename=ELEW201221060&v=MzEwOTk4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUjdxZll1ZG9GQ3ZtVmI3TklDSE9lYkc0SDlQT3JvOURaSVI=)\\[J\\]. 电子世界, 2012(21):94-95. \n4. 代国红,李兴鳌,黄伟军,方利广.[带电粒子在磁镜场中运动时速度的演变](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFD2010&filename=GKWL201003009&v=MTIwMjZZUzdEaDFUM3FUcldNMUZyQ1VSN3FmWXVkb0ZDdm1WYnpOSWliY1lyRzRIOUhNckk5RmJZUjhlWDFMdXg=)\\[J\\].物理与工程,2010(3):17-18,36.\n\n\n\n## 实验二　静电场边值问题研究实验\n\n这个实验说起来就比其他三个实验要平和很多\n\n\n\n### 仿真设置参数\n\n由于针对两个仿真的操作基本一致，所以仅在不同的地方加以标注。\n\n1.  调出`pdemodeler`工具箱，设置网格。\n2.  *区域设置*：选择工具栏的画矩形工具，确定计算范围。\n3.  *应用模式*：在菜单栏中单击`Option`下拉列表框，选择`Applications`，再选择`Electrostatics`(静电学)应用模式。\n4.  *边界条件*：进入`Boundary Mode`，再选择`Specify Boundary Conditions...`\n\n    -   对于平行板电容：\n\n        -   在左边界，选择Neumann条件，$g=0$，$q=0$。\n\n        -   在右边界，选择Neumann条件，$g=0$，$q=0$。\n\n        -   在上边界，选择Diriehlet条件，$h=1$，$r=100$。\n\n        -   在下边界，选择Diriehlet条件，$h=1$，$r=-100$。\n\n    -   对于加盖导电槽：\n\n        -   在左边界，输入Diriehlet条件，$h=1$，$r=0$。\n\n        -   在右边界，输入Diriehlet条件，$h=1$，$r=0$。\n\n        -   在上边界，选择Diriehlet条件，$h=1$，$r=100$。\n\n        -   在下边界，选择Diriehlet条件，$h=1$，$r=0$。\n5.  *方程参数*：在菜单栏中单击`PDE`按钮打开`PDE Spacification`对话框，设介电常数$\\varepsilon$为epsilon$=1$，为体电荷密度$\\rho$为rho$=0$。\n6.  *图形解显示参数设置1*：单击工具栏的`Plot Selection`(类似MATLAB线稿的一个图标)中选择Color、Height(3-D plot)、Plot in x-y grid和Show mesh四项．并在Contour plot levels中设置等位线条数，在Colormap中选择配色后，单击`plot`按钮，画出电位的三维曲面图。\n7.  *图形解显示参数设置2*：单击工具栏的`Plot Selection`(类似MATLAB线稿的一个图标)中选择Color、Contour和Arrows三项．并在Contour plot levels中设置等位线条数，在Colormap中选择配色后，单击`plot`按钮，画出电位的$x-y$方向曲线图，图上的箭头是电力线方向。\n\n\n\n### 实验结果\n\n#### 虚拟仿真平行板电容器与加盖导体槽内的电位分布\n\n<img src=\"/lab02-1-3D.png\" alt=\"lab02-1-3D\" style=\"zoom:50%;\" />\n<img src=\"/lab02-1-xy.png\" alt=\"lab02-1-xy\" style=\"zoom: 30%;\" />\n\n\n\n\n\n#### 虚拟仿真平行板电容器与加盖导体槽内的电位分布\n\n<img src=\"/lab02-2-3D.png\" alt=\"lab02-2-3D\" style=\"zoom: 50%;\" />\n<img src=\"/lab02-2-xy.png\" alt=\"lab02-2-xy\" style=\"zoom:50%;\" />\n\n\n\n\n\n\n### 参考文献\n\n+ 雷亚平, 肖洪祥, 匡晚成. [基于MATLAB的电磁场数值分析](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFD2007&filename=WDZC200710006&v=MTU1MzNDdm1WNzdPTWluUmJiRzRIdGJOcjQ5RllvUjhlWDFMdXhZUzdEaDFUM3FUcldNMUZyQ1VSN3FmWXVkb0Y=)\\[J\\]. 电子测试, 2007(10):17-19. \n\n\n\n\n\n## 实验三　平面电磁波的反射和干涉实验\n\n\n\n### 实验结果\n\n#### 平面电磁波向理想导体垂直入射的仿真结果\n\n入射波垂直入射到$z = 0$的无限大理想导电平面上，两区域的的本构参数分别取为：\n\n$$\\begin{aligned}    z<0:&\\quad \\varepsilon_1=1,\\ \\mu_1=1,\\ \\sigma_1=0.\\\\    \nz>0:&\\quad \\varepsilon_2=1,\\ \\mu_2=1,\\ \\sigma_2=\\infty. \\end{aligned}$$\n\n![lab031](/lab031.png)\n\n取角频率$\\omega=\\frac{\\pi}{2}$，则 \n\n$$k_1=\\omega\\sqrt{\\mu_1\\varepsilon_1}=\\frac{\\pi}{2},\\ \\eta_1=\\sqrt{\\frac{\\mu_1}{\\varepsilon_1}}=1$$ \n\n$\\varGamma=-1$，故\n\n $$E_{i0}=-E_{r0},$$ \n\n全部的入射波被反射形成反向传播的反射波，故不存在透射波。\n\n下图中，蓝色波形为入射波，橙色波形为反射波，绿色波形为合成的驻波。蓝绿色透明平面代表无耗介与理想导体的分界面。\n\n![lab031](/lab031.gif)\n\n令入射波振幅$E_{i0}=1$。 入射波：\n\n $$\\begin{aligned}\n\\text{电场：}&\\quad{\\vec E_i}={\\hat a_x}{E_{i0}}{e^{-j{k_1}z}}={\\hat a_x}{e^{-j{\\frac{\\pi}{2}}z}}\\\\\n\\text{磁场：}&\\quad{\\vec H_i}={\\hat a_y}\\frac{1}{\\eta_1}{E_{i0}}{e^{-j{k_1}z}}={\\hat a_y}{e^{-j{\\frac{\\pi}{2}}z}}\\\\\n\\text{电场随时间形式：}&\\quad{\\vec E_i}(z,t)={\\hat a_x}{E_{i0}}\\cos(\\omega t-k_1 z)={\\hat a_x}\\cos(\\frac{\\pi}{2}t-\\frac{\\pi}{2}z)\\end{aligned}$$\n\n反射波：\n\n $$\\begin{aligned}\n        \\text{电场：}&\\quad {\\vec E_r} =-{\\hat a_x}{E_{i0}}{e^{  j{k_1}z}}=-{\\hat a_x}{e^{ j{\\frac{\\pi}{2}}z}}\\\\\n        \\text{磁场：}&\\quad {\\vec H_r} ={\\hat a_y}\\frac{1}{\\eta _1}{E_{i0}}{e^{ j{k_1}z}}= {\\hat a_y}{e^{ j{\\frac{\\pi}{2}}z}}\\\\\n        \\text{电场随时间形式：}&\\quad {\\vec E_r}(z,t)=-{\\hat a_x}{E_{i0}}\\cos(\\omega t+k_1 z)=-{\\hat a_x}\\cos(\\frac{\\pi}{2} t+\\frac{\\pi}{2}z)\\end{aligned}$$\n\n透射波：不存在\n\n合成波（驻波）：合成波为驻波，不发生能量传输过程，仅在两个波节间进行电场能量和磁场能的交换。\n\n\n\n#### 平面电磁波向理想介质垂直入射的仿真结果\n\n入射波垂直入射到$z = 0$的无限大理想介质平面上，两区域的的本构参数分别为： \n\n$$\\begin{aligned}    z<0:&\\quad \\varepsilon_1=1,\\ \\mu_1=1,\\ \\sigma_1=0.\\\\     z>0:&\\quad \\varepsilon_2=4,\\ \\mu_2=1,\\ \\sigma_2=0.\\end{aligned}$$\n\n![lab032](/lab032.png)\n\n取角频率$\\omega=\\frac{\\pi}{2}$，则\n\n $$\\begin{aligned}{2}    &k_1=\\omega\\sqrt{\\mu_1\\varepsilon_1}=\\frac{\\pi}{2},&\\ \\eta_1=\\sqrt{\\frac{\\mu_1}{\\varepsilon_1}}=1\\\\    &k_2=\\omega\\sqrt{\\mu_2\\varepsilon_2}=\\pi,&\\eta_2=\\sqrt{\\frac{\\mu_2}{\\varepsilon_2}}=\\frac{1}{2}\n\\end{aligned}$$ \n\n$$\\varGamma=\\frac{E_{r0}}{E_{i0}}=-\\frac{1}{3}, T=\\frac{E_{t0}}{E_{i0}}=\\frac{2}{3}.$$ \n\n$$E_{r0}=-\\frac{1}{3}E_{i0},\\ E_{t0}=\\frac{2}{3}E_{i0}$$ \n\n![lab032](/lab032.gif)\n\n\n\n令入射波振幅$E_{i0}=1$。 入射波： \n\n$$\\begin{aligned}        \\text{电场：}&\\quad {\\vec E_i} ={\\hat a_x}{E_{i0}}{e^{ - j{k_1}z}}= {\\hat a_x}{e^{ - j{\\frac{\\pi}{2}}z}}\\\\        \\text{磁场：}&\\quad {\\vec H_i} ={\\hat a_y}\\frac{1}{\\eta _1}{E_{i0}}{e^{ - j{k_1}z}}= {\\hat a_y}{e^{ - j{\\frac{\\pi}{2}}z}}\\\\        \\text{电场随时间形式：}&\\quad {\\vec E_i}(z,t)={\\hat a_x}{E_{i0}}\\cos(\\omega t-k_1 z)={\\hat a_x}\\cos(\\frac{\\pi}{2} t-\\frac{\\pi}{2}z)\\end{aligned}$$\n\n反射波： \n\n$$\\begin{aligned}        \\text{电场：}&\\quad {\\vec E_r} =-\\frac{1}{3}{\\hat a_x}{E_{i0}}{e^{  j{k_1}z}}=-\\frac{1}{3}{\\hat a_x}{e^{ j{\\frac{\\pi}{2}}z}}\\\\        \\text{磁场：}&\\quad {\\vec H_r} =\\frac{1}{3}{\\hat a_y}\\frac{1}{\\eta _1}{E_{i0}}{e^{ j{k_1}z}}=\\frac{1}{3} {\\hat a_y}{e^{ j{\\frac{\\pi}{2}}z}}\\\\        \\text{电场随时间形式：}&\\quad {\\vec E_r}(z,t)=-\\frac{1}{3}{\\hat a_x}{E_{i0}}\\cos(\\omega t+k_1 z)=-\\frac{1}{3}{\\hat a_x}\\cos(\\frac{\\pi}{2} t+\\frac{\\pi}{2}z)\\end{aligned}$$\n\n透射波： \n\n$$\\begin{aligned}    \\text{电场：}&\\quad {\\vec E_t} =\\frac{2}{3}{\\hat a_x}{E_{i0}}{e^{-j{k_2}z}}=\\frac{2}{3}{\\hat a_x}{e^{-j{\\pi}z}}\\\\    \\text{磁场：}&\\quad {\\vec H_t} =\\frac{2}{3}{\\hat a_y}\\frac{1}{\\eta _2}{E_{i0}}{e^{-j{k_2}z}}=\\frac{4}{3} {\\hat a_y}{e^{-j{\\pi}z}}\\\\    \\text{电场随时间形式：}&\\quad {\\vec E_t}(z,t)=\\frac{2}{3}{\\hat a_x}{E_{i0}}\\cos(\\omega t-k_2 z)=\\frac{2}{3}{\\hat a_x}\\cos(\\frac{\\pi}{2} t-\\pi z)\\end{aligned}$$\n\n\n\n\n\n### 代码\n\n**lab031.m**\n\n```matlab\n%% Perpendicular incidence to an ideal conductor\nclear ,clc\nE0=1; % The amplitude of the incident wave at z = 0\nk1=pi/2; % phase\n\n% Draw the interface between lossless medium and conductor\nfor j=1:180\n    display(j);\n    z = linspace(-3,3,100);\n    y = linspace(-3,3,100);\n    x = 0.*repmat(z,100,1) + 10000.*repmat(y,100,1);\n    surf(z,y,x);\n    alpha(.3);\n    shading interp\n    hold on\n    plot3 ([-15 5],[0 0],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[-3 3],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[0 0],[-3 3],'k','LineWidth' ,1);\n    hold on\n    xlabel('$z$','FontSize',14,'Interpreter','latex');ylabel('$y$','FontSize',14,'Interpreter','latex');zlabel('$x$','FontSize',14,'Interpreter','latex');\n    grid on\n    set(gca ,'XLim' ,[-15 5]);\n    set(gca ,'YLim',[-3 3]);\n    set(gca ,'ZLim',[-3 3]);\n    if j==1\n        annotation('textbox',...\n            [0.433214285714286 0.278523812884377 0.17979066144921 0.0733333299727666],...\n            'String',{'$\\varepsilon_1,\\mu_1,\\sigma_1=0$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        annotation('textbox',...\n            [0.651071428571428 0.393761908122476 0.195266855927426 0.0733333299727666],...\n            'String',{'$\\varepsilon_2,\\mu_2,\\sigma_2=\\infty$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        \n        annotation('textbox',[0.63 0.56 0.07 0.09],...\n            'Color',[0.00,0.45,0.74],...\n            'String',{'${\\vec E_i}$'},...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.50 0.65 0.07 0.09],...\n            'Color',[0.47,0.67,0.19],...\n            'String','${\\vec E}$',...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.23 0.43 0.07 0.09],...\n            'Color',[0.85,0.33,0.10],...\n            'String','${\\vec E_r}$',...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        \n        % Preperation of gif\n%         ax = gca;\n%         ax.Units = 'pixels';\n%         pos = ax.Position;\n%         ti = ax.TightInset;\n%         rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n%         frame = getframe(ax,rect);\n%         im=frame2im(frame);\n%         k = 1;\n%         [I{k},map{k}]=rgb2ind(im,256);\n%         imwrite(I{k},map{k,1},'lab031.gif','gif','Loopcount',Inf,'DelayTime',0.1);\n%         k = k + 1;\n    end\n    \n    % Preperation of drawing\n    z=linspace ( -15 ,0 ,1000);\n    y=zeros (1 ,1000);\n    \n    % Electric field of incident wave\n    Ei=E0.*cos(-k1.*z+(j./90).*pi);\n    plot3(z,y,Ei ,'Color' ,[0.00,0.45,0.74],'LineWidth' ,1.5);\n    grid on\n    \n    % Electric field of reflected wave\n    Er=-E0.*cos(k1.*z+(j./90).*pi);\n    plot3(z,y,Er ,'Color' ,[0.85,0.33,0.10],'LineWidth' ,1);\n    \n    % Electric field of synthetic wave\n    E=E0.*cos(-k1.*z+(j./90).*pi)+E0.*cos(k1.*z+(j./180).*pi);\n    plot3(z,y,E,'Color' ,[0.47,0.67,0.19],'LineWidth' ,1);\n    M(j) = getframe;\n    hold off\n    \n    % Get GIF\n%     ax = gca;\n%     ax.Units = 'pixels';\n%     pos = ax.Position;\n%     ti = ax.TightInset;\n%     rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n%     frame = getframe(ax,rect);\n%     im=frame2im(frame);\n%     [I{k},map{k}]=rgb2ind(im,256);\n%     imwrite(I{k},map{k},'lab031.gif','gif','WriteMode','append','DelayTime',0.1);\n%     k = k + 1;\nend\n\n%% Write the image to the GIF in reverse order\n% for i = (k-1):-1:1\n%     imwrite(I{i},map{i},'lab031.gif','gif','WriteMode','append','DelayTime',0.1);\n% end\n\n%% Function to play animation\nfor i=1:2\n    movie(M,1,30);\nend\n```\n\n\n\n**lab032.m**\n\n```matlab\n%% Normal incidence to ideal medium\nclear ,clc\nE0=1; % The amplitude of the incident wave at z = 0\nk1=pi/2;% phase\nk2=pi;% phase\n\n\n%% Draw the interface between lossless medium and conductor\nfor j=1:180\n    display(j);\n    z = linspace(-1.5,1.5,100);\n    y = linspace(-1.5,1.5,100);\n    x = 0.*repmat(z,100,1) + 10000.*repmat(y,100,1);\n    surf(z,y,x);\n    alpha(.3);\n    shading interp\n    hold on\n    plot3 ([-15 15],[0 0],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[-1.5 1.5],[0 0],'k','LineWidth' ,1);\n    hold on\n    plot3 ([0 0],[0 0],[-1.5 1.5],'k','LineWidth' ,1);\n    hold on\n    xlabel('$z$','FontSize',14,'Interpreter','latex');ylabel('$y$','FontSize',14,'Interpreter','latex');zlabel('$x$','FontSize',14,'Interpreter','latex');\n    grid on\n    set(gca ,'XLim' ,[-15 15]);\n    set(gca ,'YLim',[-1.5 1.5]);\n    set(gca ,'ZLim',[-1.5 1.5]);\n    if j==1\n        annotation('textbox',...\n            [0.433214285714286 0.278523812884377 0.17979066144921 0.0733333299727666],...\n            'String',{'$\\varepsilon_1,\\mu_1,\\sigma_1=0$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        annotation('textbox',...\n            [0.70 0.393761908122476 0.195266855927426 0.0733333299727666],...\n            'String',{'$\\varepsilon_2,\\mu_2,\\sigma_2=0$'},...\n            'Interpreter','latex',...\n            'FontSize',13,...\n            'EdgeColor','none');\n        \n        annotation('textbox',[0.45 0.65 0.07 0.09],...\n            'Color',[0.00,0.45,0.74],...\n            'String',{'${\\vec E_i}$'},...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.23 0.43 0.07 0.09],...\n            'Color',[0.85,0.33,0.10],...\n            'String','${\\vec E_r}$',...\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        annotation('textbox',[0.73 0.45 0.07 0.09],...\n            'Color',[0.47,0.67,0.19],...\n            'String','${\\vec E_t}$',....\n            'Interpreter','latex',...\n            'FontSize',15,...\n            'FitBoxToText','off',...\n            'EdgeColor','none');\n        \n        % Preperation of gif\n        ax = gca;\n        ax.Units = 'pixels';\n        pos = ax.Position;\n        ti = ax.TightInset;\n        rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n        frame = getframe(ax,rect);\n        im=frame2im(frame);\n        k = 1;\n        [I{k},map{k}]=rgb2ind(im,256);\n        imwrite(I{k},map{k,1},'lab032.gif','gif','Loopcount',Inf,'DelayTime',0.1);\n        k = k + 1;\n    end\n    \n    % Preperation of drawing\n    z=linspace ( -15 ,0 ,1000);\n    zt=linspace (0 ,15,1000);\n    y=zeros (1 ,1000);\n    \n    % Electric field of incident wave\n    \n    Ei=E0.*cos( -k1.*z+(j./90).*pi);\n    plot3(z,y,Ei ,'Color' ,[0.00,0.45,0.74],'LineWidth' ,1.5);\n    grid on\n    \n    % Electric field of reflected waves\n    Er=-E0.*cos(k1.*z+(j./90).*pi)./3;\n    plot3(z,y,Er ,'Color' ,[0.85,0.33,0.10],'LineWidth' ,1);\n    \n    % Electric field of transmitted waves\n    Et=2*E0.*cos( -k2.*zt+(j./90).*pi)./3;;\n    plot3(zt ,y,Et ,'Color' ,[0.47,0.67,0.19],'LineWidth' ,1);\n    hold off\n%     N(j) = getframe;\n    \n    % Get GIF\n    ax = gca;\n    ax.Units = 'pixels';\n    pos = ax.Position;\n    ti = ax.TightInset;\n    rect = [-ti(1), -ti(2), pos(3)+ti(1)+ti(3), pos(4)+ti(2)+ti(4)];\n    frame = getframe(ax,rect);\n    im=frame2im(frame);\n    [I{k},map{k}]=rgb2ind(im,256);\n    imwrite(I{k},map{k},'lab032.gif','gif','WriteMode','append','DelayTime',0.1);\n    k = k + 1;\nend\n\n%% Write the image to the GIF in reverse order\nfor i = (k-1):-1:1\n    imwrite(I{i},map{i},'lab032.gif','gif','WriteMode','append','DelayTime',0.1);\nend\n\n%% Function to play animation\n% for i=1:2\n%     movie(N,1,30);\n% end\n```\n\n\n\n### 参考文献\n\n1. 李丽芬,张秋菊,李扬.[基于Matlab的均匀平面电磁波的仿真](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDHIS2&filename=XDDJ201321039&v=MjQ2MThSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZdWRxRkNybFZyM0xQU25QWkxHNEg5TE9ybzlHYlk=)\\[J\\].现代电子技术,2013,36(21):136-137+140.\n2. 火星十一郎.Matlab绘制透明平面（二元函数）\\[EB/OL\\].<https://www.cnblogs.com/hxsyl/p/4824884.html>.2015-09-21/2020-05-11.\n3. 吕秀丽,牟海维,李贤丽.[Matlab在电磁场与电磁波实验教学中之应用](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFD2010&filename=SYSY201002037&v=MDExNjR1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZdWRxRkNybFVidklOalRZZDdHNEg5SE1yWTlHWTRSOGVYMUw=)\\[J\\].实验室研究与探索,2010,29(02):110-112+195. \n4. 木子识时务.Matlab绘制动态 .gif 图\\[EB/OL\\].<https://www.jianshu.com/p/cd9501bc810a>.2017-08-20/2020-05-12. \n5. 林特斯9527.LaTeX 中插入GIF图片\\[EB/OL\\].<https://www.cnblogs.com/LinTeX9527/p/11122268.html>.2019-07-02/2020-05-12 .\n6. 始终.LaTeX 黑魔法（四）：插入动画（animate 宏包教程）\\[EB/OL\\].<https://liam.page/2017/08/10/importing-animate-in-LaTeX/>.2017-08-10/2020-05-12.\n\n\n\n### 主要心得\n\n1. 用`MATLAB`做GIF动画的感觉还是很奇妙的，以后应该会出一次博客。主要看的就是[参考文献4](https://www.jianshu.com/p/cd9501bc810a)这篇，里面的代码不用管为什么，基本上都没什么问题的，就是美中不足的是我*多手八只脚*（这个词多半没人听得懂），把他最后有一段反向添加进GIF的代码也贴过来了，就变成了入射波先进后出，有点怪异，但懒得在输出一次了，毕竟挺慢的。\n\n   > 绘制上述两个图的程序`lab031.m`是一个运动的过程。其中一部份运用到了`getframe`和`moive`两个函数，使动画延续多次。具体用法这里从略，有兴趣的话，可以运行程序尝试。\n   >\n   > 另一部分用于生成GIF动图，转化后的结果如图所示。主要的函数好像是`frame2im`和`imwrite`，需要先创建，后进行添加，所以这个应该有两次。\n\n2. 第二个“第一次”呢，就是成功在PDF文件中利用$\\LaTeX$的`animate`宏包插入了GIF（其实说不上，就只是PNG序列而已）。比较关键性的方法就是看的参考文献5、6。[参考文献6](https://liam.page/2017/08/10/importing-animate-in-LaTeX/)很详尽的叙述了GIP转PNG图像序列的转化方式，这里用到的是一个叫`ImageMagick`的工具，很好用啊，但是他是命令行指令，我有点头秃。[参考文献5](https://www.cnblogs.com/LinTeX9527/p/11122268.html)主要侧重于$\\LaTeX$内部到底怎么引用怎么安排，也是拿来就能用的代码，就很好。\n\n3. 但是这个PDF嵌入动画效果吧，就有一个局限，该动效需要使用具备JavaScript的PDF阅读器才能观看，如Adobe Acrobat等。网上有的说福昕阅读器能开，有的说不能，还有的说很卡，我不得而知。所以我在交作业的地方留了这边的链接防止GIF放不出，也不知道老师有没有看到这里啊！\n\n4. 至于说实验中遇到的问题嘛，倒也不是没有，就是被一篇论文坑了。说的就是你，[参考文献1](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDHIS2&filename=XDDJ201321039&v=MjQ2MThSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZdWRxRkNybFZyM0xQU25QWkxHNEg5TE9ybzlHYlk=)！他透射波的公式${\\vec E_t}(z,t)=\\frac{2}{3}{\\hat a_x}{E_{i0}}\\cos(\\omega t-k_2 z)=\\frac{2}{3}{\\hat a_x}\\cos(\\frac{\\pi}{2} t-\\pi z)$中$k_2$带的还是 $\\frac{\\pi}{2}$，这就不对了啊，这个波数不是$k=\\omega\\sqrt{\\varepsilon\\mu}$嘛，$k_2$显然是$k_1$的两倍啊，所以平面电磁波向理想介质垂直入射透射波被压缩了啊。\n\n\n\n## 实验四　电磁波的极化实验\n\n### 实验原理\n\n平面电磁波沿轴线前进没有 $E_z$ 分量，一般情况下，存在 分量和 $E_y$ 分量，如果$E_y$分量为零，只有$E_x$分量我们称其为X方向线极化。如果只有$E_y$分量而没有$E_x$分量我们称其为Y方向线极化。\n\n在一般情况下，$E_x$和$E_y$都存在，在接收此电磁波时，将得到包含水平与垂直两个分量的电磁波。如果此两个分量的电磁波的振幅和相位不同时，可以得到各种不同极化形式的电磁波。\n\n1. 如果电磁波场强的$X$和$Y$分量为：\n\n $$\\begin{aligned}    {E_x}&={E_{xm}}\\cos \\left( \\omega t+\\varphi_1-kz \\right)\\\\    {E_y}&={E_{ym}}\\cos \\left( \\omega t+{\\varphi _2}-kz \\right)\\end{aligned}$$ \n\n其中$\\varphi_1$、${\\varphi _2}$为初相位，$\\displaystyle k=\\frac{2\\pi }{\\lambda }$。\n\n若$\\varphi_1$等于$\\varphi_2$，或${\\varphi _1}$与$\\varphi_2$相位差为$2n\\pi$时，其合成电场为线极化波，其幅度为：\n\n电场分量与$X$轴的夹角为： \n\n$$\\alpha =\\arctan \\frac{E_y}{E_x}=\\arctan \\frac{E_{ym}}{E_{xm}}=\\text{常数}$$\n\n2. 如果$\\varphi_1$与$\\varphi_2$相位差90°或270°，则：\n\n $$\\begin{aligned}    {E_x}=&{E_{xm}}\\cos \\left( \\omega t-kz+\\varphi_1 \\right)\\\\     {E_y}=&{E_{ym}}\\cos \\left( \\omega t-kz+\\varphi_2 \\right)\\end{aligned}$$\n\n合成电磁场为：\n\n $$E=\\sqrt{E_x^{2}+E_y^{2}}=\\sqrt{E_{xm}^{2}+E_{ym}^{2}}=\\text{常数}$$\n\n它的方向是：\n\n $$\\begin{gathered}    \\tan \\alpha =\\frac{E_y}{E_x}=\\tan \\left( \\omega t-kz+\\varphi_1 \\right)\\\\     \\alpha =\\omega t-kz+\\varphi_1\\end{gathered}$$ \n\n表示合成场振幅不随时间变化，其方向是随时间而旋转的圆极化波。\n\n3. 如果其相位不为0°，180°也不是90°、270°时，合成波为椭圆极化波。\n\n\n\n### 仿真程序介绍\n\n针对**电磁波的极化实验**，我利用`MATLAB`制作了GUI界面。 如图所示，该GUI可执行程序有四部分组成：*学号尾数（生成$E_m$）、仪表盘、坐标区、按钮区*。\n\n![电磁波的极化实验GUI界面介绍](/lab04.png)\n\n制作GUI界面的主要步骤介绍见附录。其中三维空间中电场强度矢端轨迹为上图中右图蓝色线。图中红色带圆圈的矢量线为 $z=0$ 平面的电场强度矢量$\\boldsymbol{E}$。同时程序设置中设置了可以判断360°以内的极化方式，直接生成。\n\n\n\nGUI界面主要参考台湾大学郭彦甫老师的`MATLAB`视频和《Matlab GUI在电磁波极化特性教学中的应用》进行设计。设计过程中主要包含两个文件：代码文件`GUI4.m`、图像界面文件`GUI4.fig`。主要过程如下：\n\n1.  在`MATLAB`的`Command Window`中输入指令`guide`，选择`Blank GUI`，创建页面。\n2.  在左侧拖动控件到页面，我主要使用的是坐标区(axes), 静态文本框(Static text)，可编辑文本框(Edit)。\n3.  点击绿色运行按钮（三角符号），生成`GUI4.m`文件，在其中编写各按键的功能。\n4.  `Command Window`中输入指令`GUI4`，可运行程序。\n5.  `Command Window`中输入指令`deploytool`，可打包程序为exe可执行文件，名称为`Polarization_of_electromagnetic_waves.exe`，文件在一般电脑上即可运行，完整的可执行exe文件看👉[这里的链接](https://levitate.lanzous.com/iWzRAd95m3c)。若仍有问题，具体可能需要安装MATLAB Runtime。\n\n\n\n\n\n### 实验结果\n\n#### 设置的部分初始参数：\n\n+ 角频率：$\\omega=10$\n+ 波数：$k=\\frac{\\pi}{4}$\n+ 最大振幅：$E_m =5+0.1\\times N$（$N$为学号尾数后两位`16`，即$E_m=6.6$）\n\n其他参数基本上都体现在图里了。\n\n\n\n#### 线极化波\n\n-　波的传播方向：沿$z$轴正方向\n\n![lab041](/线.gif)\n\n\n\n#### 圆极化波\n\n-   波的传播方向：沿$z$轴正方向\n\n-   圆极化旋向：顺时针，**左旋**圆极化波\n\n![lab042](/圆.gif)\n\n\n\n#### 椭圆极化波\n\n-   波的传播方向：沿$z$轴正方向\n\n-   椭圆极化旋向：顺时针，**左旋**椭圆极化波\n\n![lab043](/椭圆.gif)\n\n\n\n### 代码\n\n这里只列出了其中最主要的回调函数，即按下`Stimulate`(仿真键)时的回调函数:\n\n``` matlab\n% --- Executes on button press in stimulate.\nfunction stimulate_Callback(hObject, eventdata, handles)\n% hObject    handle to stimulate (see GCBO)\n% eventdata  reserved - to be defined in a future version of MATLAB\n% handles    structure with handles and user data (see GUIDATA)\nclc;\n% frequency and Time\nomega=10;\nT=2*pi/omega;\n% wave speed k\nk=pi/4;\n% E_m: maximum of E\nN=str2double(get(handles.N,'String'));\nE_m=5+0.1*N;\nangle=str2double(get(handles.angle,'String'));\nangle_rad=angle./180.*pi;\nEm_x=E_m.*cos(angle_rad);\nEm_y=E_m.*sin(angle_rad);\nset(handles.Em_x,'String',num2str(Em_x));\nset(handles.Em_y,'String',num2str(Em_y));\nE_x=[ ];E_y=[ ];\nE_max=max(Em_x,Em_y);\n% phi: phase\nphi_x=str2double(get(handles.phi_x,'String'))*pi/180;\nphi_y=str2double(get(handles.phi_y,'String'))*pi/180;\ndelta_phi=phi_y-phi_x;\nif (mod(delta_phi,pi)==0) \n    set(handles.yanshi,'string','线极化');\nelseif (mod(delta_phi,2*pi)==3*pi/2) \n    set(handles.yanshi,'string','右旋圆极化');\nelseif (mod(delta_phi,2*pi)==pi/2) \n    set(handles.yanshi,'string','左旋圆极化');\nelseif(delta_phi<0) \n    set(handles.yanshi,'string','右旋椭圆极化');\nelse\n    set(handles.yanshi,'string','左旋椭圆极化');\nend\n% other intinal settings\nzmin=0;\nzmax=10.*pi;        % Range of z coordinate\nz=zmin:pi/9:zmax;\nn=length(z);\n\n% Calculation of drawing the outline of z = 0 plane\nfor t1=0:0.01*T:1*T\n    Ex=Em_x*cos(omega*t1-k.*z+phi_x);\n    Ey=Em_y*cos(omega*t1-k.*z+phi_y);\n    E_x=[E_x Ex(1)];E_y=[E_y Ey(1)];\nend\nz1=zeros(length(E_x));\n\n% Calculation of drawing dynamic simulation diagram\nfor t=0:0.01*T:1*T\n    % Calculate the magnitude of the x and y components of the electric field strength at each point\n    Ex=Em_x*cos(omega*t-k.*z+phi_x);\n    Ey=Em_y*cos(omega*t-k.*z+phi_y);\n    \n    %Plot the contour of the z = 0 plane and the electric field vector at time t\n    axes(handles.axes1);cla(handles.axes1);\n    plot(E_x,E_y,'k-','LineWidth',2);\n    plot(Ex(1),Ey(1),'ro','LineWidth',2);\n    plot ([-Em_x Em_x],[0 0],'k','LineWidth' ,1);\n    plot (Em_x,0,'k>','LineWidth' ,1,'MarkerFaceColor','k');\n    plot ([0 0],[-Em_y Em_y],'k','LineWidth' ,1);\n    plot (0,Em_y,'k^','LineWidth' ,1,'MarkerFaceColor','k');\n    line([0 Ex(1)],[0 Ey(1)],'Color','r','LineWidth',2);\n    xlabel('$x$','FontSize',14,'Interpreter','latex');\n    ylabel('$y$','FontSize',14,'Interpreter','latex');\n    grid on;\n    axis equal;\n    axis([-Em_x,Em_x,-Em_y,Em_y]);\n    hold on\n    \n    % Plot the outline of the z = 0 plane and the three-dimensional map of the electric field vector at time t and the dynamic map of the electric field propagation\n    axes(handles.axes2);cla(handles.axes2);\n    plot3(z1,E_x,E_y,'k-','LineWidth',2);\n    plot3(z,Ex,Ey,'b.-','LineWidth',2);\n    line([0 0],[0 Ex(1)],[0 Ey(1)],'Color','r','LineWidth',2);\n    plot3(z(1),Ex(1),Ey(1),'ro','LineWidth',2);\n    plot3 ([zmin zmax],[0 0],[0 0],'k','LineWidth' ,1);\n    plot3 (zmax,0,0,'k>','LineWidth' ,1,'MarkerFaceColor','k');\n    plot3 ([0 0],[-E_max E_max],[0 0],'k','LineWidth' ,1);\n    plot3 (0,E_max,0,'k<','LineWidth' ,1,'MarkerFaceColor','k');\n    plot3 ([0 0],[0 0],[-E_max E_max],'k','LineWidth' ,1);\n    plot3 (0,0,E_max,'k^','LineWidth' ,1,'MarkerFaceColor','k');\n    for m=1:1:n\n        line([z(m) z(m)],[0 Ex(m)],[0 Ey(m)],'Color','r','LineWidth',0.5);\n    end\n    grid on;\n    box on;\n    axis([zmin,zmax,-E_max,E_max,-E_max,E_max]);\n    axis equal;\n    xlabel('$z$','FontSize',14,'Interpreter','latex');\n    ylabel('$x$','FontSize',14,'Interpreter','latex');\n    zlabel('$y$','FontSize',14,'Interpreter','latex');\n    view(-30,5);\n    hold on\nend\n```\n\n具体的代码等5月20号电磁场实验结束以后再放。\n\n\n\n### 参考文献\n\n1. bilibili.MATLAB教程\\_台大郭彦甫（14课）原视频补档\\[V/OL\\].<https://www.bilibili.com/video/BV1GJ41137UH?t=3177&p=7>.2019-09-19/2020-05-16. \n2. 余建立.[Matlab GUI在电磁波极化特性教学中的应用](https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&dbname=CJFDLAST2018&filename=ZXDB201816130&v=MjU5Nzdiek1QelhQYkxHNEg5bk5xWTVHWklSOGVYMUx1eFlTN0RoMVQzcVRyV00xRnJDVVI3cWZZdWRxRkN2Z1Y=)\\[J\\].科技创新导报,2018,15(16):244-246.\n\n\n\n### 主要心得\n\n1. GUI界面初步入门<u>（后续或许会写一篇博客吧）</u>\n2. MATLAB中的GUI不支持*异步*，所以按下按钮差不多要等一个周期走完才行。中途试过全局变量，但是还是不行啊，如果有知道怎么*异步*的一定告诉我！\n3. 一开始想的是通过确定的$E_m$和待定的$E_{mx}$来控制即可，但发现这样不可能调出正圆来（6.6太坑爹了），就只好用$\\alpha=\\arctan\\frac{E_y}{E_x}$咯！\n4. 坐标轴的一个不错的画法，再也不用`annotation`去凑了，其中坐标轴的箭头其实是用的数据标记的左右上下小三角实现的。\n\n```matlab\n    plot3 ([zmin zmax],[0 0],[0 0],'k','LineWidth' ,1);\n    plot3 (zmax,0,0,'k>','LineWidth' ,1,'MarkerFaceColor','k');\n    plot3 ([0 0],[-E_max E_max],[0 0],'k','LineWidth' ,1);\n    plot3 (0,E_max,0,'k<','LineWidth' ,1,'MarkerFaceColor','k');\n    plot3 ([0 0],[0 0],[-E_max E_max],'k','LineWidth' ,1);\n    plot3 (0,0,E_max,'k^','LineWidth' ,1,'MarkerFaceColor','k');\n```\n\n5. 关闭`Exit`按钮的代码其实就一句`close`，清空坐标区和字符串的代码也很简单\n\n```matlab\n% 重置清空图片 \ncla(handles.axes1,'reset');\ncla(handles.axes2,'reset');\n% 重置清空动态txt的文字 \nset(handles.yanshi,'string','演示')\nset(handles.angle,'string','')\nset(handles.Em_x,'string','')\n```\n\n6. 这次是GUI，所以不是`MATLAB`自动导出的GIF，而是将GUI界面的exe可执行程序运行过程录屏后，通过Premiere转换为PNG图片序列（但为什么Premiere导出来的图这么大呢，还不清楚，100K的图还不如上次实验直出的20K的图得质量好）。","tags":["电磁场与电磁波"],"categories":["课程向"]},{"title":"10类案例带你了解论文插图制作","url":"/2020/05/04/10类案例带你了解论文插图制作/","content":"\n# 10类案例带你了解论文插图制作\n\n文章具体的讲解Slides仅限西电MSC内部参考，我会把供操作练习的数据表格放在这里（👉 **[可供练习用的数据](https://levitate.lanzoux.com/ic7vupa)**），也欢迎观看B站技术沙龙的录播（👉[BV1c5411W7U9](https://www.bilibili.com/video/BV1c5411W7U9#reply3004854776)，大家也可以直接在这个网页上观看）。\n\n\n<div class=\"aspect-ratio\">\n    \t\t<iframe  src=\"//player.bilibili.com/player.html?aid=455962029&bvid=BV1c5411W7U9&cid=199388439&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n</div>\n<div style=\"padding-bottom:10px\">\n</div>\n<style>\n/* 这个规则规定了iframe父元素容器的尺寸，我们要去它的宽高比应该是 25:14 */\n.aspect-ratio {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56%; /* 高度应该是宽度的56% */\n}/* 设定iframe的宽度和高度，让iframe占满整个父元素容器 */\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n</style>\n\n\n<div style=\"padding-bottom:10px\">\n</div>\n\n\n数模国赛、美赛部分论文资源（👉[戳这边](https://levitate.lanzoux.com/b0de3dx0h)　密码:1yj6）\n\n\n\n> 论文的内容才是重点\n>\n> 排版和插图只是锦上添花的\n\n\n\n### 选择什么工具？为什么？\n\n![选什么工具](/选什么工具.png)\n\n\n\n### 权重图、热力图、三维地图\n\n+ 我为什么把它们放在一起讲？\n  + 这三类图其实都是表示的相关位置的重要程度，其制作工具也是比较类似的。\n\n  + 当权重图到达一定数量时，也就演变成了热力图。(千万别学这样做热力图，电脑会爆炸的)\n\n\n+ 权重图可以用在哪里？怎么做？\n  + 我一般利用Excel中的色阶工具，再利用PowerPoint进行进一步的修饰。\n\n+ 热力图的制作方法有哪些？\n  + 这里主要介绍利用三维地图的方式。\n\n+ 三维地图怎么用？有什么注意事项？\n  + 这个功能在哪儿？没有这个功能怎么办？\n\n###  \n\n## 〔案例1〕用色阶来表达权重\n\n![案例1](/案例1.png)\n\n### 权重图\n\n+ 我使用的方法：Excel+PowerPoint\n  1. Excel中列出数据，利用**色阶**着色\n  2. 拷贝到Powerpoint中注意粘贴选项选择**保留原格式**。\n\n+ 两个使用案例的共性之处\n  + 这两个例子其实都相当于是一个矩阵，将矩阵的各个位置的重要程度标注出来更加明显。\n\n  + 2020美赛D这个计算的是一个逻辑距离；2019美赛D这个其实也计算的是一个距离，颜色表示危险程度。\n\n\n\n## 〔案例2〕不同软件实现热力图\n\n![案例2](/案例2.png)\n\n### 热力图\n\n+ 热力图的制作方法有哪些？\n  + Python\n    + 地图类：https://www.zhihu.com/question/33783546/answer/775946401\n\n  + MATLAB\n\n  + Excel三维地图\n\n  + 其他在线工具（图表秀、高德地图的接口……）\n    + 图表秀：https://www.tubiaoxiu.com/index.html\n    + 高德地图：https://zhuanlan.zhihu.com/p/59381797\n\n\n###  \n\n## 〔案例3〕强大的三维地图\n\n![案例3](/案例3.png)\n\n### 三维地图入门\n\n+ 这个功能在哪儿？\n  + 这个功能是基于微软的Bing地图的。根据官网显示，以下版本有三维地图的功能：*Microsoft 365 专属 Excel, Excel 2019, Excel 2016, Excel 2013.*\n\n\n+ 三维地图的功能怎么学？\n  + 上官网：https://support.office.com/zh-cn/article/%e4%b8%89%e7%bb%b4%e5%9c%b0%e5%9b%be%e5%85%a5%e9%97%a8-6b56a50d-3c3e-4a9e-a527-eea62a387030\n\n+ 没有这个功能怎么办？\n  + 换一个Office版本，~~不行就换一台电脑~~\n\n  + 利用一些其他编程软件的库，亦或者是一些在线处理工具，也很强大。（这里就不介绍了）\n\n### 三维地图的使用\n\n+ 我使用的方法：Excel\n\n  1. 在Excel中处理好相应的数据，插入菜单中选择**三维地图**。\n\n  2. 根据自己要制作的不同地图，设置地图初始参数。\n\n  3. 在对应图层，设置**位置类型**，调节**色阶**、**影响半径**等，让它长得像我们需要的热力图。（至于其他设置，大家可以自己摸索）\n\n  4. 调整好各项参数与页面大小，页面左上角演示工具栏中有**捕获屏幕**，即可获得这个图像。\n\n+ 注意事项\n  + 美赛论文不能出现中文，记得安装语言包，使地图上的文字显示为英文。\n\n  + 这个方法的缺点就是不能获得非常清晰的图像。\n\n  + Excel中三维地图的默认设置是地图，可以导入自己需要的背景图，如我提供的足球场等。\n\n\n\n## 〔案例4〕散点图\n\n![案例4](/案例4.png)\n\n### 散点图\n\n+ 制作工具：Excel or PowerPoint\n  + Office中散点图的制作其实非常基础，就是由你手中有的*x*, *y*两组值的坐标利用Office自带图表中的散点图就可以制作。\n\n  + 但这里的问题是如何做的更生动形象，这是我在美赛是画不同灵活度散点图时所思考的问题。\n\n+ 我的想法：\n  + 是否可以将这些点变得更形象化？我先把点的形式设置为小足球（有点密恐）；然后就换成了小球。\n  + 这个图片的背景能否更贴合题目？把背景设置成足球的半场。\n\n\n\n## 〔案例5〕着色图表\n\n（受19美赛A某O奖论文`#1919022`启发）\n\n![案例5](/案例5.png)\n\n\n\n### 两类基本着色图表\n\n+ 我使用的方法： MATLAB or Excel+PowerPoint\n  + 着色图表其实我是受到了19美赛A的一篇O奖论文的启发才开始做的。其实可以发现那篇O奖论文的图使用MATLAB画的，但是我们没有找到什么好方法，就用Excel+PowerPoint来实现了。\n\n####  普通折线图、线性拟合图——点実线透明、色彩对比鲜明\n\n+   推荐把点的颜色设的比较深，把线的颜色设的稍浅，显得更有层次感。\n\n+   不同线之间的颜色可以遵循两个原则：\n\n    +  对比色（建议这一大段只出现这一张图表使用）\n\n    +   同色系的不同色调（一大段有多张相似图表，可以每张图选择一个色系）\n\n+   这个在MATLAB中就能实现，不必导出到PowerPoint。\n\n\n####  面积图的实现——实际上就是在一块面积内填渐变色\n\n+ 针对MATLAB中的图：先导出为PDF，利用Adobe Acrobat中的导出为PowerPoint获得线条。\n\n1. 直接利用Office自带的面积图叠一层（勉强够用）\n   + 优点：方便，只要把数据在复制一遍选择面积图即可\n   + 缺点：Office的曲线图带有平滑拟合，而面积图无平滑拟合，所以会有留白。\n2. 把曲线分割成几段，进行填色\\*\n   + 这个基本可以填满，但是可能会出现意想不到的问题，只对二阶导数大于0的曲线符合的比较好。\n3. 利用Photoshop、Adobe Illustrator等工具处理（我不会）\n\n> 我傻了，其实面积图的实现从布尔运算更好实现，我怎么就一直没想到呢🤪。具体的可以看这篇[推文](https://mp.weixin.qq.com/s?__biz=MzI4NTQxOTIwNA==&mid=2247490248&idx=1&sn=b638df7c317b218d5baef66cdc262827&chksm=ebed2963dc9aa07555bdd3c7271b11d04971e643cfb638f380660546cdfc8ac8f11229c3c700&mpshare=1&scene=23&srcid=0225VtwwMYoNNWOJ2QUEEYol&sharer_sharetime=1614263203548&sharer_shareid=aaa05ad123b07647a23d69b2a9ace7a7#rd)（来源：黑白间设计），不在重复演示了。\n>\n> 布尔运算在“形状格式”->\"插入形状\"->合并形状\"，有结合、组合、拆分、相交和剪除五种，具体意思其实就是集合的交∩、并∪、补运算。\n>\n> ——2021年2月24日\n\n### 建议：\n\n+  多看国赛优秀论文，美赛OF奖论文，寻找别人论文里可取的一些图表表现方式。这也是我在读19美赛A的优秀论文留意到的。\n\n+  我有的图做的也不是很好，色彩搭配显得比较廉价，特别注意不要滥用渐变色（渐变色的各颜色也要注意）、透明度、阴影、虚线、发光。\n\n+ 这里介绍的也只是一部分方法，实际还有很多其他的表现方式。\n\n  \n\n## 〔案例6〕突出对比的智能图表\n\n![案例6-1](/案例6-1.png)\n\n![案例6-2](/案例6-2.png)\n\n### 你知道Office自带哪些图表类型？\n\n+  Office自带的图表类型很多\n\n   +   日常最常用的柱状图、折线图、饼图、条形图、直方图。\n\n   +   前面介绍的着色图表中的面积图就是利用组合图实现的。\n\n   +  一组数据选择折线图\n\n   +   另一组数据选择面积图\n\n   +   X Y散点图也在前面介绍过了，其实用的不算多。\n\n   +   地图功能我一般利用Excel中的三维地图实现，比较立体，功能也比较多。\n\n   +   突出对比用的比较多的就是雷达图、类似漏斗的部分图表（条形图也勉强算）\n\n   +   树状图可以表现各组分在总体中的多少。\n\n   +   股价图、曲面图、旭日图、箱型图、瀑布图，我用的比较少就不谈了\n\n+   自带图表使用也不复杂，样式基本可以用自带的图表样式解决\n\n\n\n###  常用的插件\n\n+   这些插件其实是为制作Slides推出的，这也是我推荐使用PowerPoint而不是Word的一大原因，这些插件很多有会员什么的，我觉得免费的够用了。\n\n+   iSlide插件：设计排版中的矩阵布局、环形布局很好用；有丰富的案例库、主题库、图示库、智能图表、图标库……\n\n    +  比如我那张意大利队和哈士奇队对比的图就是利用智能图表制作的，比Office自带的漏斗图更精致。\n\n    +   我还做过一个类似WiFi样子的图，也是利用的智能图表\n\n+   口袋动画PA插件：主要是做动画的，其中的矢量工具很好用\n\n+   其他还有许多插件，我没装，就不多介绍了。\n\n\n\n## 〔案例7〕~~可有可无的~~流程图&层次图\n\n![案例7-1](/案例7-1.png)\n\n![案例7-2](/案例7-2.png)\n\n### 流程图&层次图\n\n+ 我使用的方法：Visio or PowerPoint中的SmartArt\n  + Visio尽量使用它的自动连线。\n\n  + SmartArt一定要选用适合的表。\n\n+ 注意事项：\n  + 这类图形最重要的就是对齐，对齐，对齐。\n\n    + 同种矩形之间的距离都保持一致，iSlide插件的矩阵布局很好啊！\n\n    + 可以使用PowerPoint自带的智能参考线功能（智能参考线一定要打开啊）\n\n    + 一般画线都让线吸附到对应图形的节点上好了。如果不想要吸附，连线时同时按着这Alt键即可。\n+ 可以利用色块使各层次之间变的比较突出。\n  + SmartArt找不到合适的情愿不用。SmartArt也可以嵌套在别的图表中使用。\n\n\n\n### 为什么我们需要三维图形？\n\n![为什么三维](/为什么三维.png)\n\n## 〔案例8〕PowerPoint还能画三维立体图？\n\n![案例8-1](/案例8-1.png)\n\n![案例8-2](/案例8-2.png)\n\n![案例8-3](/案例8-3.png)\n\n\n\n### 三维绘图的一些工具和技巧\n\n+ 图标素材的来源：\n  + 阿里巴巴的iconfont图标库（https://www.iconfont.cn/）\n\n  + Office自带的图标（更新了以后丰富许多）、iSlide插件的图标库\n\n+ 三维绘图的关键点：**形状效果的棱台和三维旋转**\n  + 棱台注意调节深度、光线、材质等，我调节纯凭感觉。\n  + 我经常用的各种材质小球其实就是使用棱台效果调节宽度得到的。\n  + 三维旋转X Y Z调节的角度我觉得是玄学，欢迎空间解几大佬分享正确做法。\n\n<center><img src=\"/三位格式.png\" alt=\"三位格式\" style=\"zoom:60%;\" /><img src=\"/三维旋转.png\" alt=\"三维旋转\" style=\"zoom:60%;\" /></center>\n\n+ 推荐一个三维绘图相关的b站up主：[伊曼如歌](https://space.bilibili.com/316970920/)（中科大做化学的，所以图片以化学相关的为主，但是思路都很好，讲解也很清晰），还有他的两个公众号“3D max 科研绘图教程交流”、“PPT 三维科研绘图”，内容也很好。\n\n\n### 三维图形使用建议\n\n+ 三维图形有什么好处？\n  + 可以更直观地体现一些细节，比如光线是如何入射的，不然只能通过箭头的长短体现。\n\n  + 有时候就是为了好看，说难听点就是美术建模。\n\n  + 要平衡好二维图形和三维图形的关系，别什么都三维图形，混在文章里就会格格不入。\n\n+ 建议：\n  + 三维绘图其实有时候就是靠的一时的灵感，也不是很好剖析内在的想法。\n\n  + 注意三维图形各部分之间的前后堆叠关系，尤其组合图形尤为重要。\n\n  + 可以适当的引入透明色，渐变色就没什么必要了。\n\n\n\n## 〔案例9〕系统自带的画图3D怎么样？\n\n![案例9](/案例9.png)\n\n### 画图3D软件\n\n+  这个软件能制作一些模型，嵌入PowerPoint中制作出非常炫酷的功能。\n\n+  这么强大的软件怎么用呢？\n\n   +   上官网：https://support.microsoft.com/zh-cn/office/%e4%bd%bf%e7%94%a8%e7%94%bb%e5%9b%be3d-%e4%b8%ad%e7%9a%84%e5%af%b9%e8%b1%a1-3c50155c-db04-42e4-b600-3d97db8184b2?ui=zh-cn&rs=zh-cn&ad=cn\n\n   +   知乎：https://www.zhihu.com/question/65654175\n\n+ 画图3D工具很强大，但是我不会用。\n\n  \n\n## 〔案例10〕素描？铅笔画？\n\n（受19美赛A某O奖论文`#1910246`启发）\n\n![案例10](/案例10.png)\n\n### 这真的是你画的吗？你还会素描？\n\n+ 我不会画素描！！！\n  + 这是利用网上的照片加滤镜得到的。\n\n  + 有兴趣的同学可以尝试一下，虽然我不会画画，但我能模仿19美赛A的养龙图啊！\n\n+ 我使用的工具：PowerPoint中的艺术效果\n  + 选中图片，选择菜单栏的**图片格式**。\n\n  + 选择调整工具栏的**艺术效果**。\n\n  + 选择**艺术效果选项**进行微调：透明度、压力、铅笔大小……\n\n<img src=\"/艺术效果.png\" alt=\"艺术效果\" style=\"zoom:48%;\" />\n\n> 不管Word还是PowerPoint\n>\n> 字体格式统一非常重要\n\n\n\n\n\n欢迎大家批评指正，但是留言区好像还不能用（逃","tags":["论文","数学建模"],"categories":["LaTeX and ..."]},{"title":"【完结】大学本科期间笔记整理","url":"/2020/05/01/XDU-note/","content":"\n# 大学本科期间笔记整理\n\n\n\n~~这个帖子不出意外，会持续更新的\\~ 欢迎大家持续关注\\~~~  基本上大学本科的考试都结束啦，这个帖子不出意外就不会有什么新的东西了。\n\n>**说明：**\n>\n>🆕最近更新：**已授权“对策府库”搬运教材、笔记**。\n>\n>1. 戳👉**标题**就好了，这套CSS好像标题有超链接不会变蓝，带有👉标记的都能点。\n>2. **请勿二改二传！！！切记不要去学校打印店打印，不然我的版权就没了！！！已授权“对策府库”搬运教材、笔记。**\n>3. 点击👉右边或者👇下面的菜单栏🗂，可以调出目录，查找你需要的笔记！\n>4. 如果有链接失效，我也不知道我会不会补链了~也许吧。 **注意关注页面顶端📌说明（会给出蓝奏云最新链接）**\n>5. 有部分记得比较烂的就不放上来了。这个帖子里面的其实都不是笔记，真正的笔记太乱了，我大部分都记在slides上了，这里的大多都是平时或者期末时候的整理，所以还是比较清晰的。\n>6. 如果有错误欢迎在**评论区**指出，但是我应该不会改了吧。**部分更改见每门课程下的勘误说明。**\n>7. 自大三（第5学期）起的笔记，密码均为**levitate**。\n>8. 另外分享某17级电卓学长阳神笔记的👉[网址](https://blog.csdn.net/xdzhujy/article/details/105835417?utm_source=app&tdsourcetag=s_pctim_aiomsg)\n>9. **研究生笔记**见👉[【完结】研究生期间笔记整理 | Levitate_ (levitate-qian.github.io)](https://levitate-qian.github.io/2022/12/05/SEU-note/)，有不少也是本科可以参考的，如“现代数字信号处理”、“数字通信原理与系统”、“工程矩阵理论”等\n\n附上一个18级电信的培养方案\n\n<div class=\"aspect-ratio\" >\n<iframe  src=\"https://app.powerbi.com/view?r=eyJrIjoiOTg4NTE4Y2YtMTJiYS00OWQxLTk2MGQtNmFiMTVjM2ZmYzQ4IiwidCI6IjlhYWFiZDMyLTBjNmItNGM2ZS04MTgwLTUyOTFhYjRhY2JiNCIsImMiOjZ9\" frameborder=\"0\" allowFullScreen=\"true\"></iframe>\n</div>\n<style>\n/* 这个规则规定了iframe父元素容器的尺寸，我们要去它的宽高比应该是 25:14 */\n.aspect-ratio {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56%; /* 高度应该是宽度的56% */\n}/* 设定iframe的宽度和高度，让iframe占满整个父元素容器 */\n.aspect-ratio iframe {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n</style>\n<div style=\"padding-bottom: 50pt\" ></div>\n\n加载比较慢，大约需要几分钟的时间。不如先开着它，过会儿再过来看它。ヾ(•ω•`)o\n\n<img src=\"/电子课本.png\" alt=\"电子课本\" style=\"zoom:150%;\" />\n\n### 👉[部分西电电院电子课本及习题解答](https://levitate.lanzoux.com/b0de3dt0d)\n\n密码:7ng6\n\n> 主要以西电电院教材为主，大部分公共课教材是一样的，同时兼顾部分老师不用发的教材这一做法。此电子教材仅供学习使用，侵删，部分来源于无纸化群。\n>\n> 更多不同专业的电子课本可见“对策府库”：https://mp.weixin.qq.com/s/wmal12IZ_yAkupwtaJCAWg\n\n\n\n---\n\n<img src=\"/数理基础.PNG\" alt=\"数理基础\" style=\"zoom:150%;\" /> \n\n## 📐数理基础\n\n### 数学\n\n#### 👉[高等数学（第1-2学期）](https://levitate.lanzoux.com/b0ddzmhab)\n\n　密码:g112\n\n​\t5+5学分（6+6→5+5，全校统考）\n\n​\t任课老师：张莉\n\n+ 01 微分方程\n+ 02 微积分（部分摘自ywh笔记）\n+ 03 无穷级数\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理）\n\n#### 👉[线性代数（第2学期）](https://levitate.lanzoux.com/b0ddzmi9g)\n\n　密码:hs9n\n\n​\t2.5学分（3→2.5，全校统考）\n\n​\t任课老师：李仁先\n\n+ 01 一二章整理\n+ 02 三四章整理\n+ 03 五六章整理\n+ 04 总复习beamer（来源：李仁先老师）\n\n（文末[保研复习（第5部分）](#保研复习)有部分概念性的整理）\n\n#### 👉[概率论与数理统计（第3学期）](https://levitate.lanzoux.com/b0ddzxg4f)\n\n密码:308k\n\n2.5学分（3→2.5，全校统考）\n\n任课老师：朱明哲\n\n+ 01 基本概念与数字特征（一四章）\n+ 02 随机变量及其分布（二三章）\n+ 03 数理统计基础（五六章）\n+ 04 参数估计与假设检验（七八章）\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理）\n\n#### 👉[场论与复变函数（第3学期）](https://levitate.lanzoux.com/b0ddzxf2h)\n\n密码:7ybj\n\n2.5学分（3→2.5，电院单独出卷）\n\n任课老师：朱明哲\n\n+ 01 复变函数（根据11班朱明哲老师使用教材——梁昌洪《复变函数札记》体系，结合西交四版《复变函数》整合而成）\n+ 02 场论\n\n\n\n#### 👉[计算方法（第3学期，学院选修）](https://levitate.lanzoux.com/ic8d17g)\n\n2学分（学院选修，电院单独出卷）\n\n任课老师：程亮\n\n计算方法是一页开卷的形式，就1张A4纸，就直接上传了一个PDF\n\n\n\n### 物理\n\n#### 👉[大学物理（第2-3学期）](https://levitate.lanzoux.com/b0ddzxgja)\n\n密码:2n4b\n\n3.5+3.5学分（3+5→3.5+3.5，英文大雾单独出卷，中文大雾全校统考）\n\n任课老师：汪加洁，保罗（大物上）张艳艳（大物下）\n\n（大一下是英文大雾比较简单，全是原题，所以也没什么整理；大二上是中文大雾就难了，考的也很垃圾。笔记都和ppt没什么两样，记得也比较烂，所以只放了整理，笔记就不放了）\n\n+ 01 光学\n+ 02 电磁学\n+ 03 相对论与近代物理\n\n\n\n---\n\n<img src=\"/电子类.PNG\" alt=\"电子类\" style=\"zoom:150%;\" />\n\n## 📡电子类\n\n### 电信公共课\n\n#### 👉[电路基础（第3学期）](https://levitate.lanzoux.com/b0ddzxfaf)\n\n密码:hi9e\n\n3学分（4→3，除通院外其余48学时学院统考）\n\n任课老师：叶强\n\n+ 01 基本概念与规律（对应教材第1章）\n+ 02 电阻电路（对应教材第2章）\n+ 03 动态电路（对应教材第3章）\n+ 04 正弦稳态电路（对应西电王松林三版第4章前半部分，对应西电张永瑞四版第4章）\n+ 05 耦合电路（对应西电王松林三版第4章后半部分，对应西电张永瑞四版第5章）\n+ 06 电路频率响应与谐振（对应西电王松林三版第5章，对应西电张永瑞四版第6章）\n+ 07 二端口网络（对应西电王松林三版第6章，对应西电张永瑞四版第7章）\n\n\n\n#### 👉[数字电路与逻辑设计（第4学期）](https://levitate.lanzoux.com/b0de6b2cj )\n\n密码:7wtv\n\n3学分（电院单独出卷）\n\n任课老师：任爱锋\n\n+ 👉[01 数制与编码](https://levitate.lanzoux.com/ijNeCeh6ali)（对应教材第1章）\n+ 👉[02 逻辑代数与组合逻辑](https://levitate.lanzoux.com/iFJTBeh6b7a)（对应西电第三版第2、4章，高教社新版第2、3章）\n+ 👉[03 触发器与时序逻辑](https://levitate.lanzoux.com/iWMCIeh6bzi)（对应西电第三版第5、6章，高教社新版第4、5章）\n+ 👉[04 集成逻辑门](https://levitate.lanzoux.com/ia9Eaeh6c4d)（对应西电第三版第3章，高教社新版第7章）\n+ 👉[05 脉冲波形的产生与整形](https://levitate.lanzoux.com/iYDDMeh6cdc)（对应西电第三版第7章，高教社新版第6章）\n+ 👉[06 存储器和可编程逻辑器件](https://levitate.lanzoux.com/iIA6veh6chg)（对应教材第8章）\n\n\n\n#### 👉[模拟电子技术基础（第4学期）](https://levitate.lanzoux.com/b0de6fiyb )\n\n密码:e3ma\n\n3.5学分（4→3.5，电院单独出卷）\n\n任课老师：罗铭\n\n**部分内容、顺序根据《新概念模拟电路》调整**\n\n+ 👉[01 集成运算放大器基础](https://levitate.lanzoux.com/iClUkei7ued)\n  + 对应孙肖子三版第1、2、3章，二版第1、2章\n  + 主要包括运放基础、RC有源滤波器基础\n+ 👉[02 晶体管基础(v1.1)](https://levitate.lanzoux.com/i78e9f3zdkb)\n  + 对应孙肖子三版第4、5章，二版第4、5章\n  + 主要包括半导体器件（二极管、三极管、场效应管）原理、特性及其构成的放大器\n+ 👉[03 晶体管提高](https://levitate.lanzoux.com/i6yxiei7v6b)\n  + 对应孙肖子三版第6、7章，二版第6、7章\n  + 主要包括运放内部电路和频率响应\n+ 👉[04 集成运算放大器提高](https://levitate.lanzoux.com/iKOd5ei7vfa)\n  + 对应孙肖子三版第8、10、11、12章，二版第3、8、9、10章\n  + 主要包括反馈、集成运放的非线性应用、功率放大电路和电源管理\n+ 模电（孙肖子第三版）作业*（仅供参考）*\n\n> **❗几处勘误：**\n>\n> 1. 在 **02 晶体管基础(v1.1)** 中，2-2节第4条S2的2.1步骤后的电路图中，误将等效电源写作 $E_B=\\frac{R_{B1}}{R_{B1}+R_{B2}}$ 应改为 $E_B=\\frac{R_{B2}}{R_{B1}+R_{B2}}$，此错误已在v1.0版中并未出现，被我改错了😂，特此说明。（电路的化简需要**具体问题具体分析**，这边改错是受模电教材课后题5-2影响改错的，这道题非常绕）\n\n\n\n#### 👉[信号与系统（第4学期）](https://levitate.lanzoux.com/b0de6sddi ) \n\n密码:cwu8\n\n3学分（4→3，除通院外其余48学时学院统考）\n\n任课老师：刘洋\n\n**主要根据西电黑色旧版、蓝白新版课件整理**\n\n+ 👉[01 信号与系统概述](https://levitate.lanzoux.com/iLDdLellqda)（对应教材第1章）\n+ 👉[02 连续系统、离散系统分析（时域）](https://levitate.lanzoux.com/iBLFyellqeb)（对应教材第2、3章）\n+ 👉[03 傅里叶变换（频域）](https://levitate.lanzoux.com/iWE3bellqgd)（对应教材第4章）\n+ 👉[04 拉普拉斯变换（s域）](https://levitate.lanzoux.com/iY5Tfellqhe)（对应教材第5章）\n+ 👉[05 z变换（z域）](https://levitate.lanzoux.com/iAfkSellqjg)（对应教材第6章）\n+ 👉[06 系统函数](https://levitate.lanzoux.com/iC5cOellqna)（对应教材第7章）\n+ 👉[07 系统状态变量分析](https://levitate.lanzoux.com/i7RMVellqob)（对应教材第8章）\n\n> **❗几处勘误：**\n>\n> 1. **傅里叶变换**的3-1 傅里叶级数中，傅里叶级数的三角形式第3条同频率合并形式，漏写了求和符号后的$A_n$，应为$f(t)=\\frac{A_{0}}{2}+\\sum_{n=1}^{\\infty} A_n\\cos \\left(n \\Omega t+\\varphi_{n}\\right)$。傅里叶级数的指数形式第2条，等号后多写了$\\frac12$，应为$f(t)=\\sum_{n=-\\infty}^{\\infty}F_n\\mathrm{e}^{jn\\Omega t}$。\n>\n> 2. **z变换**中，z变换的性质3（移位性质）单边z变换右移公式应将求和符号下方的$k=-\\infty$改为$k=-m$，即\n>\n>    $$f(k-m)\\longleftrightarrow z^{-m}\\left[F(z)+\\sum_{k=-m}^{-1}f(k)z^{-k}\\right]$$\n>\n> 3. **z变换**的5-3 z域分析中，第7条⑤LTI离散系统的正弦稳态响应，$f(k)=A\\cos(\\omega t+\\phi)$应改为$f(k)=A\\cos(\\theta t+\\phi)$。\n>\n> 4. 把信号和数字信号串起来\n>\n>     ![信号dsp](/信号dsp.png)\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理，离散信号部分与《数字信号处理》结合）\n\n#### 👉[电磁场与电磁波（第4学期）](https://levitate.lanzoux.com/b0de78ikb)\n\n密码:7c2f\n\n3学分（电院单独出卷）\n\n任课老师：安翔\n\n+ 01 电磁场与电磁波笔记（使用Marginnote3生成的导图，比较粗糙，很多地方理得也不对）\n+ 02 电磁场与电磁波公式整理（含部分习题）\n\n> 02 电磁场与电磁波公式整理到v1.4版本。\n\n\n\n#### 👉[射频电路基础（第5学期）](https://www.lanzoui.com/b0dee1kqj)\n\n（密码往顶上看）\n\n3学分（电院单独出卷）\n\n任课老师：赵建勋\n\n+ 👉[01 谐振功率放大器](https://www.lanzoui.com/ijcZGi7r6xg)\n\n+ 👉[02 正弦波振荡器](https://www.lanzoui.com/i4btUhpkkjg)\n+ 03 振幅调制与解调（含👉[讲义](https://www.lanzoui.com/iPEYbhiahwj)和👉[beamer](https://www.lanzoui.com/in4uXhiahyb)）\n+ 👉[04 混频](https://www.lanzoui.com/iSynqiyhn4b)（混频为课堂笔记，觉得没什么好整理的）\n+ 👉[05 角度调制与解调](https://www.lanzoui.com/iOoYyiz4z9g)\n+ 06 振幅调制与解调、混频、角度调制与解调总结\n  + 👉[06-1 振幅调制与解调、混频、角度调制与解调原理.pdf](https://www.lanzoui.com/iTHMFiz4zbi)\n  + 别的都无了\n\n（射频基本更新完了，可能还会有一些串联）\n\n> 第五章振幅调制与解调是为了射频翻转课堂做的，知识点基本上全了，部分内容引自学习指导。\n\n\n\n#### 👉[数字信号处理（第6学期）](https://levitate.lanzoux.com/b0dewwpsf)\n\n（密码往顶上看）\n\n3学分（电院单独出卷）\n\n任课老师：田春娜\n\n+ 👉[01 离散时间信号与系统](https://levitate.lanzoui.com/ikRnLq8vgri)\n\n+ 👉[02 离散傅里叶变换及其快速算法](https://levitate.lanzoui.com/iQla1q8vgxe)\n\n+ 👉[03 数字滤波器的设计与结构](https://levitate.lanzoui.com/i2szwq8vhbi)\n\n    \n\n> 大三下唯一一门主干课了。应该会比较及时的整理吧。\n>\n> dsp 6月18日考试，笔记整理完了，但是可能会有点乱。\n>\n> ❗勘误与补充：\n>\n> 1. 更新了v1.1版本，查漏补缺。\n>\n> 2. “02 离散傅里叶变换及其快速算法”中2-2 FFT，其中基2DIT-FFT的旋转因子变化规律和节点间距应当为：“第$m$级蝶形运算($L=m$)的旋转因子为$W_{N\\cdot 2^{L-M}}^0,W_{N\\cdot 2^{L-M}}^1,W_{N\\cdot 2^{L-M}}^{2^{L-1}-1}$，蝶形节点间距为$2^{m-1}$”\n>\n> 3. “03 数字滤波器”3-4算法结构中，IIR滤波器的直接型设计均在a前漏了“-”号。注意分母上是有负号的则滤波器中不再出现。\n>\n> 4. “03 数字滤波器”3-1数字滤波器基础中，数字滤波器的参数图疑似有误，应该为下图，且通带最大衰减和阻带最小衰减应当再取-20log转化为dB值。\n>\n>     ![DF](/DF.jpg)\n>\n> 5. 【补】IIR滤波器与FIR滤波器的差异\n>     + FIR滤波器单位脉冲响应有限长，IIR无限长；\n>     + FIR滤波器极点固定在原点，IIR极点位于单位圆内任何地方；\n>     + FIR阶次高，IIR阶次低；\n>     + FIR可实现严格线性相位，IIR不一定；\n>     + IIR采用递归结构，FIR一般采用非递归结构；\n>     + FIR可用FFT计算，IIR不能用FFT计算；\n>     + IIR可用模拟滤波器设计，FIR借助计算机设计\n>\n> 6. 【补】DTFT、Z变换、DFT关系\n>\n>     ![dsp](/dsp.png)\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理，离散信号与系统部分见《信号与系统》）\n\n#### 👉[通信原理（第6学期，学院选修）](https://levitate.lanzoux.com/b0dewwq0d)\n\n（密码往顶上看）\n\n2学分（3→2，学院选修，电信单独出卷）\n\n任课老师：武斌，张煜\n\n+ 01 通信原理笔记（使用Marginnote3生成的导图，根据通院曹丽娜mooc整理）\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理。【注意】其内容远超电院范围，另外包括了其它相关科目（射频、无线、雷达、图像）的知识）\n\n### 大三原雷达信号方向主干课\n\n#### 👉[随机信号分析（第5学期）](https://www.lanzoui.com/b0dedvtsj)\n\n（密码往顶上看）\n\n3学分（电院单独出卷）\n\n任课老师：陈建春\n\n+ 👉[01 概率论与随机过程](https://www.lanzoui.com/iOdthiyrlch)（v1.2含概率论部分内容）\n+ 👉[02 随机过程的线性变换](https://www.lanzoui.com/irOMNhpfqsb)\n+ 👉[03 窄带随机过程](https://www.lanzoui.com/iM4ieiyijod)\n+ 👉[04 随机过程的非线性变换](https://www.lanzoui.com/iIy5riyrili)\n\n（随机基本更新完了，毕竟12月中旬要考试了/(ㄒoㄒ)/~~，其实我也不是很清楚随机是不是放到数学会更好）\n\n> 勘误：（在复习过程中发现了一部分错误）\n>\n> 1. “01 概率论与随机过程”->“1-1 随机过程的基本概念”->“4. 矩函数”中“均方差函数”应当为“均方值函数”。\n> 2. “02 随机过程的线性变换”->“2-2 通过LTI系统”->1（1）②中“$R_{YX}(\\tau)=R_{Y}(\\tau)\\otimes h(-\\tau)$”应改为“$R_{YX}(\\tau)=R_{X}(\\tau)* h(-\\tau)$”\n\n（文末[保研复习（第5部分）](#保研复习)有较为系统的概念性的整理，编号主要按照《通信原理（第七版）》第三章）\n\n#### 👉[雷达原理与系统（第6学期）](https://levitate.lanzoux.com/b0dewwpwj)\n\n（密码往顶上看）\n\n3学分（雷达原理、雷达系统3+3=3，电信单独出卷）\n\n任课老师：董春曦，曾操\n\n+ 👉[01 雷达原理与系统整理（Marginnote3版）](https://levitate.lanzoui.com/ijrCFqjekmb)\n+ [👉02 雷达原理与系统整理（单页）](https://levitate.lanzoui.com/i5V5Nqjek1a)\n\n\n\n#### 👉[现代图像分析（第6学期）](https://levitate.lanzoux.com/b0dewwpyb)\n\n（密码往顶上看）\n\n3学分（电信单独出卷）\n\n任课老师：李洁\n\n+ 👉[01 图像处理基础](https://levitate.lanzoui.com/iwYSJpeu2pg)（绪论、数字图像处理基础）\n+ 👉[02 图像处理技术](https://levitate.lanzoui.com/i7wSepi6llg)（图像变换、图像增强、图像恢复、图像压缩编码）\n+ 👉[03 图像分析方法](https://levitate.lanzoui.com/iSK23pjdf5c\n    )（图像分割、图像描述）\n\n> 图像理得东西有点多，抄死我了。\n>\n> 据说去年考的和往年题不太一样，建议结合学堂在线蓝底幻灯片复习，上课时候说考试范围是学堂在线（前八章）。整合的幻灯片来源于👉[这个链接](https://shawn-pu.lanzoui.com/b0e2mwfja)(密码：2222)，但是漏了第七章的谱聚类，所以加上谱聚类的幻灯片看👉[我的链接](https://levitate.lanzoui.com/i6tOjpjdogh)。版权归**西安电子科技大学《现代图像分析》课程组**，这里只是整合了一下。\n\n\n\n\n\n### 大三原微波天线方向主干课\n\n#### 👉[微波技术基础（第5学期）](https://www.lanzoui.com/b0dedvtta)\n\n（密码往顶上看）\n\n4学分（电信单独出卷）\n\n任课老师：陈曦（女）\n\n+ 01 微波技术基础公式整理\n+ 02 微波往年题整理\n\n\n\n> + 由于下周要微波小测，临时做了微波第一章的整理。\n>\n> + 由于11月27号微博小测，临时做了微波第二章的整理。\n>\n> + 可能微波的整理就和电磁场差不多吧，更新至v1.2版本，是$\\LaTeX$打印+手写版整理。\n>\n> + ❗勘误：\n>\n>     + 公式整理->第二部分->定义9：$\\mathrm{TE}_{10}$的场分布结构图($y$轴方向朝上)\n>\n>         ![mw_TE10](mw_TE10.png)\n\n\n\n#### 👉[天线原理（第6学期）](https://levitate.lanzoux.com/b0dewwq6j)\n\n（密码往顶上看）\n\n3学分（4→3，电信单独出卷）\n\n任课老师：栗曦\n\n+ 01 天线原理公式整理\n+ 02 天线原理笔记（上课记的笔记，可能会有些错误。一共是21次课，22讲是为了前后连贯，调整了部分内容的章节，顺序是没有问题的，我们班是先讲面天线后常用天线。请勿二改二传翻印，为防止盗印加了水印。）\n+ 03 天线原理内容提要·习题选解（主要是书后习题的部分答案。请勿二改二传翻印，为防止盗印加了水印。）【提供第7章配套代码】\n\n> + 天线原理公式整理到v1.1版本，全部内容整理完了，主要分了天线单元、阵列天线、面天线和常用天线四部分，重点是前两部分，约占70%。（v1.0版本起比v0.3版本删除了很多天线单元的内容，主要为了防止前后侧重不一致，引起误会）\n> + 对比笔记还是缺了不少东西，这个公式整理主要整理的是**上课时候说的必须掌握的公式，例题和具体内容详见笔记**。后续也许会把笔记放上来。\n> + **今年考试考了很多常用天线的看图写名称，请将来同学复习时务必注意。**\n\n\n\n#### 👉[微波电子线路（第6学期）](https://levitate.lanzoux.com/b0dewwpzc)\n\n（密码往顶上看）\n\n3学分（主干课非11、12班院选，电信单独出卷）\n\n任课老师：刘能武，郑会利\n\n+ 01 微波电子线路整理（考后整理版）\n+ 另附：2018年不完整的卷子\n\n\n\n\n\n---\n\n<img src=\"/计算机类.PNG\" alt=\"计算机类\" style=\"zoom:150%;\" />\n\n## 💻计算机类\n\n### C语言\n\n#### 计导与C程序设计（第1学期）\n\n4学分（1.5+3→4，全校统考，机试）\n\n任课老师：张淑平\n\n记得比较烂，不放了\n\n\n\n#### 👉[数据结构与算法分析（第3学期）](https://levitate.lanzoux.com/ic8ddyf)\n\n3学分（电院单独出卷，笔试）\n\n任课老师：何立火\n\n电院、AI院2019年新版《数据结构与算法》（原来叫《软件技术基础》）课后选择填空的答案，老师自己做的，错的比较多，部分改了，其中第四章忘拍了，不过问题不大。（来源：何立火老师）\n\n\n\n### Python\n\n#### 👉[高级语言程序设计（Python）【高级语言程序设计B】（第2/5学期）](https://levitate.lanzoux.com/ic8d75a)\n\n2学分（3→2+3，电院单独出卷，机试）\n\n任课老师：马晖（第2学期）李隐峰（第5学期）\n\n这是电院PythonOJ的题目程序打包，里面有的程序有-1的版本，一般就是一个对，一个错。不确定OJ每年会不会加题。\n\n大三新加的题就不加了(*/ω＼*)。\n\n\n\n### 汇编语言\n\n#### 👉[微机原理与系统设计（第5学期）](https://www.lanzoui.com/b0dedvtpg)\n\n（密码往顶上看）\n\n4学分（电院单独出卷，笔试）\n\n任课老师：张伟涛，楼顺天\n\n+ 01 微机基础与CPU结构\n+ 02 8086汇编语言\n+ 03 总线与接口设计\n\n> 微原太碎了，只能说是把大概的框架整理了一下，具体的细节还是建议看笔记和书。\n\n\n\n---\n\n<img src=\"/思政类.PNG\" alt=\"思政类\" style=\"zoom:150%;\" />\n\n## 📰思政类\n\n### 👉[思政类（第1-4学期）](https://levitate.lanzoux.com/b0ddzxfrc)\n\n密码:i05c\n\n每门3学分（思修、史纲2→3，全校统考）\n\n任课老师：陶蕴芳（思修）任芳（史纲）蒋冬双（马原）蒲伟芬（毛中特）\n\n+ 01 思修\n+ 02 史纲\n+ 03 马原（复习资料简答题，19年考试一道没考！！！）\n+ 04-1 毛中特笔记（摘自蒲伟芬老师上课用幻灯片，仅作参考，不建议作备考用）\n+ 04-2 毛概复习资料简答题（仅作参考，建议参考书本和知识图谱复习，20年全考的原题，随缘吧！！！）\n\n（建议思政课程老师发的材料随缘看待，可能马原一道不考，也有可能毛中特90%考的原题）\n\n---\n\n（工图、军理就不放了……）\n\n\n\n---\n\n<img src=\"/保研复习.png\" alt=\"保研复习\" style=\"zoom:150%;\" />\n\n## 👨‍🎓保研复习\n\n### 👉[保研复习](https://levitate.lanzoui.com/b0df54xij)\n\n（密码往顶上看）\n\n+ 数学类：\n\n    + 线性代数\n    + 概率论与数理统计\n    + 高等数学\n\n+ 信号类：\n\n    + 信号与系统\n    + 数字信号处理\n    + 随机信号分析（放到通信类可能更好）\n\n+ 通信类：\n\n    + 通信原理\n\n        > 还包括有部分其他科目:\n        >\n        > + 射频电路基础：模拟调制\n        > + 无线通信：数字调制\n        > + 雷达：匹配滤波、脉冲压缩、雷达信号检测\n        > + 图像：图像变换、图像压缩编码\n\n    + 无线通信\n    \n        \n\n> ❗勘误与补充：\n>\n> 1. 《通信原理》数字带通传输系统-》5-》③适应性第三条应当为2FSK最适合在随参信道中传输。\n","tags":["模拟电子技术","射频","电磁场与电磁波"],"categories":["课程向"]},{"title":"听说西电有一支有丶东西的数模队","url":"/2020/04/29/数学建模-听说西电有一支有丶东西的数模队/","content":"\n# 听说西电有一支有丶东西的数模队\n\n在刚刚过去的2020年数模美赛（MCM/ICM）中，我们队伍三人获得了美赛O奖+冠名INFORMS奖。\n\n说实话刚听到获得O奖冠名奖的时候我人都是懵的，一遍一遍地确认论文的编号和题号。建模队友比赛的过程中确实想过能拿O奖，还给队友分析过，但真正拿到的时候还是抑制不住激动。下面就带大家来分享一下我们的队伍和数模比赛的成长历程吧！\n\n![O奖奖状](/奖状.png)\n\n\n\n## 三位队友的特点\n\n### 建模队友（Zhengpeng Duan）\n\n> 天龙八部大理段王爷，群头衔：数模王爷\n\n前期，大量阅读论文队友找来的文献，在文献中提取对本题有用的部分，并标记以供后续使用。作为建模队员，我始终走在全队的最前面，结合所学知识初步敲定每题的模型，并与建模队友讨论优化后决定。比赛过程中偶尔给编程队友提供思路，协助编程。解决所有建模问题后，帮助论文队友书写文案，并负责审稿和修改工作。\n\n### 编程队友（Wenhao Yang）\n\n> 大一入校就有大二喊学长，群头衔：大三学长\n\n擅长使用各种语言来完成模型的求解，如C++/python/MATLAB，SPSS/Lingo/Mathematic，对学习算法以及编程有浓厚的兴趣。作为团队的队长，也善于统领全局，根据题目难度做出适当的时间安排与规划。另外也辅助建模队友的模型优化与改进，并在敲定模型和算法后讲解给论文队友听，方便论文队友理解文章模型算法书写文案。\n\n### 论文队友（Chenlai Qian）\n\n> 擅长搜集各种资料，群头衔：钱秘书\n\n前期，帮助队友寻找有用的一些材料，以及各类论文，也逐渐在找各类材料中，掌握了一定的搜集资料能力。中期，利用Powerpoint、Excel（这次美赛还有Gephi）完成各种示意图，并美化其他程序的图片，并着手开始写部分已经完成的内容。后期，阐明各个问题的解决思路，并将建模和编程队员的思想外化为文字，进行总体的统筹、归纳与排版。\n\n\n\n## 成长历程\n\n说实话刚听到获得O奖的时候我人都是懵的，一遍一遍地确认论文的编号，选的题目，当确认了是我们，我的手一直都在抖。下面就让我带着大家梳理一下我们从组队开始的一些成长历程。\n\n<img src=\"/数模历程.png\" alt=\"数模历程\" style=\"zoom:48%;\" />\n\n### “草台班子”的搭建\n\n我们是大一上学期，整个队伍组建完成的，先是dzp找到了ywh，然后ywh找到了我。截止2018年11月28日晚，我们这个“草台班子”就组建完了。\n\n![第一句话](/第一句话.png)\n\n\n\n### “校赛”——小试牛刀\n\n那个时候其实也没有多想，三个人，也就利用寒假时间看看基础的模型，算法以及论文的架构，然后就稀里糊涂地去参加了校赛，然后论文写得也稀里糊涂地拿了校二。（以下摘自ywh的说说）\n\n>  在这三天里我们：\n>\n> + 看了无数医学的课本和论文，企图幻想成为眼科专家\n> + 数不清的草稿纸，数据，模型，算法\n> + 跑机器学习代码跑到自闭\n> + 为了写一个可视化界面，最后一晚只睡了半小时。整整7个小时，4:15～6:11也就是我最绝望的时候，不过最终还是找到了解决方法结果今早到处成exe，还被队友发现有一个参数弄错了，于是显示了非常好笑的结果。\n>\n> 不管怎么说， 无论结果怎样，我们都上交了一份令自己非常满意的答卷。  这三天三夜，三人一起熬夜肝，一起相互讨论，一起抓耳挠腮。  70页文章，50页正文，20页代码。（注：很不可取，正文20页左右）  也是对我们这次辛苦的一个交代了。\n\n<img src=\"/04-1数模校二.jpg\" alt=\"04-1数模校二\"  />\n\n\n\n### 国赛培训——感悟数模\n\n我想是到国赛培训的时候，我们才对数学建模有了真正的概念与想法。其实大部分学校对大一同学参加数学建模竞赛都可能存在一定的偏见，但感谢西电的老师们让我们大一就有机会参加国赛培训。其实从我们（洋洋洒洒七十页，但有用的可能还不到15页）的校赛论文中就能看出，确实存在着很多知识积累、经验的不足导致的问题。但是就这样在没有学过概率论、复变等等课程的基础上，我们经历了一个暑假的国赛培训。\n\n国赛培训中，穆学文老师带我们训练了许多篇往年的国赛题，也借助历年的优秀论文摸索了许多数模论文的写作和技巧，练就了许多的技能，从各方面都提高了我们队伍三个人的能力。如果不是数学建模竞赛，我可能还不能非常熟悉（可能还谈不上熟练）地使用MATLAB，更不会去摸索出Word中样式、文档部件、域等非常好用的部件。\n\n![国赛培训](/国赛培训.png)\n\n![](/技能国赛.png)\n\n\n\n### “国赛”——平平淡淡\n\n到大二才知道这些能力，其实都是科研中的非常基础能力啊，大学参加的数学建模竞赛，也为了你以后的科研生涯打下了非常牢固的基础。我们国赛也就这样，拿了一个陕西省的省一，普普通通的成绩也对得上，我们平时付出的努力。（以下摘自ywh的说说）\n\n>4+5+3=12h\n>\n>三天三夜，很累很充实\n>\n>回望这一步步走过来，校赛，一轮面试，二轮面试，一轮培训，二轮培训，选拔队伍。竞赛也许就是这样，肝完以后突然就会有一种无言的失落。队友们很给力，第二轮培训，7个组6个大三就我们全是大二的，其实作为全是小一届组成的参赛队伍，还是很有压力的。这里还要感谢我们的指导老师，不仅带了我们成为正式队伍，还给了我们大一同学（刚面试时是大一）信心与勇气。\n>\n>不管是否参与，或拿奖与否。总之感谢数模，学到了也自己探索到了无数的未知领域与世界\n>\n>MATLAB，Word排版，数学模型，Lingo，SPSS，以及短时间内查阅并理解论文及数据，这可能就是数模带给我的无量财富吧。（说的好像我们要退役似的，不过应该有至少2个月不会碰数模了吧）\n>\n>ps：突然想起来第二天建模队友发自灵魂的怒吼““好好的中秋不过，X（消音），tmd在这里做数模”*（请记住这句话，划重点，要考）*哈哈哈哈哈哈哈哈，诶不对，我笑个啥子啊\n\n![](/04-2数模省一.jpg)\n\n\n\n### 美赛培训——加分在哪里\n\n内心小剧场：\n\n> ——真香！我们又回来了！\n>\n> ——不是说好了不打数模了吗，怎么又回来了呢？\n>\n> ——国赛时候再怎么和数模过不去，干嘛和竞赛加分过不去呀，国奖以上加8-10分它不香嘛。\n\n说实话，最初想参加美赛真的没想到能拿这么大的奖，纯属为了那几分去的（说的有点功利，但确实是我们最初的想法）。但在美赛培训当中，我们又逐渐体会到了属于数学建模的魅力。\n\n这样说吧，在美赛培训中有强迫我学习了许多对于科研非常有用但我原来懒得学的东西。如果不是数学建模，我们可能到现在也只能面向Bing和CDSN使用MATLAB，也不会掌握应用PowerPoint、Excel这些日常非常熟悉、我们以为很简单（其实非常强大）的办公软件去绘制不亚于Ps、Ai绘制的精美的示意图、地图，更不会使用像LaTeX这样的偏科研写作的专业排版软件。\n\n![技能1-latex](/技能1-latex.png)\n\n![技能2-ppt](/技能2-ppt.png)\n\n同时，回想一下参与数模的收获，训练还是起了很大作用，张胜利老师在训练的过程中就一直让我们学习往届的O奖论文，学习模型和写法。在比赛中我们的模型也并不复杂，但有时候模型的难点并不在于复杂与否，而是是否与题目符合，这也是老师在训练中反复跟我们强调的一点。\n\n\n\n### “美赛”——闷声发大财\n\n临近开学的四天时间我们参加了美赛，虽然我们分隔南京和无锡两地，但是通过Teamviewer和QQ视频通话解决了交流问题，也获得了比较好的结果。\n\n下面首先是我们打美赛期间的总体时间进度：\n\n> + 2月14日（不存在的情人节）\n>   + 早上完成选题收集资料以及疯狂看相关论文\n>   + 中午到晚上，完成Task 1的模型建立\n>   + 晚上熬夜完成Task 1算法实现以及数据导出论文制作\n>\n> + 2月15日\n>   + 早上到下午晚上Task 2的模型建立与指标选择\n>   + 晚上熬夜至四点处理数据，以及论文插图制作\n>\n> + 2月16日\n>   + 处理完所有数据后开始算法实现，一直到中午得出了满意的结果\n>   + 下午到晚上完成Task 3模型的建立以及图解法应用\n>   + 晚上研究Task 4的模型\n>\n> + 2月17日\n>   + 最后一整天写作、检查与润色之前的论文，添加插图，检查结果，\n>   + 完善论文其他部分的工作如摘要，灵敏性分析等。\n>\n> + 2月18日\n>   + 从17日晚一整夜三位队友一起通宵，对论文进行不断地处理，审了至少10遍以上\n>   + 对于所有插图和表格都认真审核(最后几小时还直接重画了一张表)，摘要不停润色，图片不停美化修改，文字部分也在规定范围内删删改改\n>   + 一直忙到早上7点，交上作品。\n\n其实我得承认，这是美赛能获得如此大的一个奖是肯定是有运气成分在其中的，但是也不光是运气成分，我觉得还有非常重要的原因，就是我们真的看过了很多很多年比赛O奖F奖的论文，我们从中总结出了很多的规律，我们也反思了自己的论文。（以下还是摘自ywh的说说）\n\n> 首先看到足球的问题，又是以往的训练的网络题，果断出手。\n> 1.  严重吐槽美国数模组委，改革，加了task数，不加页码的事，我真是佛了，到最后都在删图删论文，删哪儿段心里都在滴血啊。\n> 2. 我知道美赛不注重结果和数据，但这个分析到一半，12个人在场上踢球是不是有点说不过去了，嘶～真当我们没看出来是埃弗顿吗，Huskies笑死了。\n> 3. 这题目做着做着ywh就想起了年轻的他，那时候他还能在烈日下踢一个上午+一个下午的球，现在跑40min都要喘，唉，真是岁月是把杀猪刀，那些时光真的回不去了。\n> 4. 美赛这四天吧，感谢我的队友，太给力了都，无数张的插图，无数行代码，还有优化优化再优化的模型，说归说，美赛的题目还是比国赛有趣和丰富很多的就是4天太肝了，老年人肾疼了。\n>\n> 最后祝所有参加美赛的同学们都能取得理想的成绩，不管最终结果OFMHS，尽最大的努力，感受了数学巨大的魅力，就满足了。\n>\n> 还有感谢足球，青春有你，此生无憾！\n\n\n\n## 最后的一点寄语\n\n其实就我而言，在大一一直包括美赛之前，我们都是非常在意数学建模这个比赛的结果的。因为总觉得我付出了很多的心血在那几天里面，就希望自己能够夺得更高荣誉的奖项。校赛得到校二，以及国赛获得省一等奖，其实都不算特别满意。后来我们也就放平了心态，这可能就是科研道路吧，会经历很多坎坷会遭遇很多的挫折，但是我们最终都要以平和的心态去面对。但其实这次美赛成绩出来之前，我们的心态倒也算是比较平和，但是看到超出我们想象力的这么一个奖之后我是有点惊悚的。尽管以前有很多学长学姐，告诉我们数学建模比赛是一个水分比较大、含金量没那么高的比赛，都不是很建议我们去参加，但是我想说的是因为数学建模竞赛，认识了两个非常志同道合的队友，提高了阅读英文文献的能力，学会了在短时间内去学习一个复杂的模型算法，最后再以坦然平和的心态去面对，不管是数模还是科研道路上的挫折与困难。我想这才是数学建模竞赛带给我们最大的收获吧。\n这里我还想再感谢一下所有帮助过我们指导过我们的学长学姐与老师，我们也会竭尽我们所能去帮助那些想要入门的学弟学妹，希望西电的数学建模竞赛越来越好。\n\n\n\n（文案：杨文昊、钱辰涞、段正鹏，该文另载于“海棠九号书院”微信公众号）","tags":["数学建模"],"categories":["总结"]},{"title":"数模论文替换词、短语","url":"/2020/03/09/数模论文替换词、短语/","content":"\n# 数模论文替换词、短语\n\n## 归纳类常用词汇\n\n1. **归纳总结(*v.*)**：conclude, summarize\n2. **方法(*n.*)**：methodology, means to do (of doing), way to do (of doing), method of, approach to doing, take measures, steps  \n3. **分析**：analysis, \n4. Proposed, Presented, State that, Described, Illustrated, Indicated, has shown, showed, Address, Highlights\n5. **发现、注意、知道**：characterize, find, notice, know\n6. **原因 / 结果**： reason (for), cause (of), result, effect, consequence, findings\n7. 优缺点： Strengths and weaknesses, merits and demerits,merits and drawbacks, advantages and disadvantages\n8. **种类**：kind, type, category, class\n\n\n\n## 缩略常用词汇\n\n### i.e.\n\n**i.e.**是**id est**（“that is” , \"in other words\"。进一步解释用，意为：也就是）的缩写。目的是用来进一步解释前面所说的观点（不像后文的e.g.那样引入实例来形象化），意思是“那就是说，换句话说”。\n\n> 【Example】And you have to cross reference this time/effort analysis to the results (**i.e**., the bugs) that the effort yielded.\n\n- **它后面最好紧跟着一个逗号，再跟一个解释。**\n\n### e.g. \n\n**e.g.**是**exempli gratia**（\"for example; for instance;such as\"。举例用，意为：例如）的缩写，其目的用若干例子来让前面说法更具体，更易感知。\n\n> 【Example】I like sports, **e.g.**, football.\n\n- **在使用中，e后的“.”不要遗漏。**\n- 在使用中，最好把e.g.连同它的例子放在括号中，如例句\n\n### etc. \n\n**etc.**是**et cetera**(“and so forth; and the others; and other things; and the rest; and so on\"。举例用，意为：等等)的缩写。它放在列表的最后，表示前面的例子还没列举完，最后加个词“等等”。\n\n> 【Example】 I need to go to the store and buy some pie, milk, cheese, **etc.**\n\n- **etc.前面要有逗号。**\n- **一般不要在e.g.的列表最后用etc( 在including后的列表后也不宜使用etc)。**这是因为 e.g. 表示泛泛的举几个例子，并没有囊括所有的实例，其中就已经包含“等等”，如果再加一个 etc. 就多余了。\n\n### viz.\n\n**viz.**是**videlicet**（ \"namely\", \"towit\", \"precisely\", \"that is to say\"。进一步解释用，意为：即）的缩写，与e.g.不同，**viz位于同位列表之前，要把它前面单词所包含的项目全部列出。**\n\n> 【Example 1】The school offers two modules in Teaching English as a Foreign Language, **viz.** Principles and Methods of Language Teaching and Applied Linguistics.（该校提供两个模块用于英语作为外语的教学，即语言教学的原理方法和应用语言学。）\n> 【Example 2】In this paper, a new TDNN architecture with two input variable, **viz.** wave form and its phase difference, is developed to reduce the grain noise.（本文提出了一种新的TDNN结构用于降低粗晶材料结构噪声，该结构具有波形及其相位差组成的双变量输入。）\n\n- **viz.后面无逗号。** \n\n### et al.\n\n**et al.**是**et alia**（\"and others; and co-workers\"。在引用文献作者时用，意为:等其他人）的缩写。它几乎都是在列文献作者时使用，即把主要作者列出后，其它作者全放在et al. 里面。\n\n> 【Example 1】These results agree with the ones published by Pelon **et al**. (2002).\n> 【Example 2】 Clegg **et al.** (1995) explain that in the electronics industry linear-programming models can be used to analyse the viability of the recovered parts in remanufacturing.（克莱格等人（1995）解释说，电子行业的线性规划模型可以用来分析在再制造过程中回收零部件的可行性。）\n\n- **人的场合用et al，而无生命的场合用etc.(et cetera)。**\n- **et后不要加“.”,因为et不是缩写。另外，与etc.不同，et al.的前面不要逗号。**\n\n### s.t.\n\n\n平时文献中看到的**s.t.**（后面附带公式），一般对应的是subject to的缩写，后面对应的公式是约束条件，“使得...满足...”的意思，用于优化问题；但这个词比较特殊的是，它也可以作为such that的缩写，对应为“如此...以至于...，如此这般”的意思，用于数学证明等问题。上面两种释义在数学中较为常用，而且与上面的缩写词汇不同的是，它是地地道道的英语缩写。\n\n维基百科对s.t.的解释如下：\n\n> 1. Preposition\t\n>    s.t.   Alternative form of subject to, used in optimisation problems.\n> 2. Conjunction\t\n>    s.t.   (mathematics) Abbreviation of such that.\n>    Given r s.t. r<n...\n>\n> 3. 介词\n>    subject to的替代词，用于优化问题。\n> 4. 连词\n>    （数学）such that的缩写，例如事例：\n>    给定 r，使r满足r<n。\n\n所以，s.t.在不同的场景下的具体释义还是有细微差别的。在读文献时可以不作具体区分，但是在行文时还是需要考虑一下。\n\n\n\n## Summary 概要\n\n1.  This paper **concludes** with a discussion of future research consideration in section 5.\n2.  Section 5 **summarizes** the results of this investigation.\n3.  Section 5 gives the conclusions and **future directions** of research.\n4.  Finally, conclusions and future work are summarized\n5.  *A basic problem in the design of … is presented by the choice of a … rate for the measurement of experimental variables.*\n6.  The **procedure** **is useful in analyzing** how groups reach a decision.\n7.  The technique used is to employ a newly developed and versatile … **algorithm**.\n8.  The **usefulness** of … is also considered.\n9.  A brief **methodology** used in xx is discussed.\n10.  The **analysis** is useful in xx and xx problem.\n11.  A model is developed for a … analysis using ….\n12.  The use of the method is discussed and an example **is given**.\n13.  *Results* of an experimental applications of this … *analysis procedure* are given to **illustrate** the proposed technique.\n14.  This paper provides an **overview and information** useful for *approaching* ….\n15.  **Emphasis** is placed on the construction of a criterion function by which the … in achieving a hierarchical system of objectives are evaluated.\n16.  The **main emphasis** is placed on the problem of ….\n17.  A didactic example is **included** to *illustrate* the computational procedure.\n\n\n\n## Introduction & Preparation of Models\n\n### Background\n\n\n\n### Our work\n\n1. In this paper, we focus on the need for ……\n2. This paper proceeds as follow.\n3. In this paper, we shall first briefly introduce fuzzy sets and related concepts\n4. To begin with, we will provide a brief background on the ….\n5. In the next section, after a statement of the basic problem, various situations involving possibility knowledge are investigated: first, ……; then ……; lastly, …….\n\n\n\n\n\n## Body 正文主体\n\n### Objective/ Goal / Purpose 目标\n\n1. The **ultimate goal** of …… is to *allow* the non experts *to utilize* the existing knowledge, *and to* provide intelligent, computer aided instruction.\n2. The **scope** of this research ***lies in*** …….\n3. The **main theme** of the paper is …….\n4. These objectives are ***to be met with*** such thoroughness and confidence as to permit ...（优化目标）\n5. **In order to (In a gesture to)** achieve these objectives, an …… must meet the following requirements:\n6. **For the sake of** concentrating on ... research issues.\n7. A major **thrust （driver）** of the paper is to discuss approaches and strategies for structuring ... methods.\n8. **Point out** that the problem of ... .\n\n\n\n### Problem / Issue / Question 提出问题\n\n1. Unfortunately, *real-world engineering problems* such as manufacturing planning *do not fit well with* this narrowly defined model. They tend to **span broad activities** and **require consideration** of multiple aspects.\n2. Remedy（补救） / solve（解决） / alleviate（减轻） these problems\n3. ... is a difficult problem, yet to be adequately **resolved**.\n4. The traffic issue is **a hard nut to crack**.\n5. Two major problems have yet to be **addressed**\n6. This problem *in essence* involves using …… to obtain a solution.\n\n\n\n### 万金油句型\n\n1. In order to prove…., we used…\n2. We have set up….\n3. To demonstrate…., we further…\n\n\n\n### Comparison 对比\n\n1. Consistently/Consistent with…\n2. Compared with….\n\n\n\n### Cite 引用\n\n+ `(algorithm)` The technique used is to employ a newly developed and versatile … algorithm.\n+ `(study)`*Studies* of receiver biases **suggest** that such analogies might not be broadly applicable.\n+ `(study)`Previous studies of …… had **emphasized** potential advantages to group-signaling organization .\n+ `(study)`**State that** preferences evolve indirectly because they are genetically correlated with male traits that are under direct selection; **that is,** the preferences themselves are not under direct selection.\n\n\n\n### Transition 过渡\n\n1. The basic questions posed above are then discussed and conclusions are drawn.\n2. So we next explored….\n\n\n\n","tags":["论文","数学建模"],"categories":["LaTeX and ..."]},{"title":"“宅”家攻略 | 如何利用iPad高效学习","url":"/2020/03/08/ipad-learning/","content":"\n# “宅”家攻略 | 如何利用iPad高效学习\n\n“买前生产力，买后爱奇艺”，NO！！！\n\n其实重要的还是看自己的自制力！\n\n\n\n## 准备工作\n\n### 设备\n\n+ iPad：本人是iPad 2018 (128G) 配一代笔\n\n+ 笔记本电脑：单单用一个iPad既做笔记，又看网课是不够的\n\n### 软件\n\n下面列出这篇文章提到的绝大多数iPad软件，可以有选择性的下载。\n\n<img src=\"ipad-learning/幻灯片1.PNG\" alt=\"幻灯片1\" style=\"zoom:67%;\" />\n\n<img src=\"ipad-learning/幻灯片2.PNG\" alt=\"幻灯片2\" style=\"zoom:67%;\" />\n\n\n\n## 一、做笔记\n\n### 导入文件\n\n1. 使用分享按钮\n2. 部分软件支持直接将PDF等文件拖入\n\n\n\n### 【免费】OneNote\n\n多设备同步，但好像对于iPad适配没有那么好（我没有使用过）\n\n\n\n### 【付费 | 手写笔记】Notability & GoodNotes\n\nNotability（60 RMB）和GoodNotes（50 RMB）是iPad手写笔记的两大龙头软件。本人使用的软件是Notability，但舍友们也有使用GoodNotes的。下面是一个使用过两款软件的舍友（杨大佬）的评价。\n\n> 两款产品在大多数性能以及功能上都差不多\n> 所以我这里来说下主要区别，相比较而言\n>\n> note（即Notability）的界面更加简洁，笔记和老师上课的课件能够覆盖整个屏幕，比起good（即GoodNotes），nota有更清爽的页面设计，唯一让我觉得非常难受的点就是note笔记存放的深度只有2，也就是说不能文件夹下面再建立另一个文件夹，后来我的解决方法是将笔记定期整理到一个大的分类下。\n>\n> 相反而言，good的界面更加丰富，从笔记本的封面，纸张等等而言，比起nota有更多丰富的选择，在good上写字的笔感也要强于nota，当然这点看各个人，其次在good软件里面，文件夹可以无限嵌套，这倒是解决了我的问题，但是good比起nota而言更像是现实笔记本而不像电子笔记本，明显的表现有隔页之间不能连这写，还有工具栏过长导致笔记页面的压缩。\n>\n> 综上所述，nota和good都是特别好的笔记软件，因人而异，喜欢美观丰富并且爱捣鼓的小伙伴可以选择good，而像我一样喜欢简洁风的小伙伴可以选择nota。\n>\n> by 杨文昊\n\n笔记同步可以使用OneDrive。\n\n下面分享一些Notability的使用技巧（滑动窗口）：\n\n+ 软件内分屏\n\n  ![n_分屏](ipad-learning/n_分屏.gif)\n\n+ 套索工具（移动&缩放、变换样式、软件内截图）平时很无感，但用了就离不开的功能\n\n  ![n_套索](ipad-learning/n_套索.gif)\n\n+ 搜索（手写搜索与OCR文档搜索）\n\n  ![n_搜索](ipad-learning/n_搜索.gif)\n\n+ 录音（可以拖动进度条得到对应时间的笔记，我不常用，这里拿以前数模的文件做例子）\n\n  ![n_录音](ipad-learning/n_录音.gif)\n\n+ 导出的PDF自带OCR（只要不是鬼画符都能识别，识别率还是可以的）\n\n  ![n_OCR](ipad-learning/n_OCR.png)\n\n+ 写完长按变成形状（画直线、圆、椭圆）\n\n  <img src=\"ipad-learning/n_图形.gif\" alt=\"n_图形\"  />\n\n+ 文档扫描（不必再依赖于“扫描全能王”辣）\n\n  <img src=\"ipad-learning/n_文件扫描.png\" alt=\"n_文件扫描\" style=\"zoom:33%;\" />\n\n+ PDF读写（支持添加页面，手写备注自动添加后续页）。\n\n  <img src=\"ipad-learning/n_读写.png\" alt=\"n_读写\" style=\"zoom:33%;\" />\n\n+ ……\n\n\n\n### 【付费 | 电子书等】MarginNote 3\n\nMarginNote 3（内购88 RMB）整合了阅读标注工具，思维导图和学习卡。它可以边做笔记的同时直接生成思维导图，同时期末复习阶段还可以利用自带的学习卡进行复习。\n\n最近更新后手写体验获得了极大的提高，可以利用这款软件直接在教材上做笔记，并生成导图。\n\n下面以我最近做电磁场的笔记为案例，做一下软件的一些小功能的介绍吧。\n\n+ 同样支持软件内分屏\n\n  <img src=\"ipad-learning/m_分屏.jpg\" alt=\"m_分屏\" style=\"zoom:33%;\" />\n\n+ 荧光笔支持**直接**画直线\n\n  <img src=\"ipad-learning/m_高亮.jpg\" alt=\"m_高亮\" style=\"zoom:33%;\" />\n\n+ 思维导图摘录功能支持**文字高亮**和**框选**两种模式（支持不同颜色，还可继续在笔记内添加评论），同时可以选择是否自动OCR识别文字（公式不适用）。\n\n  <img src=\"ipad-learning/m_摘录.jpg\" alt=\"m_摘录\" style=\"zoom:33%;\" />\n\n+ 思维导图支持多本书共同创作\n\n  <img src=\"ipad-learning/m_多书.jpg\" alt=\"m_多书\"  />\n\n+ 学习卡支持填空，类似Anki（还未摸索到位）\n\n  <img src=\"ipad-learning/m_学习卡1.png\" alt=\"m_学习卡1\" style=\"zoom:33%;\" />\n\n  <img src=\"ipad-learning/m_学习卡2.png\" alt=\"m_学习卡2\" style=\"zoom:33%;\" />\n\n+ 留白/裁边（部分导入PDF边框特别宽）\n\n  <img src=\"ipad-learning/m_裁边1.png\" alt=\"m_裁边1\" style=\"zoom:33%;\" />\n\n  <img src=\"ipad-learning/m_裁边2.png\" alt=\"m_裁边2\" style=\"zoom:33%;\" />\n\n+ ……\n\n这个软件非常强大，至今还没摸索出很多功能，可以一起探索啊！\n\n\n\n## 二、获取电子书\n\n### 【易】 直接搜索\n\n+ 中文：鸠摩搜书、各类网盘引擎直接搜索\n+ 英文：Library Genesis、Zlibrary\n\n（下列方法仅供个人学习使用）\n\n### 【中】利用读秀SS号\n\n#### 1　登录[“全国图书馆参考咨询联盟”](http://www.ucdrs.superlib.net/)，找到需要的图书（**注意版本**）\n\n![s1](ipad-learning/s1.png)\n\n#### 2　获取SS号\n\n**【方法一】**使用油猴脚本“读秀超星电子书获取插件”\n\n直接在上述图书页面获得SS号\n\n![脚本SS](ipad-learning/脚本SS.png)\n\n**【方法二】**使用程序**“SS.exe”**\n\n**Step 1：**进入图书，右击书的封面，选择**“复制图片地址”**\n\n![S2](ipad-learning/S2.png)\n\n+ 注意：如果只要一本书50页以内直接使用“文献传递”就可以了。\n\n**Step 2：**双击程序**“SS.exe”**\n\n![S3](ipad-learning/S3.png)\n\n\n\n#### 3　去网盘搜索引擎搜索SS号，直接搜索到图书PDF版本。\n\n\n\n### 【难】利用Pdg2Pic\n\n网盘搜索引擎搜索SS号，找到一个压缩包（可能带有名字，可能不带）\n\n![S5](ipad-learning/S5.png)\n\n\n\n解压压缩包，并使用“Pdg2Pic”等软件进行转码\n\n<img src=\"ipad-learning/S6.png\" alt=\"S6\" style=\"zoom:60%;\" />\n\n获得PDF\n\n\n\n## 三、视频\n\n### 中国大学MOOC\n\n<img src=\"ipad-learning/中国大学MOOC.png\" alt=\"中国大学MOOC\" style=\"zoom: 33%;\" />\n\n+ iPad适配并不好\n+ 每次都要加入课堂略嫌麻烦\n+ 一般都有全套课件和测试题，可以方便学习。\n\n### 哔哩哔哩\n\n<img src=\"ipad-learning/b站学习.jpg\" alt=\"b站学习\" style=\"zoom:25%;\" />\n\n+ 我在b站上大学这句话不是假的，b站有很多搬运的慕课课程和up主们制作的学习视频。\n\n+ 大多慕课都是私人搬运，不一定有PPT，且没有测试题。（部分课件会放在评论区置顶）\n\n+ 有比较优质的学习氛围，甚至弹幕里可能有大佬已经回答了你想问的问题。\n\n+ 很多高校都已经开了官方账号，并上传了部分慕课（如：电子科大，中传……）。还有很多学校在疫情期间开辟了直播课程（如：清华）。\n\n+ ~~HD版不能分屏，没有画中画（据说普通版有，没有尝试）~~。（就在我写文案的这天它更新啦，**2.6版支持小窗播放**啦）\n\n  ![b站](ipad-learning/b站.png)\n\n### Alook\n\nAlook（疫情期间 6 RMB）对我的功能主要是在线视频播放。它支持倍速，下载管理，广告屏蔽……。\n\n+ 哔哩哔哩（HD版）、百度网盘客户端无法分屏，直接使用网页端可以支持倍速、画中画、分屏，方便做笔记。\n\n  ![a_b站画中画](ipad-learning/a_b站画中画.png)\n\n+ 还可以破解超星（即“学在西电learning平台”原版）的“进度条无法拖动”，“无法倍速播放”的操作，但不能计入任务点。\n\n  ![a_破解超星倍速](ipad-learning/a_破解超星倍速.png)\n\n+ 观看各大视频软件没有广告和弹窗\n\n+ 但是缺点是退出软件的“画中画”模式，无法前进、后退、调节倍速，需回退到软件才可。（这好像是苹果的问题）\n\n  ![a_画中画](ipad-learning/a_画中画.png)\n\n\n\n## 四、其他学习相关软件\n\n（写着写着变成知乎经验贴了，肿么办）\n\n### 日程安排\n\n+ Microsoft To-do：免费，手机、电脑、iPad可以多设备无缝同步。\n\n  （苹果“全家桶”用户也可以用自带的“提醒事项”）\n\n  <img src=\"ipad-learning/todo_手机.jpg\" alt=\"todo_手机\" style=\"zoom:25%;\" />\n\n  ![todo_ipad](ipad-learning/todo_ipad.png)\n\n  ![todo_PC](ipad-learning/todo_PC.png)\n\n  \n\n### 英语学习\n\n+ 欧路词典：支持导入辞书，可以分屏，软件简洁。还有单词复习功能\n\n  ![欧路词典](ipad-learning/欧路词典.png)\n\n+ TED：英语演讲\n\n### 专业课\n\n+ iCircuit （68 RMB）：可以画电路图，并分析。没有摸索透彻。这学期对于数电、模电应该还是有用处的。\n\n  ![icircuit_数电](ipad-learning/icircuit_数电.png)\n\n  ![icircuit_模电](ipad-learning/icircuit_模电.png)\n\n+ WolframAlpha （18 RMB）：知识型搜索引擎，就是有点慢\n\n  <img src=\"ipad-learning/WolframAlpha.png\" alt=\"WolframAlpha\" style=\"zoom: 33%;\" />\n\n+ GeoGebra：画图\n\n### 其他值得推荐的效率软件\n\n+ XDisplay：支持把iPad变为电脑的拓展屏幕\n+ OneDrive：可以同步一些文件，但速度日常很慢。\n+ 扫描全能王：扫描文件，HD版导出PDF无水印。现在Notability中也有类似功能\n+ XMind，Microsoft Office三件套，SketchBook\n+ ……\n\n\n\n## 可以观看的一些b站、知乎的总结与技巧\n\n\n\n\n\n\n\n**纯属经验所谈，没有恰饭，不负责任。**","tags":["iPad"],"categories":["总结"]}]