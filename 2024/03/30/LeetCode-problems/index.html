<!DOCTYPE html>
<html lang="zh-CN">








<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<link rel="preconnect" href="//www.googletagmanager.com">
	<link rel="preconnect" href="//zz.bdstatic.com">
	<link rel="preconnect" href="//sp0.baidu.com">
	<link rel="preconnect" href="//www.google-analytics.com">
	<link rel="preconnect" href="//cdn1.lncld.net">
	<link rel="preconnect" href="//unpkg.com">
	<link rel="preconnect" href="//app-router.leancloud.cn">
	<link rel="preconnect" href="//9qpuwspm.api.lncld.net">
	<link rel="preconnect" href="//gravatar.loli.net">
	<link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/jhlst/dist/京華老宋体v2_002/result.css">
<link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/LXGWWenKai-Regular/result.css"> 
	<link rel="stylesheet" href="https://chinese-fonts-cdn.deno.dev/packages/dyh/dist/SmileySans-Oblique/result.css">
	<link href="https://fonts.cdnfonts.com/css/avenir" rel="stylesheet">


	<title>【更新中】LeetCode自用刷题记录 | Levitate_</title>

	<meta name="HandheldFriendly" content="True">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
	<meta name="generator" content="hexo">
	<meta name="author" content="Levitate_">
	<meta name="description" content>

	
	<meta name="keywords" content>
	

	
	<link rel="shortcut icon" href="https://s1.ax1x.com/2022/05/18/Oo3OeI.png">
	<link rel="apple-touch-icon" href="https://s1.ax1x.com/2022/05/18/Oo3OeI.png">
	

	
	<meta name="theme-color" content="#3c484e">
	<meta name="msapplication-TileColor" content="#3c484e">
	

	

	
	<link rel="alternate" href="/atom.xml" title="Levitate_">
	

	<meta property="og:site_name" content="Levitate_">
	<meta property="og:type" content="article">
	<meta property="og:title" content="【更新中】LeetCode自用刷题记录 | Levitate_">
	<meta property="og:description" content>
	<meta property="og:url" content="https://levitate-qian.github.io/2024/03/30/LeetCode-problems/">

	
	<meta property="article:published_time" content="2024-03-29T21:03:00+08:00"> 
	<meta property="article:author" content="Levitate_">
	<meta property="article:published_first" content="Levitate_, /2024/03/30/LeetCode-problems/">
	

	
	
	
<link rel="stylesheet" href="/css/allinonecss.min.css">


	
	
	
    <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.0/katex.min.css" rel="stylesheet" type="text/css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
	

	
<link rel="alternate" href="/atom.xml" title="Levitate_" type="application/atom+xml">
</head>
<body class="post-template">
	<div class="site-wrapper">
		




<header class="site-header post-site-header outer">
    <div class="inner">
        
<nav class="site-nav"> 
    <div class="site-nav-left">
        <ul class="nav">
            <li>
                
                <a href="/" title="Home">HOME</a>
                
            </li>
            
            
            <li>
                <a href="/about" title="ABOUT">ABOUT</a>
            </li>
            
            <li>
                <a href="/archives" title="ARCHIVES">ARCHIVES</a>
            </li>
            
            <li>
                <a href="/details" title="DETAILS">DETAILS</a>
            </li>
            
            <li>
                <a href="/links" title="LINKS">LINKS</a>
            </li>
            
            
            <li>
                <p title="公告栏" style="margin: 0px" onclick="disp_notice_alert()">📌</p>
            </li>
        </ul> 
    </div>
    
    <div class="search-button-area">
        <a href="#search" class="search-button">Search ...</a>
    </div>
     
    <div class="site-nav-right">
        
        <a href="#search" class="search-button">Search ...</a>
         
        
<div class="social-links">
    
    
    <a class="social-link" title="github" href="https://github.com/Levitate-Qian/" target="_blank" rel="noopener">
        <svg viewbox="0 0 1049 1024" xmlns="http://www.w3.org/2000/svg"><path d="M524.979332 0C234.676191 0 0 234.676191 0 524.979332c0 232.068678 150.366597 428.501342 358.967656 498.035028 26.075132 5.215026 35.636014-11.299224 35.636014-25.205961 0-12.168395-0.869171-53.888607-0.869171-97.347161-146.020741 31.290159-176.441729-62.580318-176.441729-62.580318-23.467619-60.841976-58.234462-76.487055-58.234463-76.487055-47.804409-32.15933 3.476684-32.15933 3.476685-32.15933 53.019436 3.476684 80.83291 53.888607 80.83291 53.888607 46.935238 79.963739 122.553122 57.365291 152.97411 43.458554 4.345855-33.897672 18.252593-57.365291 33.028501-70.402857-116.468925-12.168395-239.022047-57.365291-239.022047-259.012982 0-57.365291 20.860106-104.300529 53.888607-140.805715-5.215026-13.037566-23.467619-66.926173 5.215027-139.067372 0 0 44.327725-13.906737 144.282399 53.888607 41.720212-11.299224 86.917108-17.383422 131.244833-17.383422s89.524621 6.084198 131.244833 17.383422C756.178839 203.386032 800.506564 217.29277 800.506564 217.29277c28.682646 72.1412 10.430053 126.029806 5.215026 139.067372 33.897672 36.505185 53.888607 83.440424 53.888607 140.805715 0 201.64769-122.553122 245.975415-239.891218 259.012982 19.121764 16.514251 35.636014 47.804409 35.636015 97.347161 0 70.402857-0.869171 126.898978-0.869172 144.282399 0 13.906737 9.560882 30.420988 35.636015 25.205961 208.601059-69.533686 358.967656-265.96635 358.967655-498.035028C1049.958663 234.676191 814.413301 0 524.979332 0z"/></svg>
    </a>
    
    
    
    
    
    
</div>
    </div>
</nav>
<script type="text/javascript">
function disp_notice_alert()
{
alert("如果出现蓝奏云链接失效，请将链接中的lanzous变为lanzoui即可解决！")
}
</script>
    </div>
</header>


<div id="site-main" class="site-main outer" role="main">
    <div class="inner">
        <header class="post-full-header">
            <div class="post-full-meta">
                <time class="post-full-meta-date" datetime="2024-03-29T21:38:44.000Z">
                    2024-03-29
                </time>
                
                <span class="date-divider">/</span>
                
                <a href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a>&nbsp;&nbsp;
                
                
                
            </div>
            <h1 class="post-full-title">【更新中】LeetCode自用刷题记录</h1>
        </header>
        <div class="post-full ">
            
            <figure class="post-full-image" style="background-image: url(https://s21.ax1x.com/2024/03/29/pFTkIht.png)">
            </figure>
            
            <div class="post-full-content">
                <article id="photoswipe" class="markdown-body">
                    <h1 id="leetcode自用刷题思路"><a class="markdownIt-Anchor" href="#leetcode自用刷题思路"></a> LeetCode自用刷题思路</h1>
<p>自用的刷题记录，以防后续不记得之前自己怎么想的~ 正式的题解还是看<strong>官方题解</strong>和**“代码随想录”**吧</p>
<blockquote>
<ul>
<li>做题顺序&amp;一些图片与思路：<a href="https://programmercarl.com/" target="_blank" rel="noopener">代码随想录 (programmercarl.com)</a>、<a href="https://leetcode.cn/problemset/" target="_blank" rel="noopener">题库 - 力扣 (LeetCode) 全球极客挚爱的技术成长平台</a>、b站视频、自制等</li>
<li>点击👉右边或者👇下面的菜单栏🗂，可以调出目录</li>
<li>前期主要是用C语言刷的，但是C的功能太简陋了，从哈希表部分开始换用C++刷题。
<ul>
<li>C转C++教程：<a href="https://www.bilibili.com/video/BV1UE411j7Ti/?spm_id_from=333.337.search-card.all.click" target="_blank" rel="noopener">C语言 转 C++ 简单教程_哔哩哔哩_bilibili</a>（up主专栏有思维导图，喵啊~）</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>明天就要华为面试了，但我已经什么都不记得了，祝我好运吧！随缘了</p>
<p>——2024年10月13日</p>
</blockquote>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<h3 id="704-二分查找"><a class="markdownIt-Anchor" href="#704-二分查找"></a> <a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></h3>
<blockquote>
<p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code> ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p>
</blockquote>
<p>注意开闭区间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[middle] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="27-移除元素"><a class="markdownIt-Anchor" href="#27-移除元素"></a> <a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a></h3>
<blockquote>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<p>快指针指向原始数组，慢指针指向新数组。如果等于val，slow不加；不等于val，fast指向的值赋给slow指向的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; numsSize; fast++) &#123;</span><br><span class="line">        <span class="comment">// 快指针指向原始数组，慢指针指向新数组。如果等于val，slow不加；不等于val，fast指向的值赋给slow指向的值</span></span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="977-有序数组的平方"><a class="markdownIt-Anchor" href="#977-有序数组的平方"></a> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">977. 有序数组的平方</a></h3>
<blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
</blockquote>
<p>动态数组不行！</p>
<p>中途比较，两头的数字一定是最大的，其平方一定在平方数组的末尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">sortedSquares</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span>* returnSize)</span> </span>&#123;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = numsSize - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>* ans = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中途比较，两头的数字一定是最大的，其平方一定在平方数组的末尾</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = numsSize - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] * nums[left] &gt;= nums[right] * nums[right]) &#123;</span><br><span class="line">            ans[i] = nums[left] * nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[i] = nums[right] * nums[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="209-长度最小的子数组"><a class="markdownIt-Anchor" href="#209-长度最小的子数组"></a> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">209. 长度最小的子数组</a></h3>
<blockquote>
<p>给定一个含有 <code>n</code> 个正整数的数组和一个正整数 <code>target</code> <strong>。</strong></p>
<p>找出该数组中满足其总和大于等于 <code>target</code> 的长度最小的 <strong>连续子数组</strong><code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度**。**如果不存在符合条件的子数组，返回 <code>0</code> 。</p>
</blockquote>
<p>暴力解法过不了</p>
<p>张开的窗口之和至少要能够装下target。首先移动end（必须到结尾），至少要装下target。接着，start向右，找最小的长度，装不下了，end向右。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">end</span> = <span class="number">0</span>; <span class="built_in">end</span> &lt; numsSize; <span class="built_in">end</span>++) &#123;</span><br><span class="line">        sum += nums[<span class="built_in">end</span>];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target) &#123; <span class="comment">//这个while是精髓！！！ 滑动初始窗口</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">end</span> - start + <span class="number">1</span>) &lt; length) &#123;</span><br><span class="line">                length = <span class="built_in">end</span> - start + <span class="number">1</span>;</span><br><span class="line">            &#125;            </span><br><span class="line">            sum -= nums[start];</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">100001</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="59-螺旋矩阵-ii"><a class="markdownIt-Anchor" href="#59-螺旋矩阵-ii"></a> <a href="https://leetcode.cn/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. 螺旋矩阵 II</a></h3>
<blockquote>
<p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code> 。</p>
</blockquote>
<p>找规律，注意边界</p>
<p>找规律，第一步先把第一行填满，后续每次转弯向右，每两次需要步长减一。注意，横纵坐标有没有超出范围，且二维数组第一位为行，第二位为列</p>
<img alt="image-20240326200626892" style="zoom:33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240326200626892.png" data-index="0" data-src="/2024/03/30/LeetCode-problems/image-20240326200626892.png">
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an array of arrays of size *returnSize.</span></span><br><span class="line"><span class="comment"> * The sizes of the arrays are returned as *returnColumnSizes array.</span></span><br><span class="line"><span class="comment"> * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>** <span class="title">generateMatrix</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* returnSize, <span class="keyword">int</span>** returnColumnSizes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化返回的结果数组</span></span><br><span class="line">    *returnSize = n;</span><br><span class="line">    *returnColumnSizes = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="keyword">int</span>** ans = (<span class="keyword">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>*) * n);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans[i] = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        (*returnColumnSizes)[i] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> shiftX = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> shiftY = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> inputNum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> directionX = <span class="number">0</span>; <span class="comment">// 0往左，1往右</span></span><br><span class="line">    <span class="keyword">int</span> directionY = <span class="number">0</span>; <span class="comment">// 0往下，1往上</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> <span class="built_in">step</span> = n; <span class="built_in">step</span> &gt; <span class="number">0</span>; <span class="built_in">step</span>-- ) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">step</span> == n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++) &#123;</span><br><span class="line">                ans[shiftY][shiftX] = inputNum;</span><br><span class="line">                inputNum++;</span><br><span class="line">                shiftX++;</span><br><span class="line">            &#125;</span><br><span class="line">            shiftX--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 先移动Y方向</span></span><br><span class="line">            <span class="keyword">if</span> (directionY == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++) &#123;</span><br><span class="line">                    shiftY++;</span><br><span class="line">                    ans[shiftY][shiftX] = inputNum;</span><br><span class="line">                    inputNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                directionY = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++) &#123;</span><br><span class="line">                    shiftY--;</span><br><span class="line">                    ans[shiftY][shiftX] = inputNum;</span><br><span class="line">                    inputNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                directionY = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//再移动X方向</span></span><br><span class="line">            <span class="keyword">if</span> (directionX == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++) &#123;</span><br><span class="line">                    shiftX--;</span><br><span class="line">                    ans[shiftY][shiftX] = inputNum;</span><br><span class="line">                    inputNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                directionX = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">step</span>; i++) &#123;</span><br><span class="line">                    shiftX++;</span><br><span class="line">                    ans[shiftY][shiftX] = inputNum;</span><br><span class="line">                    inputNum++;</span><br><span class="line">                &#125;</span><br><span class="line">                directionX = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h2>
<blockquote>
<p>链表和数组对比</p>
<table>
<thead>
<tr>
<th></th>
<th>插入/删除</th>
<th>查询</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td>数据量固定，频繁查询，较少增删</td>
</tr>
<tr>
<td>链表</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td>数据量不固定，频繁增删，较少查询</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>C：——《数据结构与算法/软件技术基础》周大为版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; linklist;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>C++：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;  <span class="comment">// 节点上存储的元素</span></span><br><span class="line">    ListNode *next;  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;  <span class="comment">// 节点的构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>——代码随想录</p>
</blockquote>
<h3 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> <a href="https://leetcode.cn/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h3>
<blockquote>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
</blockquote>
<p>定义虚拟头节点dummyHead，以解决第一个节点就是val值的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeElements</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummyHead</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">dummyHead</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="707-设计链表"><a class="markdownIt-Anchor" href="#707-设计链表"></a> <a href="https://leetcode.cn/problems/design-linked-list/" target="_blank" rel="noopener">707. 设计链表</a></h3>
<blockquote>
<p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p>
<p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p>
<p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p>
<p>实现 <code>MyLinkedList</code> 类：</p>
<ul>
<li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li>
<li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li>
<li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li>
<li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li>
<li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li>
<li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li>
</ul>
</blockquote>
<p>找准指向的元素。前一个还是后一个。另外需要分类分析头尾的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MyLinkedList</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; MyLinkedList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">MyLinkedList* <span class="title">myLinkedListCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义虚拟头节点</span></span><br><span class="line">    MyLinkedList* head = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myLinkedListGet</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    MyLinkedList* p = obj-&gt;next; <span class="comment">//定义工作指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == index) &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtHead</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    MyLinkedList* newHead = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    newHead-&gt;next = obj-&gt;next;</span><br><span class="line">    newHead-&gt;val = val;</span><br><span class="line">    obj-&gt;next = newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtTail</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    MyLinkedList* p = obj-&gt;next; <span class="comment">//定义工作指针</span></span><br><span class="line">    MyLinkedList* newTail = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    newTail-&gt;val = val;</span><br><span class="line">    newTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = newTail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        obj-&gt;next = newTail;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListAddAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    MyLinkedList* p = obj-&gt;next; <span class="comment">//工作指针</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        myLinkedListAddAtHead(obj, val);</span><br><span class="line">    &#125;</span><br><span class="line">    MyLinkedList* newAdd = (MyLinkedList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyLinkedList));</span><br><span class="line">    newAdd-&gt;val = val;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; p != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == index - <span class="number">1</span>) &#123;</span><br><span class="line">            newAdd-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = newAdd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListDeleteAtIndex</span><span class="params">(MyLinkedList* obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    MyLinkedList* p = obj-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            obj-&gt;next = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; p-&gt;next != <span class="literal">NULL</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == index - <span class="number">1</span>) &#123;</span><br><span class="line">                p-&gt;next = p-&gt;next-&gt;next; </span><br><span class="line">                <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myLinkedListFree</span><span class="params">(MyLinkedList* obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        MyLinkedList* temp =  obj;</span><br><span class="line">        obj = obj-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList struct will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = myLinkedListCreate();</span></span><br><span class="line"><span class="comment"> * int param_1 = myLinkedListGet(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtHead(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtTail(obj, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListAddAtIndex(obj, index, val);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListDeleteAtIndex(obj, index);</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * myLinkedListFree(obj);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>cpp版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* _dummyHead;</span><br><span class="line">    <span class="keyword">int</span> _size;</span><br><span class="line"></span><br><span class="line">    MyLinkedList() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; (_size - <span class="number">1</span>) || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        p-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = p;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode *p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        _size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = _dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *newNode = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">        newNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= _size) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = _dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> <a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h3>
<blockquote>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
</blockquote>
<p>【双指针】注意链表不带头节点。所以双指针的工作和带头结点的不同。</p>
<p><img alt="image-20240326200013905" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240326200013905.png" data-index="1" data-src="/2024/03/30/LeetCode-problems/image-20240326200013905.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//head 不带头节点</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">p</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">q</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">r</span> = <span class="title">q</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        q-&gt;next = p;</span><br><span class="line">        p = q;</span><br><span class="line">        q = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// head-&gt;next = NULL;</span></span><br><span class="line">    head = p;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *q = head;</span><br><span class="line">        <span class="keyword">while</span> (q) &#123;</span><br><span class="line">            ListNode *temp;</span><br><span class="line">            temp = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q;</span><br><span class="line">            q = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h3>
<blockquote>
<p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><img alt="image-20240326195630531" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240326195630531.png" data-index="2" data-src="/2024/03/30/LeetCode-problems/image-20240326195630531.png"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">swapPairs</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *dummyHead = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    ListNode *p = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode)); <span class="comment">// 定义头节点和工作指针</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    p = dummyHead;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span> &amp;&amp; p-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ListNode *temp = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        p-&gt;next-&gt;next = temp;</span><br><span class="line">        p = p-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        <span class="keyword">if</span> (dummyHead-&gt;next == <span class="literal">nullptr</span> || dummyHead-&gt;next-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = dummyHead;</span><br><span class="line">        ListNode *temp;</span><br><span class="line">        <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span> &amp;&amp; p-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            temp-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next = temp;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点"></a> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第 N 个结点</a></h3>
<blockquote>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
</blockquote>
<h4 id="解法一暴力解法两次遍历"><a class="markdownIt-Anchor" href="#解法一暴力解法两次遍历"></a> 解法一——暴力解法，两次遍历</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *dummyNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line">    ListNode *p = dummyNode;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p = dummyNode;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count - n; i++) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二双指针让快慢指针间隔n位"><a class="markdownIt-Anchor" href="#解法二双指针让快慢指针间隔n位"></a> 解法二——双指针，让快慢指针间隔n位</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">removeNthFromEnd</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *dummyNode = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    dummyNode-&gt;next = head;</span><br><span class="line">    ListNode *fast = dummyNode;</span><br><span class="line">    ListNode *slow = dummyNode;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fast-&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义虚拟头节点，方便统一处理</span></span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="160-相交链表"><a class="markdownIt-Anchor" href="#160-相交链表"></a> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h3>
<blockquote>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener"><img alt="img" class="post-img b-lazy" data-img="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" data-index="3" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
</blockquote>
<p>计算链表长度的差，移动到剩余相同长度，一个一个节点比较</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">getIntersectionNode</span><span class="params">(struct ListNode *headA, struct ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line"></span><br><span class="line">    ListNode *p = headA;</span><br><span class="line">    ListNode *q = headB;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算链表长度的差</span></span><br><span class="line">    <span class="keyword">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lenA++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lenB++;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动到相同长度</span></span><br><span class="line">    p = headA;</span><br><span class="line">    q = headB;</span><br><span class="line">    <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">        gap = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gap != <span class="number">0</span>) &#123;</span><br><span class="line">            gap--;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        gap = lenB - lenA;</span><br><span class="line">        <span class="keyword">while</span>(gap != <span class="number">0</span>) &#123;</span><br><span class="line">            gap--;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一个一个比较</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> lengthB = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = headA;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lengthA++;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* q = headB;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            lengthB++;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = headA;</span><br><span class="line">        q = headB;</span><br><span class="line">        <span class="keyword">if</span> (lengthA &gt; lengthB) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthA - lengthB; i++) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lengthB - lengthA; i++) &#123;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(lengthB, lengthA); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p == q) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解——双指针的思路</p>
<p>两者长度分别为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo separator="true">,</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m,n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span></span></span></span>，假设公共部分为后<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>，则<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><mi>a</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">m=a+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>b</mi><mo>+</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">n=b+c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span></p>
<p>开始先指向自己，走完自己全程指向对方</p>
<ul>
<li>两链表相交：
<ul>
<li>长度相等：两个指针会同时到达两个链表相交的节点</li>
<li>长度不等：走到第一个公共节点的距离是相同的，第一个走的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a+c+b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>，第二个走的是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mo>+</mo><mi>c</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">b+c+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></li>
</ul>
</li>
<li>两个链表不相交
<ul>
<li>长度相等：同时到达两个链表自己的尾节点变成NULL</li>
<li>长度不等：两个指针都会遍历完两个链表（自己加对方），变成NULL</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *p = headA;</span><br><span class="line">        ListNode *q = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = headB;</span><br><span class="line">            <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            q = headA;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == q) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            q = headA;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = headB;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == q) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="142-环形链表-ii"><a class="markdownIt-Anchor" href="#142-环形链表-ii"></a> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h3>
<blockquote>
<p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
</blockquote>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20220925103433.png" data-index="4" data-src="/2024/03/30/LeetCode-problems/20220925103433.png"></p>
<p>慢指针每次走一步，快指针每次走两部</p>
<p>相遇时</p>
<ul>
<li>
<p>slow： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x+y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span></p>
</li>
<li>
<p>fast：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x+y+n(y+z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>​ 比slow多走了n圈</p>
</li>
<li>
<p>重要的等式！！！</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo>+</mo><mi>y</mi><mo>+</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">2(x+y)=x+y+n(y+z)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span></p>
<p>于是可以推导出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>n</mi><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>−</mo><mi>y</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>y</mi><mo>+</mo><mi>z</mi><mo stretchy="false">)</mo><mo>+</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">x=n(y+z)-y = (n-1)(y+z)+z</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span>，至少多走了一圈，所以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n\ge 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>合理.</p>
</li>
<li>
<p>所以x和z的关系就是差了整数圈的关系！</p>
</li>
<li>
<p>所以从头节点走到环形入口的距离等于整数圈+相遇节点到入口。</p>
<ul>
<li>所以从相遇点、头节点出发的两个指针，每次走一步，相遇的位置一定是环形入口。</li>
<li>代码注意后续这么动的时候，slow和fast在不在变，会导致判断条件有问题！</li>
</ul>
</li>
</ul>
<ol>
<li>为何慢指针第一圈走不完一定会和快指针相遇? 可以认为快指针和慢指针是相对运动的，假设慢指针的速度是 1节点/秒，快指针的速度是 2节点/秒，当以慢指针为参考系的话（即慢指针静止），快指针的移动速度就是 1节点/秒，所以肯定会相遇。</li>
<li>为什么在第一圈就会相遇呢？ 设环的长度为 L，当慢指针刚进入环时，慢指针需要走 L 步(即 L 秒)才能走完一圈，此时快指针距离慢指针的最大距离为 L-1，我们再次以慢指针为参考系，如上所说，快指针在按照1节点/秒的速度在追赶慢指针，所以肯定能在 L 秒内追赶到慢指针。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">detectCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> <span class="title">ListNode</span>;</span></span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 先追及</span></span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后从头开始</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            ListNode *p = head;</span><br><span class="line">            ListNode *q = slow;</span><br><span class="line">            <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                q = q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>以下开始以C艹为主</p>
<h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h2>
<blockquote>
<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>
<ul>
<li>数组</li>
<li>set （集合）</li>
<li>map (映射)</li>
</ul>
<p>这里数组就没啥可说的了，我们来看一下set。</p>
<p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::set</code></td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td><code>std::multiset</code></td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td><code>std::unordered_set</code></td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>`</td>
</tr>
</tbody>
</table>
<p><code>std::unordered_set</code>底层实现为哈希表，<code>std::set</code> 和<code>std::multiset</code> 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::map</code></td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td><code>std::multimap</code></td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<p><code>std::unordered_map</code> 底层实现为哈希表，<code>std::map</code> 和<code>std::multimap</code> 的底层实现是红黑树。同理，<code>std::map</code> 和<code>std::multimap</code> 的key也是有序的。</p>
<ul>
<li>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</li>
<li>再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</li>
</ul>
<p>——代码随想录</p>
</blockquote>
<h3 id="242-有效的字母异位词"><a class="markdownIt-Anchor" href="#242-有效的字母异位词"></a> <a href="https://leetcode.cn/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h3>
<blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p>
<p>**注意：**若 <code>s</code> 和 <code>t</code> 中每个字符出现的次数都相同，则称 <code>s</code> 和 <code>t</code> 互为字母异位词。</p>
</blockquote>
<p>把小写字母表看作哈希表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; alphabetS(<span class="number">26</span>);</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; alphabetT(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            alphabetS[s[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">            alphabetT[t[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alphabetS == alphabetT) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>或者通过是不是都是0来判断，减少空间需求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAnagram</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">char</span>* t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(s) != <span class="built_in">strlen</span>(t)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *alphabet = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        alphabet[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(s); i++) &#123;</span><br><span class="line">        alphabet[s[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        alphabet[t[i] - <span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alphabet[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="349-两个数组的交集"><a class="markdownIt-Anchor" href="#349-两个数组的交集"></a> <a href="https://leetcode.cn/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></h3>
<blockquote>
<p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 它们的 交集 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
</blockquote>
<h4 id="解法一建立数组hash表"><a class="markdownIt-Anchor" href="#解法一建立数组hash表"></a> 解法一——建立数组hash表</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; hash(<span class="number">1001</span>);</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums1) &#123;</span><br><span class="line">            hash[num] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[num] != <span class="number">0</span>) &#123;</span><br><span class="line">                output.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output_vec;</span><br><span class="line">        output_vec.assign(output.begin(), output.end());</span><br><span class="line">        <span class="keyword">return</span> output_vec;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二用无序set做"><a class="markdownIt-Anchor" href="#解法二用无序set做"></a> 解法二——用无序set做</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">intersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; nums1_set(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; output_set;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_set.find(num) != <span class="number">0</span>) &#123;</span><br><span class="line">                output_set.insert(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; (output_set.begin(), output_set.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="202-快乐数"><a class="markdownIt-Anchor" href="#202-快乐数"></a> <a href="https://leetcode.cn/problems/happy-number/" target="_blank" rel="noopener">202. 快乐数</a></h3>
<blockquote>
<p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p>
<p><strong>「快乐数」</strong> 定义为：</p>
<ul>
<li>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</li>
<li>然后重复这个过程直到这个数变为 1，也可能是 <strong>无限循环</strong> 但始终变不到 1。</li>
<li>如果这个过程 <strong>结果为</strong> 1，那么这个数就是快乐数。</li>
</ul>
<p>如果 <code>n</code> 是 <em>快乐数</em> 就返回 <code>true</code> ；不是，则返回 <code>false</code> 。</p>
</blockquote>
<p>无限循环是重点！！！</p>
<p>重点是可能会陷入无限循环。<br>
需要先判断在不在之前存储的集合里面，再将sum添加进集合里面。<br>
同时集合.find的判定是和end()比。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span> &lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="keyword">int</span> mod = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (results.find(sum) == results.end()) &#123;</span><br><span class="line">            results.insert(sum);</span><br><span class="line">            mod = sum;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 下列循环求mod的各位平方和</span></span><br><span class="line">            <span class="keyword">while</span> (mod != <span class="number">0</span>) &#123;</span><br><span class="line">                sum += (mod % <span class="number">10</span>) * (mod % <span class="number">10</span>);</span><br><span class="line">                mod /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; sum &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> <a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noopener">1. 两数之和</a></h3>
<blockquote>
<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
</blockquote>
<h4 id="解法一暴力解法"><a class="markdownIt-Anchor" href="#解法一暴力解法"></a> 解法一——暴力解法</h4>
<p>复杂度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二利用哈希表的思路"><a class="markdownIt-Anchor" href="#解法二利用哈希表的思路"></a> 解法二——利用哈希表的思路</h4>
<p>利用键值对，在之前保存的键值对中找有没有能够匹配的元素。注意<strong>find的时候，是find的键值对的键</strong>，而非值，返回的是键值对的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; nums_map;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums_map.find(target - nums[i]) != nums_map.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;nums_map.find(target - nums[i])-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            nums_map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="454-四数相加-ii"><a class="markdownIt-Anchor" href="#454-四数相加-ii"></a> <a href="https://leetcode.cn/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></h3>
<blockquote>
<p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>
</blockquote>
<p>首先是无序的，但是需要次数，所以需要通过<code>unordered_map</code>。</p>
<p>分组的思想降低for循环的次数</p>
<p>map新增值不需要判断是否存在键。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums3, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; sumTwo;</span><br><span class="line">        <span class="keyword">int</span> counts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1:nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num2:nums2) &#123;</span><br><span class="line">                sumTwo[num1 + num2] += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num3:nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num4:nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sumTwo.find(- (num3 + num4)) != sumTwo.end()) &#123;</span><br><span class="line">                    counts += sumTwo[- (num3 + num4)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> counts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="383-赎金信"><a class="markdownIt-Anchor" href="#383-赎金信"></a> <a href="https://leetcode.cn/problems/ransom-note/" target="_blank" rel="noopener">383. 赎金信</a></h3>
<blockquote>
<p>给你两个字符串：<code>ransomNote</code> 和 <code>magazine</code> ，判断 <code>ransomNote</code> 能不能由 <code>magazine</code> 里面的字符构成。</p>
<p>如果可以，返回 <code>true</code> ；否则返回 <code>false</code> 。</p>
<p><code>magazine</code> 中的每个字符只能在 <code>ransomNote</code> 中使用一次。</p>
</blockquote>
<p>小写字母建立hash表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canConstruct</span><span class="params">(<span class="built_in">string</span> ransomNote, <span class="built_in">string</span> magazine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alphabet[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">if</span> (magazine.length() &lt; ransomNote.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            alphabet[magazine[i] - <span class="string">'a'</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ransomNote.length(); j++) &#123;</span><br><span class="line">            alphabet[ransomNote[j] - <span class="string">'a'</span>] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (alphabet[ransomNote[j] - <span class="string">'a'</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> <a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请</p>
<p>你返回所有和为 <code>0</code> 且不重复的三元组。</p>
<p>**注意：**答案中不可以包含重复的三元组。</p>
</blockquote>
<p>去重很困难。考虑双指针法</p>
<p>去重的位置非常重要！同时要考虑使用双指针而非哈希表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 最左边的元素大于0，那么不可能和为0</span></span><br><span class="line">                <span class="keyword">return</span> output;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">//第一个数，去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 双指针启动！</span></span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    output.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                        left++; <span class="comment">// 第二个数，去重，要求左右顺序不能错。如果这个数和后一个一样，那么会导致第二个数有重复，所以右移</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                        right--;<span class="comment">// 第三个数，去重</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//找到答案，同时收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="18-四数之和"><a class="markdownIt-Anchor" href="#18-四数之和"></a> <a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h3>
<blockquote>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且<strong>不重复</strong>的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> <strong>互不相同</strong></li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
</blockquote>
<p>不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0</code> 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，<code>target</code>是<code>-10</code>，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p>
<p>这边的重点是第二个数要求<code>j &gt; i+1</code>而非<code>j&gt;0</code>，不然数相等时候会往右缩。</p>
<p>同时注意不加<code>(long)</code>可能会溢出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">fourSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="comment">//先要从小到大排</span></span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// if (nums[i] &gt; target &amp;&amp; nums[i] &gt;= 0) &#123;</span></span><br><span class="line">            <span class="comment">//     break; //剪枝处理，类似之前的首元素大于0，那么必然不行</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="comment">// if (nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= 0) &#123;</span></span><br><span class="line">                <span class="comment">//     break; //剪枝处理，类似之前的首元素大于0，那么必然不行</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; i+<span class="number">1</span> &amp;&amp; nums[j] == nums[j<span class="number">-1</span>]) &#123;  <span class="comment">// 这边的重点是j &gt; i+1而非j&gt;0</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 双指针</span></span><br><span class="line">                <span class="keyword">int</span> left = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[j] + nums[left] + nums[right] &lt; target) &#123; <span class="comment">//会溢出</span></span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="keyword">long</span>) nums[i] + nums[j] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        output.push_back(&#123;nums[i], nums[j], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) &#123;</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="204-计数质数"><a class="markdownIt-Anchor" href="#204-计数质数"></a> <a href="https://leetcode.cn/problems/count-primes/" target="_blank" rel="noopener">204. 计数质数</a></h3>
<blockquote>
<p>给定整数 <code>n</code> ，返回 <em>所有小于非负整数 <code>n</code> 的质数的数量</em> 。</p>
</blockquote>
<p>埃氏筛</p>
<p>枚举没有考虑到数与数的关联性，因此难以再继续优化时间复杂度。</p>
<p>我们设 isPrime[i] 表示数 i 是不是质数，如果是质数则为 1，否则为 0。从小到大遍历每个数，如果这个数为质数，则将其所有的倍数都标记为合数（除了该质数本身），即 0，这样在运行结束的时候我们即能知道质数的个数。</p>
<p>这种方法的正确性是比较显然的：这种方法显然不会将质数标记成合数；另一方面，当从小到大遍历到数 x 时，倘若它是合数，则它一定是某个小于 x 的质数 y 的整数倍，故根据此方法的步骤，我们在遍历到 y 时，就一定会在此时将 x 标记为 isPrime[x]=0。因此，这种方法也不会将合数标记为质数。</p>
<p>当然这里还可以继续优化，对于一个质数 x，如果按上文说的我们从 2x 开始标记其实是冗余的，应该直接从 x⋅x 开始标记，因为 2x,3x,… 这些数一定在 x 之前就被其他数的倍数标记过了，例如 2 的所有倍数，3 的所有倍数等。</p>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">                output++;</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)i * i &lt; n) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i ; j &lt; n ; j += i) &#123;</span><br><span class="line">                        isPrime[j] = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="字符串"><a class="markdownIt-Anchor" href="#字符串"></a> 字符串</h2>
<h3 id="344-反转字符串"><a class="markdownIt-Anchor" href="#344-反转字符串"></a> <a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h3>
<blockquote>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>s</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
</blockquote>
<p>注意right的其实位置是length-1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = temp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii"></a> <a href="https://leetcode.cn/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></h3>
<blockquote>
<p>给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p>
<ul>
<li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li>
<li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li>
</ul>
</blockquote>
<p>还是写的有点复杂了，可以把两个大于等于k的条件再精简一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseStr</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> loop = s.length() / (<span class="number">2</span> * k) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loop; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果不是最后一个loop，则反转当前loop前k个</span></span><br><span class="line">            <span class="keyword">if</span> (i != loop - <span class="number">1</span>) &#123;  <span class="comment">//和下面last_loop &gt;= k合并</span></span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">2</span> * i * k;</span><br><span class="line">                <span class="keyword">int</span> right = <span class="number">2</span> * i * k + (k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    swap(s[left], s[right]);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> last_loop = s.length() % (<span class="number">2</span> * k);</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">2</span> * i * k;</span><br><span class="line">                <span class="keyword">int</span> right;</span><br><span class="line">                <span class="keyword">if</span> (last_loop &lt; k) &#123; <span class="comment">//0的情况也没事，不会进入while循环。</span></span><br><span class="line">                    right = s.length() - <span class="number">1</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> &#123;  <span class="comment">//和上面i != loop - 1合并</span></span><br><span class="line">                    right = <span class="number">2</span> * i * k + (k - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    swap(s[left], s[right]);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="54-替换数字kamacoder"><a class="markdownIt-Anchor" href="#54-替换数字kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1064" target="_blank" rel="noopener">54. 替换数字(kamacoder)</a></h3>
<blockquote>
<p><strong>题目描述</strong></p>
<p>给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 <code>a1b2c3</code>，函数应该将其转换为 <code>anumberbnumbercnumber</code>。</p>
<p><strong>输入描述</strong></p>
<p>输入一个字符串 s,s 仅包含小写字母和数字字符。</p>
<p><strong>输出描述</strong></p>
<p>打印一个新的字符串，其中每个数字字符都被替换为了number</p>
</blockquote>
<p>从后往前替换字符，复杂度低，左边不用管。</p>
<p><img alt="img" class="post-img b-lazy" data-img="https://code-thinking-1253855093.file.myqcloud.com/pics/20231030173058.png" data-index="5" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20231030173058.png"></p>
<p>注意处理完之后要左移一下，且判断条件注意边界。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;</span><br><span class="line">        <span class="keyword">int</span> countNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> oldSize = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                countNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; countNum &lt;&lt; endl;</span></span><br><span class="line">        s.resize(s.size() + <span class="number">5</span> * countNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = oldSize - <span class="number">1</span>, right = s.size() - <span class="number">1</span>; left &gt;= <span class="number">0</span>; left--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[left] &lt; <span class="string">'0'</span> || s[left] &gt; <span class="string">'9'</span>) &#123; <span class="comment">// 不应该有等号</span></span><br><span class="line">                s[right] = s[left];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[right--] = <span class="string">'r'</span>;</span><br><span class="line">                s[right--] = <span class="string">'e'</span>;</span><br><span class="line">                s[right--] = <span class="string">'b'</span>;</span><br><span class="line">                s[right--] = <span class="string">'m'</span>;</span><br><span class="line">                s[right--] = <span class="string">'u'</span>;</span><br><span class="line">                s[right--] = <span class="string">'n'</span>; <span class="comment">// 注意先减还是后减去</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词"></a> <a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 反转字符串中的单词</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> ，请你反转字符串中 <strong>单词</strong> 的顺序。</p>
<p><strong>单词</strong> 是由非空格字符组成的字符串。<code>s</code> 中使用至少一个空格将字符串中的 <strong>单词</strong> 分隔开。</p>
<p>返回 <strong>单词</strong> 顺序颠倒且 <strong>单词</strong> 之间用单个空格连接的结果字符串。</p>
<p>**注意：**输入字符串 <code>s</code>中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。</p>
</blockquote>
<p><img alt="fig" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/mutable2.png" data-index="6" data-src="/2024/03/30/LeetCode-problems/mutable2.png"></p>
<p>反转整个字符串。<br>
同时操作反转单词和去除空格，要定义一个变量表示当前单词头，然后快慢指针删除空格. （代码随想录中分开处理。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseString</span> <span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            swap(s[left++], s[right--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 反转整个字符串</span></span><br><span class="line">        reverseString (s, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时操作反转单词和去除空格，要定义一个变量表示当前单词头，然后快慢指针删除空格.</span></span><br><span class="line">        <span class="comment">// 慢指针指向单词尾部时，从单词头到慢指针反转。</span></span><br><span class="line">        <span class="comment">// 处理完一个单词后，注意单词之间有空格</span></span><br><span class="line">        <span class="keyword">int</span> wordHead = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; s.length(); fast++) &#123;</span><br><span class="line">            <span class="comment">/*三种情况（前两种可以合并）：</span></span><br><span class="line"><span class="comment">            ① fast=0 且 s[fast] 不为空，要传给slow</span></span><br><span class="line"><span class="comment">            ② fast!=0 且 s[fast] 不为空，要传给slow </span></span><br><span class="line"><span class="comment">            （这样不好处理最后一个单词）③ fast!=0 且 s[fast] 为空，s[fast-1] 不为空，要传给slow，同时从wordHead到slow-1逆转，wordHead移动到空格后</span></span><br><span class="line"><span class="comment">            ③ fast!=0 且 s[fast] 不为空，s[fast+1] 为空或者句子结尾，要传给slow后，同时从wordHead到slow逆转，slow补齐空格，wordHead移动到空格后</span></span><br><span class="line"><span class="comment">            所以先处理情况三*/</span></span><br><span class="line">            <span class="keyword">if</span> (s[fast] != <span class="string">' '</span>) &#123;</span><br><span class="line">                s[slow] = s[fast];</span><br><span class="line">                <span class="keyword">if</span> (s[fast+<span class="number">1</span>] == <span class="string">' '</span> || fast+<span class="number">1</span> &gt;= s.length()) &#123;</span><br><span class="line">                    reverseString(s, wordHead, slow);</span><br><span class="line">                    s[++slow] = <span class="string">' '</span>;</span><br><span class="line">                    wordHead = slow + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重置string长度，注意slow移向上一个单词的后一个格了</span></span><br><span class="line">        s.resize(slow<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="55-右旋字符串-kamacoder"><a class="markdownIt-Anchor" href="#55-右旋字符串-kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1065" target="_blank" rel="noopener">55. 右旋字符串 (kamacoder)</a></h3>
<blockquote>
<p><strong>题目描述</strong></p>
<p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。</p>
<p>例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。</p>
<p><strong>输入描述</strong></p>
<p>输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。</p>
<p><strong>输出描述</strong></p>
<p>输出共一行，为进行了右旋转操作后的字符串。</p>
</blockquote>
<h4 id="解法一直接字符串提取拼接"><a class="markdownIt-Anchor" href="#解法一直接字符串提取拼接"></a> 解法一——直接字符串提取拼接</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> s1 = s.substr(<span class="number">0</span>, length - k);</span><br><span class="line">    <span class="built_in">string</span> s2 = s.substr(length - k, k);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s2 &lt;&lt; s1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解法二整体反转字符串两个反转单词"><a class="markdownIt-Anchor" href="#解法二整体反转字符串两个反转单词"></a> 解法二——“整体反转字符串”+“两个反转单词”</h4>
<p>在原本字符串中处理，变成“整体反转字符串”+“两个反转单词”的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void reverseString (string &amp;s, int left, int right) &#123;</span></span><br><span class="line"><span class="comment">//     while (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">//         swap (s[left++], s[right--]);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int length = s.length();</span></span><br><span class="line">    <span class="comment">// reverseString(s, 0, length-1);</span></span><br><span class="line">    <span class="comment">// reverseString(s, 0, k-1);</span></span><br><span class="line">    <span class="comment">// reverseString(s, k, length-1);</span></span><br><span class="line">    </span><br><span class="line">    reverse(s.begin(), s.end()); <span class="comment">//左闭右开</span></span><br><span class="line">    reverse(s.begin(), s.begin() + k);</span><br><span class="line">    reverse(s.begin() + k, s.end());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="28-找出字符串中第一个匹配项的下标"><a class="markdownIt-Anchor" href="#28-找出字符串中第一个匹配项的下标"></a> <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/" target="_blank" rel="noopener">28. 找出字符串中第一个匹配项的下标</a></h3>
<blockquote>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 0 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p>
</blockquote>
<ol>
<li>注意：如果单纯通过一层for循环判断时候，当flag倒了的时候，可能前面部分字符还是重复了needle的少部分，所以需要回溯。</li>
</ol>
<h4 id="解法一-暴力解法也能解取所有的n长字串即可"><a class="markdownIt-Anchor" href="#解法一-暴力解法也能解取所有的n长字串即可"></a> 解法一—— 暴力解法也能解，取所有的n长字串即可。</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (needle[j] == haystack[i]) &#123;</span><br><span class="line">                flag++;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                i = i - j;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二kmp算法"><a class="markdownIt-Anchor" href="#解法二kmp算法"></a> 解法二——KMP算法</h4>
<ol>
<li>
<p>KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p>
</li>
<li>
<p>前缀表</p>
<ul>
<li>
<p>为什么需要？不想完全回溯。<br>
<img alt="image-20240329202856323" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240329202856323.png" data-index="7" data-src="/2024/03/30/LeetCode-problems/image-20240329202856323.png"></p>
</li>
<li>
<p>当前位置既然不能完全满足匹配串，那么至多能匹配上多少？也就是说可以少回溯多少呢？也就知道子串（匹配串）需要回溯到什么位置——这由当前位置的上一个前缀表值来确定。</p>
<p><img alt="image-20240329202910993" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240329202910993.png" data-index="8" data-src="/2024/03/30/LeetCode-problems/image-20240329202910993.png"></p>
</li>
</ul>
</li>
<li>
<p>next数组的定义</p>
<ul>
<li>
<p>初始化（前缀末尾（即最长相等前后缀长度）<code>j</code>、后缀末尾<code>i</code>）</p>
</li>
<li>
<p>前后缀不相等（防止越界<code>j&gt;0</code>且<code>s[i]!=s[j]</code>时，<code>j</code>要连续回溯到<code>next[j-1]</code>）</p>
</li>
<li>
<p>前后缀相等（<code>j</code>可以递增，同时后缀<code>i</code>指向位置的前缀表值为<code>j</code>）</p>
</li>
<li>
<p>请注意这里最后一个为什么是2：这是由于B的时候发现匹配不上了，那么<code>j=3</code>也就要回溯到<code>j=next[j-1]=next[2]=1</code>这个位置。这里需要注意为什么明明是后缀的问题，要用前缀来看呢？因为后缀和前缀相等，所以后缀要回溯的值等于前缀需要回溯到的值（好乱啊55555555）<br>
<img alt="image-20240329203055212" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240329203055212.png" data-index="9" data-src="/2024/03/30/LeetCode-problems/image-20240329203055212.png"></p>
<p><img alt="image-20240329202935587" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240329202935587.png" data-index="10" data-src="/2024/03/30/LeetCode-problems/image-20240329202935587.png"></p>
</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getNext</span> <span class="params">(<span class="keyword">int</span>* next, <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//前缀末尾，即最长相等前后缀长度</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">                j = next[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="built_in">string</span> haystack, <span class="built_in">string</span> needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> next[needle.length()];</span><br><span class="line">        getNext(next, needle); <span class="comment">//获取前缀表</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">//指向匹配串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123; <span class="comment">//i指向文本串</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j])&#123; <span class="comment">//注意这里也要连续回溯</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="459-重复的子字符串"><a class="markdownIt-Anchor" href="#459-重复的子字符串"></a> <a href="https://leetcode.cn/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h3>
<blockquote>
<p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
</blockquote>
<h4 id="解法一移动匹配"><a class="markdownIt-Anchor" href="#解法一移动匹配"></a> 解法一——移动匹配</h4>
<p>那么既然前面有相同的子串，后面有相同的子串，用 s + s，这样组成的字符串中，后面的子串做前串，前面的子串做后串，就一定还能组成一个s</p>
<p><img alt="图二" class="post-img b-lazy" data-img="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png" data-index="11" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220728104931.png"><br>
——来自代码随想录</p>
<p>代码也来自代码随想录代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t = s + s;</span><br><span class="line">        t.erase(t.begin()); t.erase(t.end() - <span class="number">1</span>); <span class="comment">// 掐头去尾</span></span><br><span class="line">        <span class="keyword">if</span> (t.find(s) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// r</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: O(n)</li>
<li>空间复杂度: O(1)</li>
</ul>
<p>不过这种解法还有一个问题，就是 我们最终还是要判断 一个字符串（s + s）是否出现过 s 的过程，大家可能直接用contains，find 之类的库函数。 却忽略了实现这些函数的时间复杂度（暴力解法是m * n，一般库函数实现为 O(m + n)）。</p>
<h4 id="解法二优化的kmp算法"><a class="markdownIt-Anchor" href="#解法二优化的kmp算法"></a> 解法二——优化的KMP算法</h4>
<p>（不是很能看懂最后一步）</p>
<p>假设字符串s使用多个重复子串构成（这个子串是最小重复单位），重复出现的子字符串长度是<code>x</code>，所以<code>s</code>是由<code>n * x</code>组成。</p>
<p>因为字符串s的最长相同前后缀的长度一定是不包含<code>s</code>本身，所以 最长相同前后缀长度必然是<code>m * x</code>，而且<code>n - m = 1</code>，（这里如果不懂，看上面的推理）</p>
<p>所以如果 <code>nx % (n - m)x = 0</code>，就可以判定有重复出现的子字符串。</p>
<p>最长相等前后缀的长度为：<code>next[len - 1]</code></p>
<p>数组长度为：len。</p>
<p>如果<code>len % (len - next[len - 1] ) == 0</code> ，则说明数组的长度正好可以被 (数组长度-最长相等前后缀的长度) 整除 ，说明该字符串有重复的子字符串。</p>
<p><strong>数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> next[s.length()];</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLoop = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; s[j] != s[i]) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[j] == s[i]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">            <span class="keyword">if</span> (next[i] &gt; maxLoop) &#123;</span><br><span class="line">                maxLoop = next[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; next[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length() % (s.length() - maxLoop) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2>
<ul>
<li>
<p>数组</p>
<ul>
<li>[移除元素](#<a href="https://leetcode.cn/problems/remove-element/" target="_blank" rel="noopener">27. 移除元素</a>)：通过两个指针在一个for循环下完成两个for循环的工作。</li>
</ul>
</li>
<li>
<p>字符串</p>
<ul>
<li>[反转字符串](#<a href="https://leetcode.cn/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a>)：使用双指针法，定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。时间复杂度是O(n)。</li>
<li>[替换数字](#<a href="https://kamacoder.com/problempage.php?pid=1064" target="_blank" rel="noopener">54. 替换数字(kamacoder)</a>)：首先扩充数组到每个空格替换成&quot;number&quot;之后的大小。然后双指针从后向前替换空格。</li>
<li>[反转字符串中的单词](#<a href="https://leetcode.cn/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 反转字符串中的单词</a>)：两次反转，同时要去除冗余空格，注意erase操作也是O(n)的操作</li>
</ul>
</li>
<li>
<p>链表</p>
<ul>
<li>
<p>[反转链表](#<a href="https://leetcode.cn/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a>)：只需要改变链表的next指针的指向，直接将链表反转 ，而不用重新定义一个新的链表。</p>
</li>
<li>
<p>[删除链表的倒数第 N 个结点](#<a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. 删除链表的倒数第 N 个结点</a>)：快指针多走N个节点</p>
</li>
<li>
<p>[相交链表](#<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a>)：计算链表长度的差，移动到剩余相同长度，一个一个节点比较</p>
</li>
<li>
<p>[环形链表II](#<a href="https://leetcode.cn/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a>)：</p>
<p>如何通过双指针判断是否有环，而且还要找到环的入口。</p>
<p><strong>使用快慢指针（双指针法），分别定义 fast 和 slow指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。</strong></p>
</li>
</ul>
</li>
<li>
<p>N数之和</p>
<ul>
<li>使用了哈希法解决了两数之和，但是哈希法并不适用于三数之和！去重不好操作</li>
<li>[三数之和](#<a href="https://leetcode.cn/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a>)：①先排序；②双指针的移动原则；③通过前后两个指针不算向中间逼近，在一个for循环下完成两个for循环的工作。</li>
<li>[四数之和](#<a href="https://leetcode.cn/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a>)：在三数之和的基础上再套一层for循环，依然是使用双指针法。</li>
<li>对于三数之和使用双指针法就是将原本暴力<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的解法，降为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的解法，四数之和的双指针解法就是将原本暴力<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>4</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^4)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的解法，降为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的解法。</li>
</ul>
</li>
</ul>
<h2 id="栈-队列"><a class="markdownIt-Anchor" href="#栈-队列"></a> 栈、队列</h2>
<blockquote>
<p><strong>我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的底层结构。</strong></p>
<p>deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。</p>
<p><strong>SGI STL中 队列底层实现缺省情况下一样使用deque实现的。</strong></p>
<p>STL 队列不被归类为容器，而被归类为container adapter（ 容器适配器）</p>
<p>队列是先进先出的数据结构，不允许有遍历行为，stack和queue不提供迭代器</p>
<p>——代码随想录</p>
</blockquote>
<h3 id="232-用栈实现队列"><a class="markdownIt-Anchor" href="#232-用栈实现队列"></a> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/" target="_blank" rel="noopener">232. 用栈实现队列</a></h3>
<blockquote>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你 <strong>只能</strong> 使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
</blockquote>
<p>第2种实现的效率<strong>远高于</strong>第1种实现。原因是：</p>
<ul>
<li>在第2种实现中，元素只会在 <code>queueIn</code> 和 <code>queueOut</code> 之间转移一次，不会反复移动。</li>
<li>第1种实现的入队每次都要移动所有元素两次，这种重复操作极大降低了效率。</li>
</ul>
<h4 id="双栈操作均集中在push"><a class="markdownIt-Anchor" href="#双栈操作均集中在push"></a> 双栈——操作均集中在push</h4>
<p>注意pop只会去掉顶上的元素，不会把顶上元素值返回回来。</p>
<p><img alt="image-20240401104414302" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240401104414302.png" data-index="12" data-src="/2024/03/30/LeetCode-problems/image-20240401104414302.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; left;</span><br><span class="line">    <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; right;</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">        <span class="comment">/* 双栈操作，定义两个栈</span></span><br><span class="line"><span class="comment">        进队列时，先把右栈所有元素pop出压入左栈，再把加入元素压入左栈栈顶；接着左栈依次出栈，右栈依次入栈；</span></span><br><span class="line"><span class="comment">        出队即右栈出栈pop即可</span></span><br><span class="line"><span class="comment">        是否为空即判断右栈是否为空 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (right.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            left.push(right.top());</span><br><span class="line">            right.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        left.push(x);</span><br><span class="line">        <span class="keyword">while</span> (left.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            right.push(left.top());</span><br><span class="line">            left.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = right.top();</span><br><span class="line">        right.pop();</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="双栈的官方题解输入栈-输出栈"><a class="markdownIt-Anchor" href="#双栈的官方题解输入栈-输出栈"></a> 双栈的官方题解——输入栈、输出栈</h4>
<p>将一个栈当作输入栈，用于压入 push传入的数据；另一个栈当作输出栈，用于 pop和 peek操作。</p>
<p>每次 pop或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>
<p>其实，在这个代码逻辑中<strong>即使 <code>queueOut</code> 中有数据，入队（<code>push</code>）操作依然是可以正常工作的</strong>。你的疑问可能源于对双栈模拟队列的工作机制的理解，我们一起来梳理一下这个逻辑。</p>
<p><strong>双栈模拟队列的核心逻辑</strong>：</p>
<ul>
<li><strong><code>queueIn</code></strong>：用于存储新入队的元素（入栈操作）。</li>
<li><strong><code>queueOut</code></strong>：用于实现出队操作（栈顶弹出，模拟队列的队首）。</li>
</ul>
<p>双栈实现队列的原理是：</p>
<ol>
<li><strong>入队时</strong>，只把数据压入 <code>queueIn</code>。</li>
<li><strong>出队时</strong>：
<ul>
<li>只有在 <code>queueOut</code> 为空时，才把 <code>queueIn</code> 中所有元素倒入 <code>queueOut</code>。</li>
<li>这样 <code>queueOut</code> 中的栈顶元素就对应队列的队首元素（先进先出）。</li>
</ul>
</li>
</ol>
<p><strong>为什么入队不会出错？</strong></p>
<ol>
<li>每次 <strong>入队（<code>push</code>）</strong> 只会把新元素加入到 <code>queueIn</code> 中，而不会影响 <code>queueOut</code>。</li>
<li><strong>出队（<code>pop</code>）</strong> 时，只有当 <code>queueOut</code> 为空时，才会将 <code>queueIn</code> 的数据转移到 <code>queueOut</code>。
<ul>
<li>如果 <code>queueOut</code> 中已有元素，出队操作会直接弹出 <code>queueOut</code> 栈顶的元素，无需转移数据。</li>
</ul>
</li>
</ol>
<p>所以，即便 <code>queueOut</code> 中已有数据，<code>push</code> 新元素只会影响 <code>queueIn</code>，不会破坏现有的队列顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; queueIn;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; queueOut;</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">      queueIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (queueOut.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!queueIn.empty()) &#123;</span><br><span class="line">          <span class="keyword">int</span> x = queueIn.top();</span><br><span class="line">          queueOut.push(x);</span><br><span class="line">          queueIn.pop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> x = queueOut.top();</span><br><span class="line">      queueOut.pop();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;pop();</span><br><span class="line">      queueOut.push(x);</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (queueIn.empty() &amp;&amp; queueOut.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="225-用队列实现栈"><a class="markdownIt-Anchor" href="#225-用队列实现栈"></a> <a href="https://leetcode.cn/problems/implement-stack-using-queues/" target="_blank" rel="noopener">225. 用队列实现栈</a></h3>
<blockquote>
<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>
<p>实现 <code>MyStack</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>
<li><code>int pop()</code> 移除并返回栈顶元素。</li>
<li><code>int top()</code> 返回栈顶元素。</li>
<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>你只能使用队列的标准操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>
<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>
</ul>
</blockquote>
<h4 id="两个队列"><a class="markdownIt-Anchor" href="#两个队列"></a> 两个队列</h4>
<p>——将pop出来的前面的元素存在另一个queue里面</p>
<p><img alt="fig1" class="post-img b-lazy" data-img="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif" data-index="13" data-src="https://assets.leetcode-cn.com/solution-static/225/225_fig1.gif"></p>
<p>——官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; queue1;</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; queue2;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue1.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            queue2.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> output = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        swap(queue1, queue2);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="一个队列"><a class="markdownIt-Anchor" href="#一个队列"></a> 一个队列</h4>
<p>——将前面pop出来的继续push回去即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; queue1;</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> queueSize = queue1.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queueSize - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            queue1.push(queue1.front());</span><br><span class="line">            queue1.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> output = queue1.front();</span><br><span class="line">        queue1.pop();</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.back();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queue1.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> <a href="https://leetcode.cn/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h3>
<blockquote>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
<li>每个右括号都有一个对应的相同类型的左括号。</li>
</ol>
</blockquote>
<p>注意右括号的情况要判断一下栈是否为空。注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; bracks;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i  = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                bracks.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">')'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!bracks.empty() &amp;&amp; bracks.top() == <span class="string">'('</span>) &#123;</span><br><span class="line">                            bracks.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">']'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!bracks.empty() &amp;&amp; bracks.top() == <span class="string">'['</span>) &#123;</span><br><span class="line">                            bracks.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">'&#125;'</span>:</span><br><span class="line">                        <span class="keyword">if</span> (!bracks.empty() &amp;&amp; bracks.top() == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                            bracks.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bracks.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>少写一点判断的话</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'&#123;'</span> || s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                S.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!S.empty() &amp;&amp; ((s[i] == <span class="string">')'</span> &amp;&amp; S.top() == <span class="string">'('</span>) || (s[i] == <span class="string">']'</span> &amp;&amp; S.top() == <span class="string">'['</span>) || (s[i] == <span class="string">'&#125;'</span> &amp;&amp; S.top() == <span class="string">'&#123;'</span>))) &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (S.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1047-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#1047-删除字符串中的所有相邻重复项"></a> <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/" target="_blank" rel="noopener">1047. 删除字符串中的所有相邻重复项</a></h3>
<blockquote>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
</blockquote>
<p><strong>字符串拼接的代价</strong>：</p>
<ul>
<li>
<p>在 C++ 中，字符串的拼接操作（<code>+=</code>）会动态调整内存。如果你每次都将字符插入到字符串的</p>
<p>最前面，会导致：</p>
<ul>
<li>多次内存重新分配。</li>
<li>数据从旧位置到新位置的频繁拷贝。</li>
</ul>
</li>
<li>
<p>因此，第一种实现的时间复杂度实际上更高。</p>
</li>
</ul>
<p><strong>第二种实现的优化</strong>：</p>
<ul>
<li>在第二种代码中，字符逐个添加到 <code>sNew</code> 的末尾（<code>+=</code> 操作），这种方式更符合字符串的内存模型，避免了频繁的拷贝。</li>
<li>最后再调用 <code>reverse</code>，将整体反转，代价是<strong>一次 O(n)</strong> 的操作，比第一种实现中频繁的插入效率高得多。</li>
</ul>
<h4 id="解法一stack"><a class="markdownIt-Anchor" href="#解法一stack"></a> 解法一——stack</h4>
<p>注意size会变</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">char</span>&gt; words;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!words.empty() &amp;&amp; s[i] == words.top()) &#123;</span><br><span class="line">                words.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                words.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> sNew;</span><br><span class="line">        <span class="keyword">int</span> wordsSize = words.size(); <span class="comment">//注意size会变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; wordsSize; j++) &#123;</span><br><span class="line">            sNew = words.top() + sNew; <span class="comment">//在前面加上字母</span></span><br><span class="line">            words.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>貌似每次在前面加字母会带来大量的时间消耗和内存消耗，所以下面那个循环可以改成这个。</p>
<p><img alt="image-20240401144455896" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240401144455896.png" data-index="14" data-src="/2024/03/30/LeetCode-problems/image-20240401144455896.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!words.empty()) &#123;</span><br><span class="line">           sNew += words.top() ; <span class="comment">//在前面加上字母</span></span><br><span class="line">           words.pop();</span><br><span class="line">       &#125;</span><br><span class="line">       reverse(sNew.begin(), sNew.end());</span><br></pre></td></tr></table></figure>
<h4 id="解法二以字符串为栈"><a class="markdownIt-Anchor" href="#解法二以字符串为栈"></a> 解法二——以字符串为栈</h4>
<p>进一步的以字符串为栈,也是比较快的，消耗内存也比较小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> sNew;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sNew.empty() &amp;&amp; s[i] == sNew.back()) &#123;</span><br><span class="line">                sNew.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sNew.push_back(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sNew;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="150-逆波兰表达式求值"><a class="markdownIt-Anchor" href="#150-逆波兰表达式求值"></a> <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h3>
<blockquote>
<p>给你一个字符串数组 <code>tokens</code> ，表示一个根据 <a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" target="_blank" rel="noopener">逆波兰表示法</a> 表示的算术表达式。</p>
<p>请你计算该表达式。返回一个表示表达式值的整数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>有效的算符为 <code>'+'</code>、<code>'-'</code>、<code>'*'</code> 和 <code>'/'</code> 。</li>
<li>每个操作数（运算对象）都可以是一个整数或者另一个表达式。</li>
<li>两个整数之间的除法总是 <strong>向零截断</strong> 。</li>
<li>表达式中不含除零运算。</li>
<li>输入是一个根据逆波兰表示法表示的算术表达式。</li>
<li>答案及所有中间计算结果可以用 <strong>32 位</strong> 整数表示。</li>
</ul>
</blockquote>
<p>用栈来解决</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">int</span> result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> token:tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">"+"</span> ) &#123;</span><br><span class="line">                result = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                result = nums.top() + result;</span><br><span class="line">                nums.pop();</span><br><span class="line">                nums.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"-"</span>) &#123;</span><br><span class="line">                result = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                result = nums.top() - result;</span><br><span class="line">                nums.pop();</span><br><span class="line">                nums.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"*"</span>) &#123;</span><br><span class="line">                result = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                result = nums.top() * result;</span><br><span class="line">                nums.pop();</span><br><span class="line">                nums.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">"/"</span>) &#123;</span><br><span class="line">                result = nums.top();</span><br><span class="line">                nums.pop();</span><br><span class="line">                result = nums.top() / result;</span><br><span class="line">                nums.pop();</span><br><span class="line">                nums.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 数字</span></span><br><span class="line">                nums.push(stoi(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="239-滑动窗口最大值"><a class="markdownIt-Anchor" href="#239-滑动窗口最大值"></a> <a href="https://leetcode.cn/problems/sliding-window-maximum/" target="_blank" rel="noopener">239. 滑动窗口最大值</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回 <em>滑动窗口中的最大值</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
</blockquote>
<p>单调队列问题</p>
<p><strong>只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p>
<p>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列</strong></p>
<p>设计单调队列的时候，pop，和push操作要保持如下规则：</p>
<ol>
<li>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</li>
<li>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止</li>
</ol>
<p><strong>在单调队列中，我们维护的是非严格单调序列</strong>（即<strong>非递增</strong>或<strong>非递减</strong>），确保<strong>重复值不会一次性全部被移除</strong>。具体来说，每次只会移除队列中的一部分元素，而不会影响同一值的其他副本。同时每次pop时候只会pop比较最前面的元素，不会对重复值造成影响</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.size();</span><br><span class="line">        <span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; window; <span class="comment">//这个双向队列里面存的是索引，而非数字本身，防止有重复，被误pop（？）</span></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">            <span class="comment">// push操作①： 如果该值比之前的大，那么就pop掉之前的直到剩下比它大的,确保队列递减</span></span><br><span class="line">            <span class="keyword">while</span> (!window.empty() &amp;&amp; nums[i] &gt; nums[window.back()]) &#123;</span><br><span class="line">                window.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            window.push_back(i); <span class="comment">//push操作②：此时队列中剩下的只有比它大的，且在队头 </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将之前的序号pop</span></span><br><span class="line">            <span class="keyword">if</span> (!window.empty() &amp;&amp; window.front() &lt; i - k + <span class="number">1</span>) &#123;</span><br><span class="line">                window.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出当前窗口的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                output.push_back(nums[window.front()]);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###　<a href="https://leetcode.cn/problems/top-k-frequent-elements/" target="_blank" rel="noopener">347. 前 K 个高频元素</a></p>
<blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>
</blockquote>
<h4 id="解法一对map的值进行排序"><a class="markdownIt-Anchor" href="#解法一对map的值进行排序"></a> 解法一——对map的值进行排序</h4>
<p>注意力扣不能直接用cmp，得包装一层结构体，同时要将map转化为vector组才能排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;x, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numsMap; <span class="comment">//无序即可，后续要排序</span></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output(k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            numsMap[num] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        cmp cp;</span><br><span class="line">        <span class="built_in">vector</span> &lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; numsMap_vector(numsMap.begin(), numsMap.end());</span><br><span class="line">        sort(numsMap_vector.begin(), numsMap_vector.end(), cp);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// output序号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = numsMap_vector.begin(); p &lt; numsMap_vector.begin() + k; p++) &#123;</span><br><span class="line">            output[i++] = p-&gt;first; <span class="comment">//这一这里p是一个指针</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二优先级序列"><a class="markdownIt-Anchor" href="#解法二优先级序列"></a> 解法二——优先级序列</h4>
<p>要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。建立一个小顶堆，然后遍历「出现次数数组」：</p>
<ul>
<li>如果堆的元素个数小于 <em>k</em>，就可以直接插入堆中。</li>
<li>如果堆的元素个数等于 <em>k</em>，则检查堆顶与当前出现次数的大小。如果堆顶更大，说明至少有 <em>k</em> 个数字的出现次数比当前值大，故舍弃当前值；否则，就弹出堆顶，并将当前值插入堆中。</li>
<li><strong>堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。</strong> 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。</li>
</ul>
<p>优先级队列的基本操作与普通队列类似，不同的是<strong>每次获得队内的元素是优先级最高的元素（要从堆的顶部开始）</strong>，因此<strong>使用的是top()方法</strong>，而不是front()方法。如下：</p>
<ol>
<li><strong>push() ：入队</strong>。向队列添加一个元素，无返回值；</li>
<li><strong>pop() ：将队列中优先级最高的元素出队</strong>。将队列中优先级最高的元素删除（出队），无返回值；</li>
<li><strong>top() ：获得队列优先级最高的元素</strong>。此函数返回值为队列中优先级最高的元素，常与pop()函数一起，先通过top()获得队列中优先级最高的元素，然后将其从队列中删除；</li>
<li><strong>size() ：获得队列大小</strong>。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名。</li>
<li><strong>empty() ：判断队列是否为空</strong>。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false。</li>
</ol>
<p>——<a href="https://blog.csdn.net/jay_zzs/article/details/106549621" target="_blank" rel="noopener">C++——优先级队列（priority_queue）_c++优先队列-CSDN博客</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp_greater</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;x, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &gt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp_less</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;x, pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x.second &lt; y.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; numsMap;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            numsMap[num] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// // 建立优先级序列（用小顶堆, 大于当前节点的要下沉，大小为k）</span></span><br><span class="line">        <span class="comment">// priority_queue &lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, cmp_greater&gt; pri_que; </span></span><br><span class="line">        <span class="comment">// // 扫描所有频率值</span></span><br><span class="line">        <span class="comment">// for (auto p = numsMap.begin(); p != numsMap.end(); p++) &#123;</span></span><br><span class="line">        <span class="comment">//     pri_que.push(*p);</span></span><br><span class="line">        <span class="comment">//     if (pri_que.size() &gt; k) &#123;</span></span><br><span class="line">        <span class="comment">//         pri_que.pop();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立优先级序列（用大顶堆, 小于当前节点的要下沉，大小不限制）</span></span><br><span class="line">        priority_queue &lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, cmp_less&gt; pri_que; </span><br><span class="line">        <span class="comment">// 扫描所有频率值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = numsMap.begin(); p != numsMap.end(); p++) &#123;</span><br><span class="line">            pri_que.push(*p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以按照任意顺序输出， 注意优先级序列也没有begin和end</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            output.push_back(pri_que.top().first); <span class="comment">// 取数值</span></span><br><span class="line">            pri_que.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树"><a class="markdownIt-Anchor" href="#二叉树"></a> 二叉树</h2>
<blockquote>
<p>二叉树的种类：</p>
<ul>
<li>满二叉树</li>
<li>完全二叉树</li>
<li>二叉搜索树（二叉排序树）：<strong>二叉搜索树是一个有序树</strong>，左子树（若非空）上所有结点的值均小于它的根结点的值，右子树（若非空）上所有结点的值均大于它的根结点的值，左右子树也分别为二叉排序树。</li>
<li>平衡二叉搜索树[AVL（Adelson-Velsky and Landis）树]：它是一棵空树或它的左右两个子树的高度（深度）差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
<ul>
<li><strong>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树</strong>，所以map、set的增删操作时间时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​</li>
<li>红黑树就是一种二叉平衡搜索树</li>
</ul>
</li>
<li>辨析
<ol>
<li>平衡二叉搜索树是不是二叉搜索树和平衡二叉树的结合？——是的，是二叉搜索树和平衡二叉树的结合。</li>
<li>平衡二叉树与完全二叉树的区别在于底层节点的位置？——是的，完全二叉树底层必须是从左到右连续的，且次底层是满的。</li>
<li>堆是完全二叉树和排序的结合，而不是平衡二叉搜索树？——堆是一棵完全二叉树，同时保证父子节点的顺序关系（有序）。 <strong>但完全二叉树一定是平衡二叉树，堆的排序是父节点大于子节点，而搜索树是父节点大于左孩子，小于右孩子，所以堆不是平衡二叉搜索树</strong>。</li>
</ol>
</li>
</ul>
<p>二叉树的遍历：</p>
<ul>
<li>深度优先遍历
<ul>
<li>前序遍历DLR（递归法，迭代法）</li>
<li>中序遍历LDR（递归法，迭代法）</li>
<li>后序遍历LRD（递归法，迭代法）</li>
</ul>
</li>
<li>广度优先遍历
<ul>
<li>层次遍历（迭代法）</li>
</ul>
</li>
</ul>
<p>二叉树的定义：</p>
<ul>
<li>
<p>C++：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>C：——《数据结构与算法/软件技术基础》周大为版</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; bitree;</span><br><span class="line">bitree *root; <span class="comment">//root指向根节点指针</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<img alt="二叉树大纲" style="zoom:50%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210219190809451.png" data-index="15" data-src="/2024/03/30/LeetCode-problems/20210219190809451.png">
<p>——代码随想录</p>
</blockquote>
<h3 id="二叉树的深度优先dfs遍历144前序145后序94中序"><a class="markdownIt-Anchor" href="#二叉树的深度优先dfs遍历144前序145后序94中序"></a> 二叉树的深度优先DFS遍历（<a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144前序</a>/<a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145后序</a>/<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94中序</a>）</h3>
<ul>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">144.二叉树的前序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">145.二叉树的后序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">94.二叉树的中序遍历</a></li>
</ul>
<h4 id="方法一递归"><a class="markdownIt-Anchor" href="#方法一递归"></a> 方法一——递归</h4>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p>前序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span> <span class="params">(TreeNode *p, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            output.push_back(p-&gt;val);</span><br><span class="line">            preorder(p-&gt;left, output);</span><br><span class="line">            preorder(p-&gt;right, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        preorder(root, output);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span> <span class="params">(TreeNode *p, <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            inorder(p-&gt;left, output);</span><br><span class="line">            output.push_back(p-&gt;val);</span><br><span class="line">            inorder(p-&gt;right, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        inorder(root, output);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            postorder(p-&gt;left, output);</span><br><span class="line">            postorder(p-&gt;right, output);</span><br><span class="line">            output.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        postorder(root, output);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法二非递归迭代"><a class="markdownIt-Anchor" href="#方法二非递归迭代"></a> 方法二——非递归迭代</h4>
<p>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。</p>
<p><strong>因为前序遍历中访问节点（遍历节点）和处理节点（将元素放进result数组中）可以同步处理，但是中序就无法做到同步！</strong></p>
<p>前序——先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子</p>
<img alt="二叉树前序遍历（迭代法）" style="zoom:50%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/二叉树前序遍历（迭代法）.gif" data-index="16" data-src="/2024/03/30/LeetCode-problems/二叉树前序遍历（迭代法）.gif">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        S.push(root); <span class="comment">// 放入根节点</span></span><br><span class="line">        <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">            TreeNode *p = S.top();</span><br><span class="line">            output.push_back(p-&gt;val); <span class="comment">//根的值</span></span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">//先压入右子树, 先入栈后出</span></span><br><span class="line">                S.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) &#123; <span class="comment">//后压入左子树</span></span><br><span class="line">                S.push(p-&gt;left);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中序——在遍历左子树之前先把根节点入栈；当左子树遍历完成，根节点出栈，遍历右子树。<strong>借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素</strong>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !S.empty()) &#123; <span class="comment">// 第一个条件是为了第一次能够满足，以能够先押入根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123; <span class="comment">// 指针访问到左边的最底层的</span></span><br><span class="line">                S.push(p);</span><br><span class="line">                p = p-&gt;left; <span class="comment">// 左子树</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// p为空，那么栈里面的就是他的祖先节点（如果目前是右子树的话甚至不一定是父节点），</span></span><br><span class="line">                p = S.top();</span><br><span class="line">                S.pop();</span><br><span class="line">                output.push_back(p-&gt;val); <span class="comment">// 根节点</span></span><br><span class="line">                p = p-&gt;right; <span class="comment">// 右子树</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>后序</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>DLR（先序）</mtext><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>调整左右顺序</mtext></mpadded></mover><mtext>DRL（逆先序）</mtext><mover><mo stretchy="true">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext>reverse</mtext></mpadded></mover><mtext>LRD（后序）</mtext></mrow><annotation encoding="application/x-tex">\text{DLR（先序）} \xrightarrow{\text{调整左右顺序}}\text{DRL（逆先序）}\xrightarrow{\text{reverse}}\text{LRD（后序）}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1113309999999998em;vertical-align:-0.010999999999999899em;"></span><span class="mord text"><span class="mord">DLR</span><span class="mord cjk_fallback">（先序）</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.100331em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">调整左右顺序</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width="400em" height="0.522em" viewbox="0 0 400000 522" preserveaspectratio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.010999999999999899em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.934392em;vertical-align:-0.01100000000000001em;"></span><span class="mord text"><span class="mord">DRL</span><span class="mord cjk_fallback">（逆先序）</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel x-arrow"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.923392em;"><span style="top:-3.322em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight x-arrow-pad"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">reverse</span></span></span></span></span><span class="svg-align" style="top:-2.689em;"><span class="pstrut" style="height:2.7em;"></span><span class="hide-tail" style="height:0.522em;min-width:1.469em;"><svg width="400em" height="0.522em" viewbox="0 0 400000 522" preserveaspectratio="xMaxYMin slice"><path d="M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.01100000000000001em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">LRD</span><span class="mord cjk_fallback">（后序）</span></span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        S.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">            TreeNode *p = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            output.push_back(p-&gt;val); <span class="comment">// 压入根节点</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                S.push(p-&gt;left); <span class="comment">//压入左节点，后出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                S.push(p-&gt;right); <span class="comment">//压入右节点，先出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(output.begin(), output.end());</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="方法三二叉树的统一迭代法"><a class="markdownIt-Anchor" href="#方法三二叉树的统一迭代法"></a> 方法三——<a href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html#%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">二叉树的统一迭代法</a></h4>
<p>将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。</p>
<p>如何标记呢，<strong>就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p>
<h3 id="二叉树的层序广度优先bfs遍历102107199637429515116117"><a class="markdownIt-Anchor" href="#二叉树的层序广度优先bfs遍历102107199637429515116117"></a> 二叉树的层序（广度优先）BFS遍历（<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102</a>/<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107</a>/<a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199</a>/<a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637</a>/<a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429</a>/<a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515</a>/<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116</a>/<a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117</a>）</h3>
<h4 id="102二叉树的层序遍历"><a class="markdownIt-Anchor" href="#102二叉树的层序遍历"></a> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">102.二叉树的层序遍历</a></h4>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p>
</blockquote>
<p>基本思想：在上层先被访问的节点，他的下层孩子在该层也会被先访问到。因此使用<strong>队列</strong>，当一个元素出队，他的孩子将会进入队列。</p>
<p>力扣的题目返回的是二维数组，需要对层也包裹一层，所以需要定义<code>qSize</code>来确定每层的大小，将每层的遍历结果输出到<code>output</code>中。</p>
<h5 id="解法一非递归迭代"><a class="markdownIt-Anchor" href="#解法一非递归迭代"></a> 解法一——非递归迭代</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size(); <span class="comment">// 为了返回二维数组，需要知道每层有多少个</span></span><br><span class="line">            <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; outputLayer;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front(); </span><br><span class="line">                outputLayer.push_back(p-&gt;val); <span class="comment">//根节点出队</span></span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left); <span class="comment">//push左孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right); <span class="comment">//push右孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(outputLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="解法二递归"><a class="markdownIt-Anchor" href="#解法二递归"></a> 解法二——递归</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelorderTraversal</span> <span class="params">(TreeNode *p, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;output, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">//空指针返回父节点。为什么不把判定条件放在访问孩子前呢？因为无法判断是否为空树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (output.size() == depth) &#123;</span><br><span class="line">            output.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;()); <span class="comment">//当前层还没有加入过，创建对应层的数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        output[depth].push_back(p-&gt;val);</span><br><span class="line">        <span class="comment">// 访问孩子，在孩子对应层的vector尾部加入</span></span><br><span class="line">        levelorderTraversal(p-&gt;left, output, depth+<span class="number">1</span>);</span><br><span class="line">        levelorderTraversal(p-&gt;right, output, depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        levelorderTraversal(root, output, depth);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="107二叉树的层次遍历ii"><a class="markdownIt-Anchor" href="#107二叉树的层次遍历ii"></a> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">107.二叉树的层次遍历II</a></h4>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回其节点值 <strong>自底向上的层序遍历</strong> 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
</blockquote>
<p>对102的正向层次遍历reverse。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrderBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; outputLayer;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                outputLayer.push_back(Q.front()-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;left) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;right) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(outputLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(output.begin(),output.end());</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="199二叉树的右视图"><a class="markdownIt-Anchor" href="#199二叉树的右视图"></a> <a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199.二叉树的右视图</a></h4>
<blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<p>每层层次遍历的最后一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == qSize - <span class="number">1</span>) &#123;<span class="comment">// 每层的最后一个元素需要保存值</span></span><br><span class="line">                    output.push_back(Q.front()-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;left) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;right) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="637二叉树的层平均值"><a class="markdownIt-Anchor" href="#637二叉树的层平均值"></a> <a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637.二叉树的层平均值</a></h4>
<blockquote>
<p>给定一个非空二叉树的根节点 <code>root</code> , 以数组的形式返回每一层节点的平均值。与实际答案相差 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>以内的答案可以被接受。</p>
</blockquote>
<p>注意与答案相差<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span>以内的答案，所以要用double了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; output;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">double</span> sumLayer = <span class="number">0.0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                sumLayer += Q.front()-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;left) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Q.front()-&gt;right) &#123;</span><br><span class="line">                    Q.push(Q.front()-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(sumLayer/qSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="429n叉树的层序遍历"><a class="markdownIt-Anchor" href="#429n叉树的层序遍历"></a> <a href="https://leetcode.cn/problems/n-ary-tree-level-order-traversal/" target="_blank" rel="noopener">429.N叉树的层序遍历</a></h4>
<blockquote>
<p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p>
<p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">levelOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="built_in">queue</span> &lt;Node*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; outputLayer;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                Node* p = Q.front();</span><br><span class="line">                outputLayer.push_back(p-&gt;val);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;children.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;children[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        Q.push(p-&gt;children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(outputLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="515在每个树行中找最大值"><a class="markdownIt-Anchor" href="#515在每个树行中找最大值"></a> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/" target="_blank" rel="noopener">515.在每个树行中找最大值</a></h4>
<blockquote>
<p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p>
</blockquote>
<p>注意可能有负数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size(); </span><br><span class="line">            <span class="keyword">int</span> maxLayer = INT_MIN; <span class="comment">//注意有负数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front(); </span><br><span class="line">                <span class="keyword">if</span> (p-&gt;val &gt; maxLayer) &#123;</span><br><span class="line">                    maxLayer = p-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left); <span class="comment">//push左孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right); <span class="comment">//push右孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output.push_back(maxLayer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="116填充每个节点的下一个右侧节点指针"><a class="markdownIt-Anchor" href="#116填充每个节点的下一个右侧节点指针"></a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116.填充每个节点的下一个右侧节点指针</a></h4>
<blockquote>
<p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;Node*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                Node *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i != qSize - <span class="number">1</span>) &#123;</span><br><span class="line">                    p-&gt;next = Q.front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="117填充每个节点的下一个右侧节点指针ii"><a class="markdownIt-Anchor" href="#117填充每个节点的下一个右侧节点指针ii"></a> <a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117.填充每个节点的下一个右侧节点指针II</a></h4>
<blockquote>
<p>给定一个二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code> 。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code> 。</p>
</blockquote>
<p>代码同116</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;Node*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                Node *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i != qSize - <span class="number">1</span>) &#123;</span><br><span class="line">                    p-&gt;next = Q.front();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另见</p>
<ul>
<li><a href="#%5B104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%5D(https://leetcode.cn/problems/maximum-depth-of-binary-tree/)">104.二叉树的最大深度</a></li>
<li><a href="#%5B111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%5D(https://leetcode.cn/problems/minimum-depth-of-binary-tree/)">111.二叉树的最小深度</a></li>
</ul>
<h3 id="226-翻转二叉树"><a class="markdownIt-Anchor" href="#226-翻转二叉树"></a> <a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener">226. 翻转二叉树</a></h3>
<blockquote>
<p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<h4 id="解法一递归"><a class="markdownIt-Anchor" href="#解法一递归"></a> 解法一——递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* temp;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = root-&gt;left;</span><br><span class="line">            root-&gt;left = root-&gt;right;</span><br><span class="line">            root-&gt;right = temp;</span><br><span class="line">            invertTree(root-&gt;left);</span><br><span class="line">            invertTree(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二迭代深度优先"><a class="markdownIt-Anchor" href="#解法二迭代深度优先"></a> 解法二——迭代（深度优先）</h4>
<p>DLR</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        S.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">            TreeNode *p = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            swap(p-&gt;left, p-&gt;right); <span class="comment">//就这一步不一样</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                S.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                S.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三迭代广度优先"><a class="markdownIt-Anchor" href="#解法三迭代广度优先"></a> 解法三——迭代（广度优先）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                swap(p-&gt;left, p-&gt;right); <span class="comment">//就这一步不一样</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="101-对称二叉树"><a class="markdownIt-Anchor" href="#101-对称二叉树"></a> <a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener">101. 对称二叉树</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
</blockquote>
<p>把NULL存进去的层序遍历。，遍历每一层时候，前半段用stack存进去，后半段pop对比。一个很垃圾的逻辑，一定程度上<code>NULL==0</code>，所以这里使用了非常丑陋的<code>76777777</code>来表示这个位置是NULL。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flagSymmetric = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flagNULL = <span class="literal">false</span>; <span class="comment">// 判断下层是否全空</span></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty() &amp;&amp; flagSymmetric &amp;&amp; !flagNULL) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">            flagNULL = <span class="literal">true</span>; <span class="comment">// 判断下层是否全空</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; qSize &lt;&lt; " ";</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i &lt; qSize / <span class="number">2</span> || depth == <span class="number">0</span>) &#123; <span class="comment">// 第二个条件为了第一层，防止没有东西可pop</span></span><br><span class="line">                    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        S.push(<span class="number">76777777</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        S.push(p-&gt;val);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (S.top() != <span class="number">76777777</span>) &#123;</span><br><span class="line">                        flagSymmetric = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    S.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (S.top() != p-&gt;val) &#123; <span class="comment">// 大于一半，且top和目前的val不等，那么不对称</span></span><br><span class="line">                    flagSymmetric = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//大于一半，且目前还对称</span></span><br><span class="line">                    S.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将孩子加入队列，由于要对称，不需要考虑NULL的情况</span></span><br><span class="line">                <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;left || p-&gt;right)&#123; <span class="comment">//只要有一个不为0，下一层就不会全空</span></span><br><span class="line">                        flagNULL = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flagSymmetric;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法一递归法"><a class="markdownIt-Anchor" href="#解法一递归法"></a> 解法一——递归法</h4>
<p>总体思路就是左子树的左边要和右子树的右边相等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkSymmetric</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123; <span class="comment">// 都空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123; <span class="comment">//有一个空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123; <span class="comment">// 非空且不等</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左子树的左和右子树的右 &amp;&amp; 左子树的右和右子树的左</span></span><br><span class="line">        <span class="keyword">return</span> checkSymmetric(p-&gt;left, q-&gt;right) &amp;&amp; checkSymmetric(p-&gt;right, q-&gt;left) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkSymmetric(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二迭代法"><a class="markdownIt-Anchor" href="#解法二迭代法"></a> 解法二——迭代法</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        Q.push(root-&gt;left);</span><br><span class="line">        Q.push(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            TreeNode *p = Q.front(); <span class="comment">// 左子树</span></span><br><span class="line">            Q.pop();</span><br><span class="line">            TreeNode *q = Q.front(); <span class="comment">// 右子树</span></span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span> &amp;&amp; q == <span class="literal">NULL</span>) &#123; <span class="comment">//都空</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)  &#123; <span class="comment">//有一个空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.push(p-&gt;left); <span class="comment">//左子树左</span></span><br><span class="line">            Q.push(q-&gt;right); <span class="comment">//右子树右</span></span><br><span class="line">            Q.push(p-&gt;right); <span class="comment">//左子树右</span></span><br><span class="line">            Q.push(q-&gt;left); <span class="comment">//右子树左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这两道题目基本和本题是一样的，只要稍加修改就可以AC。</p>
<h4 id="100相同的树"><a class="markdownIt-Anchor" href="#100相同的树"></a> <a href="https://leetcode.cn/problems/same-tree/" target="_blank" rel="noopener">100.相同的树</a></h4>
<blockquote>
<p>给你两棵二叉树的根节点 <code>p</code> 和 <code>q</code> ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="572另一个树的子树"><a class="markdownIt-Anchor" href="#572另一个树的子树"></a> <a href="https://leetcode.cn/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572.另一个树的子树</a></h4>
<blockquote>
<p>给你两棵二叉树 <code>root</code> 和 <code>subRoot</code> 。检验 <code>root</code> 中是否包含和 <code>subRoot</code> 具有相同结构和节点值的子树。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>二叉树 <code>tree</code> 的一棵子树包括 <code>tree</code> 的某个节点和这个节点的所有后代节点。<code>tree</code> 也可以看做它自身的一棵子树。</p>
</blockquote>
<p>先进行层次遍历，遍历到相同的节点值时候，开始比较是否是同一棵树</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSametree</span> <span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p || !q || p-&gt;val != q-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isSametree(p-&gt;left, q-&gt;left) &amp;&amp; isSametree(p-&gt;right, q-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* root, TreeNode* subRoot)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先进行层次遍历，遍历到相同的节点值时候，开始比较是否是同一棵树</span></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">bool</span> flagSubtree = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root &amp;&amp; subRoot) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() &amp;&amp; !flagSubtree) &#123;</span><br><span class="line">            TreeNode *p = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == subRoot-&gt;val) &#123;</span><br><span class="line">                flagSubtree = isSametree(p, subRoot);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; p-&gt;val &lt;&lt; " ";</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                Q.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                Q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flagSubtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三种官方题解：</p>
<ul>
<li>方法一：深度优先搜索暴力匹配</li>
<li>方法二：深度优先搜索序列上做串匹配</li>
<li>方法三：树哈希</li>
</ul>
<h3 id="104二叉树的最大深度"><a class="markdownIt-Anchor" href="#104二叉树的最大深度"></a> <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">104.二叉树的最大深度</a></h3>
<blockquote>
<p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p>
<p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<h4 id="递归求解深度优先遍历"><a class="markdownIt-Anchor" href="#递归求解深度优先遍历"></a> 递归求解——深度优先遍历</h4>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mtext>height</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\text{height})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord text"><span class="mord">height</span></span><span class="mclose">)</span></span></span></span>，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>
<p>——力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果根节点为空，则深度为0</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> leftDepth = maxDepth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = maxDepth(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回左右子树深度的最大值加上根节点本身的深度1</span></span><br><span class="line">        <span class="keyword">return</span> max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归迭代广度优先遍历"><a class="markdownIt-Anchor" href="#非递归迭代广度优先遍历"></a> 非递归迭代——广度优先遍历</h4>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，其中 <em>n</em> 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。</li>
<li>空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>​。</li>
</ul>
<p>——力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="559-n-叉树的最大深度"><a class="markdownIt-Anchor" href="#559-n-叉树的最大深度"></a> <a href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" target="_blank" rel="noopener">559. N 叉树的最大深度</a></h4>
<blockquote>
<p>给定一个 N 叉树，找到其最大深度。</p>
<p>最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</p>
<p>N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。</p>
</blockquote>
<h5 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;children.size(); i++) &#123;</span><br><span class="line">            depth = max(depth, maxDepth(root-&gt;children[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="迭代"><a class="markdownIt-Anchor" href="#迭代"></a> 迭代</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;Node*&gt; Q;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)&#123;</span><br><span class="line">                Node* p = Q.front() ;</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p-&gt;children.size(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;children[j]) &#123;</span><br><span class="line">                        Q.push(p-&gt;children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="111二叉树的最小深度"><a class="markdownIt-Anchor" href="#111二叉树的最小深度"></a> <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111.二叉树的最小深度</a></h3>
<blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>
<p>**说明：**叶子节点是指没有子节点的节点。</p>
</blockquote>
<p>注意要考虑一条路到底的情况，即存在单边树的情况。左右孩子都为空的节点才是叶子节点！</p>
<img alt="image-20240402191845973" style="zoom: 80%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240402191845973.png" data-index="17" data-src="/2024/03/30/LeetCode-problems/image-20240402191845973.png">
<h4 id="非递归迭代广度优先遍历-2"><a class="markdownIt-Anchor" href="#非递归迭代广度优先遍历-2"></a> 非递归迭代——广度优先遍历</h4>
<p>注意判断左右为空的时候是“且”，而非“或” <strong>只有当左右孩子都为空的时候，才说明遍历到最低点了。如果其中一个孩子不为空则不是最低点</strong></p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 是树的节点数。对每个节点访问一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</p>
<p>——力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() &amp;&amp; flag) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left == <span class="literal">NULL</span> &amp;&amp; p-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">//注意这里是且而非或</span></span><br><span class="line">                    flag = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        Q.push(p-&gt;right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Q.push(p-&gt;right); <span class="comment">// flag为真时，left为空，right必然不为空，不为真时Q无意义</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归深度优先遍历"><a class="markdownIt-Anchor" href="#递归深度优先遍历"></a> 递归——深度优先遍历</h4>
<p>必须要考虑单边树不存在的问题——需要分别考虑根节点左右孩子</p>
<p>时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span>是树的节点数。对每个节点访问一次。</p>
<p>空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>H</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(H)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi></mrow><annotation encoding="application/x-tex">H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span></span></span></span> 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。平均情况下树的高度与节点数的对数正相关，空间复杂度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span>。</p>
<p>——力扣官方题解</p>
<p>遍历的顺序为后序（左右中）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 必须要考虑单边树不存在的问题——需要分别考虑根节点左右孩子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> minDepth(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(minDepth(root-&gt;left),minDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="222-完全二叉树的节点个数"><a class="markdownIt-Anchor" href="#222-完全二叉树的节点个数"></a> <a href="https://leetcode.cn/problems/count-complete-tree-nodes/" target="_blank" rel="noopener">222. 完全二叉树的节点个数</a></h3>
<blockquote>
<p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin" target="_blank" rel="noopener">完全二叉树</a> 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层，则该层包含 <code>1~ 2h</code> 个节点。</p>
</blockquote>
<h4 id="解法一层次遍历"><a class="markdownIt-Anchor" href="#解法一层次遍历"></a> 解法一——层次遍历</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">bool</span> flagEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">            nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() &amp;&amp; !flagEnd) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++) &#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                    nums++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flagEnd = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                    nums++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    flagEnd = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二完全二叉树二分法"><a class="markdownIt-Anchor" href="#解法二完全二叉树二分法"></a> 解法二——完全二叉树+二分法</h4>
<p>这个思路有个问题，二分法的判断标准是大了，小了，这里的判断是是否为NULL。</p>
<p>通过每一次二分查找可以从上到下确定一层是往左走还是往右走。for循环包含depth次，每一次当前层指向right，下面的层都指向left，如果有值，那么该层应该指向right，为NULL则该层指向left，在进行下一层。当指向right的时候得注意nums要增加多少，<strong>我感觉我现在就在凑</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先找出二叉树的最大深度</span></span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">            depth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">bool</span>&gt; direction(depth); <span class="comment">//每一次指向的方向，右为0，左为1。</span></span><br><span class="line">        <span class="keyword">int</span> nums = <span class="built_in">pow</span>(<span class="number">2</span>, depth - <span class="number">1</span>) - <span class="number">1</span>;<span class="comment">//前(depth-1)层</span></span><br><span class="line">        <span class="comment">// 二分查找最后一层的最后一个顶点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth - <span class="number">1</span>; i++) &#123; <span class="comment">//depth次才能判断每次向左向右</span></span><br><span class="line">            TreeNode *p = root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123; <span class="comment">// 前i层已经确定方向</span></span><br><span class="line">                <span class="keyword">if</span> (direction[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    p = p-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; depth - <span class="number">1</span>; k++) &#123; <span class="comment">//后面的层往左</span></span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//为NULL，该层指向left</span></span><br><span class="line">                direction[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// cout &lt;&lt;  " NULL ";</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//指向right</span></span><br><span class="line">                nums += <span class="built_in">pow</span>(<span class="number">2</span>, depth - i - <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; p-&gt;val &lt;&lt; " ";</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// for (int i = 0 ;i &lt; depth-1; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; direction[i] &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> nums + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>原来官方题解也是这个办法啊，一定分析的比我好。。。</p>
<p>具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数 kkk，如果第 kkk 个节点存在，则节点个数一定大于或等于 kkk，如果第 kkk 个节点不存在，则节点个数一定小于 kkk，由此可以将查找的范围缩小一半，直到得到节点个数。</p>
<p>如何判断第 kkk 个节点是否存在呢？如果第 kkk 个节点位于第 hhh 层，则 kkk 的二进制表示包含 h+1h+1h+1 位，其中最高位是 111，其余各位从高到低表示从根节点到第 kkk 个节点的路径，000 表示移动到左子节点，111 表示移动到右子节点。通过位运算得到第 kkk 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 kkk 个节点是否存在。</p>
<p>——力扣官方题解</p>
<p><img alt="fig1" class="post-img b-lazy" data-img="https://assets.leetcode-cn.com/solution-static/222/1.png" data-index="18" data-src="https://assets.leetcode-cn.com/solution-static/222/1.png"></p>
<h4 id="完全二叉树的性质"><a class="markdownIt-Anchor" href="#完全二叉树的性质"></a> 完全二叉树的性质</h4>
<p>完全二叉树总能拆分成许多的满二叉树。</p>
<img alt="222.完全二叉树的节点个数1" style="zoom: 67%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20201124092634138.png" data-index="19" data-src="/2024/03/30/LeetCode-problems/20201124092634138.png">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *p = root-&gt;left;</span><br><span class="line">        TreeNode *q = root-&gt;right;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">            leftDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q = q-&gt;right;</span><br><span class="line">            rightDepth++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123; <span class="comment">//满二叉树</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftDepth) - <span class="number">1</span>; <span class="comment">//位运算，移位运算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> countNodes(root-&gt;left) + countNodes(root-&gt;right) + <span class="number">1</span>; <span class="comment">// 加上根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="110-平衡二叉树"><a class="markdownIt-Anchor" href="#110-平衡二叉树"></a> <a href="https://leetcode.cn/problems/balanced-binary-tree/" target="_blank" rel="noopener">110. 平衡二叉树</a></h3>
<blockquote>
<p>给定一个二叉树，判断它是否是 平衡二叉树</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。</p>
</blockquote>
<h4 id="自顶向下的递归"><a class="markdownIt-Anchor" href="#自顶向下的递归"></a> 自顶向下的递归</h4>
<p>首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span> <span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> max(height(p-&gt;left), height(p-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(height(root-&gt;left) - height(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="自底向上的递归"><a class="markdownIt-Anchor" href="#自底向上的递归"></a> 自底向上的递归</h4>
<p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span> <span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = height(p-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = height(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span> || <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(height(p-&gt;left), height(p-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (height(root) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="257-二叉树的所有路径"><a class="markdownIt-Anchor" href="#257-二叉树的所有路径"></a> <a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
</blockquote>
<p>注意要回溯！！！所以要把之前的节点值存起来</p>
<p><img alt="257.二叉树的所有路径" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210204151702443.png" data-index="20" data-src="/2024/03/30/LeetCode-problems/20210204151702443.png"></p>
<h4 id="解法一递归使用栈"><a class="markdownIt-Anchor" href="#解法一递归使用栈"></a> 解法一——递归+使用栈</h4>
<p>函数参数我就使用了引用，即 <code>vector&lt;int&gt;&amp; path</code> ，这是会拷贝地址的，所以 本层递归逻辑如果有<code>path.push_back(cur-&gt;val);</code> 就一定要有对应的 <code>path.pop_back()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *p, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;path,<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right)&#123; <span class="comment">//左右为空，终止，记录path</span></span><br><span class="line">            <span class="built_in">string</span> s;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path.size(); i++)&#123;</span><br><span class="line">                s += to_string(path[i]);</span><br><span class="line">                s += <span class="string">"-&gt;"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s += to_string(p-&gt;val);</span><br><span class="line">            output.push_back(s);</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            path.push_back(p-&gt;val);</span><br><span class="line">            preorder(p-&gt;left, path, output);</span><br><span class="line">            path.pop_back();<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            path.push_back(p-&gt;val);</span><br><span class="line">            preorder(p-&gt;right, path, output);</span><br><span class="line">            path.pop_back();<span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        preorder(root, path, output);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二递归使用字符串隐式回溯"><a class="markdownIt-Anchor" href="#解法二递归使用字符串隐式回溯"></a> 解法二——递归+使用字符串+隐式回溯</h4>
<p>注意path是不变的，隐式回溯了。</p>
<p>使用的是 <code>string path</code>，这里并没有加上引用<code>&amp;</code> ，即本层递归中，path + 该节点数值，但该层递归结束，上一层path的数值并不会受到任何影响。 如图所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *p, <span class="built_in">string</span> path,<span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; &amp;output)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right)&#123; <span class="comment">//左右为空，终止，记录path</span></span><br><span class="line">            output.push_back(path + to_string(p-&gt;val));</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            preorder(p-&gt;left, path + to_string(p-&gt;val) + <span class="string">"-&gt;"</span>, output); <span class="comment">//注意path是不变的，隐式回溯了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            preorder(p-&gt;right, path + to_string(p-&gt;val) + <span class="string">"-&gt;"</span>, output);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> path;</span><br><span class="line">        preorder(root, path, output);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三迭代"><a class="markdownIt-Anchor" href="#解法三迭代"></a> 解法三——迭代</h4>
<p>使用两个栈，一个存节点，一个存路径。因为路径拼接不易，所以直接存入整体路径。为了防止路径的top被污染，所以和取S的栈顶工作节点p一样，也把路径pathS先取出来，方便后续进一步使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="built_in">string</span>&gt; path; <span class="comment">// 存放路径</span></span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S; <span class="comment">// 前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            S.push(root);</span><br><span class="line">            path.push (to_string(root-&gt;val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!S.empty()) &#123;</span><br><span class="line">            TreeNode *p = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="built_in">string</span> pathS = path.top(); <span class="comment">//取出路径防止后续拼接时候多拼接一部分</span></span><br><span class="line">            path.pop();</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right) &#123;</span><br><span class="line">                output.push_back(pathS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right)&#123;</span><br><span class="line">                S.push(p-&gt;right);</span><br><span class="line">                path.push(pathS + <span class="string">"-&gt;"</span> + to_string(p-&gt;right-&gt;val)); <span class="comment">//考虑到stack出来拼接不方便，把存进去的时候直接把之前的也拼上</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left)&#123;</span><br><span class="line">                S.push(p-&gt;left);</span><br><span class="line">                path.push(pathS + <span class="string">"-&gt;"</span> + to_string(p-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="404-左叶子之和"><a class="markdownIt-Anchor" href="#404-左叶子之和"></a> <a href="https://leetcode.cn/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. 左叶子之和</a></h3>
<blockquote>
<p>给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p>
</blockquote>
<p>注意是左叶子，不是左节点。</p>
<h4 id="解法一层次遍历bfs"><a class="markdownIt-Anchor" href="#解法一层次遍历bfs"></a> 解法一——层次遍历BFS</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Q.push(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)&#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left)&#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span> (!p-&gt;left-&gt;left &amp;&amp; !p-&gt;left-&gt;right)&#123;</span><br><span class="line">                        leftSum += p-&gt;left-&gt;val;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二深度优先dfs"><a class="markdownIt-Anchor" href="#解法二深度优先dfs"></a> 解法二——深度优先DFS</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">preorder</span> <span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;left-&gt;left &amp;&amp; !p-&gt;left-&gt;right) &#123;</span><br><span class="line">                ans += p-&gt;left-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += preorder(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            ans += preorder(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="513-找树左下角的值"><a class="markdownIt-Anchor" href="#513-找树左下角的值"></a> <a href="https://leetcode.cn/problems/find-bottom-left-tree-value/" target="_blank" rel="noopener">513. 找树左下角的值</a></h3>
<blockquote>
<p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
</blockquote>
<h4 id="解法一bfsflag"><a class="markdownIt-Anchor" href="#解法一bfsflag"></a> 解法一——BFS+flag</h4>
<p>欸，我傻了，这个flag一点用也没有啊。删了也一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> bottomLeftValue = root-&gt;val;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">bool</span> flagNULL = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() &amp;&amp; !flagNULL)&#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            flagNULL = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qSize; i++)&#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>)&#123;</span><br><span class="line">                    bottomLeftValue = p-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left)&#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                    flagNULL = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                    flagNULL = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bottomLeftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二bfs左右节点相反"><a class="markdownIt-Anchor" href="#解法二bfs左右节点相反"></a> 解法二——BFS，左右节点相反</h4>
<p>在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> bottomLeftValue = root-&gt;val;</span><br><span class="line">        Q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty() )&#123;</span><br><span class="line">                TreeNode *p = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right)&#123;</span><br><span class="line">                    Q.push(p-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    Q.push(p-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                bottomLeftValue = p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bottomLeftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="dfs"><a class="markdownIt-Anchor" href="#dfs"></a> DFS</h4>
<p>太难了，绕不清</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preorder</span> <span class="params">(TreeNode *p, <span class="keyword">int</span> depth, <span class="keyword">int</span> &amp;bottomLeftValue, <span class="keyword">int</span> &amp;maxDepth)</span></span>&#123; <span class="comment">// DLR最先遍历到的就是最左节点</span></span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)&#123; <span class="comment">//全空</span></span><br><span class="line">            <span class="keyword">if</span> (depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                bottomLeftValue = p-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            preorder(p-&gt;left, depth + <span class="number">1</span>, bottomLeftValue, maxDepth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            preorder(p-&gt;right, depth + <span class="number">1</span>, bottomLeftValue, maxDepth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottomLeftValue = <span class="number">0</span>;</span><br><span class="line">        preorder(root, depth + <span class="number">1</span>, bottomLeftValue, maxDepth);</span><br><span class="line">        <span class="keyword">return</span> bottomLeftValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="路径总和112113"><a class="markdownIt-Anchor" href="#路径总和112113"></a> 路径总和（<a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener">112</a>/<a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener">113</a>）</h3>
<h4 id="112-路径总和"><a class="markdownIt-Anchor" href="#112-路径总和"></a> <a href="https://leetcode.cn/problems/path-sum/" target="_blank" rel="noopener">112. 路径总和</a></h4>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
</blockquote>
<h5 id="迭代-2"><a class="markdownIt-Anchor" href="#迭代-2"></a> 迭代</h5>
<p>注意深度优先遍历回溯时候，可能无法减去双亲结点的值，所以得把双亲的值保存，类似于“[257. 二叉树的所有路径](#<a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a>)”中的保存方式。<strong>此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; S;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            S.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(root, root-&gt;val)); <span class="comment">//根节点和为0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!S.empty())&#123;</span><br><span class="line">            pair&lt;TreeNode*,<span class="keyword">int</span>&gt; p = S.top();</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="keyword">if</span> (!p.first-&gt;left &amp;&amp; !p.first-&gt;right) &#123; <span class="comment">//叶子</span></span><br><span class="line">                <span class="keyword">if</span> (p.second == targetSum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right) &#123;</span><br><span class="line">                S.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(p.first-&gt;right, p.second + p.first-&gt;right-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left) &#123;</span><br><span class="line">                S.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(p.first-&gt;left, p.second + p.first-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="递归-2"><a class="markdownIt-Anchor" href="#递归-2"></a> 递归</h5>
<ol>
<li>
<p>确定递归函数的参数和返回类型</p>
<p>参数：需要二叉树的根节点，还需要一个计数器，这个计数器用来计算二叉树的一条边之和是否正好是目标和，计数器为int型。</p>
<p>再来看返回值，递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：</p>
<ul>
<li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是本文下半部分介绍的113.路径总和ii）</li>
<li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况我们在<a href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" target="_blank" rel="noopener">236. 二叉树的最近公共祖先 (opens new window)</a>中介绍）</li>
<li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）</li>
</ul>
</li>
<li>
<p>确定终止条件</p>
<p>不要去累加然后判断是否等于目标和，那么代码比较麻烦，可以用递减，让计数器count初始为目标和，然后每次减去遍历路径节点上的数值。</p>
<p>如果最后count == 0，同时到了叶子节点的话，说明找到了目标和。</p>
</li>
<li>
<p>确定单层递归的逻辑</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;pair&lt;TreeNode*,<span class="keyword">int</span>&gt;&gt; S;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)&#123; <span class="comment">// 递归时候没有判断左右节点是否非空，所以这里开始的时候要判断</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = targetSum - root-&gt;val; </span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">// 利用减代替加可以少传递一个参数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasPathSum(root-&gt;left, count)) &#123; <span class="comment">// 如果是true 立刻返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasPathSum(root-&gt;right, count)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个版本——代码随想录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="113-路径总和-ii"><a class="markdownIt-Anchor" href="#113-路径总和-ii"></a> <a href="https://leetcode.cn/problems/path-sum-ii/" target="_blank" rel="noopener">113. 路径总和 II</a></h4>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
</blockquote>
<h5 id="迭代-3"><a class="markdownIt-Anchor" href="#迭代-3"></a> 迭代</h5>
<p>思路类似“[257. 二叉树的所有路径](#<a href="https://leetcode.cn/problems/binary-tree-paths/" target="_blank" rel="noopener">257. 二叉树的所有路径</a>)”中的保存方式，知识这里路径的保存利用stack套vector，而非之前的stack套string</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="built_in">stack</span> &lt;pair&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; S;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathAll;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;</span><br><span class="line">            S.push(pair&lt;TreeNode*, <span class="keyword">int</span>&gt;(root, root-&gt;val));</span><br><span class="line">            pathAll.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>, root-&gt;val)); <span class="comment">// 注意这里的vector写法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!S.empty()) &#123;</span><br><span class="line">            pair&lt;TreeNode*, <span class="keyword">int</span>&gt; p = S.top() ;</span><br><span class="line">            S.pop();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path = pathAll.top();</span><br><span class="line">            pathAll.pop();</span><br><span class="line">            <span class="comment">// for (int num:path)&#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; num &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (!p.first-&gt;left &amp;&amp; !p.first-&gt;right &amp;&amp; p.second == targetSum)&#123;</span><br><span class="line">                output.push_back(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right)&#123;</span><br><span class="line">                S.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(p.first-&gt;right, p.second + p.first-&gt;right-&gt;val));</span><br><span class="line">                path.push_back(p.first-&gt;right-&gt;val);</span><br><span class="line">                pathAll.push(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left)&#123;</span><br><span class="line">                S.push(pair&lt;TreeNode*,<span class="keyword">int</span>&gt;(p.first-&gt;left, p.second + p.first-&gt;left-&gt;val));</span><br><span class="line">                path.push_back(p.first-&gt;left-&gt;val);</span><br><span class="line">                pathAll.push(path);</span><br><span class="line">                path.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="递归-3"><a class="markdownIt-Anchor" href="#递归-3"></a> 递归</h5>
<p>不需要返回值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode* p, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(p-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            output.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            findPath(p-&gt;left, targetSum - p-&gt;left-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            findPath (p-&gt;right, targetSum - p-&gt;right-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        findPath (root, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="从遍历序列恢复二叉树"><a class="markdownIt-Anchor" href="#从遍历序列恢复二叉树"></a> 从遍历序列恢复二叉树</h3>
<ul>
<li>由DLR和LDR的遍历序列可以唯一地确定一棵二叉树</li>
<li>由LRD和LDR的遍历序列可以唯一地确定一棵二叉树</li>
<li>通过DLR或者LRD的遍历序列确定二叉树或子树的根节点，通过LDR确定左右子树的序列。</li>
</ul>
<h4 id="106-从中序与后序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#106-从中序与后序遍历序列构造二叉树"></a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. 从中序与后序遍历序列构造二叉树</a></h4>
<blockquote>
<p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
</blockquote>
<p>一层一层切割</p>
<ul>
<li>第一步：如果数组大小为零的话，说明是空节点了。</li>
<li>第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。</li>
<li>第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点</li>
<li>第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）</li>
<li>第五步：切割后序数组，切成后序左数组和后序右数组</li>
<li>第六步：递归处理左区间和右区间</li>
</ul>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/tree-1712473381702-3.jpg" data-index="21" data-src="/2024/03/30/LeetCode-problems/tree-1712473381702-3.jpg"><img alt="106.从中序与后序遍历序列构造二叉树" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210203154249860.png" data-index="22" data-src="/2024/03/30/LeetCode-problems/20210203154249860.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="comment">// 数组大小为0，空节点</span></span><br><span class="line">        <span class="keyword">if</span> (inorder.empty() &amp;&amp; postorder.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不为空，postorder的最后一个元素是根节点</span></span><br><span class="line">        TreeNode* p = <span class="keyword">new</span> TreeNode (postorder[postorder.size() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到中序的切割点</span></span><br><span class="line">        <span class="keyword">int</span> cutPoint;</span><br><span class="line">        <span class="keyword">for</span> (cutPoint = <span class="number">0</span>; cutPoint &lt; inorder.size(); cutPoint++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[cutPoint] == postorder[postorder.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割中序 （左闭右开）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorder_left</span><span class="params">(inorder.begin(), inorder.begin() + cutPoint)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorder_right</span><span class="params">(inorder.begin() + cutPoint + <span class="number">1</span>, inorder.end())</span></span>; <span class="comment">//不包含分割点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割后序 （左闭右开）中序数组大小一定是和后序数组的大小相同的</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder_left</span><span class="params">(postorder.begin(), postorder.begin() + inorder_left.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorder_right</span><span class="params">(postorder.begin() + inorder_left.size(), postorder.end() - <span class="number">1</span>)</span></span>; <span class="comment">//不包含分割点，最后一个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对左右子树递归</span></span><br><span class="line">        p-&gt;left = buildTree(inorder_left, postorder_left);</span><br><span class="line">        p-&gt;right = buildTree(inorder_right, postorder_right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了减少vector的查找时间，官方题解建立（元素，下标）键值对的哈希</p>
<p>这里注意一个细节：为什么可以用下标减一来表示后序的每次根节点呢？因为他先构造右子树，每次的根节点刚好是最后一个，而当右子树构造完以后正好下标来到左子树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> post_idx;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(<span class="keyword">int</span> in_left, <span class="keyword">int</span> in_right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果这里没有节点构造二叉树了，就结束</span></span><br><span class="line">        <span class="keyword">if</span> (in_left &gt; in_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择 post_idx 位置的元素作为当前子树根节点</span></span><br><span class="line">        <span class="keyword">int</span> root_val = postorder[post_idx];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据 root 所在位置分成左右两棵子树</span></span><br><span class="line">        <span class="keyword">int</span> index = idx_map[root_val];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下标减一</span></span><br><span class="line">        post_idx--;</span><br><span class="line">        <span class="comment">// 构造右子树</span></span><br><span class="line">        root-&gt;right = helper(index + <span class="number">1</span>, in_right, inorder, postorder);</span><br><span class="line">        <span class="comment">// 构造左子树</span></span><br><span class="line">        root-&gt;left = helper(in_left, index - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从后序遍历的最后一个元素开始</span></span><br><span class="line">        post_idx = (<span class="keyword">int</span>)postorder.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立（元素，下标）键值对的哈希表</span></span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : inorder) &#123;</span><br><span class="line">            idx_map[val] = idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, (<span class="keyword">int</span>)inorder.size() - <span class="number">1</span>, inorder, postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>——官方题解</p>
<h4 id="105-从前序与中序遍历序列构造二叉树"><a class="markdownIt-Anchor" href="#105-从前序与中序遍历序列构造二叉树"></a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. 从前序与中序遍历序列构造二叉树</a></h4>
<blockquote>
<p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p>
</blockquote>
<p>利用无序映射做</p>
<p>这里利用<code>pre_index++</code>来表示前序的根节点也是和上述同理。更好理解的话还是把先序、中序的头尾都放在helper函数的输入里面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pre_index;</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; idx_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span> <span class="params">(<span class="keyword">int</span> in_begin, <span class="keyword">int</span> in_end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in_begin &gt; in_end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到分割点</span></span><br><span class="line">        <span class="keyword">int</span> cutPoint = idx_map[preorder[pre_index]]; <span class="comment">// 这是分割点在inorder中的下标索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//　建立节点</span></span><br><span class="line">        TreeNode *p = <span class="keyword">new</span> TreeNode(preorder[pre_index]); <span class="comment">// 分割点的值是preorder[begin]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前序的分割点递增</span></span><br><span class="line">        pre_index++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左右子树</span></span><br><span class="line">        p-&gt;left = helper(in_begin, cutPoint - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">        p-&gt;right = helper(cutPoint + <span class="number">1</span>, in_end, preorder, inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        pre_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:inorder) &#123;</span><br><span class="line">            idx_map[num] = index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>, inorder.size() - <span class="number">1</span>, preorder, inorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="654-最大二叉树"><a class="markdownIt-Anchor" href="#654-最大二叉树"></a> <a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank" rel="noopener">654. 最大二叉树</a></h3>
<blockquote>
<p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的<strong>最大二叉树</strong></em> 。</p>
</blockquote>
<p>思路非常类似于“从遍历序列恢复二叉树”，但是这里需要注意的是不需要建立哈希表存储索引和值的关系，因为你每次要在序列中找到最大值，还是需要通过for循环来寻找，因此unordered_map在这里作用不大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归求解，每次先找最大</span></span><br><span class="line">        <span class="keyword">int</span> maxNumIndex = begin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin + <span class="number">1</span>; i &lt;= end; i++)&#123; <span class="comment">//从begin+1开始可以减少工作量哈</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[maxNumIndex]) &#123;</span><br><span class="line">                maxNumIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(nums[maxNumIndex]);</span><br><span class="line">        root-&gt;left = helper(nums, begin, maxNumIndex - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = helper(nums, maxNumIndex + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="617-合并二叉树"><a class="markdownIt-Anchor" href="#617-合并二叉树"></a> <a href="https://leetcode.cn/problems/merge-two-binary-trees/" target="_blank" rel="noopener">617. 合并二叉树</a></h3>
<blockquote>
<p>给你两棵二叉树： <code>root1</code> 和 <code>root2</code> 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，<strong>不为</strong> null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p><strong>注意:</strong> 合并过程必须从两个树的根节点开始。</p>
</blockquote>
<h4 id="解法一迭代层次遍历列举所有情况"><a class="markdownIt-Anchor" href="#解法一迭代层次遍历列举所有情况"></a> 解法一——迭代+层次遍历+列举所有情况</h4>
<p>非常朴素的想法，层次遍历+列举所有情况，将左右操作都从第二个子树合并到第一个子树上，所有的节点不存在问题，都通过创建0节点解决。这里需要注意的是不光要将0节点加到队列中以保证两子树的队列长度一致，同时子树1是要返回的，那么他的具体节点也需要有。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 层次遍历，在root1上操作</span></span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q1;</span><br><span class="line">        <span class="built_in">queue</span> &lt;TreeNode*&gt; Q2;</span><br><span class="line">        <span class="keyword">if</span> (root1 != <span class="literal">NULL</span> || root2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                root1 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                root2 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Q1.push(root1);</span><br><span class="line">            Q2.push(root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!Q1.empty() || !Q2.empty()) &#123;</span><br><span class="line">            TreeNode *p1 = Q1.front();</span><br><span class="line">            Q1.pop();</span><br><span class="line">            TreeNode *p2 = Q2.front();</span><br><span class="line">            Q2.pop();</span><br><span class="line">            <span class="keyword">if</span> (p1 &amp;&amp; p2) &#123;</span><br><span class="line">                p1-&gt;val += p2-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// left、right四种情况</span></span><br><span class="line">            <span class="comment">// if (p1-&gt;left) &#123;</span></span><br><span class="line">            <span class="comment">//     Q1.push(p1-&gt;left);</span></span><br><span class="line">            <span class="comment">//     if (p2-&gt;left) &#123;</span></span><br><span class="line">            <span class="comment">//         Q2.push(p2-&gt;left);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     else &#123;</span></span><br><span class="line">            <span class="comment">//         Q2.push(new TreeNode(0));</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (p1-&gt;right) &#123;</span></span><br><span class="line">            <span class="comment">//     Q1.push(p1-&gt;right);</span></span><br><span class="line">            <span class="comment">//     if (p2-&gt;right) &#123;</span></span><br><span class="line">            <span class="comment">//         Q2.push(p2-&gt;right);</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">//     else &#123;</span></span><br><span class="line">            <span class="comment">//         Q2.push(new TreeNode(0));</span></span><br><span class="line">            <span class="comment">//     &#125;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (!p1-&gt;left &amp;&amp; p2-&gt;left) &#123;</span></span><br><span class="line">            <span class="comment">//     p1-&gt;left = new TreeNode(0);</span></span><br><span class="line">            <span class="comment">//     Q1.push(p1-&gt;left);</span></span><br><span class="line">            <span class="comment">//     Q2.push(p2-&gt;left);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (!p1-&gt;right &amp;&amp; p2-&gt;right) &#123;</span></span><br><span class="line">            <span class="comment">//     p1-&gt;right = new TreeNode(0);</span></span><br><span class="line">            <span class="comment">//     Q1.push(p1-&gt;right);</span></span><br><span class="line">            <span class="comment">//     Q2.push(p2-&gt;right);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// 其余的p1、p2左右子树均不存在的情况不需要考虑</span></span><br><span class="line">            <span class="comment">// 综合一下只有两种情况，都不存在，和其他</span></span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;left || p2-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!p1-&gt;left)&#123;</span><br><span class="line">                    p1-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!p2-&gt;left)&#123;</span><br><span class="line">                    p2-&gt;left = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Q1.push(p1-&gt;left);</span><br><span class="line">                Q2.push(p2-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;right || p2-&gt;right)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!p1-&gt;right)&#123;</span><br><span class="line">                    p1-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!p2-&gt;right)&#123;</span><br><span class="line">                    p2-&gt;right = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Q1.push(p1-&gt;right);</span><br><span class="line">                Q2.push(p2-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二递归深度优先"><a class="markdownIt-Anchor" href="#解法二递归深度优先"></a> 解法二——递归+深度优先</h4>
<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>
<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；<strong>且即使其中一个有子树也不需要管了，毕竟另外一个直接空了</strong></p>
<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>
<p>——力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; !root2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!root1 &amp;&amp; root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root1 &amp;&amp; !root2) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *merged = <span class="keyword">new</span> TreeNode (root1-&gt;val + root2-&gt;val);</span><br><span class="line">        merged-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);</span><br><span class="line">        merged-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="700-二叉搜索树中的搜索"><a class="markdownIt-Anchor" href="#700-二叉搜索树中的搜索"></a> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/" target="_blank" rel="noopener">700. 二叉搜索树中的搜索</a></h3>
<blockquote>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和一个整数值 <code>val</code>。</p>
<p>你需要在 BST 中找到节点值等于 <code>val</code> 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 <code>null</code> 。</p>
</blockquote>
<p>二叉搜索树(二叉排序树)是一个有序树：</p>
<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉搜索树</li>
</ul>
<h4 id="迭代-4"><a class="markdownIt-Anchor" href="#迭代-4"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val == val) &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &gt; val) &#123;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-4"><a class="markdownIt-Anchor" href="#递归-4"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root-&gt;val == val)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="98-验证二叉搜索树"><a class="markdownIt-Anchor" href="#98-验证二叉搜索树"></a> <a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener">98. 验证二叉搜索树</a></h3>
<blockquote>
<p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
</blockquote>
<p><strong>不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了</strong>，而是左子树都小于中间节点，右子树都大于中间节点。</p>
<p>要知道中序遍历下，输出的二叉搜索树节点的数值是有序序列。</p>
<h4 id="迭代中序遍历"><a class="markdownIt-Anchor" href="#迭代中序遍历"></a> 迭代——中序遍历</h4>
<p>定义flag，防止第一次比较order超范围有问题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中序遍历</span></span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; order;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                S.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = S.top();</span><br><span class="line">                S.pop();</span><br><span class="line">                <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                    order.push_back(p-&gt;val);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; p-&gt;val &lt;&lt; " ";</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; order[order.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">                    order.push_back(p-&gt;val);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; p-&gt;val &lt;&lt; " ";</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-5"><a class="markdownIt-Anchor" href="#递归-5"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *pre = <span class="literal">NULL</span>; <span class="comment">//记录前一个，中序的前一个总比后一个小</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> validLeft = isValidBST(root-&gt;left);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;val &gt;= root-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> validRight = isValidBST(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> validLeft &amp;&amp; validRight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="530-二叉搜索树的最小绝对差"><a class="markdownIt-Anchor" href="#530-二叉搜索树的最小绝对差"></a> <a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. 二叉搜索树的最小绝对差</a></h3>
<blockquote>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
</blockquote>
<p><strong>在有序数组求任意两数最小值差等价于相邻两数的最小值差</strong>。</p>
<p>迭代</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> minDistance = INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(p || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(p)&#123;</span><br><span class="line">                S.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = S.top();</span><br><span class="line">                S.pop();</span><br><span class="line">                <span class="keyword">if</span>((pre != <span class="number">-1</span>) &amp;&amp; (p-&gt;val - pre) &lt; minDistance) &#123;</span><br><span class="line">                    minDistance = p-&gt;val - pre;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = p-&gt;val;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDistance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="501-二叉搜索树中的众数"><a class="markdownIt-Anchor" href="#501-二叉搜索树中的众数"></a> <a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/" target="_blank" rel="noopener">501. 二叉搜索树中的众数</a></h3>
<blockquote>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796" target="_blank" rel="noopener">众数</a>（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>
<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
</blockquote>
<p>几个可以利用的特点：</p>
<ol>
<li>中序遍历是有序的</li>
<li>遍历一次就可以找到所有的众数——如果 频率count 等于 maxCount（最大频率），当然要把这个元素加入到结果集中（以下代码为result数组），不仅要更新maxCount，而且要清空结果集</li>
</ol>
<p>递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> maxCount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>; <span class="comment">//不能直接定义int类型，否则，NULL==0</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) &#123;</span><br><span class="line">            inorder(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断、计数</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pre-&gt;val == p-&gt;val) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//不相等清零</span></span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p; <span class="comment">//更新节点</span></span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt; maxCount) &#123;</span><br><span class="line">            maxCount = count;</span><br><span class="line">            output.clear();</span><br><span class="line">            output.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (count == maxCount) &#123;</span><br><span class="line">            output.push_back(p-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) &#123;</span><br><span class="line">            inorder(p-&gt;right);</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="236-二叉树的最近公共祖先"><a class="markdownIt-Anchor" href="#236-二叉树的最近公共祖先"></a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">236. 二叉树的最近公共祖先</a></h3>
<blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
</blockquote>
<p><img alt="236.二叉树的最近公共祖先2" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/202102041512582.png" data-index="23" data-src="/2024/03/30/LeetCode-problems/202102041512582.png"></p>
<ul>
<li>如何从底向上遍历？</li>
<li>遍历整棵树，还是遍历局部树？</li>
<li>如何把结果传到根节点的？</li>
</ul>
<p>思路有点难想，一共分为两种情况：</p>
<ul>
<li>情况一：p、q分属在一个顶点的左右子树上</li>
<li>情况二：p在q的子树下，q在p的子树下</li>
</ul>
<p>首先考虑“情况一”，在递归寻找的过程中，如果我能找到这个其中一个节点，我就回传（此时不需要考虑是否为叶子节点，为什么呢？此时其实就是“情况二”）。如果一个顶点的左右都有值，那就说明这个节点是公共节点，又因为我们是从下到上回溯的，所以碰到的一定是最近公共祖先（也就是最深的，再往上的一定至少有一边为NULL）。</p>
<p>下面考虑“情况二”的问题。如果p在q的子树下或q在p的子树下，题目中又保证<code>p</code> 和 <code>q</code> 均存在于给定的二叉树中，且互不相同，那么是不是就可以说<strong>假设我现在找到了p，如果我在后续的递归遍历中再也没有找到q，那么q一定就在p的子树中</strong>，所以这就解决了一个节点属于另一个元素的孩子的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">//NULL就直接回传，如果遇到需要找的p、q也回传，注意如果q（p）在p（q）的子树下就不往下递归了，虽然我没递归到，但是一定在这个下面。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左右子树递归寻找</span></span><br><span class="line">        TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *right = lowestCommonAncestor(root-&gt;right,  p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root; <span class="comment">// 如果左右子树都有，那他就是最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left &amp;&amp; !right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right &amp;&amp; !left) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="235-二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#235-二叉搜索树的最近公共祖先"></a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">235. 二叉搜索树的最近公共祖先</a></h3>
<blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
</blockquote>
<ul>
<li><strong>是</strong>公共祖先：因为是有序树，所以 如果 中间节点是 q 和 p 的公共祖先，那么 中节点的值 一定是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[p, q]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose">]</span></span></span></span>​区间的。即 <code>中节点-&gt;val &gt; p-&gt;val &amp;&amp; 中节点-&gt;val &lt; q-&gt;val</code> 或者 <code>中节点-&gt;val &gt; q-&gt;val &amp;&amp; 中节点-&gt;val &lt; p-&gt;val</code>。</li>
<li><strong>最近</strong>公共祖先：<strong>如果一个节点值大于根节点，一个节点值小于根节点</strong>，说明他们他们一个在根节点的左子树上一个在根节点的右子树上，<strong>那么根节点就是他们的最近公共祖先节点</strong>。【反证法】此时，如果最近公共祖先在左子树中，说明p、q必须都得在左子树中，和“一个结点值大于根节点”矛盾；如果最近公共祖先在右子树中，说明p、q必须都得在右子树中，和“一个结点值小于根节点”矛盾；只剩最后一种情况：根节点就是最近公共祖先呗</li>
</ul>
<h4 id="递归-6"><a class="markdownIt-Anchor" href="#递归-6"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123; <span class="comment">//p，q都在左子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123; <span class="comment">//p，q都在右子树</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;val &lt;= p-&gt;val &amp;&amp; root-&gt;val &gt;= q-&gt;val) || (root-&gt;val &gt;= p-&gt;val &amp;&amp; root-&gt;val &lt;= q-&gt;val)) &#123; <span class="comment">// 分叉点或者就是其中一个节点，其实这个就是上两个以外的else</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="迭代-5"><a class="markdownIt-Anchor" href="#迭代-5"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) &#123; <span class="comment">//p，q都在左子树</span></span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) &#123; <span class="comment">//p，q都在右子树</span></span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 分叉点或者就是其中一个节点，其实这个就是上两个以外的else</span></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="701-二叉搜索树中的插入操作"><a class="markdownIt-Anchor" href="#701-二叉搜索树中的插入操作"></a> <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">701. 二叉搜索树中的插入操作</a></h3>
<blockquote>
<p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
</blockquote>
<p>根据定义完成。</p>
<ul>
<li>注意root因为要返回，所以不能直接对他操作</li>
<li>需要考虑空root的问题</li>
</ul>
<h4 id="迭代-6"><a class="markdownIt-Anchor" href="#迭代-6"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123; <span class="comment">// 考虑空节点的问题</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val &gt; p-&gt;val)  &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                    p = p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p-&gt;right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                    p = p-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p-&gt;left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 注意root不能变</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-7"><a class="markdownIt-Anchor" href="#递归-7"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123; <span class="comment">// 考虑空节点的问题,递归中其实就是最后一步</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; root-&gt;val)  &#123;</span><br><span class="line">            root-&gt;right = insertIntoBST(root-&gt;right, val); <span class="comment">//接收到的就是返回的原始root，只是新增了子节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;left = insertIntoBST(root-&gt;left, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="450-删除二叉搜索树中的节点"><a class="markdownIt-Anchor" href="#450-删除二叉搜索树中的节点"></a> <a href="https://leetcode.cn/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">450. 删除二叉搜索树中的节点</a></h3>
<blockquote>
<p>给定一个二叉搜索树的根节点 <strong>root</strong> 和一个值 <strong>key</strong>，删除二叉搜索树中的 <strong>key</strong> 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p>
<p>一般来说，删除节点可分为两个步骤：</p>
<ol>
<li>首先找到需要删除的节点；</li>
<li>如果找到了，删除它。</li>
</ol>
</blockquote>
<ul>
<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>
<li>找到删除的节点
<ul>
<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li>
<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>
<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>
<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>
</ul>
</li>
</ul>
<p>其实第五种情况简单来说就是，<u>删除节点</u>的左子树的任意一个元素，一定小于右子树的任意元素，那我直接放到右子树的最小元素的左子树上就好啦！</p>
<h4 id="迭代-7"><a class="markdownIt-Anchor" href="#迭代-7"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先要找到删除元素</span></span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        TreeNode *pParent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">bool</span> direction = <span class="literal">true</span>; <span class="comment">// 布尔值判断是在parent的左子树（true）还是右子树（false）</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key &gt; p-&gt;val) &#123;</span><br><span class="line">                pParent = p;</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">                direction = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; p-&gt;val) &#123;</span><br><span class="line">                pParent = p;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">                direction = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//相等</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123; <span class="comment">//没找到</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对删除元素操作</span></span><br><span class="line">        TreeNode *q = <span class="literal">NULL</span>; <span class="comment">// q用于指示pParent后续指向何方</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right) &#123; <span class="comment">// 全空</span></span><br><span class="line">            q = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;left &amp;&amp; p-&gt;right) &#123; <span class="comment">// 左空右不空</span></span><br><span class="line">            q = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left &amp;&amp; !p-&gt;right) &#123; <span class="comment">// 左不空右空</span></span><br><span class="line">            q = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 左右都不空</span></span><br><span class="line">            q = p-&gt;right; <span class="comment">//指向右子树，并将原来的左子树放在原来的右子树的最左下方</span></span><br><span class="line">            TreeNode *pLeft = p-&gt;left; <span class="comment">//原来的左子树</span></span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;left) &#123;</span><br><span class="line">                p = p-&gt;left; <span class="comment">// 指向原来的右子树的最左下方</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时p-&gt;left为空</span></span><br><span class="line">            p-&gt;left = pLeft;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新子树节点放置在原来pParent下方，这里需要注意，万一删除的节点就是根节点的情况</span></span><br><span class="line">        <span class="keyword">if</span> (pParent) &#123; <span class="comment">//删除的节点非根节点</span></span><br><span class="line">            <span class="keyword">if</span>(direction) &#123;</span><br><span class="line">                pParent-&gt;left = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pParent-&gt;right = q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//删除的节点就是根节点</span></span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-8"><a class="markdownIt-Anchor" href="#递归-8"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对删除元素操作</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; <span class="comment">// 全空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) &#123; <span class="comment">// 左空右不空</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left &amp;&amp; !root-&gt;right) &#123; <span class="comment">// 左不空右空</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">// 左右都不空          </span></span><br><span class="line">                TreeNode *rootRight = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (rootRight-&gt;left) &#123;</span><br><span class="line">                    rootRight = rootRight-&gt;left; <span class="comment">// 指向原来的右子树的最左下方</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//此时rootRight-&gt;left为空</span></span><br><span class="line">                rootRight-&gt;left = root-&gt;left;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; rootRight-&gt;val &lt;&lt; " ";</span></span><br><span class="line">                <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归寻找左右</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; key) &#123;</span><br><span class="line">            root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="669-修剪二叉搜索树"><a class="markdownIt-Anchor" href="#669-修剪二叉搜索树"></a> <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">669. 修剪二叉搜索树</a></h3>
<blockquote>
<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
</blockquote>
<p>先找到两个临界点值。</p>
<ul>
<li><code>low</code>：工作节点p满足<code>p-&gt;val &gt;= low &amp;&amp; p-&gt;left-&gt;val &lt; low</code>， 则<code>p = p-&gt;right</code></li>
<li><code>high</code>：工作节点p满足<code>p-&gt;val &lt;= high &amp;&amp; p-&gt;right-&gt;val &gt; high</code>， 则<code>p = p-&gt;left</code></li>
</ul>
<p>例如对于low的临界点来说，他一定是左孩子，双亲一定大于他，他本身的右孩子也一定大于他。**但是要注意右孩子可能还是会有小于low的情况出现！！！**所以要用while</p>
<p>此外处理根节点不在范围内的问题时候，不能分开来考虑，例如先low，后high，否则可能有问题。</p>
<h4 id="迭代-8"><a class="markdownIt-Anchor" href="#迭代-8"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (root &amp;&amp; (root-&gt;val &gt; high || root-&gt;val &lt; low)) &#123; <span class="comment">// 不能分开来，先左后右</span></span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="comment">// 找low的临界点</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;val &gt;= low &amp;&amp; p-&gt;left &amp;&amp; p-&gt;left-&gt;val &lt; low) &#123; <span class="comment">// 注意这里是while</span></span><br><span class="line">                p-&gt;left = p-&gt;left-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;left; <span class="comment">// 还没到临界点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = root;</span><br><span class="line">        <span class="comment">// 找high的临界点</span></span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p-&gt;val &lt;= high &amp;&amp; p-&gt;right &amp;&amp; p-&gt;right-&gt;val &gt; high) &#123;<span class="comment">// 注意这里是while</span></span><br><span class="line">                p-&gt;right = p-&gt;right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;right; <span class="comment">// 还没到临界点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-9"><a class="markdownIt-Anchor" href="#递归-9"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; low) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; high) &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;left = trimBST(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = trimBST(root-&gt;right, low, high);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="108-将有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#108-将有序数组转换为二叉搜索树"></a> <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. 将有序数组转换为二叉搜索树</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 平衡 二叉搜索树。</p>
<p><strong>平衡二叉树</strong> 是指该树所有节点的左右子树的深度相差不超过 1。</p>
</blockquote>
<p>注意是所有节点的左右子树的深度相差不超过 1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* p = <span class="keyword">new</span> TreeNode(nums[(left + right) / <span class="number">2</span>]);</span><br><span class="line">        p-&gt;left = helper(nums, left, (left + right) / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">        p-&gt;right = helper(nums, (left + right) / <span class="number">2</span> + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="538-把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#538-把二叉搜索树转换为累加树"></a> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">538. 把二叉搜索树转换为累加树</a></h3>
<blockquote>
<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
</blockquote>
<p>逆中序遍历</p>
<h4 id="迭代-9"><a class="markdownIt-Anchor" href="#迭代-9"></a> 迭代</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                S.push(p);</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = S.top();</span><br><span class="line">                S.pop();</span><br><span class="line">                sum += p-&gt;val;</span><br><span class="line">                p-&gt;val = sum;</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归-10"><a class="markdownIt-Anchor" href="#递归-10"></a> 递归</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">            root-&gt;right = convertBST(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">            root-&gt;left = convertBST(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="回溯"><a class="markdownIt-Anchor" href="#回溯"></a> 回溯</h2>
<blockquote>
<p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。</p>
<p>回溯法，一般可以解决如下几种问题：</p>
<ul>
<li>
<p>组合问题：N个数里面按一定规则找出k个数的集合</p>
<ul>
<li>剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了。</li>
<li>一个集合来求<strong>组合</strong>的话，就需要startIndex；多个集合取组合，各个集合之间相互不影响，那么就不用startIndex</li>
<li><strong>去重问题</strong>——used</li>
</ul>
</li>
<li>
<p>切割问题：一个字符串按一定规则有几种切割方式</p>
</li>
<li>
<p>子集问题：一个N个数的集合里有多少符合条件的子集</p>
<ul>
<li>在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。</li>
</ul>
</li>
<li>
<p>排列问题：N个数按一定规则全排列，有几种排列方式</p>
</li>
<li>
<p>棋盘问题：N皇后，解数独等等</p>
</li>
</ul>
<p><strong>组合是不强调元素顺序的，排列是强调元素顺序</strong>。</p>
<p><strong>回溯法解决的问题都可以抽象为树形结构</strong>！因为回溯法解决的都是在集合中递归查找子集，<strong>集合的大小就构成了树的宽度，递归的深度就构成了树的深度</strong>。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。<strong>for循环横向遍历，递归纵向遍历，回溯不断调整结果集</strong><br>
<img alt="回溯算法理论基础" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210130173631174.png" data-index="24" data-src="/2024/03/30/LeetCode-problems/20210130173631174.png"></p>
<ul>
<li><strong>在for循环上做剪枝操作是回溯法剪枝的常见套路！</strong></li>
</ul>
<p>模板</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); &#x2F;&#x2F; 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img alt="回溯算法大纲" style="zoom:50%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210219192050666.png" data-index="25" data-src="/2024/03/30/LeetCode-problems/20210219192050666.png">
<hr>
<p>以下来自<a href="https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw" target="_blank" rel="noopener">回溯算法入门级详解 + 练习（持续更新）</a></p>
<p>「回溯算法」强调了「深度优先遍历」思想的用途，用一个 <strong>不断变化</strong> 的变量，在尝试各种可能的过程中，搜索需要的结果。强调了 <strong>回退</strong> 操作对于搜索的合理性。</p>
<p>回溯算法用于 <strong>搜索一个问题的所有的解</strong> ，通过深度优先遍历的思想实现。</p>
<p>与动态规划的区别：</p>
<ul>
<li>
<p>共同点——用于求解多阶段决策问题。多阶段决策问题即：</p>
<ul>
<li>
<p>求解一个问题分为很多步骤（阶段）；</p>
</li>
<li>
<p>每一个步骤（阶段）可以有多种选择。</p>
</li>
</ul>
</li>
<li>
<p>不同点</p>
<ul>
<li>动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；</li>
<li>回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合"></a> <a href="https://leetcode.cn/problems/combinations/" target="_blank" rel="noopener">77. 组合</a></h3>
<blockquote>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
</blockquote>
<p>回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。</p>
<p><img alt="77.组合1" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20201123195242899.png" data-index="26" data-src="/2024/03/30/LeetCode-problems/20201123195242899.png"></p>
<h4 id="解法一暴力回溯"><a class="markdownIt-Anchor" href="#解法一暴力回溯"></a> 解法一——暴力回溯</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            output.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line">            temp.pop_back(); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> output;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二回溯剪枝"><a class="markdownIt-Anchor" href="#解法二回溯剪枝"></a> 解法二——回溯+剪枝</h4>
<p><strong>如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>
<ol>
<li>已经选择的元素个数：<code>path.size()</code>;</li>
<li>还需要的元素个数为: <code>k - path.size()</code>;</li>
<li>在集合n中至多要从该起始位置 : <code>n - (k - path.size()) + 1</code>，开始遍历</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k) &#123;</span><br><span class="line">            output.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n - (k - temp.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            backtracking(n, k, i + <span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line">            temp.pop_back(); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        backtracking(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> output;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="216-组合总和-iii"><a class="markdownIt-Anchor" href="#216-组合总和-iii"></a> <a href="https://leetcode.cn/problems/combination-sum-iii/" target="_blank" rel="noopener">216. 组合总和 III</a></h3>
<blockquote>
<p>找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
</blockquote>
<p>隐含sum的回溯，通过两个方法剪枝</p>
<ul>
<li>i的范围，要保证后续有这么多的树可以取</li>
<li>sum和target的关系，如果加上当前数target已经炸了，那么就不往下了，这里隐含了一点，i是从小到大排列的，加上这个比较小的都不行，后面的就都不用加了。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> target, <span class="keyword">int</span> start, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == k &amp;&amp; sum == target) &#123;</span><br><span class="line">            output.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span> - (k - temp.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + i &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(i);</span><br><span class="line">            backtracking (k, target, i + <span class="number">1</span>, sum + i); <span class="comment">// 隐含sum的回溯</span></span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(k, n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合"></a> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">17. 电话号码的字母组合</a></h3>
<blockquote>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/200px-telephone-keypad2svg.png" data-index="27" data-src="/2024/03/30/LeetCode-problems/200px-telephone-keypad2svg.png"></p>
</blockquote>
<p>注意alphabet的定义方式是大括号。此外<code>digitsStart</code>不能使用<code>stoi</code>，这个也不知道是为什么。此外需要注意为空的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; alphabet = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">string</span> digits, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == digits.length()) &#123;</span><br><span class="line">            output.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digitsStart = digits[start] - <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alphabet[digitsStart].length(); i++) &#123;</span><br><span class="line">            temp.push_back(alphabet[digitsStart][i]);</span><br><span class="line">            backtracking(digits, start + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">letterCombinations</span><span class="params">(<span class="built_in">string</span> digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> <a href="https://leetcode.cn/problems/combination-sum/" target="_blank" rel="noopener">39. 组合总和</a></h3>
<blockquote>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p>
<p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p>
</blockquote>
<ul>
<li>组合没有数量要求</li>
<li>元素可无限重复选取</li>
</ul>
<p>有两点需要注意：</p>
<ul>
<li>递归的时候下一次的start是i，不是i+1，也不是start。不是start（因为是这个数及其以后的可选），也不是i+1（因为可以重复选取）</li>
<li>剪枝时候的判定条件<code>sum + candidates[i] &gt; target</code>就<code>break</code>，数组需要有序</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            output.push_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.push_back(candidates[i]);</span><br><span class="line">            backtracking(candidates, target, sum + candidates[i], i); <span class="comment">// 隐含sum的回溯，注意这里是i不是start（因为是这个数及其以后的可选），也不是i+1（因为可以重复选取）</span></span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end()); <span class="comment">// 注意需要有序的时候，我们的break策略才是成立的</span></span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>差不多的写法，只是把target直接改了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> startIdx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIdx; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            temp.emplace_back(candidates[i]);</span><br><span class="line">            backtracking(candidates, target - candidates[i], i);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="40-组合总和-ii"><a class="markdownIt-Anchor" href="#40-组合总和-ii"></a> <a href="https://leetcode.cn/problems/combination-sum-ii/" target="_blank" rel="noopener">40. 组合总和 II</a></h3>
<blockquote>
<p>给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<p>**注意：**解集不能包含重复的组合。</p>
</blockquote>
<p>candidates中有重复的数字，这个重复数字可以在同一个解里面使用，但是解集不能包含重复的元素。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,</span><br><span class="line">输出:[[1,1,6],[1,2,5],[1,7],[2,6]]</span><br></pre></td></tr></table></figure>
<p>所以不能直接通过以下方式将输入candidates数组去重来实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort(candidates.begin(), candidates.end());</span><br><span class="line"><span class="keyword">auto</span> end_unique = unique(candidates.begin(), candidates.end());</span><br><span class="line">candidates.erase(end_unique, candidates.end());</span><br></pre></td></tr></table></figure>
<p><strong>我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重</strong>。</p>
<p><img alt="40.组合总和II" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20230310000918.png" data-index="28" data-src="/2024/03/30/LeetCode-problems/20230310000918.png"></p>
<p>与39题的区别：</p>
<ul>
<li>同意元素不能无限取，所以递归时候是<code>i+1</code>。</li>
<li>加入了这一个判断<code>i &gt; start &amp;&amp; candidates[i] == candidates[i-1]</code>，以防止出现一摸一样的结果。第二部分很好理解，就是说如果这一个和上一个值是一样的，那我就跳过。但是注意到同一个树枝上面的元素是可以重复的，所以需要<code>i &gt; start</code>这一约束，防止直接不让重复了，也就保证了示例中的<code>[1,1,6]</code>这组解还是能够出来。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.emplace_back(candidates[i]);</span><br><span class="line">            backtracking(candidates, target, sum + candidates[i], i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(candidates.begin(), candidates.end());</span><br><span class="line">        backtracking(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串"></a> <a href="https://leetcode.cn/problems/palindrome-partitioning/" target="_blank" rel="noopener">131. 分割回文串</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 回文串 。返回 <code>s</code> 所有可能的分割方案。</p>
<p><strong>回文串</strong> 是向前和向后读都相同的字符串。</p>
</blockquote>
<h4 id="解法一暴力回溯-2"><a class="markdownIt-Anchor" href="#解法一暴力回溯-2"></a> 解法一——暴力回溯</h4>
<p>检测到是回文串送入temp</p>
<ul>
<li>在处理组合问题的时候，递归参数需要传入start，表示下一轮递归遍历的起始位置，这个start就是切割线。</li>
<li>为了方便处理回文串，也要传入start和end，就可以减少切割。</li>
<li><code>start == s.length() - 1</code>时，最后一个值还没有传入</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span> <span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; s.length() - <span class="number">1</span>) &#123; <span class="comment">// 注意这里是&gt;，而非==，因为最后一个start也要存入</span></span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, start, i)) &#123;</span><br><span class="line">                temp.emplace_back(s.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二回溯优化回文串的识别"><a class="markdownIt-Anchor" href="#解法二回溯优化回文串的识别"></a> 解法二——回溯+优化回文串的识别</h4>
<p>给定字符串<code>&quot;abcde&quot;</code>, 在已知<code>&quot;bcd&quot;</code>不是回文字串时, 不再需要去双指针操作<code>&quot;abcde&quot;</code>而可以直接判定它一定不是回文字串。</p>
<p>具体来说, 给定一个字符串<code>s</code>, 长度为<code>n</code>, 它成为回文字串的充分必要条件是<code>s[0] == s[n-1]</code>且<code>s[1:n-1]</code>是回文字串。</p>
<p><img alt="image-20240410155458022" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240410155458022.png" data-index="29" data-src="/2024/03/30/LeetCode-problems/image-20240410155458022.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; isPalindrome; <span class="comment">//放事先计算好的是否回文子串的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">computePalindrome</span> <span class="params">(<span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 </span></span><br><span class="line">        isPalindrome.resize(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (s.length(), <span class="literal">true</span>)); <span class="comment">// 创建二维数组，长度为s.length() x s.length()，全部赋值为true</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="comment">// 需要保证计算[i, j]区间时候，[i+1, j-1]区间已经计算完毕</span></span><br><span class="line">                isPalindrome[i][j] = (s[i] == s[j]) &amp;&amp; isPalindrome[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="comment">// if (j == i) &#123;isPalindrome[i][j] = true;&#125; // 等于的时候必然是true，不需要重新赋值</span></span><br><span class="line">                <span class="comment">// else if (j - i == 1) &#123;isPalindrome[i][j] = (s[i] == s[j]);&#125; //差一位的时候，第二个条件相当于已经满足了，因为是true</span></span><br><span class="line">                <span class="comment">// else &#123;isPalindrome[i][j] = (s[i] == s[j] &amp;&amp; isPalindrome[i+1][j-1]);&#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; s.length() - <span class="number">1</span>) &#123; <span class="comment">// 注意这里是&gt;，而非==，因为最后一个start也要存入</span></span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome[start][i]) &#123;</span><br><span class="line">                temp.emplace_back(s.substr(start, i - start + <span class="number">1</span>));</span><br><span class="line">                backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">partition</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        computePalindrome(s);</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="93-复原-ip-地址"><a class="markdownIt-Anchor" href="#93-复原-ip-地址"></a> <a href="https://leetcode.cn/problems/restore-ip-addresses/" target="_blank" rel="noopener">93. 复原 IP 地址</a></h3>
<blockquote>
<p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 <code>0</code> 到 <code>255</code> 之间组成，且不能含有前导 <code>0</code>），整数之间用 <code>'.'</code> 分隔。</p>
<ul>
<li>例如：<code>&quot;0.1.2.201&quot;</code> 和<code>&quot;192.168.1.1&quot;</code> 是 <strong>有效</strong> IP 地址，但是 <code>&quot;0.011.255.245&quot;</code>、<code>&quot;192.168.1.312&quot;</code> 和 <code>&quot;192.168@1.1&quot;</code> 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 <code>s</code> ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 <code>s</code> 中插入 <code>'.'</code> 来形成。你 <strong>不能</strong> 重新排序或删除 <code>s</code> 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
</blockquote>
<p>先考虑暴力回溯，在考虑剪枝</p>
<h4 id="解法一暴力回溯temp是字符串数组"><a class="markdownIt-Anchor" href="#解法一暴力回溯temp是字符串数组"></a> 解法一——暴力回溯，temp是字符串数组</h4>
<p>注意这里不需要代码中对i的for循环，这个本来就是递归要做的循环，还是没有理解透啊，加入这个循环以后会导致缺数。</p>
<p>这里也考虑了一点剪枝的问题</p>
<ul>
<li>比如<code>j &lt; start + 3</code>，就是每个segment值不会大于255，那么就不会大于3.</li>
<li>此外<code>if (segment &gt; 4) {continue;}</code>，就是对于segment分段总数的限制。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSegment</span> <span class="params">(<span class="built_in">string</span> sSegment)</span> </span>&#123; <span class="comment">// 左右皆为闭</span></span><br><span class="line">        <span class="keyword">if</span> (sSegment.size() &gt; <span class="number">1</span> &amp;&amp; sSegment[<span class="number">0</span>] == <span class="string">'0'</span>) &#123; <span class="comment">// 多位前导0的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; sSegment &lt;&lt; ",";</span></span><br><span class="line">        <span class="keyword">int</span> num = stoi(sSegment);</span><br><span class="line">        <span class="keyword">if</span> (num &lt; <span class="number">0</span> || num &gt; <span class="number">255</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> segment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == s.length() &amp;&amp; segment == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">// string tempOutput = temp[0] + "." + temp[1] + "." + temp[2] + "." + temp[3];</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; temp[0] + "." + temp[1] + "." + temp[2] + "." + temp[3] &lt;&lt; endl;</span></span><br><span class="line">            output.emplace_back(temp[<span class="number">0</span>] + <span class="string">"."</span> + temp[<span class="number">1</span>] + <span class="string">"."</span> + temp[<span class="number">2</span>] + <span class="string">"."</span> + temp[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (int i = start; i &lt; s.length(); i++)&#123;</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; start + <span class="number">3</span> &amp;&amp; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="built_in">string</span> sSegment = s.substr(start, j - start + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (segment &gt; <span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isValidSegment(sSegment)) &#123;</span><br><span class="line">                    temp.emplace_back(sSegment);</span><br><span class="line">                    backtracking(s, j + <span class="number">1</span>, segment + <span class="number">1</span>);</span><br><span class="line">                    temp.pop_back();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">restoreIpAddresses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        backtracking(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二temp就是对源字符串加点"><a class="markdownIt-Anchor" href="#解法二temp就是对源字符串加点"></a> 解法二——temp就是对源字符串加点</h4>
<p><a href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html#%E6%80%9D%E8%B7%AF" target="_blank" rel="noopener">代码随想录</a>的方法</p>
<p><img alt="93.复原IP地址" class="post-img b-lazy" data-img="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png" data-index="30" data-src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201123203735933-20230310132314109.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; s.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isValid(s, startIndex, i)) &#123; <span class="comment">// 判断 [startIndex,i] 这个区间的子串是否合法</span></span><br><span class="line">        s.insert(s.begin() + i + <span class="number">1</span> , <span class="string">'.'</span>);  <span class="comment">// 在i的后面插入一个逗点</span></span><br><span class="line">        pointNum++;</span><br><span class="line">        backtracking(s, i + <span class="number">2</span>, pointNum);   <span class="comment">// 插入逗点之后下一个子串的起始位置为i+2</span></span><br><span class="line">        pointNum--;                         <span class="comment">// 回溯</span></span><br><span class="line">        s.erase(s.begin() + i + <span class="number">1</span>);         <span class="comment">// 回溯删掉逗点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">break</span>; <span class="comment">// 不合法，直接结束本层循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> <a href="https://leetcode.cn/problems/subsets/" target="_blank" rel="noopener">78. 子集</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<p>数组的 <strong>子集</strong> 是从数组中选择一些元素（可能为空）。</p>
</blockquote>
<p>其实还是一个组合问题，和顺序无关。</p>
<p><strong>子集是收集树形结构中树的所有节点的结果</strong>。</p>
<p><strong>而组合问题、分割问题是收集树形结构中叶子节点的结果</strong>。</p>
<h4 id="解法一递归-2"><a class="markdownIt-Anchor" href="#解法一递归-2"></a> 解法一——递归</h4>
<h5 id="思路一每个元素有选和不选两个情况"><a class="markdownIt-Anchor" href="#思路一每个元素有选和不选两个情况"></a> 思路一——每个元素有选和不选两个情况</h5>
<p>递归的过程就是每次去掉一个数，再求子集。而每个元素又选和不选两个情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.size()) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.emplace_back(nums[start]);</span><br><span class="line">        backtracking(nums, start + <span class="number">1</span>);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        backtracking(nums, start + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; empty;</span></span><br><span class="line">        <span class="comment">// output.emplace_back(empty);</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="思路二遍历整个树的所有节点"><a class="markdownIt-Anchor" href="#思路二遍历整个树的所有节点"></a> 思路二——遍历整个树的所有节点</h5>
<p><img alt="78.子集" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/78.%E5%AD%90%E9%9B%86.png" data-index="31" data-src="/2024/03/30/LeetCode-problems/78.%E5%AD%90%E9%9B%86.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        output.emplace_back(temp);</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= nums.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// backtracking(nums, start + 1);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; empty;</span></span><br><span class="line">        <span class="comment">// output.emplace_back(empty);</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二枚举迭代"><a class="markdownIt-Anchor" href="#解法二枚举迭代"></a> 解法二——枚举迭代</h4>
<p>创建一个0，1的mask实现枚举，相当于一个二进制的数组和当前数组取<code>与</code>。</p>
<p>其中，<code>&lt;&lt;</code>是左移运算，每次乘2.</p>
<ul>
<li><code>1 &lt;&lt; numsSize</code>创建<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn><mo>∼</mo><msup><mn>2</mn><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mi>S</mi><mi>i</mi><mi>z</mi><mi>e</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">0\sim 2^{numsSize-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span><span class="mord mathdefault mtight">e</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>的二进制序列长度。</li>
<li><code>1 &lt;&lt; i</code>判断该mask下，这个数字要不要push进去。注意<code>1 &lt;&lt; 0</code>出来的是<code>001</code>，<code>1 &lt;&lt; 1</code>出来的是<code>010</code>，<code>1 &lt;&lt; 2</code>出来的是<code>100</code>，刚好与mask的各个位置吻合。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> numsSize = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; numsSize); mask++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    temp.emplace_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="90-子集-ii"><a class="markdownIt-Anchor" href="#90-子集-ii"></a> <a href="https://leetcode.cn/problems/subsets-ii/" target="_blank" rel="noopener">90. 子集 II</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的 子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
</blockquote>
<h4 id="解法一递归-3"><a class="markdownIt-Anchor" href="#解法一递归-3"></a> 解法一——递归</h4>
<p>套路类似“40. 组合总和 II”，先排序，如果和上一个相同的话，那就continue</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        output.emplace_back(temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>  (<span class="keyword">int</span> i = start; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            backtracking(nums, i + <span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二枚举迭代-2"><a class="markdownIt-Anchor" href="#解法二枚举迭代-2"></a> 解法二——枚举迭代</h4>
<p>mask需要考虑去重，i不需要考虑去重。</p>
<p>要加入一个判断<code>if (i &gt; 0 &amp;&amp; (mask &gt;&gt; (i - 1) &amp; 1) == 0 &amp;&amp; nums[i] == nums[i - 1])</code>，这个不好想啊！</p>
<p>对于当前选择的数<em>x</em>，若前面有与其相同的数 <em>y</em>，且没有选择 <em>y</em>，此时包含 <em>x</em> 的子集，必然会出现在包含 <em>y</em> 的所有子集中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numSize = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; numSize); mask++) &#123;</span><br><span class="line">            temp.clear();</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (mask &gt;&gt;(i<span class="number">-1</span>) &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp.emplace_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="491-非递减子序列"><a class="markdownIt-Anchor" href="#491-非递减子序列"></a> <a href="https://leetcode.cn/problems/non-decreasing-subsequences/" target="_blank" rel="noopener">491. 非递减子序列</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>
<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>
</blockquote>
<p>求自增子序列，是不能对原数组进行排序的，排完序的数组都是自增子序列了。所以和子集问题并不一样！！！</p>
<h4 id="解法一深搜"><a class="markdownIt-Anchor" href="#解法一深搜"></a> 解法一——深搜</h4>
<p>定义之前的最大值<code>last</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == nums.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[start] &gt;= last) &#123; <span class="comment">// 输入并递归</span></span><br><span class="line">            temp.emplace_back(nums[start]);</span><br><span class="line">            backtracking(nums, start + <span class="number">1</span>, nums[start]);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[start] != last) &#123;</span><br><span class="line">            backtracking(nums, start + <span class="number">1</span>, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        backtracking(nums, <span class="number">0</span>, INT_MIN);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二回溯set去重"><a class="markdownIt-Anchor" href="#解法二回溯set去重"></a> 解法二——回溯+set去重</h4>
<p>以下写法<code>if (i &gt; start &amp;&amp; nums[i] == nums[i-1])</code>是<strong>错误</strong>的，因为可能重复值并不出现在相邻元素，即使改成<code>if (i &gt; start &amp;&amp; nums[i] == last)</code>也不对，需要判断之前的所有元素才行。如测试用例<code>[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= last) &#123;</span><br><span class="line">                temp.emplace_back(nums[i]);</span><br><span class="line">                backtracking(nums, i+<span class="number">1</span>, nums[i]);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">            <span class="comment">//     backtracking(nums, i+1, last);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以需要用到set来记录之前的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        output.emplace_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; thisLayer;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123; <span class="comment">// 使用set对本层元素进行去重</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; thisLayer.find(nums[i]) != thisLayer.end()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= last) &#123;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            thisLayer.insert(nums[i]);</span><br><span class="line">            backtracking(nums, i+<span class="number">1</span>, nums[i]);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者用数组来作为哈希</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        output.emplace_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> thisLayer[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123; </span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; thisLayer[nums[i] + <span class="number">100</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= last) &#123;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            thisLayer[nums[i] + <span class="number">100</span>]++;</span><br><span class="line">            backtracking(nums, i+<span class="number">1</span>, nums[i]);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外可以不定义last元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> thisLayer[<span class="number">201</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.size(); i++)&#123; </span><br><span class="line">            <span class="keyword">if</span> ((!temp.empty() &amp;&amp; nums[i] &lt; temp.back()) || thisLayer[nums[i] + <span class="number">100</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            thisLayer[nums[i] + <span class="number">100</span>]++;</span><br><span class="line">            backtracking(nums, i+<span class="number">1</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">findSubsequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort(nums.begin(), nums.end());</span></span><br><span class="line">        backtracking(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="46-全排列"><a class="markdownIt-Anchor" href="#46-全排列"></a> <a href="https://leetcode.cn/problems/permutations/" target="_blank" rel="noopener">46. 全排列</a></h3>
<blockquote>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
</blockquote>
<p>排列问题</p>
<p>排列问题需要一个used数组，标记已经选择的元素，如图橘黄色部分所示:</p>
<p><img alt="46.全排列" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20211027181706.png" data-index="32" data-src="/2024/03/30/LeetCode-problems/20211027181706.png"></p>
<p>因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。<strong>而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次</strong>。</p>
<p>这里的used数组和非递减子集中的set含义非常像，虽然这边是用于标记是否使用过，上文是用于是否有重复元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.size()) &#123; <span class="comment">// 终止条件</span></span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span> <span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        backtracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="47-全排列-ii"><a class="markdownIt-Anchor" href="#47-全排列-ii"></a> <a href="https://leetcode.cn/problems/permutations-ii/" target="_blank" rel="noopener">47. 全排列 II</a></h3>
<blockquote>
<p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>
</blockquote>
<h4 id="解法一利用unordered_map"><a class="markdownIt-Anchor" href="#解法一利用unordered_map"></a> 解法一——利用<code>unordered_map</code></h4>
<p>相当于定义了一个hash表，存储每个数字(first，键)能用多少次(second，值)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,  <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.size()) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = used.begin(); p != used.end(); p++) &#123; </span><br><span class="line">            <span class="keyword">if</span> (p-&gt;second == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;second--;</span><br><span class="line">            temp.emplace_back(p-&gt;first);</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">            p-&gt;second++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; used;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            used[num] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        backtracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二利用used数组并对其限制条件"><a class="markdownIt-Anchor" href="#解法二利用used数组并对其限制条件"></a> 解法二——利用used数组，并对其限制条件</h4>
<p>只要设定一个规则，保证在填第idx 个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」</p>
<p>这里涉及两个条件，关系为“或”，第二个条件很好理解，用过了就不能用了，第一个条件有点难理解：</p>
<ul>
<li><code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false</code></li>
<li><code>used[i] == true</code></li>
</ul>
<p><code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == false</code>限制了从左到右填入的顺序，属于是“同层（树层）剪枝”</p>
<p><img alt="image-20240411144113495" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240411144113495.png" data-index="33" data-src="/2024/03/30/LeetCode-problems/image-20240411144113495.png"></p>
<p><img alt="47.全排列II2" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20201124201406192.png" data-index="34" data-src="/2024/03/30/LeetCode-problems/20201124201406192.png"></p>
<p>如果该作<code>i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &amp;&amp; used[i-1] == true</code>，则变成“不同层（树枝）剪枝”，情况复杂很多</p>
<img alt="image-20240411144439089" style="zoom:33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240411144439089.png" data-index="35" data-src="/2024/03/30/LeetCode-problems/image-20240411144439089.png">
<p><img alt="47.全排列II3" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20201124201431571.png" data-index="36" data-src="/2024/03/30/LeetCode-problems/20201124201431571.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums,  <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; &amp;used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.size() == nums.size()) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; "return " &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123; </span><br><span class="line">            <span class="comment">// for (bool jj:used) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; jj &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">if</span> ((i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>) || used[i] == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; "continue "&lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            temp.emplace_back(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(nums, used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        backtracking(nums, used);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="332-重新安排行程"><a class="markdownIt-Anchor" href="#332-重新安排行程"></a> <a href="https://leetcode.cn/problems/reconstruct-itinerary/" target="_blank" rel="noopener">332. 重新安排行程</a></h3>
<blockquote>
<p>给你一份航线列表 <code>tickets</code> ，其中 <code>tickets[i] = [fromi, toi]</code> 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。</p>
<p>所有这些机票都属于一个从 <code>JFK</code>（肯尼迪国际机场）出发的先生，所以该行程必须从 <code>JFK</code> 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。</p>
<ul>
<li>例如，行程 <code>[&quot;JFK&quot;, &quot;LGA&quot;]</code> 与 <code>[&quot;JFK&quot;, &quot;LGB&quot;]</code> 相比就更小，排序更靠前。</li>
</ul>
<p>假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。</p>
</blockquote>
<p>一个机场映射多个机场，同时由于字典顺序小的行程，所以需要里面套的是有序的map：两种表示</p>
<ul>
<li><code>unordered_map&lt;string, multiset&gt; targets</code>：<code>unordered_map&lt;出发机场, 到达机场的集合&gt; targets</code>遍历multiset不能删除元素</li>
<li><code>unordered_map&lt;string, map&lt;string, int&gt;&gt; targets</code>：<code>unordered_map&lt;出发机场, map&lt;到达机场, 航班次数&gt;&gt; targets</code>可以使用&quot;航班次数&quot;这个字段的数字做相应的增减，来标记到达机场是否使用过了。</li>
</ul>
<p>有几个点需要注意：</p>
<ul>
<li>最终的路径长度应该是比ticket长度要大1的</li>
<li>在使用迭代器遍历元素时候，如果要改变元素值，需要使用<code>&amp;</code>，即<code>for (auto &amp;p : airports[last])</code></li>
<li>vector，map元素遍历时候的写法要注意。<strong>难还难在容器的选择和使用上</strong></li>
<li>该题目的情况下，应该采用有返回值的回溯比较好。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&gt; airports;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span> <span class="params">(<span class="built_in">string</span> last, <span class="keyword">int</span> ticketsSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (output.size() == ticketsSize + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;p : airports[last]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.second !=  <span class="number">0</span>) &#123;</span><br><span class="line">                p.second--;</span><br><span class="line">                output.emplace_back(p.first);</span><br><span class="line">                <span class="keyword">if</span> (backtracking(p.first, ticketsSize)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                output.pop_back();</span><br><span class="line">                p.second++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findItinerary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; tickets)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ticketsSize = tickets.size();</span><br><span class="line">        <span class="comment">// 建立unordered_map存储一对多的机场关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p: tickets) &#123;</span><br><span class="line">            airports[p[<span class="number">0</span>]][p[<span class="number">1</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        output.emplace_back(<span class="string">"JFK"</span>);</span><br><span class="line">        backtracking(output.back(), ticketsSize);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="51-n-皇后"><a class="markdownIt-Anchor" href="#51-n-皇后"></a> <a href="https://leetcode.cn/problems/n-queens/" target="_blank" rel="noopener">51. N 皇后</a></h3>
<blockquote>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p><strong>n 皇后问题</strong> 研究的是如何将 <code>n</code> 个皇后放置在 <code>n×n</code> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 <code>n</code> ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>
<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 <code>'Q'</code> 和 <code>'.'</code> 分别代表了皇后和空位。</p>
</blockquote>
<p>根据题意暴力回溯即可，和代码随想录不同。</p>
<ul>
<li>利用 columns 数组记录每个皇后的位置，最后再构建棋盘</li>
<li>这样判断是否合理时候比较简单，只需要考虑列不同、左斜、右斜等几种情况即可。</li>
<li>其实还可以进一步简化，当第一行只需要一半即可，因为偶数时候必定有对称的情况，奇数时候除了第一行刚好为中间，其余也有对称情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; output;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; columns; <span class="comment">//n个位置，表示第n个皇后在第n行的第几个格子</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">temp</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">// if (!(n % 2) &amp;&amp; columns[0] == n / 2) &#123; // 奇数列情况，中间的情况是不能反转的</span></span><br><span class="line">                temp[i][columns[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// flag检测列标是否和前面元素冲突</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; n; column++) &#123; <span class="comment">//第row元素的列标, 一定有一个反转的情况成立</span></span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++) &#123; <span class="comment">// j表示前面的行</span></span><br><span class="line">                <span class="keyword">if</span> (columns[j] == column || (row - j) == (columns[j] - column) || (row - j) == - (columns[j] - column)) &#123; <span class="comment">// 列标重合，斜线</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123; <span class="comment">// 没问题，回溯</span></span><br><span class="line">                columns.emplace_back(column);</span><br><span class="line">                backtracking(n, row + <span class="number">1</span>);</span><br><span class="line">                columns.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="37-解数独"><a class="markdownIt-Anchor" href="#37-解数独"></a> <a href="https://leetcode.cn/problems/sudoku-solver/" target="_blank" rel="noopener">37. 解数独</a></h3>
<blockquote>
<p>编写一个程序，通过填充空格来解决数独问题。</p>
<p>数独的解法需 <strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。（请参考示例图）</li>
</ol>
<p>数独部分空格内已填入了数字，空白格用 <code>'.'</code> 表示。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= <span class="number">9</span> || column &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (board[row][column] &lt; <span class="string">'1'</span> || board[row][column] &gt; <span class="string">'9'</span>) &#123; <span class="comment">// 注意这里是或的关系</span></span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (num = <span class="number">1</span>; num &lt; <span class="number">10</span>; num++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; row &lt;&lt; " " &lt;&lt; column &lt;&lt; " " &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (isValid(board, row, column, num)) &#123;</span><br><span class="line">                    board[row][column] = num + <span class="string">'0'</span>;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; row &lt;&lt; " " &lt;&lt; column &lt;&lt; " " &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">if</span> (column == <span class="number">9</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (backtracking(board, row + <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="comment">// 换行</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (backtracking(board, row, column + <span class="number">1</span>)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125; <span class="comment">// 继续</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    board[row][column] = <span class="string">'.'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">10</span> &amp;&amp; board[row][column] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不能让一元素为.，说明前面是有错的, 注意已经自增过了，所以这里是10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (column == <span class="number">9</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(board, row + <span class="number">1</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// 换行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (backtracking(board, row, column + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="comment">// 继续</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; row &lt;&lt; " " &lt;&lt; column &lt;&lt; " " &lt;&lt; num &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123; <span class="comment">// 检查同一行</span></span><br><span class="line">            <span class="keyword">if</span> (board[row][i] - <span class="string">'0'</span> == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++) &#123; <span class="comment">// 检查同一列</span></span><br><span class="line">            <span class="keyword">if</span> (board[j][column] - <span class="string">'0'</span> == num) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> blockLeft = (column / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> blockTop = (row / <span class="number">3</span>) * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = blockLeft; i &lt; blockLeft + <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = blockTop; j &lt; blockTop + <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[j][i] - <span class="string">'0'</span> == num) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        backtracking(board, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码随想录的解答略有区别，主要是他直接把每个顶点的循环放在backtracking里面了，这样里面每一次跑都会进入两层for循环，如果有值就continue；此外循环可以直接通过<code>for (char k = '1'; k &lt;= '9'; k++)</code>来进行，就不需要补<code>+'0'</code>的操作了。</p>
<h2 id="贪心算法"><a class="markdownIt-Anchor" href="#贪心算法"></a> 贪心算法</h2>
<blockquote>
<p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优</strong>。</p>
<p>如何验证可不可以用贪心算法呢？<strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧</strong>。</p>
<p>贪心算法一般分为如下四步：</p>
<ul>
<li>将问题分解为若干个子问题</li>
<li>找出适合的贪心策略</li>
<li>求解每一个子问题的最优解</li>
<li>将局部最优解堆叠成全局最优解</li>
</ul>
<p><img alt="贪心算法大纲" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210917104315.png" data-index="37" data-src="/2024/03/30/LeetCode-problems/20210917104315.png"></p>
<p>区间类问题——先排序</p>
</blockquote>
<h3 id="455-分发饼干"><a class="markdownIt-Anchor" href="#455-分发饼干"></a> <a href="https://leetcode.cn/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h3>
<blockquote>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
</blockquote>
<h4 id="解法一两重for循环"><a class="markdownIt-Anchor" href="#解法一两重for循环"></a> 解法一——两重for循环</h4>
<p>优先满足胃口大的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> gStart = g.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 优先满足胃口大的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = gStart; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; s[i] &lt;&lt; " " &lt;&lt; g[j] &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] &gt;= g[j]) &#123;</span><br><span class="line">                    </span><br><span class="line">                    output++;</span><br><span class="line">                    gStart = j - <span class="number">1</span>; <span class="comment">// 从目前满足的下一个开始</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二一层for循环"><a class="markdownIt-Anchor" href="#解法二一层for循环"></a> 解法二——一层for循环</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        sort(g.begin(), g.end());</span><br><span class="line">        sort(s.begin(), s.end());</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sStart = s.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = g.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 优先满足胃口大的</span></span><br><span class="line">            <span class="keyword">if</span> (sStart &gt;= <span class="number">0</span> &amp;&amp; s[sStart] &gt;= g[i]) &#123;</span><br><span class="line">                output++;</span><br><span class="line">                sStart--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="376-摆动序列"><a class="markdownIt-Anchor" href="#376-摆动序列"></a> <a href="https://leetcode.cn/problems/wiggle-subsequence/" target="_blank" rel="noopener">376. 摆动序列</a></h3>
<blockquote>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， <code>[1, 7, 4, 9, 2, 5]</code> 是一个 <strong>摆动序列</strong> ，因为差值 <code>(6, -3, 5, -7, 3)</code> 是正负交替出现的。</li>
<li>相反，<code>[1, 4, 7, 2, 5]</code> 和 <code>[1, 7, 4, 5, 5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums</code> 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
</blockquote>
<ul>
<li>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列。</li>
<li>其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</li>
</ul>
<p>考虑的因素</p>
<ul>
<li>单调坡度只记录首尾</li>
<li>需要考虑平坡（两种情况）<br>
<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20230108174452.png" data-index="38" data-src="/2024/03/30/LeetCode-problems/20230108174452.png"></li>
<li>只有一个或两个元素——两个元素判断是否是平坡</li>
</ul>
<h4 id="解法一贪心"><a class="markdownIt-Anchor" href="#解法一贪心"></a> 解法一——贪心</h4>
<p>起点终点、平坡比较难判断。。。（还是没太想清楚，后面仔细想想）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index0, index1; </span><br><span class="line">        <span class="keyword">int</span> output = (nums[<span class="number">1</span>] - nums[<span class="number">0</span>] == <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">for</span> (index0 = <span class="number">0</span>, index1 = <span class="number">1</span>; index1 &lt; nums.size() - <span class="number">1</span>; index1++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" index0: "</span> &lt;&lt; nums[index0] &lt;&lt; <span class="string">" index1: "</span> &lt;&lt; nums[index1] &lt;&lt; <span class="string">" index2:"</span> &lt;&lt; nums[index1+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">" prev: "</span> &lt;&lt; (nums[index1] - nums[index0]) &lt;&lt; <span class="string">" curr: "</span> &lt;&lt; (nums[index1+<span class="number">1</span>] - nums[index1])&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (((nums[index1] - nums[index0]) * (nums[index1 + <span class="number">1</span>] - nums[index1]) &lt; <span class="number">0</span>) || ((nums[index1] - nums[index0]) == <span class="number">0</span>) &amp;&amp; (nums[index1 + <span class="number">1</span>] - nums[index1]) != <span class="number">0</span>) &#123; <span class="comment">//满足摆动</span></span><br><span class="line">                output++;</span><br><span class="line">                index0 = index1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划"><a class="markdownIt-Anchor" href="#解法二动态规划"></a> 解法二——动态规划</h4>
<p>考虑用动态规划的思想来解决这个问题。</p>
<ol>
<li><em>up</em>[<em>i</em>] 表示以前 <em>i</em> 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。</li>
<li><em>down</em>[<em>i</em>] 表示以前 <em>i</em> 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。</li>
</ol>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext> down </mtext><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">down</mi><mo>⁡</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">down</mi><mo>⁡</mo><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>≥</mo><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>u</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mtext> down </mtext><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo separator="true">,</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mtext> nums </mtext><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
&amp; u p[i]= \begin{cases}u p[i-1], &amp; \text { nums }[i] \leq n u m s[i-1] \\
\max (u p[i-1], \text { down }[i-1]+1), &amp; \text { nums }[i]&gt;\text { nums }[i-1]\end{cases} \\
&amp; \operatorname{down}[i]= \begin{cases}\operatorname{down}[i-1], &amp; \text { nums }[i] \geq \text { nums }[i-1] \\
\max (u p[i-1]+1, \text { down }[i-1]), &amp; \text { nums }[i]&lt;\text { nums }[i-1]\end{cases}
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.600059999999999em;vertical-align:-3.0500299999999996em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.5500299999999996em;"><span style="top:-5.55003em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0500299999999996em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.5500299999999996em;"><span style="top:-5.55003em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> down </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.75em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">n</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop"><span class="mord mathrm">d</span><span class="mord mathrm">o</span><span class="mord mathrm" style="margin-right:0.01389em;">w</span><span class="mord mathrm">n</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">u</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord"> down </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord"> nums </span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.0500299999999996em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>仅需要前一个状态来进行转移，所以我们维护两个变量即可。</p>
<p>——官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numSize = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (numSize &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> numSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; up(numSize) ;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; down(numSize);</span><br><span class="line">        up[<span class="number">0</span>] = down[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123; <span class="comment">// 比上一个大</span></span><br><span class="line">                up[i] = max(up[i<span class="number">-1</span>], down[i<span class="number">-1</span>] + <span class="number">1</span>); <span class="comment">//上摆情况是在“上一元素上摆”和“上一元素下摆的基础上加上这个元素上摆”</span></span><br><span class="line">                down[i] = down[i<span class="number">-1</span>]; <span class="comment">// 加入这个元素不能组成下摆</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123; <span class="comment">// 比上一个元素小，不可能上摆</span></span><br><span class="line">                down[i] = max(down[i<span class="number">-1</span>], up[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 相等</span></span><br><span class="line">                up[i] = up[i<span class="number">-1</span>];</span><br><span class="line">                down[i] = down[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(up[numSize<span class="number">-1</span>], down[numSize<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>仅需要前一个状态来进行转移，所以我们维护两个变量即可。每有一个「峰」到「谷」的下降趋势，<em>down</em> 值才会增加，每有一个「谷」到「峰」的上升趋势，<em>up</em> 值才会增加。且过程中 <em>down</em> 与 <em>up</em> 的差的绝对值值恒不大于 1，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numSize = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (numSize &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> numSize;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">1</span>, down = <span class="number">1</span>; <span class="comment">//长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」 之和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; numSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123; <span class="comment">// 比上一个大</span></span><br><span class="line">                up =  down + <span class="number">1</span>); <span class="comment">//上摆情况是在“上一元素上摆”和“上一元素下摆的基础上加上这个元素上摆”</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123; <span class="comment">// 比上一个元素小，不可能上摆</span></span><br><span class="line">                down =  up + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(up, down);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="53-最大子数组和"><a class="markdownIt-Anchor" href="#53-最大子数组和"></a> <a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。<strong>子数组</strong> 是数组中连续的 <strong>非空</strong> 元素序列。</p>
</blockquote>
<h4 id="解法一贪心-2"><a class="markdownIt-Anchor" href="#解法一贪心-2"></a> 解法一——贪心</h4>
<p>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。</p>
<p>全局最优：选取最大“连续和”</p>
<p><strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。</p>
<p>注意“连续和”为负数的时候前一个数字一定为负数，所以应该要舍弃。其关键在于：<strong>不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> output = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; output) &#123;</span><br><span class="line">                output = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-2"><a class="markdownIt-Anchor" href="#解法二动态规划-2"></a> 解法二——动态规划</h4>
<p>其实和贪心的思路很类似，只是把sum变成了dp数组。但是思路比贪心好想。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> output = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>] + nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; output) &#123;</span><br><span class="line">                output = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机-ii"><a class="markdownIt-Anchor" href="#122-买卖股票的最佳时机-ii"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h3>
<blockquote>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
</blockquote>
<h4 id="解法一贪心-3"><a class="markdownIt-Anchor" href="#解法一贪心-3"></a> 解法一——贪心</h4>
<p><strong>其实最终利润是可以分解的，那么本题就很容易了！</strong></p>
<p>假如第 0 天买入，第 3 天卖出，那么利润为：<code>prices[3] - prices[0]</code>。相当于<code>(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])</code>。<strong>此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！</strong></p>
<p>但是不同的天的是可以叠加的。所以可以一天一天的利润考虑，只要有利润&gt;0就买。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> profitDay = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            profitDay = prices[i] - prices[i<span class="number">-1</span>];           </span><br><span class="line">            <span class="keyword">if</span> (profitDay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                output += profitDay;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-3"><a class="markdownIt-Anchor" href="#解法二动态规划-3"></a> 解法二——动态规划</h4>
<ul>
<li><code>dp[i][0]</code> 表示第i天持有股票所得现金。</li>
<li><code>dp[i][1]</code> 表示第i天不持有股票所得最多现金</li>
</ul>
<p>如果第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>天持有股票即<code>dp[i][0]</code>， 那么可以由两个状态推出来</p>
<ul>
<li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：<code>dp[i - 1][0]</code></li>
<li>第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：<code>dp[i - 1][1] - prices[i]</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>]; <span class="comment">// 第0天持有股票目前的利润</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 第0天不持有股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 第i-1天有股票不动，或第i-1天没有股票买进</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]); <span class="comment">// 第i-1天没有股票不动，或第i-1天有股票卖出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size()<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="55-跳跃游戏"><a class="markdownIt-Anchor" href="#55-跳跃游戏"></a> <a href="https://leetcode.cn/problems/jump-game/" target="_blank" rel="noopener">55. 跳跃游戏</a></h3>
<blockquote>
<p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<p>**转化为跳跃覆盖范围究竟可不可以覆盖到终点！**每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numSize = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxIndex &amp;&amp; i &lt; numSize; i++) &#123;</span><br><span class="line">            maxIndex = max(maxIndex, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (maxIndex &gt;= numSize - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="45-跳跃游戏-ii"><a class="markdownIt-Anchor" href="#45-跳跃游戏-ii"></a> <a href="https://leetcode.cn/problems/jump-game-ii/" target="_blank" rel="noopener">45. 跳跃游戏 II</a></h3>
<blockquote>
<p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p>
<p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p>
<ul>
<li><code>0 &lt;= j &lt;= nums[i]</code></li>
<li><code>i + j &lt; n</code></li>
</ul>
<p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p>
</blockquote>
<p>生成到每个位置所需的最少跳跃次数。每个位置的最少跳跃次数是连续的。只要每一次在这个最小跳跃次数覆盖范围内找下一次的覆盖范围即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minJump = <span class="number">0</span>; <span class="comment">//记录当前位置需要最少几次跳跃到达</span></span><br><span class="line">        <span class="keyword">int</span> maxIndex = <span class="number">0</span>; <span class="comment">//记录当前能到达的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> premaxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(premaxIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                minJump++;</span><br><span class="line">                premaxIndex = maxIndex - i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + i &gt; maxIndex) &#123; <span class="comment">// 可以更新maxIndex</span></span><br><span class="line">                maxIndex = nums[i] + i;</span><br><span class="line">            &#125;</span><br><span class="line">            premaxIndex--;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; minJump &lt;&lt; " " &lt;&lt; maxIndex &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minJump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另一个思路</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxJump = <span class="number">0</span>; <span class="comment">// 最远到</span></span><br><span class="line">        <span class="keyword">int</span> jumpTimes = <span class="number">0</span>; <span class="comment">// 目前的位置要跳几次</span></span><br><span class="line">        <span class="keyword">int</span> preMaxJump = <span class="number">0</span>; <span class="comment">// 上一次最远到</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= preMaxJump) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + i &gt; maxJump) &#123; <span class="comment">// 能跳的比目前的远</span></span><br><span class="line">                    maxJump = nums[i] + i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                jumpTimes++;</span><br><span class="line">                preMaxJump = maxJump;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + i &gt; maxJump) &#123; <span class="comment">// 能跳的比目前的远</span></span><br><span class="line">                    maxJump = nums[i] + i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpTimes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1005-k-次取反后最大化的数组和"><a class="markdownIt-Anchor" href="#1005-k-次取反后最大化的数组和"></a> <a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/" target="_blank" rel="noopener">1005. K 次取反后最大化的数组和</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，按以下方法修改该数组：</p>
<ul>
<li>选择某个下标 <code>i</code> 并将 <code>nums[i]</code> 替换为 <code>-nums[i]</code> 。</li>
</ul>
<p>重复这个过程恰好 <code>k</code> 次。可以多次选择同一个下标 <code>i</code> 。</p>
<p>以这种方式修改数组后，返回数组 <strong>可能的最大和</strong></p>
</blockquote>
<h4 id="解法一逻辑复杂的分类讨论"><a class="markdownIt-Anchor" href="#解法一逻辑复杂的分类讨论"></a> 解法一——逻辑复杂的分类讨论</h4>
<p>分三种情况：</p>
<ul>
<li>负数：①负数个数&gt;=k，②负数个数&lt;k</li>
<li>0：有无0</li>
<li>正数</li>
</ul>
<p>其实0和负数可以统一考虑，当非正数&lt;k时，倒数的那个数字反转剩余次数即可。</p>
<p>先排序，优先反转小的负数，这里考虑的一些情况：</p>
<ul>
<li>负数或0：k用完没有？用完了那就只能是负数了</li>
<li>正数：k还有没有没用完，只需要考虑模2为1的情况，也就是得翻转一个数的情况，没用完有两种情况
<ul>
<li>前面有负数，且那个负数绝对值比正数最小的要小，反转最大的负数</li>
<li>前面没有负数了，或者负数绝对值比正数最小的要大，反转最小的正数</li>
</ul>
</li>
<li>还有一个情况，全是负数，那么可能出现出循环k还没用完的情况，那需要考虑是否需要反转最大的负数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">bool</span> flagNotPositive = <span class="literal">true</span>; <span class="comment">//非正数</span></span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    output -= nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    output += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (flagNotPositive == <span class="literal">true</span>) &#123;</span><br><span class="line">                    flagNotPositive = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; -nums[i<span class="number">-1</span>] &lt; nums[i] ) &#123;</span><br><span class="line">                            output += <span class="number">2</span> * nums[i<span class="number">-1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            output -= <span class="number">2</span> * nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                output += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; nums[i] &lt;&lt; " " &lt;&lt; output &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; k % <span class="number">2</span> == <span class="number">1</span> &amp;&amp;  nums[nums.size()<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            output += <span class="number">2</span> * nums[nums.size()<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二贪心"><a class="markdownIt-Anchor" href="#解法二贪心"></a> 解法二——贪心</h4>
<p>这里思路和我最大的不同就是按照绝对值大小排序。。。能减轻很多负担</p>
<ul>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<p>两次贪心：</p>
<ul>
<li>局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。</li>
<li>一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。局部最优：只找数值最小的正整数进行反转，当前数值和可以达到最大，全局最优：整个 数组和 达到最大。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort (nums.begin(), nums.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> &amp;&amp; k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = - nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            output += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            output -= <span class="number">2</span> * nums[nums.size()<span class="number">-1</span>]; <span class="comment">// 不管最后一个数原本是正负均成立，因为转成正数了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="134-加油站"><a class="markdownIt-Anchor" href="#134-加油站"></a> <a href="https://leetcode.cn/problems/gas-station/" target="_blank" rel="noopener">134. 加油站</a></h3>
<blockquote>
<p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
</blockquote>
<h4 id="解法一暴力解法一点点优化"><a class="markdownIt-Anchor" href="#解法一暴力解法一点点优化"></a> 解法一——暴力解法+一点点优化</h4>
<p>如果x到达不了y+1，那么x-y之间的点也不可能到达y+1，因为中间任何一点的油都是拥有前面的余量的，所以下次遍历直接从y+1开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = gas.size();</span><br><span class="line">        <span class="comment">// if (accumulate(gas.begin(), gas.end(), 0) &lt; accumulate(gas.begin(), gas.end(), 0)) &#123;</span></span><br><span class="line">        <span class="comment">//     return -1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> gasSum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> station = (i + j) % n;</span><br><span class="line">                gasSum = gasSum + gas[station] - cost[station];</span><br><span class="line">                <span class="keyword">if</span> (gasSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; "break" &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt;  station &lt;&lt; " " &lt;&lt; gasSum &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == n) &#123; <span class="comment">// 说明转完一圈了</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i + j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二贪心-2"><a class="markdownIt-Anchor" href="#解法二贪心-2"></a> 解法二——贪心</h4>
<p>首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p>
<p>局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gas.size(); i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            totalSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;   <span class="comment">// 当前累加rest[i]和 curSum一旦小于0</span></span><br><span class="line">                start = i + <span class="number">1</span>;  <span class="comment">// 起始位置更新为i+1</span></span><br><span class="line">                curSum = <span class="number">0</span>;     <span class="comment">// curSum从0开始</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 说明怎么走都不可能跑一圈了</span></span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>——代码随想录</p>
<h3 id="135-分发糖果"><a class="markdownIt-Anchor" href="#135-分发糖果"></a> <a href="https://leetcode.cn/problems/candy/" target="_blank" rel="noopener">135. 分发糖果</a></h3>
<blockquote>
<p><code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 <code>1</code> 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
</blockquote>
<h4 id="解法一两次贪心"><a class="markdownIt-Anchor" href="#解法一两次贪心"></a> 解法一——两次贪心</h4>
<p>两次贪心的策略：</p>
<ul>
<li>一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</li>
<li>一次是从右到左遍历，只比较左边孩子评分比右边大的情况。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">candys</span><span class="params">(ratings.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.size(); i++) &#123;<span class="comment">//从左到右贪心</span></span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                candys[i] = candys[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = ratings.size() - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;<span class="comment">// 从右往左贪心，注意更新值的时候比较的值要已经更新过了</span></span><br><span class="line">            <span class="keyword">if</span> (ratings[j] &gt; ratings[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                candys[j] = max(candys[j] , candys[j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> accumulate(candys.begin(), candys.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二常数空间遍历"><a class="markdownIt-Anchor" href="#解法二常数空间遍历"></a> 解法二——常数空间遍历</h4>
<p>我们从左到右枚举每一个同学，记前一个同学分得的糖果数量为 pre：</p>
<ul>
<li>如果当前同学比上一个同学评分高，说明我们就在最近的递增序列中，直接分配给该同学 pre+1 个糖果即可。<br>
<img alt="fig1" style="zoom:33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/1.png" data-index="39" data-src="/2024/03/30/LeetCode-problems/1.png"></li>
<li>否则我们就在一个递减序列中，我们直接分配给当前同学一个糖果，并把该同学所在的递减序列中所有的同学都再多分配一个糖果，以保证糖果数量还是满足条件。
<ul>
<li>我们无需显式地额外分配糖果，只需要记录当前的递减序列长度，即可知道需要额外分配的糖果数量。<br>
<img alt="fig2" style="zoom: 33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/2.png" data-index="40" data-src="/2024/03/30/LeetCode-problems/2.png"></li>
<li>同时注意当当前的递减序列长度和上一个递增序列等长时，需要把最近的递增序列的最后一个同学也并进递减序列中。<br>
<img alt="fig3" style="zoom: 33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/3.png" data-index="41" data-src="/2024/03/30/LeetCode-problems/3.png"></li>
</ul>
</li>
</ul>
<p>我们只要记录当前递减序列的长度 dec，最近的递增序列的长度 inc 和前一个同学分得的糖果数量 pre 即可。</p>
<p>——力扣官方题解</p>
<p>可以同时考虑两边的问题，只是右边的问题通过前面递减序列加1得到。（真的想不到啊）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dec = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> inc = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ratings.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                dec = <span class="number">0</span>;</span><br><span class="line">                output += ++pre;</span><br><span class="line">                inc = pre;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ratings[i] == ratings[i<span class="number">-1</span>]) &#123; <span class="comment">//相等=》归一</span></span><br><span class="line">                dec = <span class="number">0</span>;</span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">                output += pre;</span><br><span class="line">                inc = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//小于</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; " A " &lt;&lt; dec &lt;&lt; " B " &lt;&lt; inc &lt;&lt; " ";</span></span><br><span class="line">                dec ++;</span><br><span class="line">                <span class="keyword">if</span> (dec == inc) &#123; <span class="comment">// 合并入最后一个上升节点</span></span><br><span class="line">                    dec ++;</span><br><span class="line">                &#125;</span><br><span class="line">                output += dec; <span class="comment">//而非pre，因为最新加入的这个元素一定是1，但是递减序列中前面的元素还需要+1</span></span><br><span class="line">                pre = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; output &lt;&lt; " ";</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="860-柠檬水找零"><a class="markdownIt-Anchor" href="#860-柠檬水找零"></a> <a href="https://leetcode.cn/problems/lemonade-change/" target="_blank" rel="noopener">860. 柠檬水找零</a></h3>
<blockquote>
<p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 <code>bills</code> ，其中 <code>bills[i]</code> 是第 <code>i</code> 位顾客付的账。如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
</blockquote>
<p>账单是20的情况，为什么要优先消耗一个10和一个5呢？<strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p>
<p>局部最优：遇到账单20，优先消耗美元10，完成本次找零。</p>
<p>全局最优：完成全部账单的找零。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">lemonadeChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> note5 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> note10 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bills.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bills[i] == <span class="number">5</span>) &#123;</span><br><span class="line">                note5 ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                note5 --;</span><br><span class="line">                note10 ++;</span><br><span class="line">                <span class="keyword">if</span> (note5 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 20 dollar</span></span><br><span class="line">                <span class="keyword">if</span> (note10 &gt; <span class="number">0</span> &amp;&amp; note5 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    note10--;</span><br><span class="line">                    note5--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (note5 &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    note5 = note5 - <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="406-根据身高重建队列"><a class="markdownIt-Anchor" href="#406-根据身高重建队列"></a> <a href="https://leetcode.cn/problems/queue-reconstruction-by-height/" target="_blank" rel="noopener">406. 根据身高重建队列</a></h3>
<blockquote>
<p>假设有打乱顺序的一群人站成一个队列，数组 <code>people</code> 表示队列中一些人的属性（不一定按顺序）。每个 <code>people[i] = [hi, ki]</code> 表示第 <code>i</code> 个人的身高为 <code>hi</code> ，前面 <strong>正好</strong> 有 <code>ki</code> 个身高大于或等于 <code>hi</code> 的人。</p>
<p>请你重新构造并返回输入数组 <code>people</code> 所表示的队列。返回的队列应该格式化为数组 <code>queue</code> ，其中 <code>queue[j] = [hj, kj]</code> 是队列中第 <code>j</code> 个人的属性（<code>queue[0]</code> 是排在队列前面的人）。</p>
</blockquote>
<p>在按照身高从大到小排序后：</p>
<p><strong>局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性</strong></p>
<p><strong>全局最优：最后都做完插入操作，整个队列满足题目队列属性</strong></p>
<h4 id="解法一插入用数组"><a class="markdownIt-Anchor" href="#解法一插入用数组"></a> 解法一——插入用数组</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &gt; y[<span class="number">0</span>] || (x[<span class="number">0</span>] == y[<span class="number">0</span>] &amp;&amp; x[<span class="number">1</span>] &lt; y [<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 保证这个元素前面的值比他大或相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">reconstructQueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> peopleSize = people.size();</span><br><span class="line">        <span class="comment">// 先考虑身高，前面的都比他大或者相等，相等的时候k越小越靠前</span></span><br><span class="line">        sort (people.begin(), people.end(), cmp);</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; peopleSize; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; "[" &lt;&lt; people[i][0] &lt;&lt; "," &lt;&lt; people[i][1] &lt;&lt; "],";</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 只需要按照k为下标重新插入队列即可，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleSize; i++) &#123;</span><br><span class="line">            Q.insert(Q.begin() + people[i][<span class="number">1</span>], people[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二插入用链表"><a class="markdownIt-Anchor" href="#解法二插入用链表"></a> 解法二——插入用链表</h4>
<p>list内部使用链表实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &gt; y[<span class="number">0</span>] || (x[<span class="number">0</span>] == y[<span class="number">0</span>] &amp;&amp; x[<span class="number">1</span>] &lt; y [<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 保证这个元素前面的值比他大或相等</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">reconstructQueue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; people)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> peopleSize = people.size();</span><br><span class="line">        <span class="comment">// 先考虑身高，前面的都比他大或者相等，相等的时候k越小越靠前</span></span><br><span class="line">        sort (people.begin(), people.end(), cmp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只需要按照k为下标重新插入队列即可，优先按身高高的people的k来插入，后序插入节点也不会影响前面已经插入的节点</span></span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; peopleSize; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">list</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = Q.begin();</span><br><span class="line">            <span class="keyword">while</span> (position--) &#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            Q.insert(it, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; (Q.begin(), Q.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="452-用最少数量的箭引爆气球"><a class="markdownIt-Anchor" href="#452-用最少数量的箭引爆气球"></a> <a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/" target="_blank" rel="noopener">452. 用最少数量的箭引爆气球</a></h3>
<blockquote>
<p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 <code>points</code> ，其中<code>points[i] = [xstart, xend]</code> 表示水平直径在 <code>xstart</code> 和 <code>xend</code>之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 <code>x</code> 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>xstart</code>，<code>xend</code>， 且满足  <code>xstart ≤ x ≤ xend</code>，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 <code>points</code> ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。</p>
</blockquote>
<p>思路就是先排序，先按照start从小到大排序，如果start相等则按照end从小到大排序。</p>
<p>然后遍历每个point，找当前遍历过的所有点里哪个end最小，一旦一个点的start超过了这个最小的end，那就不得不射一箭了。射完箭以后minEnd需要重置。</p>
<p>最后要补射一箭，因为最后一个区间没有射箭呢。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">0</span>] == y[<span class="number">0</span>]) &#123;<span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];&#125;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>]; <span class="comment">// 小的在前</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        sort (points.begin(), points.end());</span><br><span class="line">        <span class="keyword">int</span> arrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minEnd = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">1</span>] &lt; minEnd) &#123; <span class="comment">// 当前的end比之前的end还要小</span></span><br><span class="line">                minEnd = points[i][<span class="number">1</span>];  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; minEnd) &#123; <span class="comment">//start坐标大于之前的最小的end，必须射箭</span></span><br><span class="line">                arrow++;</span><br><span class="line">                minEnd = points[i][<span class="number">1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrow + <span class="number">1</span>; <span class="comment">// 最后一部分没有射箭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="435-无重叠区间"><a class="markdownIt-Anchor" href="#435-无重叠区间"></a> <a href="https://leetcode.cn/problems/non-overlapping-intervals/" target="_blank" rel="noopener">435. 无重叠区间</a></h3>
<blockquote>
<p>给定一个区间的集合 <code>intervals</code> ，其中 <code>intervals[i] = [starti, endi]</code> 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
</blockquote>
<p>思路——排序加哈希表</p>
<p>先按照每个区间的长度排序，区间长度一致按照start从小到大。然后再建立哈希表保存左闭右开区间的元素。</p>
<p>这个思路是错误的，并不是说区间长度越小越不容易造成重叠的。</p>
<p>【反例】万一有这么一组数字<code>[[-100,1],[1,2],[2,3],[3,100],[-3,7]]</code>。按照以上的逻辑会首先排成<code>[[1,2],[2,3],[-3,7],[-100,1],[3,100]]</code>，然后得到的结果应该去除<code>[-100,1],[3,100]</code>这两个，保留以下三个<code>[1,2],[2,3],[-3,7]</code>。然后正确的应该是保留四个<code>[1,2],[2,3],[-100,1],[3,100]</code>，去除一个<code>[-3,7]</code></p>
<p>想复杂了，其实和452是一样的！！！</p>
<h4 id="解法一贪心左边缘"><a class="markdownIt-Anchor" href="#解法一贪心左边缘"></a> 解法一——贪心+左边缘</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (x[0] == y[0]) &#123;</span></span><br><span class="line">        <span class="comment">//     return x[1] &lt; y[1];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> erase = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &lt; minEnd) &#123;</span><br><span class="line">                erase++;</span><br><span class="line">                <span class="keyword">if</span> (intervals[i][<span class="number">1</span>] &lt; minEnd) &#123;</span><br><span class="line">                    minEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//大于之前的区间了，重新计数</span></span><br><span class="line">                minEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> erase;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二贪心右边缘"><a class="markdownIt-Anchor" href="#解法二贪心右边缘"></a> 解法二——贪心+右边缘</h4>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20230201164134.png" data-index="42" data-src="/2024/03/30/LeetCode-problems/20230201164134.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (x[0] == y[0]) &#123;</span></span><br><span class="line">        <span class="comment">//     return x[1] &lt; y[1];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">1</span>] &lt; y[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">//非重叠区间至少有一个</span></span><br><span class="line">        <span class="keyword">int</span> minEnd = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= minEnd) &#123;</span><br><span class="line">                count++;                </span><br><span class="line">                minEnd = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.size() - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="763-划分字母区间"><a class="markdownIt-Anchor" href="#763-划分字母区间"></a> <a href="https://leetcode.cn/problems/partition-labels/" target="_blank" rel="noopener">763. 划分字母区间</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p>
<p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p>
<p>返回一个表示每个字符串片段的长度的列表。</p>
</blockquote>
<p>在遍历的过程中相当于是要找每一个字母的边界，<strong>如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了</strong>。此时前面出现过所有字母，最远也就到这个边界了。</p>
<p>记录下每个字母出现的end位置，从前往后遍历，当前字母的end位置更加靠后了，更新maxEnd，如果end更前则不用管。当走到maxEnd的时候，分割这个片段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> alphabet[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 记录每个字母出现的end位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            alphabet[s[i] - <span class="string">'a'</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxEnd = alphabet[s[<span class="number">0</span>] - <span class="string">'a'</span>]; <span class="comment">//当前片段目前能够分割的最后位置</span></span><br><span class="line">        <span class="keyword">int</span> prevEnd = <span class="number">-1</span>; <span class="comment">// 上一次的end（不含）</span></span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (alphabet[s[i] - <span class="string">'a'</span>] &gt; maxEnd) &#123;</span><br><span class="line">                maxEnd = alphabet[s[i] - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == maxEnd) &#123;</span><br><span class="line">                output.emplace_back(maxEnd - prevEnd);</span><br><span class="line">                prevEnd = maxEnd;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="56-合并区间"><a class="markdownIt-Anchor" href="#56-合并区间"></a> <a href="https://leetcode.cn/problems/merge-intervals/" target="_blank" rel="noopener">56. 合并区间</a></h3>
<blockquote>
<p>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x[<span class="number">0</span>] &lt; y[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort (intervals.begin(), intervals.end(), cmp);</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        temp[<span class="number">0</span>] = intervals[<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//当前区间左边缘</span></span><br><span class="line">        temp[<span class="number">1</span>] = intervals[<span class="number">0</span>][<span class="number">1</span>];<span class="comment">//当前区间右边缘（含）</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; temp[<span class="number">1</span>]) &#123; <span class="comment">// 保存上一个区间</span></span><br><span class="line">                output.emplace_back(temp);</span><br><span class="line">                temp = intervals[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// 左边缘小于等于当前右边缘</span></span><br><span class="line">                temp[<span class="number">1</span>] = max(temp[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output.emplace_back(temp); <span class="comment">// 保存最后一个区间</span></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="738-单调递增的数字"><a class="markdownIt-Anchor" href="#738-单调递增的数字"></a> <a href="https://leetcode.cn/problems/monotone-increasing-digits/" target="_blank" rel="noopener">738. 单调递增的数字</a></h3>
<blockquote>
<p>当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 <code>n</code> ，返回 <em>小于或等于 <code>n</code> 的最大数字，且数字呈 <strong>单调递增</strong></em> 。</p>
</blockquote>
<p>n / 10 * 10 - 1 最后一位必然是9，比别的大或等于，所以可以不考虑最后一位。只考虑前几位即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIncreaseingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> prev = n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; n%10 &lt;&lt; " " &lt;&lt; prev &lt;&lt;" ";</span></span><br><span class="line">            <span class="keyword">if</span> (n % <span class="number">10</span> &gt; prev) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = n % <span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">10</span> || isIncreaseingDigits(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prev = n; <span class="comment">// 前缀部分，每次只需要判断前缀是否为单调递增即可，因为最后一位必然是9.</span></span><br><span class="line">        <span class="keyword">int</span> divideTime = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isIncreaseingDigits(prev - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// n / 10 * 10 - 1 最后一位必然是9，比别的大或等于，所以可以不考虑最后一位。</span></span><br><span class="line">            prev = prev / <span class="number">10</span>;</span><br><span class="line">            divideTime++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(divideTime != <span class="number">0</span>)&#123;</span><br><span class="line">            prev *= <span class="number">10</span>;</span><br><span class="line">            divideTime--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> prev - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>代码随想录的方法使用字符串操作。</p>
<h3 id="968-监控二叉树"><a class="markdownIt-Anchor" href="#968-监控二叉树"></a> <a href="https://leetcode.cn/problems/binary-tree-cameras/" target="_blank" rel="noopener">968. 监控二叉树</a></h3>
<blockquote>
<p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
</blockquote>
<p>深度优先，后序遍历</p>
<p>两个注意点：</p>
<ul>
<li>空节点命名为哪个状态，应当是<code>1</code>已经覆盖，因为叶子节点实际上并不需要单独的摄像头</li>
<li>根节点返回0的情况，即根节点还没有摄像头覆盖，需要+1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">inorder</span> <span class="params">(TreeNode* p, <span class="keyword">int</span> &amp;numCamera)</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// 0: 未覆盖； 1: 已覆盖； 2: 摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = inorder(p-&gt;left, numCamera);</span><br><span class="line">        <span class="keyword">int</span> right = inorder(p-&gt;right, numCamera);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123; <span class="comment">// 包含00，01，10，02，20</span></span><br><span class="line">            numCamera++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 摄像头</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">2</span> || right == <span class="number">2</span>) &#123; <span class="comment">// 包含22，21，12</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 已经覆盖</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//11</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numCamera = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inorder(root, numCamera) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> numCamera + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numCamera;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<blockquote>
<p>动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，<strong>这一点就区分于贪心</strong>，贪心没有状态推导，而是从局部直接选最优的。</p>
<p>大家知道动规是由<strong>前一个状态</strong>推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。</p>
<p>动态规划问题：</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<img alt="img" style="zoom:33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/动态规划-总结大纲1.jpg" data-index="43" data-src="/2024/03/30/LeetCode-problems/动态规划-总结大纲1.jpg">
<ul>
<li>只是求排列组合数时候可以用动规，但是要给出所有答案得用回溯。</li>
</ul>
<p>背包问题</p>
<p><img alt="416.分割等和子集1" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20230310000726.png" data-index="44" data-src="/2024/03/30/LeetCode-problems/20230310000726.png"></p>
</blockquote>
<h3 id="509-斐波那契数"><a class="markdownIt-Anchor" href="#509-斐波那契数"></a> <a href="https://leetcode.cn/problems/fibonacci-number/" target="_blank" rel="noopener">509. 斐波那契数</a></h3>
<blockquote>
<p><strong>斐波那契数</strong> （通常用 <code>F(n)</code> 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) &#x3D; 0，F(1) &#x3D; 1</span><br><span class="line">F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给定 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
</blockquote>
<h4 id="解法一直接递推"><a class="markdownIt-Anchor" href="#解法一直接递推"></a> 解法一——直接递推</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> prev0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">1</span>) &#123;</span><br><span class="line">            temp = prev0 + prev1;</span><br><span class="line">            prev0 = prev1;</span><br><span class="line">            prev1 = temp;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-4"><a class="markdownIt-Anchor" href="#解法二动态规划-4"></a> 解法二——动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="70-爬楼梯"><a class="markdownIt-Anchor" href="#70-爬楼梯"></a> <a href="https://leetcode.cn/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h3>
<blockquote>
<p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p>
<p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">46</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 上1楼只有一种方式</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">//上2楼有两种方式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]; <span class="comment">// 上到这个楼层有两个方式，一个台阶、两个台阶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="746-使用最小花费爬楼梯"><a class="markdownIt-Anchor" href="#746-使用最小花费爬楼梯"></a> <a href="https://leetcode.cn/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">746. 使用最小花费爬楼梯</a></h3>
<blockquote>
<p>给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>
<p>你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p>
<p>请你计算并返回达到楼梯顶部的最低花费。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; cost.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// 到第二层有两种方式：下标0直接2步上来，下标1一步上来</span></span><br><span class="line">            dp[<span class="number">2</span>] = min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]) + cost[i];</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">1</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="62-不同路径"><a class="markdownIt-Anchor" href="#62-不同路径"></a> <a href="https://leetcode.cn/problems/unique-paths/" target="_blank" rel="noopener">62. 不同路径</a></h3>
<blockquote>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/1697422740-adxmsI-image.png" data-index="45" data-src="/2024/03/30/LeetCode-problems/1697422740-adxmsI-image.png"></p>
</blockquote>
<h4 id="解法一动态规划硬解"><a class="markdownIt-Anchor" href="#解法一动态规划硬解"></a> 解法一——动态规划硬解</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">roadMap</span> <span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        roadMap[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    roadMap[i][j] = roadMap[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    roadMap[i][j] = roadMap[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    roadMap[i][j] = roadMap[i - <span class="number">1</span>][j] + roadMap[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roadMap[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改一下，更简单、更快一点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">roadMap</span> <span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n,<span class="number">0</span>))</span></span>;</span><br><span class="line">        roadMap[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                    roadMap[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    roadMap[i][j] = roadMap[i - <span class="number">1</span>][j] + roadMap[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> roadMap[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二数论方法"><a class="markdownIt-Anchor" href="#解法二数论方法"></a> 解法二——数论方法</h4>
<p>组合问题</p>
<p>无论怎么走，走到终点都需要 <code>m + n - 2</code> 步，一定有<code>m - 1</code>要往下走，那么就需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold">C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">\mathbf C_{m+n-2}^{m-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.324639em;"></span><span class="mord"><span class="mord mathbf">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.854239em;"><span style="top:-2.433692em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.1031310000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.324639em;"><span></span></span></span></span></span></span></span></span></span>​次</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mi mathvariant="bold">A</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msubsup><mi mathvariant="bold">C</mi><mi>n</mi><mi>m</mi></msubsup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mi>m</mi><mo stretchy="false">!</mo></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{gathered}
\mathbf A_n^m=\frac{n!}{(n-m)!}\\ 
\mathbf C_n^m = \frac{n!}{(n-m)!m!}
\end{gathered}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:5.214880000000001em;vertical-align:-2.3574400000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.8574400000000004em;"><span style="top:-4.85744em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.2499999999999996em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">!</span><span class="mord mathdefault">m</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.3574400000000004em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>则计算</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi mathvariant="bold">C</mi><mrow><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>⋯</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi>n</mi></mrow><mrow><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋯</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathbf C_{m+n-2}^{m-1} = \frac{(m+n-2)!}{(n-1)!(m-1)!} = \frac{(m+n-2)\cdots(n+1)n}{(m-1)\cdots1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.178878em;vertical-align:-0.31477em;"></span><span class="mord"><span class="mord mathbf">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-2.443561em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.31477em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> output = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> numerator = n, denominator = <span class="number">1</span>; numerator &lt; m + n - <span class="number">1</span>; numerator++, denominator++ ) &#123;</span><br><span class="line">            output = output * numerator / denominator;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="63-不同路径-ii"><a class="markdownIt-Anchor" href="#63-不同路径-ii"></a> <a href="https://leetcode.cn/problems/unique-paths-ii/" target="_blank" rel="noopener">63. 不同路径 II</a></h3>
<blockquote>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>
<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>
<p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。<br>
<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/robot1.jpg" data-index="46" data-src="/2024/03/30/LeetCode-problems/robot1.jpg"></p>
</blockquote>
<h4 id="解法一动态规划"><a class="markdownIt-Anchor" href="#解法一动态规划"></a> 解法一——动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 初始化 第一行 第一列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; obstacleGrid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            obstacleGrid[i][<span class="number">0</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> || obstacleGrid[<span class="number">0</span>][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            obstacleGrid[<span class="number">0</span>][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; obstacleGrid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; obstacleGrid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    obstacleGrid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 不需要分类讨论了。障碍和两边都挡住的就是0啊，那加上去也没影响</span></span><br><span class="line">                    obstacleGrid[i][j] = obstacleGrid[i<span class="number">-1</span>][j] + obstacleGrid[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; obstacleGrid.size(); i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; obstacleGrid[0].size(); j++) &#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; obstacleGrid[i][j] &lt;&lt; " ";</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> - obstacleGrid[obstacleGrid.size() - <span class="number">1</span>][obstacleGrid[<span class="number">0</span>].size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="343-整数拆分"><a class="markdownIt-Anchor" href="#343-整数拆分"></a> <a href="https://leetcode.cn/problems/integer-break/" target="_blank" rel="noopener">343. 整数拆分</a></h3>
<blockquote>
<p>给定一个正整数 <code>n</code> ，将其拆分为 <code>k</code> 个 <strong>正整数</strong> 的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。</p>
<p>返回 <em>你可以获得的最大乘积</em> 。</p>
</blockquote>
<h4 id="解法一数论技巧"><a class="markdownIt-Anchor" href="#解法一数论技巧"></a> 解法一——数论？技巧？</h4>
<p>我们知道正方形面积最大，所以分出来的数字一定比较接近。所以我直接遍历了分n种的情况，每次算当前的成绩比较。</p>
<p>但是这里需要注意，因为不是整除，所以可能需要考虑向上向下取整两种情况。</p>
<p>向下取整的情况最后一个比较好考虑，就是普通的因子+余数。</p>
<p>向上取整的要稍微想一想，是普通的因子+余数-之前i-1个因子每个都多考虑了1。或者利用以下这组关系</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>x</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>i</mi><mo stretchy="false">)</mo><mo>⋅</mo><mi>i</mi><mo>+</mo><mi>n</mi><mi mathvariant="normal">%</mi><mi>i</mi><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">(n/i+1)\cdot(i-1)+x = (n/i)\cdot i+ n\%i = n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord mathdefault">n</span><span class="mord">%</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> maxNum  = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> prod = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (n % i &gt; i - n % i)&#123;  <span class="comment">// 说明要进位</span></span><br><span class="line">                <span class="keyword">int</span> factor = n / i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    prod *= factor;</span><br><span class="line">                &#125;</span><br><span class="line">                prod *= n % i + n / i - (i - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> factor = n / i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    prod *= factor;</span><br><span class="line">                &#125;</span><br><span class="line">                prod *= (factor + n % i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxNum &lt; prod) &#123;</span><br><span class="line">                maxNum = prod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-5"><a class="markdownIt-Anchor" href="#解法二动态规划-5"></a> 解法二——动态规划</h4>
<p>dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。</p>
<p>dp[i]最大乘积是怎么得到的呢？其实可以从1遍历j，然后有两种渠道得到dp[i].</p>
<ul>
<li>一个是j * (i - j) 直接相乘。</li>
<li>一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。</li>
</ul>
<p>注意第一种情况表示i-j不拆；第二种情况会拆分i-j，因为我们保存在数组中的值必定是拆分过的，那么也就没有保存i-j这个本身的值，例如dp[2]=1，但是如果一个数乘上2，反而还要比1大呢。</p>
<p>在遍历过程中会j和i-j的地位是完全对等的，也就是说拆j和拆i-j是完全一致的。</p>
<p>所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">当<span class="number">1</span>为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为<span class="number">2</span>的时候两棵树的布局是一样的啊！<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">59</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++) &#123;</span><br><span class="line">                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="96-不同的二叉搜索树"><a class="markdownIt-Anchor" href="#96-不同的二叉搜索树"></a> <a href="https://leetcode.cn/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. 不同的二叉搜索树</a></h3>
<blockquote>
<p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>
</blockquote>
<p><img alt="96.不同的二叉搜索树1" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210107093129889.png" data-index="47" data-src="/2024/03/30/LeetCode-problems/20210107093129889.png"></p>
<p>当1为头结点的时候，其右子树有两个节点，这两个节点的布局，和n为2的时候两棵树的布局是一样的！</p>
<p>当3为头结点的时候，其左子树有两个节点，这两个节点的布局，和n为2的时候两棵树的布局也是一样的！</p>
<p>当2为头结点的时候，其左右子树都只有一个节点，布局和n为1的时候只有一棵树的布局也是一样的！</p>
<p>dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量</p>
<p>元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量</p>
<p>元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量</p>
<p>元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量</p>
<p>有2个元素的搜索树数量就是dp[2]。</p>
<p>有1个元素的搜索树数量就是dp[1]。</p>
<p>有0个元素的搜索树数量就是dp[0]。</p>
<p>所以<code>dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]</code></p>
<p><strong>意思是当有3个元素的时候，1、2、3每个元素都有可能当根节点，而每个元素作为根节点的时候的，左右子树所有有可能的序列类型。</strong></p>
<p>在上面的分析中，其实已经看出其递推关系， dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]</p>
<p>j相当于是头结点的元素，从1遍历到i为止。</p>
<p>所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量</p>
<p>——代码随想录</p>
<p>代码中的递推公式使用的是</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>∗</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mspace width="1em"><mi>j</mi><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mo>⋯</mo><mtext> </mtext><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn></mspace></mrow><annotation encoding="application/x-tex">dp[i] +=dp[j]*dp[i-j-1],\quad j = 0,1,\cdots, i-1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">20</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//为0的子树有一种</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                dp[i] += dp[j] * dp[i - j - <span class="number">1</span>]; <span class="comment">// 左子树从0到i-1个元素，右子树从i-1到0个元素；</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="0-1背包问题"><a class="markdownIt-Anchor" href="#0-1背包问题"></a> 0-1背包问题</h3>
<h4 id="0-1背包问题二维数组"><a class="markdownIt-Anchor" href="#0-1背包问题二维数组"></a> 0-1背包问题——二维数组</h4>
<ol>
<li>
<p>确定dp数组以及下标的含义</p>
<p><code>dp[i][j]</code>表示从下标为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo>−</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0-i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的物品里任意取，放进容量为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>​的背包，价值总和最大是多少，即二维数组中的数字是最大价值</p>
<img alt="image-20240417111706222" style="zoom:33%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240417111706222-1713323828602-1.png" data-index="48" data-src="/2024/03/30/LeetCode-problems/image-20240417111706222-1713323828602-1.png">
</li>
<li>
<p>确定递推公式：<code>dp[i][j]</code>有两种情况得到</p>
<ol>
<li>不放物品<code>i</code>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
<li>放物品<code>i</code>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mtext>weight</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mtext>value</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j-\text{weight}[i]]+\text{value}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">weight</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">value</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span></li>
</ol>
<p>即递推公式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mtext> </mtext><mo stretchy="false">{</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>−</mo><mtext>weight</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo><mo>+</mo><mtext>value</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = \max\,\{dp[i-1][j],dp[i-1][j-\text{weight}[i]]+\text{value}[i]\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">weight</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">value</span></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">}</span></span></span></span></p>
</li>
<li>
<p>dp数组如何初始化</p>
<ol>
<li>第一列：背包重量为0的情况，必然为0</li>
<li>第一行（递推需要<code>i-1</code>状态）：背包重量小于<code>weight[0]</code>的为0，大于等于的为<code>value[0]</code></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 dp</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(weight.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(bagweight + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= bagweight; j++) &#123;</span><br><span class="line">    dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>确定遍历顺序：有两个遍历的维度：物品与背包重量</p>
<ol>
<li>
<p>那么我先给出先遍历物品，然后遍历背包重量的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>先遍历背包，再遍历物品，也是可以的！（注意这里使用的二维dp数组）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>举例推导dp数组</p>
</li>
</ol>
<h4 id="0-1背包问题滚动数组"><a class="markdownIt-Anchor" href="#0-1背包问题滚动数组"></a> 0-1背包问题——滚动数组</h4>
<p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>;</p>
<p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i])</code>;</strong></p>
<p><strong>与其把<code>dp[i - 1]</code>这一层拷贝到<code>dp[i]</code>上，不如只用一个一维数组了</strong>，只用<code>dp[j]</code>（一维数组，也可以理解是一个滚动数组）。</p>
<p>这就是滚动数组的由来，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p>
<ul>
<li>
<p>遍历顺序问题：</p>
</li>
<li>
<p>举一个例子（物品i=0时，背包重量j从0开始）：物品0的重量weight[0] = 1，价值value[0] = 15</p>
<p>如果正序遍历</p>
<p>dp[1] = dp[1 - weight[0]] + value[0] = 15</p>
<p>dp[2] = dp[2 - weight[0]] + value[0] = 30 （因为这里用的是用到了dp[1]，而这个dp[1]已经被上一步更新过了）</p>
<p>此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。</p>
</li>
<li>
<p>所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="46-携带研究材料-kamacoder"><a class="markdownIt-Anchor" href="#46-携带研究材料-kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1046" target="_blank" rel="noopener">46. 携带研究材料 (kamacoder)</a></h4>
<blockquote>
<p>题目描述</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的空间，并且具有不同的价值。</p>
<p>小明的行李空间为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料只能选择一次，并且只有选与不选两种选择，不能进行切割。</p>
</blockquote>
<h5 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemNum;</span><br><span class="line">    <span class="keyword">int</span> maxWeight;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; itemNum &gt;&gt; maxWeight;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">weight</span><span class="params">(itemNum)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value</span><span class="params">(itemNum)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;weighti:weight) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weighti;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;valuei:value) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; valuei;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二维矩阵</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(itemNum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(maxWeight + <span class="number">1</span>, <span class="number">0</span>))</span></span>; <span class="comment">// 注意这里要加1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[<span class="number">0</span>]; j &lt;= maxWeight; j++) &#123; <span class="comment">// 注意这里有等号</span></span><br><span class="line">        dp[<span class="number">0</span>][j] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历, 先遍历物品，后遍历背包大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; itemNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxWeight; j++) &#123; <span class="comment">// 注意这里有等号</span></span><br><span class="line">            <span class="keyword">if</span> (weight[i] &gt; j) &#123; <span class="comment">// 这个物品比目前能承载的最大重量还要大</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">                <span class="comment">// 这边的j - weight[i]是不会超范围的，因为他不是在前一个基础上加，而是直接找过去到前面的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[itemNum - <span class="number">1</span>][maxWeight] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="滚动数组"><a class="markdownIt-Anchor" href="#滚动数组"></a> 滚动数组</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> include &lt;iostream&gt;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itemNum;</span><br><span class="line">    <span class="keyword">int</span> maxWeight;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; itemNum &gt;&gt; maxWeight;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">weight</span><span class="params">(itemNum)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value</span><span class="params">(itemNum)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;weighti:weight) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weighti;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;valuei:value) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; valuei;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化二维矩阵</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(maxWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 注意这里要加1</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 开始遍历, 先遍历物品，后遍历背包大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; itemNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = maxWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 注意这里有等号</span></span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[maxWeight] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="416-分割等和子集"><a class="markdownIt-Anchor" href="#416-分割等和子集"></a> <a href="https://leetcode.cn/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. 分割等和子集</a></h3>
<blockquote>
<p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
</blockquote>
<ul>
<li>背包的体积为sum / 2</li>
<li>背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值</li>
<li>背包如果正好装满，说明找到了总和为 sum / 2 的子集。</li>
<li>背包中每一个元素是不可重复放入。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxWeight = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; dp(maxWeight + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = maxWeight; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[maxWeight] == maxWeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>01背包相对于本题，主要要理解，题目中物品是nums[i]，重量是nums[i]，价值也是nums[i]，背包体积是sum/2。</p>
<p>或者采用true/false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-1背包</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">2</span>) &#123;<span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(sum/<span class="number">2</span> + <span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = sum/<span class="number">2</span>; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum/<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1049-最后一块石头的重量-ii"><a class="markdownIt-Anchor" href="#1049-最后一块石头的重量-ii"></a> <a href="https://leetcode.cn/problems/last-stone-weight-ii/" target="_blank" rel="noopener">1049. 最后一块石头的重量 II</a></h3>
<blockquote>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
</blockquote>
<p>因为是“最小”的可能重量，所以分组由我们决定。</p>
<p>用归纳法可以证明，无论按照何种顺序粉碎石头，最后一块石头的重量总是可以表示成</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></munderover><msub><mi>k</mi><mi>i</mi></msub><mo>×</mo><mi>s</mi><mi>t</mi><mi>o</mi><mi>n</mi><mi>e</mi><msub><mi>s</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>k</mi><mi>i</mi></msub><mo>∈</mo><mo stretchy="false">{</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\sum_{i=1}^{n-1}k_i\times stones_i, k_i\in\{-1,1\}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span></span></p>
<p>我们将这组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{k_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>对应的石头划分成两堆，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_i=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的石头分至一堆，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>i</mi></msub><mo>=</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_i=-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span>的石头分至另一堆。由于这是最小非负值所对应的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><msub><mi>k</mi><mi>i</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{k_i\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>，这两堆石头重量之差的绝对值也是所有划分当中最小的。</p>
<p>所以问题就转化成了分成两组，是他们的绝对值最小。那么可以利用“416.分割等和子集”的思路。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(stones.begin(), stones.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxWeight = sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(maxWeight + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stones.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = maxWeight; j &gt;= stones[i]; j--) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum - dp[maxWeight]) - dp[maxWeight];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="494-目标和"><a class="markdownIt-Anchor" href="#494-目标和"></a> <a href="https://leetcode.cn/problems/target-sum/" target="_blank" rel="noopener">494. 目标和</a></h3>
<blockquote>
<p>给你一个非负整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
</blockquote>
<p>分成两堆，一堆取正，一堆取负数。那么有</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.15999999999999992em" columnalign="left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>+</mo><mi>n</mi><mi>e</mi><mi>g</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>=</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>p</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>−</mo><mi>n</mi><mi>e</mi><mi>g</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mo>=</mo><mi>s</mi><mi>u</mi><mi>m</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{
\begin{array}{l}
positive +negtive = target\\
positive - negetive = sum
\end{array}
\right.
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">{</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>所以postive之和就要等于(target+sum)/2。</p>
<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法。只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。</p>
<p>例如：dp[j]，j 为5，</p>
<ul>
<li>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。</li>
<li>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。</li>
<li>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包</li>
<li>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包</li>
<li>已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包</li>
</ul>
<p>那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p>
<p>所以求组合类问题的公式，都是类似这种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] +&#x3D; dp[j - nums[i]]</span><br></pre></td></tr></table></figure>
<p>——代码随想录</p>
<p>j是背包大小，dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> != <span class="number">0</span> || <span class="built_in">abs</span>(target) &gt; sum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> positiveSum = (sum + target) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(positiveSum + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = positiveSum; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[positiveSum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="474-一和零"><a class="markdownIt-Anchor" href="#474-一和零"></a> <a href="https://leetcode.cn/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h3>
<blockquote>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的长度，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
</blockquote>
<p><code>dp[i][j]</code>：最多有i个0和j个1的strs的最大子集的大小为<code>dp[i][j]</code>。</p>
<p>递推关系：有上一个字符串推出结果，假设当前字符串种有zeroNum个0，oneNum个1，上一个字符串至多有<code>dp[i - zeroNum][j - oneNum]</code>个子集，那么当前的可以保存下的子集的数量就要加一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxForm</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s:strs) &#123;</span><br><span class="line">            <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c:s) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">                    zero++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    one++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= zero; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = n; j &gt;= one; j--) &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i][j], dp[i - zero][j - one] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="完全背包问题"><a class="markdownIt-Anchor" href="#完全背包问题"></a> 完全背包问题</h3>
<h4 id="完全背包问题-2"><a class="markdownIt-Anchor" href="#完全背包问题-2"></a> 完全背包问题</h4>
<p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>
<p><strong>完全背包和01背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p>
<p>首先再回顾一下01背包的核心代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。</p>
<p>而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先遍历物品，再遍历背包</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = weight[i]; j &lt;= bagWeight ; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——代码随想录</p>
<p>求组合数：<a href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html" target="_blank" rel="noopener">动态规划：518.零钱兑换II (opens new window)</a></p>
<p>求排列数：<a href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html" target="_blank" rel="noopener">动态规划：377. 组合总和 Ⅳ (opens new window)</a>、<a href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html" target="_blank" rel="noopener">动态规划：70. 爬楼梯进阶版（完全背包） (opens new window)</a></p>
<p>求最小数（组合问题）：<a href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html" target="_blank" rel="noopener">动态规划：322. 零钱兑换 (opens new window)</a>、<a href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html" target="_blank" rel="noopener">动态规划：279.完全平方数</a></p>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<h4 id="52-携带研究材料kamacoder"><a class="markdownIt-Anchor" href="#52-携带研究材料kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1052" target="_blank" rel="noopener">52. 携带研究材料(kamacoder)</a></h4>
<blockquote>
<p>题目描述</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。他需要带一些研究材料，但是他的行李箱空间有限。这些研究材料包括实验设备、文献资料和实验样本等等，它们各自占据不同的重量，并且具有不同的价值。</p>
<p>小明的行李箱所能承担的总重量为 N，问小明应该如何抉择，才能携带最大价值的研究材料，每种研究材料可以选择无数次，并且可以重复选择。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, V;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">weight</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">value</span><span class="params">(N)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(V + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = weight[i]; j &lt;= V; j++) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[V] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="518-零钱兑换-ii"><a class="markdownIt-Anchor" href="#518-零钱兑换-ii"></a> <a href="https://leetcode.cn/problems/coin-change-ii/" target="_blank" rel="noopener">518. 零钱兑换 II</a></h3>
<blockquote>
<p>给你一个整数数组 <code>coins</code> 表示不同面额的硬币，另给一个整数 <code>amount</code> 表示总金额。</p>
<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 <code>0</code> 。</p>
<p>假设每一种面额的硬币有无限个。</p>
<p>题目数据保证结果符合 32 位带符号整数。</p>
</blockquote>
<p>求组合方式。</p>
<p>本题要求凑成总和的组合数，元素之间明确要求没有顺序。</p>
<p>所以纯完全背包是能凑成总和就行，不用管怎么凑的。</p>
<p>本题是求凑出来的方案个数，且每个方案个数是为组合数。</p>
<p>那么本题，两个for循环的先后顺序可就有说法了。</p>
<p>我们先来看 外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设：coins[0] = 1，coins[1] = 5。</p>
<p>那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。</p>
<p><strong>所以这种遍历顺序中dp[j]里计算的是组合数！</strong></p>
<p>如果把两个for交换顺序，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= amount; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">if</span> (j - coins[i] &gt;= <span class="number">0</span>) dp[j] += dp[j - coins[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。</p>
<p><strong>此时dp[j]里算出来的就是排列数！</strong></p>
<p>可能这里很多同学还不是很理解，<strong>建议动手把这两种方案的dp数组数值变化打印出来，对比看一看！（实践出真知）</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                dp[j] += dp[j - coins[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="377-组合总和-iv"><a class="markdownIt-Anchor" href="#377-组合总和-iv"></a> <a href="https://leetcode.cn/problems/combination-sum-iv/" target="_blank" rel="noopener">377. 组合总和 Ⅳ</a></h3>
<blockquote>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
</blockquote>
<p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p>
<p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p>
<p>如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！</p>
<p>所以本题遍历顺序最终遍历顺序：<strong>target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历</strong>。</p>
<p>——代码随想录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= target; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &lt;= j &amp;&amp; dp[j] &lt; INT_MAX - dp[j - nums[i]]) &#123;  <span class="comment">//C++测试用例有两个数相加超过int的数据，所以需要在if里加上dp[i] &lt; INT_MAX - dp[i - num]。</span></span><br><span class="line">                    dp[j] += dp[j - nums[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="57-爬楼梯-kamacoder"><a class="markdownIt-Anchor" href="#57-爬楼梯-kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1067" target="_blank" rel="noopener">57. 爬楼梯 (kamacoder)</a></h3>
<blockquote>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬至多m (1 &lt;= m &lt; n)个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>注意：给定 n 是一个正整数</p>
</blockquote>
<p>求排列数。背包体积是n，物品大小是1到m。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= j) &#123;</span><br><span class="line">                dp[j] += dp[j - i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="322-零钱兑换"><a class="markdownIt-Anchor" href="#322-零钱兑换"></a> <a href="https://leetcode.cn/problems/coin-change/" target="_blank" rel="noopener">322. 零钱兑换</a></h3>
<blockquote>
<p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>
</blockquote>
<p>首先这是个组合问题。 初始值怎么取很重要！</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = coins[i]; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - coins[i]] != INT_MAX) &#123;</span><br><span class="line">                    dp[j] = min(dp[j - coins[i]] + <span class="number">1</span>, dp[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[amount] == INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="279-完全平方数"><a class="markdownIt-Anchor" href="#279-完全平方数"></a> <a href="https://leetcode.cn/problems/perfect-squares/" target="_blank" rel="noopener">279. 完全平方数</a></h3>
<blockquote>
<p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
</blockquote>
<p>组合问题。dp[j]表示的是最小数量。j就表示序列嘛，i就是完全平方数啊，或者说完全平方数的根。背包的元素就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>i</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[j - i*i] != INT_MAX) &#123;</span><br><span class="line">                    dp[j] = min(dp[j], dp[j - i * i] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解的好像更好理解</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo>+</mo><munderover><mo><mi>min</mi><mo>⁡</mo></mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mrow><mo stretchy="false">⌊</mo><msqrt><mi>i</mi></msqrt><mo stretchy="false">⌋</mo></mrow></munderover><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><msup><mi>j</mi><mn>2</mn></msup><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i] = 1 +\min_{j=1}^{\lfloor\sqrt{i}\rfloor} f[i-j^2]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.5619015em;vertical-align:-0.863772em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6981294999999998em;"><span style="top:-2.0723360000000004em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">min</span></span></span><span style="top:-3.65386em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">⌊</span><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.920385em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-2.880385em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewbox="0 0 400000 1080" preserveaspectratio="xMinYMin slice"><path d="M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z"/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11961500000000003em;"><span></span></span></span></span></span><span class="mclose mtight">⌋</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.863772em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1141079999999999em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minN = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minN = min(minN, dp[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = minN + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="139-单词拆分"><a class="markdownIt-Anchor" href="#139-单词拆分"></a> <a href="https://leetcode.cn/problems/word-break/" target="_blank" rel="noopener">139. 单词拆分</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p>
<p>**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
</blockquote>
<p>完全背包，排序问题。</p>
<p>dp[j]表示s从0开始截取的长度是否能够通过字典中的值组成。</p>
<p>dp[j]为true的前提是dp[k]为true且从k+1到j区间的字符串在字典中出现。</p>
<h4 id="解法一遍历物品时候直接遍历字典列表"><a class="markdownIt-Anchor" href="#解法一遍历物品时候直接遍历字典列表"></a> 解法一——遍历物品时候直接遍历字典列表</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.length() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wordDict.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - (<span class="keyword">int</span>) wordDict[i].length() &gt;= <span class="number">0</span>) &#123; <span class="comment">// 这里需要加一个int 否则他出不来负数</span></span><br><span class="line">                    <span class="built_in">string</span> sSub = s.substr(j - wordDict[i].length(), wordDict[i].length());</span><br><span class="line">                    <span class="keyword">if</span> (dp[j - wordDict[i].length()] &amp;&amp; wordDict[i] == sSub)&#123;</span><br><span class="line">                        dp[j] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二遍历物品时候遍历截取的字符串长度"><a class="markdownIt-Anchor" href="#解法二遍历物品时候遍历截取的字符串长度"></a> 解法二——遍历物品时候，遍历截取的字符串长度</h4>
<p>——代码随想录</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordBreak</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordDict.begin(), wordDict.end())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size() + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.size(); i++) &#123;   <span class="comment">// 遍历背包</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;       <span class="comment">// 遍历物品</span></span><br><span class="line">                <span class="built_in">string</span> word = s.substr(j, i - j); <span class="comment">//substr(起始位置，截取的个数)</span></span><br><span class="line">                <span class="keyword">if</span> (wordSet.find(word) != wordSet.end() &amp;&amp; dp[j]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="多重背包问题"><a class="markdownIt-Anchor" href="#多重背包问题"></a> 多重背包问题</h3>
<h4 id="多重背包问题-2"><a class="markdownIt-Anchor" href="#多重背包问题-2"></a> 多重背包问题</h4>
<p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>
<p>实现方式——把每种商品遍历的个数放在01背包里面在遍历一遍。</p>
<h4 id="56-携带矿石资源-kamacoder"><a class="markdownIt-Anchor" href="#56-携带矿石资源-kamacoder"></a> <a href="https://kamacoder.com/problempage.php?pid=1066" target="_blank" rel="noopener">56. 携带矿石资源 (kamacoder)</a></h4>
<blockquote>
<p>你是一名宇航员，即将前往一个遥远的行星。在这个行星上，有许多不同类型的矿石资源，每种矿石都有不同的重要性和价值。你需要选择哪些矿石带回地球，但你的宇航舱有一定的容量限制。</p>
<p>给定一个宇航舱，最大容量为 C。现在有 N 种不同类型的矿石，每种矿石有一个重量 w[i]，一个价值 v[i]，以及最多 k[i] 个可用。不同类型的矿石在地球上的市场价值不同。你需要计算如何在不超过宇航舱容量的情况下，最大化你所能获取的总价值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> C, N;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; C &gt;&gt; N;</span><br><span class="line">    </span><br><span class="line">    vector&lt;int&gt; weights(N), values(N), maxNums(N);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;weight:weights) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value:values) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;maxNum:maxNums) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; maxNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(C + <span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = C; j &gt;= weights[i]; j--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= maxNums[i] &amp;&amp; (j - k * weights[i]) &gt;= <span class="number">0</span>; k++) &#123;</span><br><span class="line">                dp[j] = max(dp[j], dp[j - k * weights[i]] + k * values[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[C] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="198-打家劫舍"><a class="markdownIt-Anchor" href="#198-打家劫舍"></a> <a href="https://leetcode.cn/problems/house-robber/" target="_blank" rel="noopener">198. 打家劫舍</a></h3>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>
</blockquote>
<p><strong>dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]</strong>。</p>
<p>决定dp[i]的因素就是第i房间偷还是不偷。两种情况，不偷和偷，<strong>不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额</strong></p>
<p>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p>
<p>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考 虑i-1房，</p>
<p>然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]); </span><br><span class="line">            <span class="comment">// 两种情况，不偷和偷，不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[nums.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="213-打家劫舍-ii"><a class="markdownIt-Anchor" href="#213-打家劫舍-ii"></a> <a href="https://leetcode.cn/problems/house-robber-ii/" target="_blank" rel="noopener">213. 打家劫舍 II</a></h3>
<blockquote>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>
</blockquote>
<h4 id="解法一建立二维数组"><a class="markdownIt-Anchor" href="#解法一建立二维数组"></a> 解法一——建立二维数组</h4>
<p>建立二维数组，分两种情况，偷0【1】和不偷0【0】</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums.size() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 分两种情况，偷0【1】和不偷0【0】</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123; <span class="comment">// 结尾单独考虑</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] + nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">1</span>] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 考虑最后一家</span></span><br><span class="line">        dp[nums.size() - <span class="number">1</span>][<span class="number">0</span>] = max(dp[nums.size() - <span class="number">2</span>][<span class="number">0</span>], dp[nums.size() - <span class="number">3</span>][<span class="number">0</span>] + nums[nums.size() - <span class="number">1</span>]); <span class="comment">// 不偷0</span></span><br><span class="line">        dp[nums.size() - <span class="number">1</span>][<span class="number">1</span>] = dp[nums.size() - <span class="number">2</span>][<span class="number">1</span>]; <span class="comment">// 偷0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(dp[nums.size() - <span class="number">1</span>][<span class="number">0</span>], dp[nums.size() - <span class="number">1</span>][<span class="number">1</span>]);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二利用上一题的代码分两个子函数"><a class="markdownIt-Anchor" href="#解法二利用上一题的代码分两个子函数"></a> 解法二——利用上一题的代码，分两个子函数</h4>
<p>三种情况：</p>
<ul>
<li>情况一：考虑不包含首尾元素</li>
<li>情况二：考虑包含首元素，不包含尾元素</li>
<li>情况三：考虑包含尾元素，不包含首元素</li>
</ul>
<p>情况二、三 包括情况一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start + <span class="number">1</span>] = max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]); </span><br><span class="line">            <span class="comment">// 两种情况，不偷和偷，不偷那么就是之前任何一个位置的最大值，偷只能在间隔一个未知的最大值再加上当前的金额</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> situation2 = robRange(nums, <span class="number">0</span>, nums.size() - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> situation3 = robRange(nums, <span class="number">1</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(situation2, situation3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="337-打家劫舍-iii"><a class="markdownIt-Anchor" href="#337-打家劫舍-iii"></a> <a href="https://leetcode.cn/problems/house-robber-iii/" target="_blank" rel="noopener">337. 打家劫舍 III</a></h3>
<blockquote>
<p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 <code>root</code> 。</p>
<p>除了 <code>root</code> 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 <strong>两个直接相连的房子在同一天晚上被打劫</strong> ，房屋将自动报警。</p>
<p>给定二叉树的 <code>root</code> 。返回 <em><strong>在不触动警报的情况下</strong> ，小偷能够盗取的最高金额</em> 。</p>
</blockquote>
<h4 id="解法一二维数组记录"><a class="markdownIt-Anchor" href="#解法一二维数组记录"></a> 解法一——二维数组记录</h4>
<p>递归，得知道当前节点的子节点有没有没抢劫。采用后序遍历。</p>
<p>这里处理起来就复杂在：</p>
<ul>
<li>左右子树：4种情况——有无。</li>
<li>左右偷不偷：4种情况——各自偷不偷。只有左右孩子都不偷，这次才能偷。而当前不偷则应该上一轮四种情况都可以。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp; <span class="comment">// 索引0表示不偷， 索引1表示偷</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">robPostOrder</span> <span class="params">(TreeNode *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">            robPostOrder(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">            robPostOrder(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点的四种情况：左右子树都有、有一个、都没有</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;left &amp;&amp; p-&gt;right) &#123;</span><br><span class="line">            <span class="comment">// 这里有四个情况啊：左偷右不偷、左不偷右偷、左偷右偷、左不偷右不偷。四种情况这次都可以不偷，但是只有最后一种情况这次可以偷</span></span><br><span class="line">            <span class="comment">// 当前不偷：那就是左右索引上一次的偷的和（这里应该是加而不是取最大值）当前不偷上一次也可以不偷啊，</span></span><br><span class="line">            temp[<span class="number">0</span>] = max(dp[dp.size() - <span class="number">2</span>][<span class="number">1</span>] + dp[dp.size() - <span class="number">1</span>][<span class="number">1</span>], max(dp[dp.size() - <span class="number">2</span>][<span class="number">0</span>] + dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>], max(dp[dp.size() - <span class="number">2</span>][<span class="number">1</span>] + dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>], dp[dp.size() - <span class="number">2</span>][<span class="number">0</span>] + dp[dp.size() - <span class="number">1</span>][<span class="number">1</span>]))); </span><br><span class="line">            <span class="comment">// 当前偷：那就是左右索引上一次的不偷的和（这里应该是加而不是取最大值）（相当于是当前索引上上次可能偷的和）</span></span><br><span class="line">            temp[<span class="number">1</span>] = dp[dp.size() - <span class="number">2</span>][<span class="number">0</span>] + dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>] + p-&gt;val; </span><br><span class="line">            dp.pop_back(); <span class="comment">// 需要把子树的pop掉，不然根节点找不到左子树的</span></span><br><span class="line">            dp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;left || p-&gt;right) &#123; <span class="comment">// 有一个非空</span></span><br><span class="line">            <span class="comment">// 当前不偷：那就是非空子树上一次的偷的值</span></span><br><span class="line">            temp[<span class="number">0</span>] = max(dp[dp.size() - <span class="number">1</span>][<span class="number">1</span>], dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>]); </span><br><span class="line">            <span class="comment">// 当前偷：那就是非空子树上一次的不偷的值（相当于是当前索引上上次可能偷的值）</span></span><br><span class="line">            temp[<span class="number">1</span>] = dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>] + p-&gt;val; </span><br><span class="line">            dp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 根节点</span></span><br><span class="line">            temp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 不偷</span></span><br><span class="line">            temp[<span class="number">1</span>] = p-&gt;val; <span class="comment">// 偷</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; temp[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt;  temp[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        dp.emplace_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.emplace_back(<span class="number">0</span>);</span><br><span class="line">        temp.emplace_back(<span class="number">0</span>);</span><br><span class="line">        robPostOrder(root);</span><br><span class="line">        <span class="comment">// for (auto p:dp) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; p[0] &lt;&lt; " " &lt;&lt;  p[1] &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> max(dp[dp.size() - <span class="number">1</span>][<span class="number">0</span>], dp[dp.size() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二一个数组即可"><a class="markdownIt-Anchor" href="#解法二一个数组即可"></a> 解法二——一个数组即可</h4>
<p>——代码随想录</p>
<p>做了几点简化：</p>
<ul>
<li>它不需要我的二维数组才保存dp，直接每次返回当前节点偷或者不偷的情况</li>
<li>不偷的情况不需要我的四个和取max，只需要两边各取max即可。</li>
<li>空节点也不需要单独考虑，直接返回0，0即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result = robTree(root);</span><br><span class="line">        <span class="keyword">return</span> max(result[<span class="number">0</span>], result[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为2的数组，0：不偷，1：偷</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">robTree</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = robTree(cur-&gt;left);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = robTree(cur-&gt;right);</span><br><span class="line">        <span class="comment">// 偷cur，那么就不能偷左右节点。</span></span><br><span class="line">        <span class="keyword">int</span> val1 = cur-&gt;val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况</span></span><br><span class="line">        <span class="keyword">int</span> val2 = max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + max(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> &#123;val2, val1&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="121-买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#121-买卖股票的最佳时机"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h3>
<blockquote>
<p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p>
<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>
<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p>
</blockquote>
<h4 id="解法一贪心-4"><a class="markdownIt-Anchor" href="#解法一贪心-4"></a> 解法一——贪心</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            low = min(low, prices[i]);</span><br><span class="line">            output = max(output, prices[i] - low);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-6"><a class="markdownIt-Anchor" href="#解法二动态规划-6"></a> 解法二——动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 第0天买入股票，手头剩下</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 第0天抛出股票</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], prices[i] + dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从递推公式可以看出，dp[i]只是依赖于dp[i - 1]的状态。只需要记录 当前天的dp状态和前一天的dp状态就可以了，可以使用滚动数组来节省空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>; <span class="comment">// 注意这里只开辟了一个2 * 2大小的二维数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], prices[i] + dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="122-买卖股票的最佳时机-ii-2"><a class="markdownIt-Anchor" href="#122-买卖股票的最佳时机-ii-2"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h3>
<blockquote>
<p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p>
<p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p>
</blockquote>
<p>贪心见前一部分，给出动规解法</p>
<p>与买卖股票1的区别——<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>不止和上次也没持有比较，还和上次持有但是买了有关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="123-买卖股票的最佳时机-iii"><a class="markdownIt-Anchor" href="#123-买卖股票的最佳时机-iii"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. 买卖股票的最佳时机 III</a></h3>
<blockquote>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>分四个状态：第一笔持有、第一笔卖出、第二笔持有、第二笔卖出</p>
<p>如果第一次卖出已经是最大值了，那么我们可以在当天立刻买入再立刻卖出。</p>
<p>在动态规划结束后，由于我们可以进行不超过两笔交易，因此最终的答案在 0，sell1，sell2中，且为三者中的最大值。然而我们可以发现，由于在边界条件中 sell1和 sell2的值已经为 0，并且在状态转移的过程中我们维护的是最大值，因此 sell1和 sell2最终一定大于等于 0。同时，如果最优的情况对应的是恰好一笔交易，那么它也会因为我们在转移时允许在同一天买入并且卖出这一宽松的条件，从 sell1转移至 sell2，因此最终的答案即为 sell2</p>
<p>——力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 第一次持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 第一次卖出</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 第二次持有,第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">// 第二次卖出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(- prices[i], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = max(dp[i][<span class="number">1</span>] - prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span>]); <span class="comment">// 之前错在这里，应该要在这里引入第一次卖出的结果</span></span><br><span class="line">            dp[i][<span class="number">3</span>] = max(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; dp[prices.size() - 1][1] &lt;&lt; " " &lt;&lt; dp[prices.size() - 1][3];</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="188-买卖股票的最佳时机-iv"><a class="markdownIt-Anchor" href="#188-买卖股票的最佳时机-iv"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">188. 买卖股票的最佳时机 IV</a></h3>
<blockquote>
<p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<p>和上一题一致，只是换成了循环</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span> * k))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span> * j] = - prices[<span class="number">0</span>]; <span class="comment">// 2*j的位置是持有，2*j+1的位置是不持有</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(- prices[i], dp[i<span class="number">-1</span>][<span class="number">0</span>]); <span class="comment">// 2*j的位置是持有</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]); <span class="comment">//2*j+1的位置是不持有</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k; j++) &#123;</span><br><span class="line">                dp[i][<span class="number">2</span> * j] = max(dp[i<span class="number">-1</span>][<span class="number">2</span> * j - <span class="number">1</span>] - prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span> * j]); <span class="comment">// 2*j的位置是持有</span></span><br><span class="line">                dp[i][<span class="number">2</span> * j + <span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span> * j] + prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span> * j + <span class="number">1</span>]); <span class="comment">//2*j+1的位置是不持有</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">2</span> * k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="309-买卖股票的最佳时机含冷冻期"><a class="markdownIt-Anchor" href="#309-买卖股票的最佳时机含冷冻期"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">309. 买卖股票的最佳时机含冷冻期</a></h3>
<blockquote>
<p>给定一个整数数组<code>prices</code>，其中第 <code>prices[i]</code> 表示第 <code>*i*</code> 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<ul>
<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>
</ul>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有且不在不在冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 冷冻期</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 持有只有两种：上一期持有，上次不持有-price[i]</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]); <span class="comment">// 上一次在冷冻期，或者上一次不持有</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 上一期持有，本期抛售</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[i][0] &lt;&lt; " " &lt;&lt; dp[i][1] &lt;&lt; " " &lt;&lt; dp[i][2] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>], dp[prices.size() - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="714-买卖股票的最佳时机含手续费"><a class="markdownIt-Anchor" href="#714-买卖股票的最佳时机含手续费"></a> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">714. 买卖股票的最佳时机含手续费</a></h3>
<blockquote>
<p>给定一个整数数组 <code>prices</code>，其中 <code>prices[i]</code>表示第 <code>i</code> 天的股票价格 ；整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">// 未持有 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[prices.size() - <span class="number">1</span>][<span class="number">0</span>], dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="300-最长递增子序列"><a class="markdownIt-Anchor" href="#300-最长递增子序列"></a> <a href="https://leetcode.cn/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长递增子序列</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p>
<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>; <span class="comment">// 考虑当前元素加入时候的最长值</span></span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123; <span class="comment">// 通过之前的遍历</span></span><br><span class="line">                    dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; output) &#123;</span><br><span class="line">                output = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="674-最长连续递增序列"><a class="markdownIt-Anchor" href="#674-最长连续递增序列"></a> <a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h3>
<blockquote>
<p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>
<p><strong>连续递增的子序列</strong> 可以由两个下标 <code>l</code> 和 <code>r</code>（<code>l &lt; r</code>）确定，如果对于每个 <code>l &lt;= i &lt; r</code>，都有 <code>nums[i] &lt; nums[i + 1]</code> ，那么子序列 <code>[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]</code> 就是连续递增子序列。</p>
</blockquote>
<p>这道题看上去和动规没啥关系啊！原来我这是贪心的解法啊</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; output) &#123;</span><br><span class="line">                output = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="718-最长重复子数组"><a class="markdownIt-Anchor" href="#718-最长重复子数组"></a> <a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">718. 最长重复子数组</a></h3>
<blockquote>
<p>给两个整数数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>两个数组中 <strong>公共的</strong> 、长度最长的子数组的长度</em> 。</p>
</blockquote>
<h4 id="解法一二维数组"><a class="markdownIt-Anchor" href="#解法一二维数组"></a> 解法一——二维数组</h4>
<p><code>dp[i][j]</code>：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为<code>dp[i][j]</code>。</p>
<p>减一是为了方便初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums2.size() + <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="comment">// dp[i+1][j+1]表示截至nums1的i位置，nums2的j位置最长重复子数组是多少</span></span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>; <span class="comment">// 注意这里是和谁比</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (output &lt; dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    output = dp[i+<span class="number">1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二滚动数组"><a class="markdownIt-Anchor" href="#解法二滚动数组"></a> 解法二——滚动数组</h4>
<p><img alt="718.最长重复子数组" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/2021011215282060-20230310134554486.jpg" data-index="49" data-src="/2024/03/30/LeetCode-problems/2021011215282060-20230310134554486.jpg"></p>
<p><code>dp[i][j]</code>都是由<code>dp[i - 1][j - 1]</code>推出。那么压缩为一维数组，也就是<code>dp[j]</code>都是由<code>dp[j - 1]</code>推出。也就是相当于可以把上一层<code>dp[i - 1][j]</code>拷贝到下一层<code>dp[i][j]</code>来继续用。<strong>此时遍历B数组的时候，就要从后向前遍历，这样避免重复覆盖</strong>。</p>
<p>注意，不相等要赋零初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = nums2.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                    dp[j+<span class="number">1</span>] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j+<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不相等要附零</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (output &lt; dp[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    output = dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1143-最长公共子序列"><a class="markdownIt-Anchor" href="#1143-最长公共子序列"></a> <a href="https://leetcode.cn/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. 最长公共子序列</a></h3>
<blockquote>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
</blockquote>
<p>滚动数组太难想了。</p>
<h4 id="解法一二维数组-2"><a class="markdownIt-Anchor" href="#解法一二维数组-2"></a> 解法一——二维数组</h4>
<p>每行对应不同的text1序列，到text1的第几位了，之前的元素最多能和text2重合几位</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(text1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (text2.size() + <span class="number">1</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; text2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]); <span class="comment">// 注意这里不是dp[i][j]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.size()][text2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二滚动数组-2"><a class="markdownIt-Anchor" href="#解法二滚动数组-2"></a> 解法二——滚动数组</h4>
<p>太绕了,还是二维数组吧</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(<span class="built_in">string</span> text1, <span class="built_in">string</span> text2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(text2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;  <span class="comment">// 存储上一位没有+1的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; text2.size(); j++) &#123; </span><br><span class="line">                <span class="comment">/* 这里会存在一个矛盾，当text1[i] == text2[j]时候，我要加1，我希望这里的dp[j]是没有加1过的</span></span><br><span class="line"><span class="comment">                但是当text1[i] != text2[j]时候，我需要在两种情况下（①i和j+1；②i+1和j）取最大，希望这里的dp[j]是加1过的</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (text1[i] == text2[j]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> old = dp[j+<span class="number">1</span>];</span><br><span class="line">                    dp[j+<span class="number">1</span>] = temp + <span class="number">1</span>;</span><br><span class="line">                    temp = max(old, temp); <span class="comment">// 这里需要比较的是dp[j+1]原来的值和原来的temp，</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j+<span class="number">1</span>] = max(dp[j+<span class="number">1</span>], temp);</span><br><span class="line">                    temp = dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// int newlen = max(temp, dp[j+1]);</span></span><br><span class="line">                <span class="comment">// if (text1[i] == text2[j]) &#123;</span></span><br><span class="line">                <span class="comment">//     dp[j+1] = temp+1;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// temp = newlen;</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j+<span class="number">1</span>] &gt; output) &#123;</span><br><span class="line">                    output = dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1035-不相交的线"><a class="markdownIt-Anchor" href="#1035-不相交的线"></a> <a href="https://leetcode.cn/problems/uncrossed-lines/" target="_blank" rel="noopener">1035. 不相交的线</a></h3>
<blockquote>
<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
</blockquote>
<p><strong>难就难在这一步抽象！</strong>： 直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。</p>
<p>就转换成了上一道题的问题。这里我还是用滚动数组来试一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums2.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newlen = max(dp[j+<span class="number">1</span>], temp); <span class="comment">// 先存一下到当前位置最多连线数量是多少，不考虑该位置相等加一的问题。</span></span><br><span class="line">                <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123; <span class="comment">// 相等了也是在temp的基础上加</span></span><br><span class="line">                    dp[j+<span class="number">1</span>] = temp + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                temp = newlen;</span><br><span class="line">                <span class="keyword">if</span> (output &lt; dp[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    output = dp[j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="53-最大子数组和-2"><a class="markdownIt-Anchor" href="#53-最大子数组和-2"></a> <a href="https://leetcode.cn/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子数组和</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong>是数组中的一个连续部分。</p>
<p><strong>子数组</strong> 是数组中连续的 <strong>非空</strong> 元素序列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> output = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = max(dp[i<span class="number">-1</span>] + nums[i], nums[i]); <span class="comment">// 如果之前的加上这个数反而还不如这个数字，那就没意义了</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; output) &#123;</span><br><span class="line">                output = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="392-判断子序列"><a class="markdownIt-Anchor" href="#392-判断子序列"></a> <a href="https://leetcode.cn/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h3>
<blockquote>
<p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，<code>&quot;ace&quot;</code>是<code>&quot;abcde&quot;</code>的一个子序列，而<code>&quot;aec&quot;</code>不是）。</p>
<p><strong>进阶：</strong></p>
<p>如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k &gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？</p>
</blockquote>
<h4 id="解法一双指针"><a class="markdownIt-Anchor" href="#解法一双指针"></a> 解法一——双指针</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; t.length(); j++) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    start = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> (start == t.length() &amp;&amp; i != s.length() - <span class="number">1</span>) &#123; <span class="comment">// 防止超出去</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == t.length() - <span class="number">1</span> &amp;&amp; s[i] != t[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-7"><a class="markdownIt-Anchor" href="#解法二动态规划-7"></a> 解法二——动态规划</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(t.length() + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j]; <span class="comment">// 未匹配，保留上一个匹配的值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()][t.length()] == s.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="115-不同的子序列"><a class="markdownIt-Anchor" href="#115-不同的子序列"></a> <a href="https://leetcode.cn/problems/distinct-subsequences/" target="_blank" rel="noopener">115. 不同的子序列</a></h3>
<blockquote>
<p>给你两个字符串 <code>s</code> 和 <code>t</code> ，统计并返回在 <code>s</code> 的 <strong>子序列</strong> 中 <code>t</code> 出现的个数，结果需要对 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>9</mn></msup><mo>+</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">10^9 + 7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">7</span></span></span></span>​ 取模。</p>
</blockquote>
<p>或者也可以把i为1的情况放进去一起考虑，后来发现不需要乘了，而是加的关系。但是第0行还是需要初始化的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinct</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;&gt; <span class="title">dp</span><span class="params">(t.length() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt; (s.length() + <span class="number">1</span>))</span></span>; <span class="comment">// t才是要找的子序列</span></span><br><span class="line">        <span class="comment">// dp[i+1][j+1]表示截至t的第i个字母，s的第j个字母有多少种方案。</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t[<span class="number">0</span>] == s[j]) &#123;</span><br><span class="line">                dp[<span class="number">1</span>][j+<span class="number">1</span>] = ++temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[<span class="number">1</span>][j+<span class="number">1</span>] = dp[<span class="number">1</span>][j]; <span class="comment">// 不等那么就保留前面的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; 1 &lt;&lt; " " &lt;&lt; j+1 &lt;&lt; " " &lt;&lt; dp[1][j+1] &lt;&lt; " " &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            temp = <span class="number">0</span>; <span class="comment">// 当前字母i有几种</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(t[i] == s[j]) &#123;</span><br><span class="line">                    temp++;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j] + dp[i][j]; <span class="comment">// 因为这里要考虑乘法，所以需要单独考虑s的第0个字母。</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i+<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i+1 &lt;&lt; " " &lt;&lt; j+1 &lt;&lt; " " &lt;&lt; dp[i+1][j+1] &lt;&lt; " " &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t.length()][s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="583-两个字符串的删除操作"><a class="markdownIt-Anchor" href="#583-两个字符串的删除操作"></a> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/" target="_blank" rel="noopener">583. 两个字符串的删除操作</a></h3>
<blockquote>
<p>给定两个单词 <code>word1</code> 和 <code>word2</code> ，返回使得 <code>word1</code> 和 <code>word2</code> <strong>相同</strong>所需的<strong>最小步数</strong>。</p>
<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>
</blockquote>
<p>求最大公共子串？然后再减一下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(word1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(word2.size() + <span class="number">1</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = max(dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (word1.size() + word2.size() - <span class="number">2</span> * dp[word1.size()][word2.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="72-编辑距离"><a class="markdownIt-Anchor" href="#72-编辑距离"></a> <a href="https://leetcode.cn/problems/edit-distance/" target="_blank" rel="noopener">72. 编辑距离</a></h3>
<blockquote>
<p>给你两个单词 <code>word1</code> 和 <code>word2</code>， <em>请返回将 <code>word1</code> 转换成 <code>word2</code> 所使用的最少操作数</em> 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</blockquote>
<p>我们可以发现，如果我们有单词 A 和单词 B：</p>
<p>对单词 A 删除一个字符和对单词 B 插入一个字符是等价的。例如当单词 A 为 doge，单词 B 为 dog 时，我们既可以删除单词 A 的最后一个字符 e，得到相同的 dog，也可以在单词 B 末尾添加一个字符 e，得到相同的 doge；</p>
<p>同理，对单词 B 删除一个字符和对单词 A 插入一个字符也是等价的；</p>
<p>对单词 A 替换一个字符和对单词 B 替换一个字符是等价的。例如当单词 A 为 bat，单词 B 为 cat 时，我们修改单词 A 的第一个字母 b -&gt; c，和修改单词 B 的第一个字母 c -&gt; b 是等价的。</p>
<p>这样以来，本质不同的操作实际上只有三种：</p>
<ul>
<li>在单词 A 中插入一个字符；</li>
<li>在单词 B 中插入一个字符；</li>
<li>修改单词 A 的一个字符</li>
</ul>
<p>——力扣官方题解</p>
<p><strong>两个单词都可以操作！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(word1.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(word2.size() + <span class="number">1</span>))</span></span>;</span><br><span class="line">        <span class="comment">// 边界条件需要初始化，毕竟你一个单词万一是空的这么说直接啥也不需要了？</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 0;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            dp[i+<span class="number">1</span>][<span class="number">0</span>] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.size(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j+<span class="number">1</span>] = j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word1.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; word2.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (word1[i] == word2[j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>  &#123;</span><br><span class="line">                    <span class="comment">// 否则三种操作，A加一个单词，B加一个单词，A换一个字符</span></span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = min(&#123;dp[i][j+<span class="number">1</span>], dp[i+<span class="number">1</span>][j], dp[i][j]&#125;) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[word1.size()][word2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="647-回文子串"><a class="markdownIt-Anchor" href="#647-回文子串"></a> <a href="https://leetcode.cn/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>
<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>
<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
</blockquote>
<h4 id="解法一双指针-2"><a class="markdownIt-Anchor" href="#解法一双指针-2"></a> 解法一——双指针</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>; <span class="comment">// 0位置的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> center = <span class="number">1</span>; center &lt; s.length(); center++)  &#123;</span><br><span class="line">            output ++; <span class="comment">// 独自的</span></span><br><span class="line">            <span class="comment">// 区分奇偶，偶数往左找</span></span><br><span class="line">            <span class="keyword">if</span> (s[center] == s[center - <span class="number">1</span>]) &#123; <span class="comment">// 偶</span></span><br><span class="line">                left = center - <span class="number">1</span>;</span><br><span class="line">                right = center;</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 奇数是必然有的情况，不需要else</span></span><br><span class="line">            left = center - <span class="number">1</span>;</span><br><span class="line">            right = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">                output++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二动态规划-8"><a class="markdownIt-Anchor" href="#解法二动态规划-8"></a> 解法二——动态规划</h4>
<p>布尔类型的<code>dp[i][j]</code>：表示区间范围<code>[i,j]</code> （注意是左闭右闭）的子串是否是回文子串，如果是<code>dp[i][j]</code>为true，否则为false。</p>
<p>遍历时候，需要的元素出现在左下角。</p>
<p><img alt="647.回文子串" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20210121171032473-20230310132134822.jpg" data-index="50" data-src="/2024/03/30/LeetCode-problems/20210121171032473-20230310132134822.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.length(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>])) &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不如双指针好理解。</p>
<h3 id="516-最长回文子序列"><a class="markdownIt-Anchor" href="#516-最长回文子序列"></a> <a href="https://leetcode.cn/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. 最长回文子序列</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> ，找出其中最长的回文子序列，并返回该序列的长度。</p>
<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s.length()))</span></span>;</span><br><span class="line">        <span class="comment">// 保存的是区间内回文子串最长是多少</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j] = j - i + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = max(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h2>
<h3 id="739-每日温度"><a class="markdownIt-Anchor" href="#739-每日温度"></a> <a href="https://leetcode.cn/problems/daily-temperatures/" target="_blank" rel="noopener">739. 每日温度</a></h3>
<blockquote>
<p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>
</blockquote>
<p>只要存下标就好了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S; <span class="comment">//栈底元素对应的温度最大（只要存下标！！！） 栈里面的元素递增</span></span><br><span class="line">        <span class="keyword">int</span> numSize = temperatures.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">output</span><span class="params">(numSize)</span></span>;</span><br><span class="line">        S.push(numSize - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = numSize - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; temperatures[i] &gt;= temperatures[S.top()]) &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (S.empty()) &#123;</span><br><span class="line">                output[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                output[i] = S.top() - i;</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="496-下一个更大元素-i"><a class="markdownIt-Anchor" href="#496-下一个更大元素-i"></a> <a href="https://leetcode.cn/problems/next-greater-element-i/" target="_blank" rel="noopener">496. 下一个更大元素 I</a></h3>
<blockquote>
<p><code>nums1</code> 中数字 <code>x</code> 的 <strong>下一个更大元素</strong> 是指 <code>x</code> 在 <code>nums2</code> 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 <code>x</code> 大的元素。</p>
<p>给你两个 <strong>没有重复元素</strong> 的数组 <code>nums1</code> 和 <code>nums2</code> ，下标从 <strong>0</strong> 开始计数，其中<code>nums1</code> 是 <code>nums2</code> 的子集。</p>
<p>对于每个 <code>0 &lt;= i &lt; nums1.length</code> ，找出满足 <code>nums1[i] == nums2[j]</code> 的下标 <code>j</code> ，并且在 <code>nums2</code> 确定 <code>nums2[j]</code> 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 <code>-1</code> 。</p>
<p>返回一个长度为 <code>nums1.length</code> 的数组 <code>ans</code> 作为答案，满足 <code>ans[i]</code> 是如上所述的 <strong>下一个更大元素</strong> 。</p>
</blockquote>
<p>单调栈+哈希表</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; nums1Index;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S; <span class="comment">// 这道题可以直接存数值了</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">output</span><span class="params">(nums1.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">            nums1Index[nums1[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = nums2.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1Index[nums2[j]] == <span class="number">0</span>) &#123;</span><br><span class="line">                S.push(nums2[j]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; nums2[j] &gt;= S.top()) &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; nums1Index[nums2[j]] - 1 &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span> (S.empty()) &#123;</span><br><span class="line">                output[nums1Index[nums2[j]] - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                output[nums1Index[nums2[j]] - <span class="number">1</span>] = S.top();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(nums2[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="503-下一个更大元素-ii"><a class="markdownIt-Anchor" href="#503-下一个更大元素-ii"></a> <a href="https://leetcode.cn/problems/next-greater-element-ii/" target="_blank" rel="noopener">503. 下一个更大元素 II</a></h3>
<blockquote>
<p>给定一个循环数组 <code>nums</code> （ <code>nums[nums.length - 1]</code> 的下一个元素是 <code>nums[0]</code> ），返回 <em><code>nums</code> 中每个元素的 <strong>下一个更大元素</strong></em> 。</p>
<p>数字 <code>x</code> 的 <strong>下一个更大的元素</strong> 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 <code>-1</code> 。</p>
</blockquote>
<p>模一下？做两遍，第一遍不操作output；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S; <span class="comment">// 先存一遍，但不操作output；</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">output</span><span class="params">(nums.size())</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; (nums[i] &gt;= S.top())) &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)  &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; (nums[i] &gt;= S.top())) &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (S.empty()) &#123;</span><br><span class="line">                output[i] = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                output[i] = S.top();</span><br><span class="line">            &#125;</span><br><span class="line">            S.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="42-接雨水"><a class="markdownIt-Anchor" href="#42-接雨水"></a> <a href="https://leetcode.cn/problems/trapping-rain-water/" target="_blank" rel="noopener">42. 接雨水</a></h3>
<blockquote>
<p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/rainwatertrap.png" data-index="51" data-src="/2024/03/30/LeetCode-problems/rainwatertrap.png"></p>
<p>（PS：怎么想到了注水法功控，虽然好像不完全是一回事情！）</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S; <span class="comment">// 还是应该存下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; height[i] &gt;= height[S.top()]) &#123;</span><br><span class="line">                <span class="keyword">int</span> last = height[S.top()];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; S.top() &lt;&lt; " " ;</span></span><br><span class="line">                S.pop(); <span class="comment">//只有在每pop一次才相当于积攒了一部分水</span></span><br><span class="line">                <span class="keyword">if</span> (!S.empty()) &#123; <span class="comment">// S空了左边是挡不住水的</span></span><br><span class="line">                    <span class="keyword">int</span> length = i - S.top() - <span class="number">1</span>; <span class="comment">// 因为减完包含了最左边挡住的柱子</span></span><br><span class="line">                    output += length * (min(height[S.top()] , height[i]) - last); <span class="comment">// 距离*高度</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; output &lt;&lt; endl;</span></span><br><span class="line">            &#125;            </span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="84-柱状图中最大的矩形"><a class="markdownIt-Anchor" href="#84-柱状图中最大的矩形"></a> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. 柱状图中最大的矩形</a></h3>
<blockquote>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/histogram.jpg" data-index="52" data-src="/2024/03/30/LeetCode-problems/histogram.jpg"></p>
</blockquote>
<p>“42. 接雨水” 是找每个柱子左右两边第一个大于该柱子高度的柱子，而本题是找每个柱子左右两边第一个小于该柱子的柱子。</p>
<p>太绕了，吐血</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; S; <span class="comment">// 保存下标；</span></span><br><span class="line">        heights.insert(heights.begin(), <span class="number">0</span>);</span><br><span class="line">        heights.push_back(<span class="number">0</span>);</span><br><span class="line">        S.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; heights.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!S.empty() &amp;&amp; heights[i] &lt; heights[S.top()]) &#123;</span><br><span class="line">                last = heights[S.top()];</span><br><span class="line">                S.pop();</span><br><span class="line">                <span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">                    temp = (i - S.top() - <span class="number">1</span>) * last; <span class="comment">// 不在S里面的值都比边缘高</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp = (i + <span class="number">1</span>) * heights[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp &gt; output) &#123;</span><br><span class="line">                    output = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if (S.empty()) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; i &lt;&lt; " " &lt;&lt; output &lt;&lt; " " &lt;&lt; last &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// &#125; </span></span><br><span class="line">            <span class="comment">// else &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; i &lt;&lt; " " &lt;&lt; output &lt;&lt; " " &lt;&lt; last &lt;&lt; " " &lt;&lt; S.top() &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            S.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="图论"><a class="markdownIt-Anchor" href="#图论"></a> 图论</h2>
<blockquote>
<p>深搜(DFS)和广搜(BFS)</p>
<ul>
<li>dfs是可一个方向去搜，不到黄河不回头，直到遇到绝境了，搜不下去了，再换方向（换方向的过程就涉及到了回溯）。</li>
<li>bfs是先把本节点所连接的所有节点遍历一遍，走到下一个节点的时候，再把连接节点的所有节点遍历一遍，搜索方向更像是广度，四面八方的搜索过程。</li>
</ul>
<p><strong>DFS</strong></p>
<p>回溯算法，其实就是dfs的过程，这里给出dfs的代码框架：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本节点所连接的其他节点) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        dfs(图，选择的节点); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong>——一圈一圈搜索</p>
<p><img alt="图三" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/20220825103900.png" data-index="53" data-src="/2024/03/30/LeetCode-problems/20220825103900.png"></p>
<p>仅仅需要一个容器，能保存我们要遍历过的元素就可以，<strong>那么用队列，还是用栈，甚至用数组，都是可以的</strong>。</p>
<p>广搜代码模板，该模板针对的就是，上面的四方格的地图： （详细注释）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;; <span class="comment">// 表示四个方向</span></span><br><span class="line"><span class="comment">// grid 是地图，也就是一个二维数组</span></span><br><span class="line"><span class="comment">// visited标记访问过的节点，不要重复访问</span></span><br><span class="line"><span class="comment">// x,y 表示开始搜索节点的下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; que; <span class="comment">// 定义队列</span></span><br><span class="line">    que.push(&#123;x, y&#125;); <span class="comment">// 起始节点加入队列</span></span><br><span class="line">    visited[x][y] = <span class="literal">true</span>; <span class="comment">// 只要加入队列，立刻标记为访问过的节点</span></span><br><span class="line">    <span class="keyword">while</span>(!que.empty()) &#123; <span class="comment">// 开始遍历队列里的元素</span></span><br><span class="line">        pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; cur = que.front(); que.pop(); <span class="comment">// 从队列取元素</span></span><br><span class="line">        <span class="keyword">int</span> curx = cur.first;</span><br><span class="line">        <span class="keyword">int</span> cury = cur.second; <span class="comment">// 当前节点坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123; <span class="comment">// 开始想当前节点的四个方向左右上下去遍历</span></span><br><span class="line">            <span class="keyword">int</span> nextx = curx + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> nexty = cury + dir[i][<span class="number">1</span>]; <span class="comment">// 获取周边四个方向的坐标</span></span><br><span class="line">            <span class="keyword">if</span> (nextx &lt; <span class="number">0</span> || nextx &gt;= grid.size() || nexty &lt; <span class="number">0</span> || nexty &gt;= grid[<span class="number">0</span>].size()) <span class="keyword">continue</span>;  <span class="comment">// 坐标越界了，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[nextx][nexty]) &#123; <span class="comment">// 如果节点没被访问过</span></span><br><span class="line">                que.push(&#123;nextx, nexty&#125;);  <span class="comment">// 队列添加该节点为下一轮要遍历的节点</span></span><br><span class="line">                visited[nextx][nexty] = <span class="literal">true</span>; <span class="comment">// 只要加入队列立刻标记，避免重复访问</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>——代码随想录</p>
</blockquote>
<h3 id="797-所有可能的路径"><a class="markdownIt-Anchor" href="#797-所有可能的路径"></a> <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/" target="_blank" rel="noopener">797. 所有可能的路径</a></h3>
<blockquote>
<p>给你一个有 <code>n</code> 个节点的 <strong>有向无环图（DAG）</strong>，请你找出所有从节点 <code>0</code> 到节点 <code>n-1</code> 的路径并输出（<strong>不要求按特定顺序</strong>）</p>
<p><code>graph[i]</code> 是一个从节点 <code>i</code> 可以访问的所有节点的列表（即从节点 <code>i</code> 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == graph.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nodeNext:graph[node]) &#123;</span><br><span class="line">            temp.emplace_back(nodeNext);</span><br><span class="line">            dfs(graph, nodeNext);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allPathsSourceTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.emplace_back(<span class="number">0</span>);</span><br><span class="line">        dfs(graph, <span class="number">0</span>);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="200-岛屿数量"><a class="markdownIt-Anchor" href="#200-岛屿数量"></a> <a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noopener">200. 岛屿数量</a></h3>
<blockquote>
<p>给你一个由 <code>'1'</code>（陆地）和 <code>'0'</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<h4 id="解法一dfs"><a class="markdownIt-Anchor" href="#解法一dfs"></a> 解法一——DFS</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//超范围</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[xNext][yNext] &amp;&amp; grid[xNext][yNext] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; xNext &lt;&lt; " " &lt;&lt; yNext &lt;&lt; " "  &lt;&lt; endl;</span></span><br><span class="line">                visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(); <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size(); <span class="comment">// 列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (m, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; output &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">// 未访问过，且是陆地</span></span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    output++;</span><br><span class="line">                    dfs(grid, visited, i, j); <span class="comment">// 将所有链接到的陆地标记为true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二bfs"><a class="markdownIt-Anchor" href="#解法二bfs"></a> 解法二——BFS</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &gt;&gt; Q;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>; <span class="comment">// 以起始点为圆心广搜</span></span><br><span class="line">        Q.push(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">int</span> xCur = cur.first;</span><br><span class="line">            <span class="keyword">int</span> yCur = cur.second;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> xNext = xCur + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yNext = yCur + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">//超范围</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited[xNext][yNext] &amp;&amp; grid[xNext][yNext] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(); <span class="comment">// 行</span></span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size(); <span class="comment">// 列</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (m, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="string">'1'</span>) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; output &lt;&lt; endl;</span></span><br><span class="line">                    <span class="comment">// 未访问过，且是陆地</span></span><br><span class="line">                    <span class="comment">// visited[i][j] = true;</span></span><br><span class="line">                    output++;</span><br><span class="line">                    bfs(grid, visited, i, j); <span class="comment">// 将所有链接到的陆地标记为true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="695-岛屿的最大面积"><a class="markdownIt-Anchor" href="#695-岛屿的最大面积"></a> <a href="https://leetcode.cn/problems/max-area-of-island/" target="_blank" rel="noopener">695. 岛屿的最大面积</a></h3>
<blockquote>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> 。</p>
<p><strong>岛屿</strong> 是由一些相邻的 <code>1</code> (代表土地) 构成的组合，这里的「相邻」要求两个 <code>1</code> 必须在 <strong>水平或者竖直的四个方向上</strong> 相邻。你可以假设 <code>grid</code> 的四个边缘都被 <code>0</code>（代表水）包围着。</p>
<p>岛屿的面积是岛上值为 <code>1</code> 的单元格的数目。</p>
<p>计算并返回 <code>grid</code> 中最大的岛屿面积。如果没有岛屿，则返回面积为 <code>0</code> 。</p>
</blockquote>
<p>考虑使用广搜。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        Q.push(&#123;x, y&#125;);</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> areaSize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cur = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> xNext = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yNext = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited[xNext][yNext] &amp;&amp; grid[xNext][yNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                    visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                    Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                    areaSize++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> areaSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> areaSize = bfs(grid, visited, i, j);</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j &lt;&lt; " " &lt;&lt; areaSize &lt;&lt; endl;</span></span><br><span class="line">                    output = max(areaSize, output);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1020-飞地的数量"><a class="markdownIt-Anchor" href="#1020-飞地的数量"></a> <a href="https://leetcode.cn/problems/number-of-enclaves/" target="_blank" rel="noopener">1020. 飞地的数量</a></h3>
<blockquote>
<p>给你一个大小为 <code>m x n</code> 的二进制矩阵 <code>grid</code> ，其中 <code>0</code> 表示一个海洋单元格、<code>1</code> 表示一个陆地单元格。</p>
<p>一次 <strong>移动</strong> 是指从一个陆地单元格走到另一个相邻（<strong>上、下、左、右</strong>）的陆地单元格或跨过 <code>grid</code> 的边界。</p>
<p>返回网格中 <strong>无法</strong> 在任意次数的移动中离开网格边界的陆地单元格的数量。</p>
</blockquote>
<h4 id="解法一深搜visited数组"><a class="markdownIt-Anchor" href="#解法一深搜visited数组"></a> 解法一——深搜+visited数组</h4>
<p>思路：通过深搜，标记边缘点能够联通的位置。再统计内部其余未被visit的点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[xNext][yNext] &amp;&amp; grid[xNext][yNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; (grid[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123; <span class="comment">// 第一行和最后一行</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[<span class="number">0</span>][j] &amp;&amp; grid[<span class="number">0</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                visited[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[grid.size() - <span class="number">1</span>][j] &amp;&amp; grid[grid.size() - <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                visited[grid.size() - <span class="number">1</span>][j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, grid.size() - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size() - <span class="number">1</span>; i++) &#123; <span class="comment">// 第一列和最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i][<span class="number">0</span>] &amp;&amp; grid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                visited[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i][grid[<span class="number">0</span>].size() - <span class="number">1</span>] &amp;&amp; grid[i][grid[<span class="number">0</span>].size() - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                visited[i][grid[<span class="number">0</span>].size() - <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">                dfs(grid, visited, i, grid[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[i][j] &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二深搜优化空间"><a class="markdownIt-Anchor" href="#解法二深搜优化空间"></a> 解法二——深搜+优化空间</h4>
<p>不使用visited数组，直接对grid进行操作。visit过就将对应位置置零。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size())&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[xNext][yNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[xNext][yNext] = <span class="number">0</span>;</span><br><span class="line">                dfs(grid, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123; <span class="comment">// 第一行和最后一行</span></span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">                dfs(grid,  <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[grid.size() - <span class="number">1</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[grid.size() - <span class="number">1</span>][j] = <span class="number">0</span>;</span><br><span class="line">                dfs(grid,  grid.size() - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size() - <span class="number">1</span>; i++) &#123; <span class="comment">// 第一列和最后一列</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][<span class="number">0</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">                dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][grid[<span class="number">0</span>].size() - <span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[i][grid[<span class="number">0</span>].size() - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                dfs(grid, i, grid[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; grid.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; grid[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="130-被围绕的区域"><a class="markdownIt-Anchor" href="#130-被围绕的区域"></a> <a href="https://leetcode.cn/problems/surrounded-regions/" target="_blank" rel="noopener">130. 被围绕的区域</a></h3>
<blockquote>
<p>给你一个 <code>m x n</code> 的矩阵 <code>board</code> ，由若干字符 <code>'X'</code> 和 <code>'O'</code> ，找到所有被 <code>'X'</code> 围绕的区域，并将这些区域里所有的 <code>'O'</code> 用 <code>'X'</code> 填充。</p>
</blockquote>
<p>与边缘相连的陆地不能沉没，用’T’表示。最后对中心处理，没有和边缘相连的陆地’O’沉没掉变成’X’，而相连的’T’改成’O’。</p>
<h4 id="解法一广搜"><a class="markdownIt-Anchor" href="#解法一广搜"></a> 解法一——广搜</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        Q.push(&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cur = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> xNext = cur.first + dir[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yNext = cur.second + dir[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xNext &lt;= <span class="number">0</span> || yNext &lt;= <span class="number">0</span> || xNext &gt;= board.size() - <span class="number">1</span> || yNext &gt;= board[<span class="number">0</span>].size() - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[xNext][yNext] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[xNext][yNext] = <span class="string">'T'</span>;</span><br><span class="line">                    Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                bfs(board, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[board.size() - <span class="number">1</span>][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                bfs(board, board.size() - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.size() - <span class="number">1</span>; i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                bfs(board, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][board[<span class="number">0</span>].size() - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                bfs(board, i, board[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; board[i][j] &lt;&lt; " ";</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二深搜"><a class="markdownIt-Anchor" href="#解法二深搜"></a> 解法二——深搜</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt;= <span class="number">0</span> || yNext &lt;= <span class="number">0</span> || xNext &gt;= grid.size() - <span class="number">1</span> || yNext &gt;= grid[<span class="number">0</span>].size() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[xNext][yNext] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                grid[xNext][yNext] = <span class="string">'T'</span>;</span><br><span class="line">                dfs(grid, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                dfs(board, <span class="number">0</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[board.size() - <span class="number">1</span>][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                dfs(board, board.size() - <span class="number">1</span>, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.size() - <span class="number">1</span>; i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                dfs(board, i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][board[<span class="number">0</span>].size() - <span class="number">1</span>] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                dfs(board, i, board[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; board.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; board[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; board[i][j] &lt;&lt; " ";</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'O'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (board[i][j] == <span class="string">'T'</span>) &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="417-太平洋大西洋水流问题"><a class="markdownIt-Anchor" href="#417-太平洋大西洋水流问题"></a> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">417. 太平洋大西洋水流问题</a></h3>
<blockquote>
<p>有一个 <code>m × n</code> 的矩形岛屿，与 <strong>太平洋</strong> 和 <strong>大西洋</strong> 相邻。 <strong>“太平洋”</strong> 处于大陆的左边界和上边界，而 <strong>“大西洋”</strong> 处于大陆的右边界和下边界。</p>
<p>这个岛被分割成一个由若干方形单元格组成的网格。给定一个 <code>m x n</code> 的整数矩阵 <code>heights</code> ， <code>heights[r][c]</code> 表示坐标 <code>(r, c)</code> 上单元格 <strong>高于海平面的高度</strong> 。</p>
<p>岛上雨水较多，如果相邻单元格的高度 <strong>小于或等于</strong> 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。</p>
<p>返回网格坐标 <code>result</code> 的 <strong>2D 列表</strong> ，其中 <code>result[i] = [ri, ci]</code> 表示雨水从单元格 <code>(ri, ci)</code> 流动 <strong>既可流向太平洋也可流向大西洋</strong> 。</p>
</blockquote>
<p>想法：建一个表格表示每个位置能够流到哪里。建立表格的原则是低的能向高的覆盖。</p>
<p>原来想一并把output结果处理的，结果还是不行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flows, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;int&gt; temp(2);</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= heights.size() || yNext &gt;= heights[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heights[xNext][yNext] &gt;= heights[x][y]) &#123;</span><br><span class="line">                <span class="comment">// next位置能流到当前位置</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; flows[x][y] &lt;&lt; "|| " &lt;&lt; xNext &lt;&lt; " " &lt;&lt; yNext &lt;&lt; " " &lt;&lt; flows[xNext][yNext] ;</span></span><br><span class="line">                <span class="keyword">if</span> (flows[xNext][yNext] == flows[x][y]) &#123; <span class="comment">// 33,22,11,00</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (flows[xNext][yNext] + flows[x][y] &gt;= <span class="number">3</span> &amp;&amp; flows[xNext][yNext] &lt; <span class="number">3</span>)  &#123; <span class="comment">// 32,23,31,13,30,03,12,21</span></span><br><span class="line">                    <span class="comment">// temp[0] = xNext;</span></span><br><span class="line">                    <span class="comment">// temp[1] = yNext;</span></span><br><span class="line">                    <span class="comment">// output.emplace_back(temp);</span></span><br><span class="line">                    flows[xNext][yNext] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//01,10,02,20</span></span><br><span class="line">                    flows[xNext][yNext] = max(flows[xNext][yNext], flows[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; " || " &lt;&lt; flows[xNext][yNext] &lt;&lt; endl;</span></span><br><span class="line">                dfs(heights, flows, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pacificAtlantic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">// // 两个角落的先传进去</span></span><br><span class="line">        <span class="comment">// temp[0] = 0; temp[1] = heights[0].size() - 1; output.emplace_back(temp);</span></span><br><span class="line">        <span class="comment">// if (heights[0].size() == 1 &amp;&amp; heights.size() == 1) &#123;</span></span><br><span class="line">        <span class="comment">//     return output;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// temp[1] = 0; temp[0] = heights.size() - 1; output.emplace_back(temp);</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flows</span><span class="params">(heights.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(heights[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">        <span class="comment">// 初始化左上为1(太平洋)、右下为2（大西洋）、右上角、左下角角落为3（全都可以）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            flows[i][<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">            flows[i][heights[<span class="number">0</span>].size() - <span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; heights[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            flows[<span class="number">0</span>][j] += <span class="number">1</span>;</span><br><span class="line">            flows[heights.size() - <span class="number">1</span>][j] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flows[<span class="number">0</span>][heights[<span class="number">0</span>].size() - <span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        flows[heights.size() - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            <span class="comment">// if (flows[i][0] == 3) &#123;</span></span><br><span class="line">            <span class="comment">//     temp[0] = i; temp[1] = 0; output.emplace_back(temp);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dfs(heights, flows, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// if (heights[0].size() == 1)&#123;</span></span><br><span class="line">            <span class="comment">//     continue;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (flows[i][heights[0].size() - 1] == 3) &#123;</span></span><br><span class="line">            <span class="comment">//     temp[0] = i; temp[1] = heights[0].size() - 1; output.emplace_back(temp);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dfs(heights, flows, i, heights[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; heights[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            <span class="comment">// if (flows[0][j] == 3) &#123;</span></span><br><span class="line">            <span class="comment">//     temp[0] = 0; temp[1] = j; output.emplace_back(temp);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dfs(heights, flows, <span class="number">0</span>, j);</span><br><span class="line">            <span class="comment">// if (heights.size() == 1)&#123;</span></span><br><span class="line">            <span class="comment">//     continue;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// if (flows[heights.size() - 1][j] == 3) &#123;</span></span><br><span class="line">            <span class="comment">//     temp[0] = heights.size() - 1; temp[1] = j; output.emplace_back(temp);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            dfs(heights, flows, heights.size() - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size() ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; heights[<span class="number">0</span>].size() ; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flows[i][j] == <span class="number">3</span>)&#123;</span><br><span class="line">                    temp[<span class="number">0</span>] = i;</span><br><span class="line">                    temp[<span class="number">1</span>] = j;</span><br><span class="line">                    output.emplace_back(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>改了一下能够一遍处理的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; output; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flows, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= heights.size() || yNext &gt;= heights[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heights[xNext][yNext] &gt;= heights[x][y]) &#123;</span><br><span class="line">                <span class="comment">// next位置能流到当前位置</span></span><br><span class="line">                <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; flows[x][y] &lt;&lt; "|| " &lt;&lt; xNext &lt;&lt; " " &lt;&lt; yNext &lt;&lt; " " &lt;&lt; flows[xNext][yNext] ;</span></span><br><span class="line">                <span class="keyword">if</span> (flows[xNext][yNext] == flows[x][y]) &#123; <span class="comment">// 33,22,11,00</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (flows[xNext][yNext] + flows[x][y] &gt;= <span class="number">3</span> &amp;&amp; flows[xNext][yNext] &lt; <span class="number">3</span>)  &#123; <span class="comment">// 32,23,31,13,30,03,12,21</span></span><br><span class="line">                    temp[<span class="number">0</span>] = xNext;</span><br><span class="line">                    temp[<span class="number">1</span>] = yNext;</span><br><span class="line">                    output.emplace_back(temp);</span><br><span class="line">                    flows[xNext][yNext] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//01,10,02,20</span></span><br><span class="line">                    flows[xNext][yNext] = max(flows[xNext][yNext], flows[x][y]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; " || " &lt;&lt; flows[xNext][yNext] &lt;&lt; endl;</span></span><br><span class="line">                dfs(heights, flows, xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pacificAtlantic</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        <span class="comment">// // 两个角落的先传进去</span></span><br><span class="line">        <span class="comment">// temp[0] = 0; temp[1] = heights[0].size() - 1; output.emplace_back(temp);</span></span><br><span class="line">        <span class="comment">// if (heights[0].size() == 1 &amp;&amp; heights.size() == 1) &#123;</span></span><br><span class="line">        <span class="comment">//     return output;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// temp[1] = 0; temp[0] = heights.size() - 1; output.emplace_back(temp);</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flows</span><span class="params">(heights.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(heights[<span class="number">0</span>].size()))</span></span>;</span><br><span class="line">        <span class="comment">// 初始化左上为1(太平洋)、右下为2（大西洋）、右上角、左下角角落为3（全都可以）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            flows[i][<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">            flows[i][heights[<span class="number">0</span>].size() - <span class="number">1</span>] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; heights[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            flows[<span class="number">0</span>][j] += <span class="number">1</span>;</span><br><span class="line">            flows[heights.size() - <span class="number">1</span>][j] += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        flows[<span class="number">0</span>][heights[<span class="number">0</span>].size() - <span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">        flows[heights.size() - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            <span class="keyword">if</span> (flows[i][<span class="number">0</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">                temp[<span class="number">0</span>] = i; temp[<span class="number">1</span>] = <span class="number">0</span>; output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heights[<span class="number">0</span>].size() != <span class="number">1</span> &amp;&amp; flows[i][heights[<span class="number">0</span>].size() - <span class="number">1</span>] == <span class="number">3</span>) &#123;</span><br><span class="line">                temp[<span class="number">0</span>] = i; temp[<span class="number">1</span>] = heights[<span class="number">0</span>].size() - <span class="number">1</span>; output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; heights[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            <span class="keyword">if</span> (flows[<span class="number">0</span>][j] == <span class="number">3</span>) &#123;</span><br><span class="line">                temp[<span class="number">0</span>] = <span class="number">0</span>; temp[<span class="number">1</span>] = j; output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (heights.size() != <span class="number">1</span> &amp;&amp; flows[heights.size() - <span class="number">1</span>][j] == <span class="number">3</span>) &#123;</span><br><span class="line">                temp[<span class="number">0</span>] = heights.size() - <span class="number">1</span>; temp[<span class="number">1</span>] = j; output.emplace_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); i++) &#123;<span class="comment">// 首尾列</span></span><br><span class="line">            dfs(heights, flows, i, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (heights[<span class="number">0</span>].size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(heights, flows, i, heights[<span class="number">0</span>].size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; heights[<span class="number">0</span>].size() - <span class="number">1</span>; j++) &#123;<span class="comment">// 首尾行</span></span><br><span class="line">            dfs(heights, flows, <span class="number">0</span>, j);</span><br><span class="line">            <span class="keyword">if</span> (heights.size() == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(heights, flows, heights.size() - <span class="number">1</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//  for (int i = 0; i &lt; heights.size() ; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; heights[0].size() ; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (flows[i][j] == 3)&#123;</span></span><br><span class="line">        <span class="comment">//             temp[0] = i;</span></span><br><span class="line">        <span class="comment">//             temp[1] = j;</span></span><br><span class="line">        <span class="comment">//             output.emplace_back(temp);</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="827-最大人工岛"><a class="markdownIt-Anchor" href="#827-最大人工岛"></a> <a href="https://leetcode.cn/problems/making-a-large-island/" target="_blank" rel="noopener">827. 最大人工岛</a></h3>
<blockquote>
<p>给你一个大小为 <code>n x n</code> 二进制矩阵 <code>grid</code> 。<strong>最多</strong> 只能将一格 <code>0</code> 变成 <code>1</code> 。</p>
<p>返回执行此操作后，<code>grid</code> 中最大的岛屿面积是多少？</p>
<p><strong>岛屿</strong> 由一组上、下、左、右四个方向相连的 <code>1</code> 形成。</p>
</blockquote>
<p>暴力思路——每次改一个，看结果怎么变化。</p>
<p>思路：一遍深搜先把每个位置对应的岛屿大小保存。第二遍只检测原来为0的位置，通过四个方向的岛屿面积累加得到。这里保存岛屿大小时候需要把岛屿的编号也保存，以保证独立性。由于统计岛屿大小时候无法直接录入最终的岛屿面积，所以只保存编号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> islandIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[xNext][yNext] == <span class="number">1</span>) &#123;</span><br><span class="line">                grid[xNext][yNext] = islandIndex;</span><br><span class="line">                count ++;</span><br><span class="line">                dfs(grid, xNext, yNext, islandIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// int islandAreaSum  (vector&lt;vector&lt;int&gt;&gt; areaIndex, int x, int y, unordered_map &lt;int, int&gt; areaMap) &#123;</span></span><br><span class="line">    <span class="comment">//     int area = 0;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; 4; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         int xNext = x + dir[i][0];</span></span><br><span class="line">    <span class="comment">//         int yNext = y + dir[i][1];</span></span><br><span class="line">    <span class="comment">//         if (xNext &lt; 0 || yNext &lt; 0 || xNext &gt;= areaIndex.size() || yNext &gt;= areaIndex[0].size()) &#123;</span></span><br><span class="line">    <span class="comment">//             continue;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if (areaIndex[xNext][yNext] != 0) &#123;</span></span><br><span class="line">    <span class="comment">//             // cout &lt;&lt; xNext &lt;&lt; " | " &lt;&lt; yNext &lt;&lt; " " &lt;&lt;areaMap[areaIndex[xNext][yNext]] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//             area += areaMap[areaIndex[xNext][yNext]];</span></span><br><span class="line">    <span class="comment">//             areaMap[areaIndex[xNext][yNext]] = 0; // 置零只能加一次，同时这个局部变量不影响全局</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     // cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " " &lt;&lt; area &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//     return area + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;int&gt;&gt; areaIndex(grid.size(), vector&lt;int&gt;(grid[0].size())); // 保存每个位置的编号</span></span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; areaMap; <span class="comment">// 保存编号和面积的关系</span></span><br><span class="line">        <span class="keyword">bool</span> allOne = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一遍深搜先把每个位置对应的岛屿大小保存。</span></span><br><span class="line">        <span class="keyword">int</span> islandIndex = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    allOne = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = islandIndex;</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                    dfs(grid,  i, j, islandIndex);</span><br><span class="line">                    areaMap[islandIndex] = count;</span><br><span class="line">                    islandIndex++;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; count &lt;&lt; " ";</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allOne) &#123;</span><br><span class="line">            <span class="keyword">return</span> grid.size() * grid[<span class="number">0</span>].size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二次深搜搜原来为0的位置，累加能得到的最大面积</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 检查四个方向陆地面积的和</span></span><br><span class="line">                    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">                    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> xNext = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> yNext = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (temp.find(grid[xNext][yNext]) == temp.end()) &#123;</span><br><span class="line">                            <span class="comment">// cout &lt;&lt; xNext &lt;&lt; " | " &lt;&lt; yNext &lt;&lt; " " &lt;&lt;areaMap[areaIndex[xNext][yNext]] &lt;&lt; endl;</span></span><br><span class="line">                            area += areaMap[grid[xNext][yNext]];</span><br><span class="line">                            temp.insert(grid[xNext][yNext]);</span><br><span class="line">                            <span class="comment">// areaMap[areaIndex[xNext][yNext]] = 0; </span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxArea = max(area + <span class="number">1</span>, maxArea);</span><br><span class="line">                    <span class="comment">// maxArea = max(islandAreaSum(grid, i, j, areaMap), maxArea);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="127-单词接龙"><a class="markdownIt-Anchor" href="#127-单词接龙"></a> <a href="https://leetcode.cn/problems/word-ladder/" target="_blank" rel="noopener">127. 单词接龙</a></h3>
<blockquote>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
</blockquote>
<ul>
<li>图中的线是如何连在一起的</li>
<li>起点和终点的最短路径长度</li>
</ul>
<p><strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(<span class="built_in">string</span> beginWord, <span class="built_in">string</span> endWord, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">wordSet</span><span class="params">(wordList.begin(), wordList.end())</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (wordSet.find(endWord) == wordSet.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; isVisited; <span class="comment">// 保存到这个单词的路径长度</span></span><br><span class="line">        <span class="comment">// 使用广搜</span></span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; Q;</span><br><span class="line">        Q.push(beginWord);</span><br><span class="line">        isVisited[beginWord] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="built_in">string</span> cur = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">                <span class="built_in">string</span> newWord = cur;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    newWord[i] = <span class="string">'a'</span> + j;</span><br><span class="line">                    <span class="keyword">if</span> (newWord == endWord) &#123;</span><br><span class="line">                        <span class="keyword">return</span> isVisited[cur] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (wordSet.find(newWord) != wordSet.end() &amp;&amp; isVisited[newWord] == <span class="number">0</span>) &#123;</span><br><span class="line">                        isVisited[newWord] = isVisited[cur] + <span class="number">1</span>;</span><br><span class="line">                        Q.push(newWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="841-钥匙和房间"><a class="markdownIt-Anchor" href="#841-钥匙和房间"></a> <a href="https://leetcode.cn/problems/keys-and-rooms/" target="_blank" rel="noopener">841. 钥匙和房间</a></h3>
<blockquote>
<p>有 <code>n</code> 个房间，房间按从 <code>0</code> 到 <code>n - 1</code> 编号。最初，除 <code>0</code> 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>
<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>
<p>给你一个数组 <code>rooms</code> 其中 <code>rooms[i]</code> 是你进入 <code>i</code> 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
<p>和上一题的思路类似，利用广度搜索。但是可以不定义isVisited为int了，bool就够了，外面放一个count计数满为止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canVisitAllRooms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; rooms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>; <span class="comment">// 0号房间一定能够进入</span></span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(rooms.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        visited[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> room:rooms[<span class="number">0</span>]) &#123;</span><br><span class="line">            Q.push(room);</span><br><span class="line">            visited[room] = <span class="literal">true</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count == rooms.size()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rooms[cur].size(); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[rooms[cur][i]] == <span class="literal">false</span>) &#123; <span class="comment">// 说明还没有过</span></span><br><span class="line">                    Q.push(rooms[cur][i]);</span><br><span class="line">                    visited[rooms[cur][i]] = <span class="literal">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="keyword">if</span> (count == rooms.size()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="463-岛屿的周长"><a class="markdownIt-Anchor" href="#463-岛屿的周长"></a> <a href="https://leetcode.cn/problems/island-perimeter/" target="_blank" rel="noopener">463. 岛屿的周长</a></h3>
<blockquote>
<p>给定一个 <code>row x col</code> 的二维网格地图 <code>grid</code> ，其中：<code>grid[i][j] = 1</code> 表示陆地， <code>grid[i][j] = 0</code> 表示水域。</p>
<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
</blockquote>
<h4 id="解法一深搜-2"><a class="markdownIt-Anchor" href="#解法一深搜-2"></a> 解法一——深搜</h4>
<p>深搜把</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid,  <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (grid[xNext][yNext] == <span class="number">1</span> ) &#123;</span><br><span class="line">                grid[xNext][yNext] = <span class="number">2</span>;</span><br><span class="line">                dfs(grid,  xNext, yNext);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[xNext][yNext] == <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)) ;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    grid[i][j] = <span class="number">2</span>;</span><br><span class="line">                    dfs(grid,  i, j);</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二遍历"><a class="markdownIt-Anchor" href="#解法二遍历"></a> 解法二——遍历</h4>
<p>遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，就可以计算边了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt;(grid[0].size(), false)) ;</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> xNext = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> yNext = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size() || grid[xNext][yNext] == <span class="number">0</span>) &#123;</span><br><span class="line">                            count++;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3>
<h4 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h4>
<p>大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p>
<p>并查集主要有两个功能：</p>
<ul>
<li>将两个元素添加到一个集合中。</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">1005</span>; <span class="comment">// n根据题目中节点数量而定，一般比节点数量大一点就好</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; father = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (n, <span class="number">0</span>); <span class="comment">// C++里的一种数组结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集里寻根的过程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u == father[u] ? u : father[u] = find(father[u]); <span class="comment">// 路径压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 u 和 v是否找到同一个根</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u);</span><br><span class="line">    v = find(v);</span><br><span class="line">    <span class="keyword">return</span> u == v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将v-&gt;u 这条边加入并查集</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    u = find(u); <span class="comment">// 寻找u的根</span></span><br><span class="line">    v = find(v); <span class="comment">// 寻找v的根</span></span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> ; <span class="comment">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span></span><br><span class="line">    father[v] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过模板，我们可以知道，并查集主要有三个功能。</p>
<ol>
<li>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个</li>
<li>将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上</li>
<li>判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</li>
</ol>
<h4 id="2492-两个城市间路径的最小分数"><a class="markdownIt-Anchor" href="#2492-两个城市间路径的最小分数"></a> <a href="https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/" target="_blank" rel="noopener">2492. 两个城市间路径的最小分数</a></h4>
<blockquote>
<p>给你一个正整数 <code>n</code> ，表示总共有 <code>n</code> 个城市，城市从 <code>1</code> 到 <code>n</code> 编号。给你一个二维数组 <code>roads</code> ，其中 <code>roads[i] = [ai, bi, distancei]</code> 表示城市 <code>ai</code> 和 <code>bi</code> 之间有一条 <strong>双向</strong> 道路，道路距离为 <code>distancei</code> 。城市构成的图不一定是连通的。</p>
<p>两个城市之间一条路径的 <strong>分数</strong> 定义为这条路径中道路的 <strong>最小</strong> 距离。</p>
<p>城市 <code>1</code> 和城市 <code>n</code> 之间的所有路径的 <strong>最小</strong> 分数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>一条路径指的是两个城市之间的道路序列。</li>
<li>一条路径可以 <strong>多次</strong> 包含同一条道路，你也可以沿着路径多次到达城市 <code>1</code> 和城市 <code>n</code> 。</li>
<li>测试数据保证城市 <code>1</code> 和城市<code>n</code> 之间 <strong>至少</strong> 有一条路径。</li>
</ul>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parent  = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">100005</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100005</span>; ++i) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findparent</span><span class="params">( <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (parent[x] != x) &#123;</span></span><br><span class="line">        <span class="comment">//     parent[x] = findparent(parent, parent[x]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return parent[x];</span></span><br><span class="line">        <span class="keyword">return</span> x == parent[x] ? x : (parent[x] = findparent(parent[x])); <span class="comment">// 路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = findparent(x);</span><br><span class="line">        <span class="keyword">int</span> fy = findparent(y);</span><br><span class="line">        parent[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScore</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// vector&lt;int&gt; parent(n + 1);</span></span><br><span class="line">        init();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rd : roads) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rd[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = rd[<span class="number">1</span>];</span><br><span class="line">            add(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> f0 = findparent(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; f0 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; rd : roads) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rd[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> fx = findparent( x);</span><br><span class="line">            <span class="comment">// int fy = findparent(parent, rd[1]);</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; fx &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">if</span> (fx == f0 ) &#123;</span><br><span class="line">                res = min(res, rd[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1971-寻找图中是否存在路径"><a class="markdownIt-Anchor" href="#1971-寻找图中是否存在路径"></a> <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/" target="_blank" rel="noopener">1971. 寻找图中是否存在路径</a></h3>
<blockquote>
<p>有一个具有 <code>n</code> 个顶点的 <strong>双向</strong> 图，其中每个顶点标记从 <code>0</code> 到 <code>n - 1</code>（包含 <code>0</code> 和 <code>n - 1</code>）。图中的边用一个二维整数数组 <code>edges</code> 表示，其中 <code>edges[i] = [ui, vi]</code> 表示顶点 <code>ui</code> 和顶点 <code>vi</code> 之间的双向边。 每个顶点对由 <strong>最多一条</strong> 边连接，并且没有顶点存在与自身相连的边。</p>
<p>请你确定是否存在从顶点 <code>source</code> 开始，到顶点 <code>destination</code> 结束的 <strong>有效路径</strong> 。</p>
<p>给你数组 <code>edges</code> 和整数 <code>n</code>、<code>source</code> 和 <code>destination</code>，如果从 <code>source</code> 到 <code>destination</code> 存在 <strong>有效路径</strong> ，则返回 <code>true</code>，否则返回 <code>false</code> 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> parent[<span class="number">200001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200001</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == parent[u] ? u : (parent[u] = findParent(parent[u]));</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPath</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; edges.size(); i++) &#123;</span></span><br><span class="line">        <span class="comment">//     join(edges[i][0], edges[i][1]);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> isSame(source, destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="684-冗余连接"><a class="markdownIt-Anchor" href="#684-冗余连接"></a> <a href="https://leetcode.cn/problems/redundant-connection/" target="_blank" rel="noopener">684. 冗余连接</a></h3>
<blockquote>
<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>
<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的那个。</p>
</blockquote>
<p>大致思路就是后面的加入得边的两个端点不能是相同的祖先。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> parent[<span class="number">1001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findParent</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == parent[u] ? u : (parent[u] = findParent(parent[u]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        parent[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSame(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="685-冗余连接-ii"><a class="markdownIt-Anchor" href="#685-冗余连接-ii"></a> <a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener">685. 冗余连接 II</a></h3>
<blockquote>
<p>在本问题中，有根树指满足以下条件的 <strong>有向</strong> 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 <code>n</code> 个节点（节点值不重复，从 <code>1</code> 到 <code>n</code>）的树及一条附加的有向边构成。附加的边包含在 <code>1</code> 到 <code>n</code> 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 <code>edges</code> 。 每个元素是一对 <code>[ui, vi]</code>，用以表示 <strong>有向</strong> 图中连接顶点 <code>ui</code> 和顶点 <code>vi</code> 的边，其中 <code>ui</code> 是 <code>vi</code> 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 <code>n</code> 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
</blockquote>
<p>三种情况：</p>
<ul>
<li>
<p>出现入度为2的节点</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png" data-index="54" data-src="/2024/03/30/LeetCode-problems/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II1.png"></p>
</li>
<li>
<p>存在有向环<br>
<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png" data-index="55" data-src="/2024/03/30/LeetCode-problems/685.%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5II2.png"></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> parent[<span class="number">1001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findParent</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == parent[u] ? u : (parent[u] = findParent(parent[u]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="comment">// u是v的根节点；</span></span><br><span class="line">        parent[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTreeRemove</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; removeEdge)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="comment">// if (edge[0] == removeEdge[0] &amp;&amp; edge[1] == removeEdge[1]) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(edge == removeEdge) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSame(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRemove</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSame(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inDegree[<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; S; <span class="comment">// 保存入度大于2的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            inDegree[edge[<span class="number">1</span>]] ++;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[edge[<span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">                S.push(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在入度为2的节点</span></span><br><span class="line">        <span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTreeRemove(edges, S.top())) &#123;</span><br><span class="line">                <span class="keyword">return</span> S.top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                <span class="keyword">return</span> S.top();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在有向环</span></span><br><span class="line">        <span class="keyword">return</span> getRemove(edges);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;<span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> parent[<span class="number">1001</span>];</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findParent</span> <span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> u == parent[u] ? u : (parent[u] = findParent(parent[u]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSame</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="keyword">return</span> u == v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = findParent(u);</span><br><span class="line">        v = findParent(v);</span><br><span class="line">        <span class="comment">// u是v的根节点；</span></span><br><span class="line">        parent[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isTreeRemove</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; removeEdge)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="comment">// if (edge[0] == removeEdge[0] &amp;&amp; edge[1] == removeEdge[1]) &#123;</span></span><br><span class="line">            <span class="keyword">if</span>(edge == removeEdge) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isSame(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getRemove</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;edges)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSame(edge[<span class="number">0</span>], edge[<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">            &#125;</span><br><span class="line">            join(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantDirectedConnection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inDegree[<span class="number">1001</span>];</span><br><span class="line">        <span class="built_in">stack</span> &lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; S; <span class="comment">// 保存入度大于2的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            inDegree[edge[<span class="number">1</span>]] ++;          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> edge:edges) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[edge[<span class="number">1</span>]] == <span class="number">2</span>) &#123;</span><br><span class="line">                S.push(edge);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在入度为2的节点</span></span><br><span class="line">        <span class="keyword">if</span> (!S.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isTreeRemove(edges, S.top())) &#123;</span><br><span class="line">                <span class="keyword">return</span> S.top();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                S.pop();</span><br><span class="line">                <span class="keyword">return</span> S.top();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存在有向环</span></span><br><span class="line">        <span class="keyword">return</span> getRemove(edges);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="增补热题100"><a class="markdownIt-Anchor" href="#增补热题100"></a> 增补——热题100</h2>
<h3 id="49-字母异位词分组"><a class="markdownIt-Anchor" href="#49-字母异位词分组"></a> <a href="https://leetcode.cn/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h3>
<blockquote>
<p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p>
<p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">groupAnagrams</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; output;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; hashMap;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">string</span> str = strs[i];</span><br><span class="line">            sort(str.begin(), str.end());</span><br><span class="line">            hashMap[str].emplace_back(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> str:hashMap) &#123;</span><br><span class="line">            output.emplace_back(str.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="128-最长连续序列"><a class="markdownIt-Anchor" href="#128-最长连续序列"></a> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h3>
<blockquote>
<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
</blockquote>
<ul>
<li>怎么判断呢，就是用哈希表查找这个数前面一个数是否存在，即num-1在序列中是否存在。存在那这个数肯定不是开头，直接跳过。</li>
<li>因此只需要对每个开头的数进行循环，直到这个序列不再连续，因此复杂度是O(n)。 以题解中的序列举例:<br>
<strong>[100，4，200，1，3，4，2]</strong><br>
去重后的哈希序列为：<strong>[100，4，200，1，3，2]</strong></li>
</ul>
<p>——力扣题解评论</p>
<p>我写的和题解反的，但是结果都一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; hashSet;</span><br><span class="line">        <span class="comment">// 先去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">            hashSet.insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:hashSet) &#123;</span><br><span class="line">            <span class="comment">// 要防止后续的数字继续遍历，所以要确保开始遍历一定是结尾！！！题解的写法是保一定是开头</span></span><br><span class="line">            <span class="keyword">if</span> (hashSet.find(num + <span class="number">1</span>) == hashSet.end()) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> cur = num;</span><br><span class="line">                <span class="keyword">while</span> (hashSet.find(cur - <span class="number">1</span>) != hashSet.end()) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; num &lt;&lt; " " &lt;&lt; cur &lt;&lt; " " &lt;&lt;  count &lt;&lt; endl;</span></span><br><span class="line">                    count++;</span><br><span class="line">                    cur--;</span><br><span class="line">                &#125;</span><br><span class="line">                output = max(output, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="283-移动零"><a class="markdownIt-Anchor" href="#283-移动零"></a> <a href="https://leetcode.cn/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h3>
<blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">0</span>; right &lt; nums.size(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span> ) &#123;</span><br><span class="line">                nums[left++] = nums[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; left &lt; nums.size(); left++) &#123;</span><br><span class="line">            nums[left] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-盛最多水的容器"><a class="markdownIt-Anchor" href="#11-盛最多水的容器"></a> <a href="https://leetcode.cn/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h3>
<blockquote>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
</blockquote>
<h4 id="解法一单调栈"><a class="markdownIt-Anchor" href="#解法一单调栈"></a> 解法一——单调栈</h4>
<p>很慢，能过</p>
<p>单调栈，栈内元素从小到大</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; increasingVector;</span><br><span class="line">        increasingVector.emplace_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; increasingVector.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = min(height[i], height[increasingVector[j]]) * (i - increasingVector[j]);</span><br><span class="line">                output = max(temp, output);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &gt; height[increasingVector[increasingVector.size() - <span class="number">1</span>]]) &#123;</span><br><span class="line">                increasingVector.emplace_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二双指针"><a class="markdownIt-Anchor" href="#解法二双指针"></a> 解法二——双指针</h4>
<p>左右两个指针总是移动较小的那个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                h = height[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                h = height[right];</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = (right - left + <span class="number">1</span>) * h;</span><br><span class="line">            output = max(temp, output);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-无重复字符的最长子串"><a class="markdownIt-Anchor" href="#3-无重复字符的最长子串"></a> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. 无重复字符的最长子串</a></h3>
<blockquote>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长</strong> <strong>子串</strong> 的长度。</p>
</blockquote>
<p>还以为是KMP算法。不需要KMP，使用滑动窗口就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">hashMap</span><span class="params">(<span class="number">128</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        hashMap[s[left] - <span class="string">' '</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashMap[s[right] - <span class="string">' '</span>]) &#123; <span class="comment">// 之前存过了</span></span><br><span class="line">                <span class="keyword">while</span> (s[left] != s[right]) &#123;</span><br><span class="line">                    hashMap[s[left] - <span class="string">' '</span>] = <span class="literal">false</span>;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 此时正好检测到s[left] == s[right], 哈希表不需要动</span></span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                hashMap[s[right] - <span class="string">' '</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; right &lt;&lt; " " &lt;&lt; left &lt;&lt; " " &lt;&lt; endl;</span></span><br><span class="line">            output = max(output, right - left + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="438-找到字符串中所有字母异位词"><a class="markdownIt-Anchor" href="#438-找到字符串中所有字母异位词"></a> <a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. 找到字符串中所有字母异位词</a></h3>
<blockquote>
<p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p><strong>异位词</strong> 指由相同字母重排列形成的字符串（包括相同的字符串）</p>
</blockquote>
<p>想复杂了！滑动窗口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; p.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pCount</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p.length(); i++) &#123;</span><br><span class="line">            sCount[s[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">            pCount[p[i] - <span class="string">'a'</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sCount == pCount) &#123;</span><br><span class="line">            output.emplace_back(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length() - p.length(); j++) &#123;</span><br><span class="line">            sCount[s[j] - <span class="string">'a'</span>] --;</span><br><span class="line">            sCount[s[j + p.length()] - <span class="string">'a'</span>] ++ ;</span><br><span class="line">            <span class="keyword">if</span> (sCount == pCount) &#123;</span><br><span class="line">                output.emplace_back(j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="560-和为-k-的子数组"><a class="markdownIt-Anchor" href="#560-和为-k-的子数组"></a> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为 K 的子数组</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。</p>
<p>子数组是数组中元素的连续非空序列。</p>
</blockquote>
<p>连续，那好像好办一点！</p>
<h4 id="解法一暴力解法但是超时"><a class="markdownIt-Anchor" href="#解法一暴力解法但是超时"></a> 解法一——暴力解法，但是超时</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preSum</span><span class="params">(nums.size())</span></span>; <span class="comment">// 记录到当前位置之前能够组成的数字大小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                preSum[j] += nums[i];</span><br><span class="line">                <span class="keyword">if</span> (preSum[j] == k) &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二前缀和建表"><a class="markdownIt-Anchor" href="#解法二前缀和建表"></a> 解法二——前缀和建表</h4>
<p>定义<code>pre[i]</code>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,\dots, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的和，那么<code>pre[i]</code>可以有<code>pre[i-1]</code>递推得到，<code>pre[i] = pre[i-1] + nums[i]</code>。要使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>j</mi><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[j,\dots, i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>的和为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>，<code>pre[j-1] + k == pre[i]</code>。也就是说到i位置时候，要找和为k的子序列，只需要找到之前和为<code>pre[i]-k</code>的子序列有多少个。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; preSum;</span><br><span class="line">        preSum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num:nums) &#123;</span><br><span class="line">            pre += num;</span><br><span class="line">            output += preSum[pre - k];</span><br><span class="line">            preSum[pre] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="76-最小覆盖子串"><a class="markdownIt-Anchor" href="#76-最小覆盖子串"></a> <a href="https://leetcode.cn/problems/minimum-window-substring/" target="_blank" rel="noopener">76. 最小覆盖子串</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
</blockquote>
<p>很凌乱的做法,5555</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minWindow</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> output;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sCount</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 计数用</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">tCount</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">// 计数用</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">originMap</span><span class="params">(<span class="number">100</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">tMap</span><span class="params">(<span class="number">100</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 判断对应字母有没有满足</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">leftRight</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            tCount[t[i] - <span class="string">'A'</span>] ++;</span><br><span class="line">            tMap[t[i] - <span class="string">'A'</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (right = <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tCount[s[right] - <span class="string">'A'</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">                sCount[s[right] - <span class="string">'A'</span>] ++;</span><br><span class="line">                <span class="comment">// cout &lt;&lt; right &lt;&lt; " " &lt;&lt; sCount[s[right] - 'A'] &lt;&lt; " " &lt;&lt; tCount[s[right] - 'A'] &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span> (sCount[s[right] - <span class="string">'A'</span>] &gt;= tCount[s[right] - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                    tMap[s[right] - <span class="string">'A'</span>] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果都清空了</span></span><br><span class="line">                <span class="keyword">if</span> (tMap == originMap) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; "C" &lt;&lt; " ";</span></span><br><span class="line">                    <span class="comment">// 先让left右移，看看能右移到什么程度还能满足要求</span></span><br><span class="line">                    <span class="keyword">while</span> (tMap == originMap &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; "B" &lt;&lt; " ";</span></span><br><span class="line">                        <span class="keyword">if</span> (tCount[s[left] - <span class="string">'A'</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                            left++;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (sCount[s[left] - <span class="string">'A'</span>] &gt; tCount[s[left] - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                                sCount[s[left] - <span class="string">'A'</span>] --;</span><br><span class="line">                                left++;</span><br><span class="line">                                <span class="comment">// cout &lt;&lt; "A" &lt;&lt; " ";</span></span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 全false，说明满足</span></span><br><span class="line">                    <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                        leftRight[<span class="number">0</span>] = left;</span><br><span class="line">                        leftRight[<span class="number">1</span>] = right;</span><br><span class="line">                        len = right - left + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == INT_MAX) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substr(leftRight[<span class="number">0</span>], len);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="189-轮转数组"><a class="markdownIt-Anchor" href="#189-轮转数组"></a> <a href="https://leetcode.cn/problems/rotate-array/" target="_blank" rel="noopener">189. 轮转数组</a></h3>
<blockquote>
<p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
</blockquote>
<h4 id="解法一队列"><a class="markdownIt-Anchor" href="#解法一队列"></a> 解法一——队列</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        k = k % nums.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            Q.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size() + k; i++) &#123;</span><br><span class="line">            Q.push(nums[i % nums.size()]);</span><br><span class="line">            nums[i % nums.size()] = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二两次反转"><a class="markdownIt-Anchor" href="#解法二两次反转"></a> 解法二——两次反转</h4>
<p>类似卡码网55</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            swap(nums[start++],nums[end--]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        reverseVector(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">        k = k % nums.size();</span><br><span class="line">        reverseVector(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverseVector(nums, k, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="238-除自身以外数组的乘积"><a class="markdownIt-Anchor" href="#238-除自身以外数组的乘积"></a> <a href="https://leetcode.cn/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. 除自身以外数组的乘积</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>题目数据 <strong>保证</strong> 数组 <code>nums</code>之中任意元素的全部前缀元素和后缀的乘积都在 <strong>32 位</strong> 整数范围内。</p>
<p>请 **不要使用除法，**且在 <code>O(n)</code> 时间复杂度内完成此题。</p>
</blockquote>
<p>不要使用除法咋做啊。注意本来除法也不行，有0的问题</p>
<h4 id="解法一左右乘积列表"><a class="markdownIt-Anchor" href="#解法一左右乘积列表"></a> 解法一——左右乘积列表</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        right[nums.size() - <span class="number">1</span>] = nums[nums.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size();i++) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] * nums[i];</span><br><span class="line">            right[nums.size() - <span class="number">1</span> - i] =  right[nums.size() - i] * nums[nums.size() - <span class="number">1</span> - i];</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = right[<span class="number">1</span>];</span><br><span class="line">        answer[nums.size() - <span class="number">1</span>] = left[nums.size() - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size() - <span class="number">1</span>;i++) &#123;</span><br><span class="line">            answer[i] = left[i - <span class="number">1</span>] * right[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二空间复杂度为mathcal-o1"><a class="markdownIt-Anchor" href="#解法二空间复杂度为mathcal-o1"></a> 解法二——空间复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></h4>
<p>右侧不用一个vector来存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">answer</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            answer[i] = answer[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = nums[nums.size() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            answer[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="41-缺失的第一个正数"><a class="markdownIt-Anchor" href="#41-缺失的第一个正数"></a> <a href="https://leetcode.cn/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></h3>
<blockquote>
<p>给你一个未排序的整数数组 <code>nums</code> ，请你找出其中没有出现的最小的正整数。</p>
<p>请你实现时间复杂度为 <code>O(n)</code> 并且只使用常数级别额外空间的解决方案。</p>
</blockquote>
<p>排序的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>啊，而且要没有额外的空间的话哈希表好像也不好使。</p>
<h4 id="解法一原始数组作为hash表"><a class="markdownIt-Anchor" href="#解法一原始数组作为hash表"></a> 解法一——原始数组作为hash表</h4>
<p>我们为什么要使用哈希表？这是因为哈希表是一个可以支持快速查找的数据结构：给定一个元素，我们可以在O(1) 的时间查找该元素是否在哈希表中。</p>
<p><strong>对于一个长度为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> 的数组，其中没有出现的最小正整数只能在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, N+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 中。这是因为如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span> 都出现了，那么答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，否则答案是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1, N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>​ 中没有出现的最小正整数。</strong></p>
<p>【怎么标记呢？】</p>
<ul>
<li>我们将数组中所有小于等于 0 的数修改为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></li>
<li>我们遍历数组中的每一个数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>，它可能已经被打了标记，因此原本对应的数为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mtext> </mtext><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\,|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∣</span></span></span></span> 为绝对值符号。如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">|x| \in [1, N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>，那么我们给数组中的第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">|x| - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个位置的数添加一个负号。注意如果它已经有负号，不需要重复添加；</li>
<li>在遍历完成之后，如果数组中的每一个数都是负数，那么答案是 N+1N+1N+1，否则答案是第一个正数的位置加 111。</li>
</ul>
<p><strong>用下标的正负作为bool类型的hash表</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = nums.size() + <span class="number">1</span>; <span class="comment">// 如果要出现N+1的情况，里面存的数字应该是1~N，所以这边要避开N</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(nums[i]) &lt;= nums.size()) &#123;</span><br><span class="line">                nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>] = - <span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(nums[i]) - <span class="number">1</span>]); <span class="comment">// 这里要防止反转两次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二类似排序直接交换到对应下标位置去"><a class="markdownIt-Anchor" href="#解法二类似排序直接交换到对应下标位置去"></a> 解法二——类似排序？直接交换到对应下标位置去</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;=<span class="number">1</span> &amp;&amp; nums[i] &lt;=nums.size() &amp;&amp; nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123; </span><br><span class="line">                <span class="comment">// 第三个条件防止死循环，另外这里是while!换回去的那个元素还得接着换</span></span><br><span class="line">                swap(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="73-矩阵置零"><a class="markdownIt-Anchor" href="#73-矩阵置零"></a> <a href="https://leetcode.cn/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. 矩阵置零</a></h3>
<blockquote>
<p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a></strong> 算法**。**</p>
</blockquote>
<h4 id="解法一记录行列"><a class="markdownIt-Anchor" href="#解法一记录行列"></a> 解法一——记录行列</h4>
<p>一个简单的思路，先遍历一遍记录哪些行列需要标记为0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setZeroes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">row</span><span class="params">(matrix.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">column</span><span class="params">(matrix[<span class="number">0</span>].size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    row[i] = <span class="literal">true</span>;</span><br><span class="line">                    column[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (row[i] == <span class="literal">true</span> || column[j] == <span class="literal">true</span>) &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二使用标记变量"><a class="markdownIt-Anchor" href="#解法二使用标记变量"></a> 解法二——使用标记变量</h4>
<p>这两个解法真的太离谱了，不想写</p>
<p>【两个标记变量】</p>
<p>我们可以用矩阵的第一行和第一列代替方法一中的两个标记数组，以达到 O(1) 的额外空间。但这样会导致原数组的第一行和第一列被修改，无法记录它们是否原本包含 0。因此我们需要额外使用两个标记变量分别记录第一行和第一列是否原本包含 0。</p>
<p>【一个标记变量】</p>
<p>这样，第一列的第一个元素即可以标记第一行是否出现 0。但为了防止每一列的第一个元素被提前更新，我们需要从最后一行开始，倒序地处理矩阵元素。</p>
<h3 id="54-螺旋矩阵"><a class="markdownIt-Anchor" href="#54-螺旋矩阵"></a> <a href="https://leetcode.cn/problems/spiral-matrix/" target="_blank" rel="noopener">54. 螺旋矩阵</a></h3>
<blockquote>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
</blockquote>
<p>写的一坨shit</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> length = m * n;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;; <span class="comment">// 01右；10下；0-1左；-10上</span></span><br><span class="line">        <span class="keyword">int</span> countDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            output.emplace_back(matrix[x][y]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; count &lt;&lt; " || ";</span></span><br><span class="line">            <span class="keyword">if</span>(count &lt;= <span class="number">1</span>) &#123; <span class="comment">// count = 1 换方向</span></span><br><span class="line">                countDir = (countDir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                m -= <span class="built_in">abs</span>(dir[countDir][<span class="number">0</span>]);</span><br><span class="line">                n -= <span class="built_in">abs</span>(dir[countDir][<span class="number">1</span>]);</span><br><span class="line">                count = <span class="built_in">abs</span>(dir[countDir][<span class="number">0</span>]) * m + <span class="built_in">abs</span>(dir[countDir][<span class="number">1</span>]) * n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt;" "  &lt;&lt;count &lt;&lt; " || " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " || " &lt;&lt; countDir &lt;&lt; " " &lt;&lt; dir[countDir][0] &lt;&lt; " " &lt;&lt; dir[countDir][1] &lt;&lt; endl;</span></span><br><span class="line">            x += dir[countDir][<span class="number">0</span>];</span><br><span class="line">            y += dir[countDir][<span class="number">1</span>];</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="48-旋转图像"><a class="markdownIt-Anchor" href="#48-旋转图像"></a> <a href="https://leetcode.cn/problems/rotate-image/" target="_blank" rel="noopener">48. 旋转图像</a></h3>
<blockquote>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p>
<p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p>
</blockquote>
<h4 id="解法一旋转矩阵的思路一圈一圈来"><a class="markdownIt-Anchor" href="#解法一旋转矩阵的思路一圈一圈来"></a> 解法一——旋转矩阵的思路，一圈一圈来</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> length = n;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="keyword">while</span>(length &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            Q = <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; (); <span class="comment">// 记得要清空</span></span><br><span class="line">            y = (n - length) / <span class="number">2</span>;</span><br><span class="line">            x = n - (n - length) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123; <span class="comment">// 往上</span></span><br><span class="line">                Q.push(matrix[x][y]);</span><br><span class="line">                x += dir[<span class="number">3</span>][<span class="number">0</span>];</span><br><span class="line">                y += dir[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//绕圈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length - <span class="number">1</span>) * <span class="number">4</span>; i ++) &#123;</span><br><span class="line">                <span class="comment">// length-1为一组</span></span><br><span class="line">                Q.push(matrix[x][y]);</span><br><span class="line">                matrix[x][y] = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                x += dir[i/(length - <span class="number">1</span>)][<span class="number">0</span>];</span><br><span class="line">                y += dir[i/(length - <span class="number">1</span>)][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">// cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            length -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也可以不用这么多空间，点对点来旋转</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++) &#123; <span class="comment">// 一共n/2圈向下取整</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = matrix[i][j];</span><br><span class="line">                <span class="comment">// 对应的四个位置坐标分别为</span></span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二用翻转代替旋转"><a class="markdownIt-Anchor" href="#解法二用翻转代替旋转"></a> 解法二——用翻转代替旋转</h4>
<p>旋转90°实际上就是线上下翻转，在主对角线反转。</p>
<p><img alt="image-20240527170107807" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20240527170107807.png" data-index="56" data-src="/2024/03/30/LeetCode-problems/image-20240527170107807.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.size();</span><br><span class="line">        <span class="comment">// 上下翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[n - i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 主对角线反转</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                swap(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="240-搜索二维矩阵-ii"><a class="markdownIt-Anchor" href="#240-搜索二维矩阵-ii"></a> <a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">240. 搜索二维矩阵 II</a></h3>
<blockquote>
<p>编写一个高效的算法来搜索 <em>m</em> × <em>n</em> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>
<ul>
<li>每行的元素从左到右升序排列。</li>
<li>每列的元素从上到下升序排列。</li>
</ul>
</blockquote>
<p>【Z 字形查找】</p>
<p>我们可以从矩阵 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">matrix</mtext></mrow><annotation encoding="application/x-tex">\textit{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord textit">matrix</span></span></span></span></span> 的右上角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, n-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>进行搜索。在每一步的搜索过程中，如果我们位于位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>，那么我们希望在以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">matrix</mtext></mrow><annotation encoding="application/x-tex">\textit{matrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord textit">matrix</span></span></span></span></span> 的左下角为左下角、以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x, y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span> 为右上角的矩阵中进行搜索，即行的范围为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[x, m - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，列的范围为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0, y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span>：</p>
<ul>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">matrix</mtext><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>=</mo><mtext mathvariant="italic">target</mtext></mrow><annotation encoding="application/x-tex">\textit{matrix}[x, y] = \textit{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">matrix</span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textit">target</span></span></span></span></span>，说明搜索完成；</p>
</li>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">matrix</mtext><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>&gt;</mo><mtext mathvariant="italic">target</mtext></mrow><annotation encoding="application/x-tex">\textit{matrix}[x, y] &gt; \textit{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">matrix</span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textit">target</span></span></span></span></span>，由于每一列的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 列的元素都是严格大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">target</mtext></mrow><annotation encoding="application/x-tex">\textit{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textit">target</span></span></span></span></span> 的，因此我们可以将它们全部忽略，即将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> 减少 1；</p>
</li>
<li>
<p>如果 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">matrix</mtext><mo stretchy="false">[</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mtext mathvariant="italic">target</mtext></mrow><annotation encoding="application/x-tex">\textit{matrix}[x, y] &lt; \textit{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">matrix</span></span><span class="mopen">[</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textit">target</span></span></span></span></span>，由于每一行的元素都是升序排列的，那么在当前的搜索矩阵中，所有位于第 xxx 行的元素都是严格小于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext mathvariant="italic">target</mtext></mrow><annotation encoding="application/x-tex">\textit{target}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textit">target</span></span></span></span></span> 的，因此我们可以将它们全部忽略，即将 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> 增加 1。</p>
</li>
</ul>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(x &lt; m &amp;&amp; y &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (matrix[x][y] &gt; target) &#123;</span><br><span class="line">                y--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="234-回文链表"><a class="markdownIt-Anchor" href="#234-回文链表"></a> <a href="https://leetcode.cn/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h3>
<blockquote>
<p>给你一个单链表的头节点 <code>head</code> ，请你判断该链表是否为回文链表。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>回文</strong> 序列是向前和向后读都相同的序列。</p>
</blockquote>
<h4 id="解法一栈保存数值"><a class="markdownIt-Anchor" href="#解法一栈保存数值"></a> 解法一——栈保存数值</h4>
<p>空间复杂度O(n)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            S.push(p-&gt;val);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;val != S.top()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            S.pop();</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二快慢指针反转后面的链表"><a class="markdownIt-Anchor" href="#解法二快慢指针反转后面的链表"></a> 解法二——快慢指针反转后面的链表</h4>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表。</li>
<li>返回结果。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        ListNode *q = head;</span><br><span class="line">        <span class="keyword">while</span> (q-&gt;next != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        ListNode *p1 = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode *q1 = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode * temp = q1-&gt;next;</span><br><span class="line">            q1-&gt;next = p1;</span><br><span class="line">            p1 = q1;</span><br><span class="line">            q1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ListNode *r = head;</span></span><br><span class="line">        <span class="comment">// while (r != nullptr) &#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; r-&gt;val;</span></span><br><span class="line">        <span class="comment">//     r = r-&gt;next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// 比较</span></span><br><span class="line">        q = head;    </span><br><span class="line">        p = p1;    </span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val != q-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="141-环形链表"><a class="markdownIt-Anchor" href="#141-环形链表"></a> <a href="https://leetcode.cn/problems/linked-list-cycle/" target="_blank" rel="noopener">141. 环形链表</a></h3>
<blockquote>
<p>给你一个链表的头节点 <code>head</code> ，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。<strong>注意：<code>pos</code> 不作为参数进行传递</strong> 。仅仅是为了标识链表的实际情况。</p>
<p><em>如果链表中存在环</em> ，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
</blockquote>
<p>快慢指针，能够重合就是有环，快指针走到头了就是没环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast-&gt;next != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="21-合并两个有序链表"><a class="markdownIt-Anchor" href="#21-合并两个有序链表"></a> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h3>
<blockquote>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/merge_ex1.jpg" data-index="57" data-src="/2024/03/30/LeetCode-problems/merge_ex1.jpg"></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = list1;</span><br><span class="line">        ListNode *p2 = list2;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)  &#123;</span><br><span class="line">            p= p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *head = p;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &gt;= p2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-两数相加"><a class="markdownIt-Anchor" href="#2-两数相加"></a> <a href="https://leetcode.cn/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h3>
<blockquote>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/addtwonumber1.jpg" data-index="58" data-src="/2024/03/30/LeetCode-problems/addtwonumber1.jpg"></p>
</blockquote>
<p><strong>进位标志</strong>（Carry Flag, CF）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1 = l1;</span><br><span class="line">        ListNode *p2 = l2;</span><br><span class="line">        <span class="keyword">bool</span> CF = <span class="literal">false</span>;</span><br><span class="line">        p1-&gt;val = p1-&gt;val + p2-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(p1-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            p1-&gt;val -= <span class="number">10</span>;</span><br><span class="line">            CF = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1-&gt;next != <span class="literal">nullptr</span> || p2-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                p1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                p2-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            p1-&gt;val = p1-&gt;val + p2-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (CF) &#123;</span><br><span class="line">                p1-&gt;val += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p1-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                p1-&gt;val -= <span class="number">10</span>;</span><br><span class="line">                CF = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                CF = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (CF) &#123;</span><br><span class="line">            p1-&gt;next = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="25-k-个一组翻转链表"><a class="markdownIt-Anchor" href="#25-k-个一组翻转链表"></a> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">25. K 个一组翻转链表</a></h3>
<blockquote>
<p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。</p>
<p><code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。<br>
<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/reverse_ex1.jpg" data-index="59" data-src="/2024/03/30/LeetCode-problems/reverse_ex1.jpg"></p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/reverse_ex2.jpg" data-index="60" data-src="/2024/03/30/LeetCode-problems/reverse_ex2.jpg"></p>
</blockquote>
<ul>
<li>双指针</li>
</ul>
<p>hair–dummyHead</p>
<p>pre-slow</p>
<p>tail–fast</p>
<p>nex–fast-&gt;next</p>
<p>绕也绕不清</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *dummyHead = <span class="keyword">new</span> ListNode (<span class="number">0</span>, head);</span><br><span class="line">        ListNode *slow = dummyHead;</span><br><span class="line">        ListNode *fast = dummyHead;</span><br><span class="line">        <span class="comment">// bool isEnd = false;</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        ListNode *pNext ;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k &amp;&amp; fast != <span class="literal">nullptr</span>; i++) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; fast -&gt;val &lt;&lt; endl;</span></span><br><span class="line">            pNext = fast-&gt;next;</span><br><span class="line">            <span class="comment">//反转链表</span></span><br><span class="line">            ListNode *p = slow;</span><br><span class="line">            ListNode *q = slow-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (q != pNext) &#123; <span class="comment">// 这个判断条件！！是pNext，不是fast，不然会导致最后一个fast对应位置没指回去，不用担心q已经跑到前面去了怎么办，还有p比他慢一步</span></span><br><span class="line">                ListNode *temp = q-&gt;next;</span><br><span class="line">                q-&gt;next = p;</span><br><span class="line">                p = q;</span><br><span class="line">                q = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* tmp;</span><br><span class="line">            <span class="comment">// 这边往下是真的很难想清。可以想象第一次</span></span><br><span class="line">            slow-&gt;next-&gt;next = pNext;  <span class="comment">// 这是让原来的head的下一个指向下一次的起点，而非dummyHead</span></span><br><span class="line">            <span class="comment">// cout&lt;&lt; slow-&gt;next-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; pNext-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            tmp = slow-&gt;next;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; tmp-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            slow-&gt;next = p; <span class="comment">// 这里用p就好了，这个是为了让dummyHead指向新的head</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; slow-&gt;next-&gt;val &lt;&lt; endl;</span></span><br><span class="line">            slow = tmp;</span><br><span class="line">            fast = tmp;</span><br><span class="line">            <span class="comment">// ListNode *qqq = dummyHead;</span></span><br><span class="line">            <span class="comment">// while(qqq-&gt;next != NULL) &#123;</span></span><br><span class="line">            <span class="comment">//     cout &lt;&lt; qqq-&gt;next-&gt;val &lt;&lt; " ";</span></span><br><span class="line">            <span class="comment">//     qqq = qqq-&gt;next;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再贴一个官方题解：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    pair&lt;ListNode*, ListNode*&gt; myReverse(ListNode* head, ListNode* tail) &#123;</span><br><span class="line">        ListNode* prev = tail-&gt;next;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        <span class="keyword">while</span> (prev != tail) &#123;</span><br><span class="line">            ListNode* nex = p-&gt;next;</span><br><span class="line">            p-&gt;next = prev;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = nex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;tail, head&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* hair = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        hair-&gt;next = head;</span><br><span class="line">        ListNode* pre = hair;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="comment">// 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!tail) &#123;</span><br><span class="line">                    <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* nex = tail-&gt;next;</span><br><span class="line">            <span class="comment">// 这里是 C++17 的写法，也可以写成</span></span><br><span class="line">            <span class="comment">// pair&lt;ListNode*, ListNode*&gt; result = myReverse(head, tail);</span></span><br><span class="line">            <span class="comment">// head = result.first;</span></span><br><span class="line">            <span class="comment">// tail = result.second;</span></span><br><span class="line">            tie(head, tail) = myReverse(head, tail);</span><br><span class="line">            <span class="comment">// 把子链表重新接回原链表</span></span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            tail-&gt;next = nex;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = tail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> hair-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="138-随机链表的复制"><a class="markdownIt-Anchor" href="#138-随机链表的复制"></a> <a href="https://leetcode.cn/problems/copy-list-with-random-pointer/" target="_blank" rel="noopener">138. 随机链表的复制</a></h3>
<blockquote>
<p>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p>
<p>构造这个链表的 <strong><a href="https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin" target="_blank" rel="noopener">深拷贝</a></strong>。 深拷贝应该正好由 <code>n</code> 个 <strong>全新</strong> 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 <code>next</code> 指针和 <code>random</code> 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。<strong>复制链表中的指针都不应指向原链表中的节点</strong> 。</p>
<p>例如，如果原链表中有 <code>X</code> 和 <code>Y</code> 两个节点，其中 <code>X.random --&gt; Y</code> 。那么在复制链表中对应的两个节点 <code>x</code> 和 <code>y</code> ，同样有 <code>x.random --&gt; y</code> 。</p>
<p>返回复制链表的头节点。</p>
<p>用一个由 <code>n</code> 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 <code>[val, random_index]</code> 表示：</p>
<ul>
<li><code>val</code>：一个表示 <code>Node.val</code> 的整数。</li>
<li><code>random_index</code>：随机指针指向的节点索引（范围从 <code>0</code> 到 <code>n-1</code>）；如果不指向任何节点，则为 <code>null</code> 。</li>
</ul>
<p>你的代码 <strong>只</strong> 接受原链表的头节点 <code>head</code> 作为传入参数。</p>
</blockquote>
<h4 id="解法一回溯"><a class="markdownIt-Anchor" href="#解法一回溯"></a> 解法一——回溯</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment">    Node* random;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = NULL;</span></span><br><span class="line"><span class="comment">        random = NULL;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; connectedNode;</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!connectedNode.count(head)) &#123;</span><br><span class="line">            Node* newHead = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">            connectedNode[head] = newHead;</span><br><span class="line">            newHead-&gt;next = copyRandomList(head-&gt;next);</span><br><span class="line">            newHead-&gt;random = copyRandomList(head-&gt;random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> connectedNode[head];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二迭代-节点拆分"><a class="markdownIt-Anchor" href="#解法二迭代-节点拆分"></a> 解法二——迭代 + 节点拆分</h4>
<p>注意到方法一需要使用哈希表记录每一个节点对应新节点的创建情况，而我们可以使用一个小技巧来省去哈希表的空间。</p>
<p>我们首先将该链表中每一个节点拆分为两个相连的节点，例如对于链表 A→B→C，我们可以将其拆分为 A→A′→B→B′→C→C′ 。对于任意一个原节点 S，其拷贝节点 S′ 即为其后继节点。</p>
<p>——力扣官方题解<br>
<img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/2-1717660182142-1.png" data-index="61" data-src="/2024/03/30/LeetCode-problems/2-1717660182142-1.png"></p>
<p><img alt="img" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/3-1717660191799-4.png" data-index="62" data-src="/2024/03/30/LeetCode-problems/3-1717660191799-4.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新节点连进来</span></span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* newP = <span class="keyword">new</span> Node(p-&gt;val);</span><br><span class="line">            newP-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = newP;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 新节点的指针域</span></span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next-&gt;next) &#123;</span><br><span class="line">            Node* newP = p-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                newP-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  &#123;</span><br><span class="line">                newP = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//断开</span></span><br><span class="line">        Node* newHead = head-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (Node* p = head; p != <span class="literal">nullptr</span>; p = p-&gt;next) &#123;</span><br><span class="line">            Node* newP = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (newP-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                newP-&gt;next = newP-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="148-排序链表"><a class="markdownIt-Anchor" href="#148-排序链表"></a> <a href="https://leetcode.cn/problems/sort-list/" target="_blank" rel="noopener">148. 排序链表</a></h3>
<blockquote>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
</blockquote>
<p>对链表自顶向下归并排序的过程如下。</p>
<p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 2 步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</p>
<ol>
<li>对两个子链表分别排序。</li>
<li>将两个排序后的子链表合并，得到完整的排序后的链表。</li>
<li>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。</li>
</ol>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sortTwoList (head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">sortTwoList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123; <span class="comment">// 链表为空</span></span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next == tail) &#123; <span class="comment">// 只剩一个元素</span></span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast != tail) &#123;</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoList(sortTwoList(head, mid), sortTwoList(mid, tail));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (head2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1 = head1;</span><br><span class="line">        ListNode *p2 = head2;</span><br><span class="line"></span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">if</span> (head1-&gt;val &lt; head2-&gt;val) &#123;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * head = p;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="23-合并-k-个升序链表"><a class="markdownIt-Anchor" href="#23-合并-k-个升序链表"></a> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">23. 合并 K 个升序链表</a></h3>
<blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<h4 id="最naive的思想存起来呗"><a class="markdownIt-Anchor" href="#最naive的思想存起来呗"></a> 最naive的思想——存起来呗</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempMin = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> tempMinPos = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; minNum.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minNum[i] &lt; tempMin) &#123;</span><br><span class="line">                tempMin = minNum[i];</span><br><span class="line">                tempMinPos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempMinPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> K = lists.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">minNum</span><span class="params">(K)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">vector</span>&lt;ListNode*&gt; p;</span><br><span class="line">        <span class="keyword">int</span> headIndex = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> headNum = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; K; i++) &#123;</span><br><span class="line">            p.emplace_back(lists[i]);</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                minNum[i] = lists[i]-&gt;val;</span><br><span class="line">                <span class="keyword">if</span> (headIndex == <span class="number">-1</span> || headNum &gt; minNum[i]) &#123;</span><br><span class="line">                    headIndex = i;</span><br><span class="line">                    headNum = minNum[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minNum[i] = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (headIndex == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* head = p[headIndex];</span><br><span class="line">        p[headIndex] = p[headIndex]-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (p[headIndex] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            minNum[headIndex] = p[headIndex]-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minNum[headIndex] = INT_MAX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在minNum中最小值，直到最小值为INT_MAX</span></span><br><span class="line">        ListNode* temp = head;</span><br><span class="line">        <span class="keyword">int</span> minPos = findMin(minNum);</span><br><span class="line">        <span class="keyword">while</span> (minPos != <span class="number">-1</span>) &#123;</span><br><span class="line">            temp-&gt;next = p[minPos];</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">            p[minPos] = p[minPos]-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (p[minPos] != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                minNum[minPos] = p[minPos]-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minNum[minPos] = INT_MAX;</span><br><span class="line">            &#125;</span><br><span class="line">            minPos = findMin(minNum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="分治合并"><a class="markdownIt-Anchor" href="#分治合并"></a> 分治合并</h4>
<img alt="img" style="zoom:50%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png" data-index="63" data-src="/2024/03/30/LeetCode-problems/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(<span class="built_in">vector</span> &lt;ListNode*&gt; &amp;lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(merge(lists, left, mid), merge(lists, mid + <span class="number">1</span>, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((!head1) || (!head2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> head1 ? head1 : head2;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p1 = head1;</span><br><span class="line">        ListNode *p2 = head2;</span><br><span class="line"></span><br><span class="line">        ListNode *p;</span><br><span class="line">        <span class="keyword">if</span> (head1-&gt;val &lt; head2-&gt;val) &#123;</span><br><span class="line">            p = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode * head = p;</span><br><span class="line">        <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = p1;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p1 = p1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p-&gt;next = p2;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">                p2 = p2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="146-lru-缓存"><a class="markdownIt-Anchor" href="#146-lru-缓存"></a> <a href="https://leetcode.cn/problems/lru-cache/" target="_blank" rel="noopener">146. LRU 缓存</a></h3>
<blockquote>
<p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU" target="_blank" rel="noopener">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p>
<p>实现 <code>LRUCache</code> 类：</p>
<ul>
<li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li>
<li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li>
<li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li>
</ul>
<p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p>
</blockquote>
<p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p>
<ul>
<li>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</li>
<li>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</li>
</ul>
<p>这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：</p>
<ul>
<li>
<p>对于 get 操作，首先判断 key 是否存在：</p>
<ul>
<li>
<p>如果 key 不存在，则返回 −1；</p>
</li>
<li>
<p>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。</p>
</li>
</ul>
</li>
<li>
<p>对于 put 操作，首先判断 key 是否存在：</p>
<ul>
<li>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；</li>
<li>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。</li>
</ul>
</li>
</ul>
<p>——力扣官方题解</p>
<p>想不到双向链表，纯粹抄——主要要想到双向链表，这样比较好处理头尾的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode *prev;</span><br><span class="line">    DLinkedNode *next;</span><br><span class="line">    DLinkedNode(): key(<span class="number">0</span>), value(<span class="number">0</span>), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    DLinkedNode(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value): key(_key), value(_value), prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">int</span> capacityA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        capacityA = capacity;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        tail = <span class="keyword">new</span> DLinkedNode();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123; <span class="comment">// key不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            moveToHead(node);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!cache.count(key)) &#123;</span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> DLinkedNode(key, value);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            addToHead(node);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacityA) &#123;</span><br><span class="line">                <span class="comment">// 超出容量</span></span><br><span class="line">                DLinkedNode *removed = removeTail();</span><br><span class="line">                cache.erase(removed-&gt;key);</span><br><span class="line">                <span class="keyword">delete</span> removed;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            DLinkedNode* node = cache[key];</span><br><span class="line">            node-&gt;value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode *node = tail-&gt;prev;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="543-二叉树的直径"><a class="markdownIt-Anchor" href="#543-二叉树的直径"></a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. 二叉树的直径</a></h3>
<blockquote>
<p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p>
<p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p>
<p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p>
</blockquote>
<p>每个节点的直径为（左子树深度+右子树深度）+1，而他的父节点的节点深度等于max（左子树深度，右子树深度）+1.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> diameter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> depthL = depth(p-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> depthR = depth(p-&gt;right);</span><br><span class="line">        diameter = max(diameter, depthL + depthR + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max(depthL, depthR) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        diameter = <span class="number">1</span>;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> diameter - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="230-二叉搜索树中第-k-小的元素"><a class="markdownIt-Anchor" href="#230-二叉搜索树中第-k-小的元素"></a> <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">230. 二叉搜索树中第 K 小的元素</a></h3>
<blockquote>
<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p>
</blockquote>
<p>二叉搜索树的中序排列是有序的——中序排列即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span> &lt;TreeNode*&gt; S;</span><br><span class="line">        TreeNode *p = root;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p || !S.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                S.push(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                p = S.top();</span><br><span class="line">                <span class="comment">// cout &lt;&lt; count &lt;&lt; " ";</span></span><br><span class="line">                <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                S.pop();</span><br><span class="line">                p = p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="114-二叉树展开为链表"><a class="markdownIt-Anchor" href="#114-二叉树展开为链表"></a> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">114. 二叉树展开为链表</a></h3>
<blockquote>
<p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p>
<ul>
<li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li>
<li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" target="_blank" rel="noopener"><strong>先序遍历</strong></a> 顺序相同。</li>
</ul>
</blockquote>
<h4 id="解法一遍历一个数组非原地"><a class="markdownIt-Anchor" href="#解法一遍历一个数组非原地"></a> 解法一——遍历+一个数组（非原地）</h4>
<p>不知道为啥我写的超出内存限制，他写的就不超出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TreeNode *dummyHead = new TreeNode(0, nullptr, root);</span></span><br><span class="line">        <span class="comment">// dummyHead-&gt;right = root;</span></span><br><span class="line">        <span class="comment">// TreeNode* p = dummyHead-&gt;right;</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; S;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; V;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        S.push(root);</span><br><span class="line">        <span class="comment">// V.emplace_back(dummyHead);</span></span><br><span class="line">        <span class="keyword">while</span>(!S.empty()) &#123;</span><br><span class="line">            TreeNode *p = S.top();</span><br><span class="line">            V.emplace_back(p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;right) &#123;</span><br><span class="line">                S.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;left) &#123;</span><br><span class="line">                S.push(p-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TreeNode *q = V[0];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; V.size(); i++) &#123;</span><br><span class="line">            TreeNode *prev = V[i - <span class="number">1</span>];</span><br><span class="line">            TreeNode *curr = V[i];</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">// q = Q.front();</span></span><br><span class="line">            <span class="comment">// Q.pop();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> v = <span class="built_in">vector</span>&lt;TreeNode*&gt;();</span><br><span class="line">        <span class="keyword">auto</span> stk = <span class="built_in">stack</span>&lt;TreeNode*&gt;();</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span> || !stk.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                v.push_back(node);</span><br><span class="line">                stk.push(node);</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            node = stk.top(); stk.pop();</span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = v.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> prev = v.at(i - <span class="number">1</span>), curr = v.at(i);</span><br><span class="line">            prev-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prev-&gt;right = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>chatgpt的分析结果：你在第一个代码中同时使用了栈（<code>stack&lt;TreeNode*&gt; S</code>）和向量（<code>vector&lt;TreeNode*&gt; V</code>）。栈用于深度优先遍历，而向量用于存储访问顺序，这使得你在遍历每个节点时需要额外存储两次节点信息。这会增加内存使用，特别是在树很大的时候。</p>
<p>第二个代码将遍历结果直接存入向量，而栈只用于辅助遍历，这样减少了节点的重复存储。</p>
<h4 id="解法二寻找前驱节点"><a class="markdownIt-Anchor" href="#解法二寻找前驱节点"></a> 解法二——寻找前驱节点</h4>
<p>注意到前序遍历访问各节点的顺序是根节点、左子树、右子树。如果一个节点的左子节点为空，则该节点不需要进行展开操作。如果一个节点的左子节点不为空，则该节点的左子树中的最后一个节点被访问之后，该节点的右子节点被访问。该节点的左子树中最后一个被访问的节点是左子树中的最右边的节点，也是该节点的前驱节点。因此，问题转化成寻找当前节点的前驱节点。</p>
<p>具体做法是，对于当前节点，如果其左子节点不为空，则在其左子树中找到最右边的节点，作为前驱节点，将当前节点的右子节点赋给前驱节点的右子节点，然后将当前节点的左子节点赋给当前节点的右子节点，并将当前节点的左子节点设为空。对当前节点处理结束后，继续处理链表中的下一个节点，直到所有节点都处理结束。</p>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        subflatten(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">subflatten</span><span class="params">(TreeNode* p)</span> </span>&#123;</span><br><span class="line">        TreeNode* left = p-&gt;left;</span><br><span class="line">        TreeNode* right = p-&gt;right;</span><br><span class="line">        TreeNode* last = p;</span><br><span class="line">        p-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p-&gt;right = left;</span><br><span class="line">            last = subflatten(left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            last-&gt;right = right; <span class="comment">// 注意这里是last的右孩子</span></span><br><span class="line">            last = subflatten(right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last; <span class="comment">// 链表的最后一位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="437-路径总和-iii"><a class="markdownIt-Anchor" href="#437-路径总和-iii"></a> <a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noopener">437. 路径总和 III</a></h3>
<blockquote>
<p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p>
<p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
</blockquote>
<p>迭代隐式回溯</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rootSum</span><span class="params">(TreeNode* root, <span class="keyword">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">            output++;</span><br><span class="line">        &#125;</span><br><span class="line">        output += rootSum(root-&gt;left, targetSum - root-&gt;val);</span><br><span class="line">        output += rootSum(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> output = rootSum(root, targetSum);</span><br><span class="line">        output += pathSum(root-&gt;left, targetSum);</span><br><span class="line">        output += pathSum(root-&gt;right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="124-二叉树中的最大路径和"><a class="markdownIt-Anchor" href="#124-二叉树中的最大路径和"></a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">124. 二叉树中的最大路径和</a></h3>
<blockquote>
<p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p>
</blockquote>
<p>思路和“[543. 二叉树的直径]”类似，但是注意这里需要考虑当贡献大于0时候在加上。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> pathSum;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPath</span><span class="params">(TreeNode * p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftSum = maxPath(p-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightSum = maxPath(p-&gt;right);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 注意下列和直径的区别，需要考虑贡献度</span></span><br><span class="line">        <span class="comment">// int leftSum = maxPath(p-&gt;left);</span></span><br><span class="line">        <span class="comment">// int rightSum = maxPath(p-&gt;right);</span></span><br><span class="line">        <span class="comment">// pathSum = max(pathSum, max(leftSum + rightSum + p-&gt;val, max(rightSum + p-&gt;val, max(leftSum + p-&gt;val, p-&gt;val))));</span></span><br><span class="line">        <span class="comment">// return max(max(leftSum, 0), max(rightSum, 0)) + p-&gt;val;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> leftSum = max(maxPath(p-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> rightSum = max(maxPath(p-&gt;right), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        pathSum = max(pathSum, leftSum + rightSum + p-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> max(leftSum, rightSum) + p-&gt;val; </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pathSum = root-&gt;val;</span><br><span class="line">        maxPath(root);</span><br><span class="line">        <span class="keyword">return</span> pathSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="994-腐烂的橘子"><a class="markdownIt-Anchor" href="#994-腐烂的橘子"></a> <a href="https://leetcode.cn/problems/rotting-oranges/" target="_blank" rel="noopener">994. 腐烂的橘子</a></h3>
<blockquote>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
</blockquote>
<p>BFS</p>
<p>碰到1不动，碰到2开始广搜。</p>
<p>注意对于如下的例子，两头一起烂才是最快的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[2,1,1],</span><br><span class="line"> [1,1,1],</span><br><span class="line"> [0,1,2]]</span><br></pre></td></tr></table></figure>
<p>所以不能只考虑每个点的，然后再找最小的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(grid.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(grid[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        Q.push(&#123;x, y&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currLoopNum = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLoopNum; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">int</span> xCurr = curr.first;</span><br><span class="line">                <span class="keyword">int</span> yCurr = curr.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xNext = xCurr + dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> yNext = yCurr + dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size() || grid[xNext][yNext] == <span class="number">2</span>) &#123; <span class="comment">// 2说明就是中心烂橘子，不需要重新计算</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((grid[xNext][yNext] == <span class="number">1</span> || grid[xNext][yNext] == <span class="number">3</span>) &amp;&amp; visited[xNext][yNext] == <span class="literal">false</span>) &#123;</span><br><span class="line">                        Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                        visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                        grid[xNext][yNext] = <span class="number">3</span>;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; xNext &lt;&lt; " " &lt;&lt; yNext;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            time ++;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; time &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; "A";</span></span><br><span class="line">        <span class="keyword">return</span> time - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> column = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        <span class="keyword">bool</span> flagOne = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    Q.push(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    flagOne = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Q.size() == <span class="number">0</span> &amp;&amp; flagOne == <span class="literal">false</span>) &#123; <span class="comment">// 考虑没有烂橘子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> currLoopNum = Q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currLoopNum; i++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = Q.front();</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">int</span> xCurr = curr.first;</span><br><span class="line">                <span class="keyword">int</span> yCurr = curr.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xNext = xCurr + dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> yNext = yCurr + dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= grid.size() || yNext &gt;= grid[<span class="number">0</span>].size() || grid[xNext][yNext] == <span class="number">2</span>) &#123; <span class="comment">// 2说明就是中心烂橘子，不需要重新计算</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[xNext][yNext] == <span class="number">1</span> ) &#123;</span><br><span class="line">                        Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                        grid[xNext][yNext] = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; xNext &lt;&lt; " " &lt;&lt; yNext;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            time ++;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; time &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; i &lt;&lt; " " &lt;&lt; j;</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> time - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了确认是否所有新鲜橘子都被腐烂，可以记录一个变量 cnt 表示当前网格中的新鲜橘子数，广度优先搜索的时候如果有新鲜橘子被腐烂，则 cnt=cnt−1 ，最后搜索结束时如果 cnt 大于 0 ，说明有新鲜橘子没被腐烂，返回 −1 ，否则返回所有新鲜橘子被腐烂的时间的最大值即可，也可以在广度优先搜索的过程中把已腐烂的新鲜橘子的值由 1 改为 2，最后看网格中是否有值为 1 即新鲜的橘子即可。</p>
<h3 id="207-课程表"><a class="markdownIt-Anchor" href="#207-课程表"></a> <a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener">207. 课程表</a></h3>
<blockquote>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<p>不能成环？<br>
结果答案是拓扑排序，太难了</p>
<p><img alt="image-20241006105916273" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20241006105916273.png" data-index="64" data-src="/2024/03/30/LeetCode-problems/image-20241006105916273.png"></p>
<p>用一个栈来存储所有<strong>已经搜索完成的节点</strong>。假设我们当前搜索到了节点 u，如果它的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时我们就可以把 u 入栈。可以发现，如果我们从栈顶往栈底的顺序看，由于 u 处于栈顶的位置，那么 u 出现在所有 u 的相邻节点的前面。因此对于 u 这个节点而言，它是满足拓扑排序的要求的。</p>
<p>方法一： 从入度思考(从前往后排序)， 入度为0的节点在拓扑排序中一定排在前面, 然后删除和该节点对应的边, 迭代寻找入度为0的节点。</p>
<p>方法二： 从出度思考(从后往前排序)， 出度为0的节点在拓扑排序中一定排在后面, 然后删除和该节点对应的边, 迭代寻找出度为0的节点。</p>
<h4 id="深度优先栈"><a class="markdownIt-Anchor" href="#深度优先栈"></a> 深度优先——栈</h4>
<p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li>
<p>「未搜索」：我们还没有搜索到这个节点；</p>
</li>
<li>
<p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p>
</li>
<li>
<p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p>
</li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p>
<ul>
<li>
<p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p>
<ul>
<li>
<p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p>
</li>
<li>
<p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p>
</li>
<li>
<p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u,v) 之前的拓扑关系，以及不用进行任何操作。</p>
</li>
</ul>
</li>
<li>
<p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p>
</li>
</ul>
<p>作者：力扣官方题解</p>
<p><img alt="image-20241006134104937" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20241006134104937.png" data-index="65" data-src="/2024/03/30/LeetCode-problems/image-20241006134104937.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 1 搜索中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(edges, visited, v);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// 搜索完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 0 未搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prerequisite = prerequisites[i];</span><br><span class="line">            edges[prerequisite[<span class="number">1</span>]].emplace_back(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(edges, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先队列"><a class="markdownIt-Anchor" href="#广度优先队列"></a> 广度优先——队列</h4>
<p>我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p>作者：力扣官方题解</p>
<p><img alt="image-20241006134142872" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20241006134142872.png" data-index="66" data-src="/2024/03/30/LeetCode-problems/image-20241006134142872.png"></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indeg</span><span class="params">(numCourses)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prerequisite = prerequisites[i];</span><br><span class="line">            edges[prerequisite[<span class="number">1</span>]].emplace_back(prerequisite[<span class="number">0</span>]); <span class="comment">// 1是0的先修课</span></span><br><span class="line">            indeg[prerequisite[<span class="number">0</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123; <span class="comment">// 入度为0，加入队列删除边</span></span><br><span class="line">                Q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            visited++;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v:edges[u]) &#123;</span><br><span class="line">                indeg[v] --;</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited == numCourses; <span class="comment">// 如果没环，应该就都结束了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="210-课程表-ii"><a class="markdownIt-Anchor" href="#210-课程表-ii"></a> <a href="https://leetcode.cn/problems/course-schedule-ii/" target="_blank" rel="noopener">210. 课程表 II</a></h4>
<blockquote>
<p>现在你总共有 <code>numCourses</code> 门课需要选，记为 <code>0</code> 到 <code>numCourses - 1</code>。给你一个数组 <code>prerequisites</code> ，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示在选修课程 <code>ai</code> 前 <strong>必须</strong> 先选修 <code>bi</code> 。</p>
<ul>
<li>例如，想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> ，我们用一个匹配来表示：<code>[0,1]</code> 。</li>
</ul>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output; <span class="comment">// 数组模拟栈</span></span><br><span class="line">    <span class="keyword">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; visited, <span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>; <span class="comment">// 1 搜索中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v:edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(edges, visited, v);</span><br><span class="line">                <span class="keyword">if</span> (valid == <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>; <span class="comment">// 搜索完成</span></span><br><span class="line">        output.emplace_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">// 0 未搜索</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prerequisite = prerequisites[i];</span><br><span class="line">            edges[prerequisite[<span class="number">1</span>]].emplace_back(prerequisite[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(edges, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(output.begin(), output.end());</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">edges</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">indeg</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.size(); i++) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prerequisite = prerequisites[i];</span><br><span class="line">            edges[prerequisite[<span class="number">1</span>]].emplace_back(prerequisite[<span class="number">0</span>]); <span class="comment">// 1是0的先修课</span></span><br><span class="line">            indeg[prerequisite[<span class="number">0</span>]] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123; <span class="comment">// 入度为0，加入队列删除边</span></span><br><span class="line">                Q.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">            visited++;</span><br><span class="line">            <span class="keyword">int</span> u = Q.front();</span><br><span class="line">            Q.pop();</span><br><span class="line">            output.emplace_back(u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v:edges[u]) &#123;</span><br><span class="line">                indeg[v] --;</span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( visited == numCourses ) &#123;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="208-实现-trie-前缀树"><a class="markdownIt-Anchor" href="#208-实现-trie-前缀树"></a> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">208. 实现 Trie (前缀树)</a></h3>
<blockquote>
<p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin" target="_blank" rel="noopener">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
</blockquote>
<p>Trie 是一颗非典型的多叉树模型，多叉好理解，即每个结点的分支数量可能为多个。非典型指的是节点设计不同。<strong>一次建树，多次查询</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>字母映射表next <code>TrieNode* next[26]</code>中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值.</p>
<ol>
<li>Trie 的形状和单词的插入或删除顺序无关，也就是说对于任意给定的一组单词，Trie 的形状都是唯一的。</li>
<li>查找或插入一个长度为 L 的单词，访问 next 数组的次数最多为 L+1，和 Trie 中包含多少个单词无关。</li>
<li>Trie 的每个结点中都保留着一个字母表，这是很耗费空间的。如果 Trie 的高度为 n，字母表的大小为 m，最坏的情况是 Trie 中还不存在前缀相同的单词，那空间复杂度就为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。</li>
</ol>
<p>作者：路漫漫我不畏</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    Trie* next[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    Trie() &#123;</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">memset</span>(next, <span class="number">0</span>, <span class="keyword">sizeof</span>(next));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123; <span class="comment">// 这个操作和构建链表很像。首先从根结点的子结点开始与 word 第一个字符进行匹配，一直匹配到前缀链上没有对应的字符，这时开始不断开辟新的结点，直到插入完 word 的最后一个字符，同时还要将最后一个结点isEnd = true;，表示它是一个单词的末尾。</span></span><br><span class="line"></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c:word) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next[c - <span class="string">'a'</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;next[c - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123; <span class="comment">// 从根结点的子结点开始，一直向下匹配即可，如果出现结点值为空就返回 false</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>  (<span class="keyword">auto</span> c:word) &#123;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123; <span class="comment">// 和search的区别只在最后的判断</span></span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>  (<span class="keyword">auto</span> c:prefix) &#123;</span><br><span class="line">            node = node-&gt;next[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>在你的<code>Trie</code>实现中：</p>
<ul>
<li><code>Trie* node = this;</code>是用来从当前对象（即根节点）开始操作的。</li>
<li>如果你用<code>new Trie()</code>，那意味着你创建了一个新的<code>Trie</code>对象，这个对象和原来的<code>Trie</code>无关，并且是一个全新的空的前缀树。所以这里的区别在于，你是想要操作当前已有的前缀树，还是想要创建一个新的空的前缀树。</li>
</ul>
<p>总结</p>
<ul>
<li><code>this</code>指针是对已有对象的引用。</li>
<li>新建对象（使用<code>new</code>）是创建一个新的实例，它和原始对象没有直接关系。</li>
<li>使用<code>this</code>的场景是想操作已有对象的内部，而使用<code>new</code>则是为了创建一个新对象来存储新的数据或状态。</li>
</ul>
<h3 id="22-括号生成"><a class="markdownIt-Anchor" href="#22-括号生成"></a> <a href="https://leetcode.cn/problems/generate-parentheses/" target="_blank" rel="noopener">22. 括号生成</a></h3>
<blockquote>
<p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
</blockquote>
<p>有效括号对数，<code>（</code>必须要再<code>）</code>之前</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; output;</span><br><span class="line">    <span class="built_in">string</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> usedLeft, <span class="keyword">int</span> usedRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (usedLeft == n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - usedRight; i++) &#123; <span class="comment">// 补齐右括号</span></span><br><span class="line">                temp.push_back(<span class="string">')'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            output.emplace_back(temp);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - usedRight; i++) &#123; <span class="comment">// 不要忘记这边要pop掉</span></span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usedLeft &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 选择加入‘(’， 不管什么情况都可以，只要还有n</span></span><br><span class="line">            temp.push_back(<span class="string">'('</span>);</span><br><span class="line">            backtracking(n, usedLeft + <span class="number">1</span>, usedRight);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (usedLeft &gt; usedRight) &#123;</span><br><span class="line">                temp.push_back(<span class="string">')'</span>);</span><br><span class="line">                backtracking(n, usedLeft, usedRight + <span class="number">1</span>);</span><br><span class="line">                temp.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        backtracking(n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="79-单词搜索"><a class="markdownIt-Anchor" href="#79-单词搜索"></a> <a href="https://leetcode.cn/problems/word-search/" target="_blank" rel="noopener">79. 单词搜索</a></h3>
<blockquote>
<p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
</blockquote>
<p>图论解法——广度优先好像有问题，比如之前visited过的元素，那条路径被废弃了，万一在后面需要visit，就不行了。无法回溯回去——所以下面的解法是错的。。。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; Q;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(board.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        Q.push(&#123;x, y&#125;);</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" "</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> qSize = Q.size();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;  qSize &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; qSize; j++) &#123;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; curr = Q.front();</span><br><span class="line">                <span class="keyword">int</span> xCurr = curr.first;</span><br><span class="line">                <span class="keyword">int</span> yCurr = curr.second;</span><br><span class="line">                Q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xNext = xCurr + dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> yNext = yCurr + dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= board.size() || yNext &gt;= board[<span class="number">0</span>].size() || board[xNext][yNext] != word[len] || visited[xNext][yNext] == <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Q.push(&#123;xNext, yNext&#125;);</span><br><span class="line">                    visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len - <span class="number">1</span> == word.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bool output = false;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bfs(board, word, i, j) == <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是正确写法——深搜，虽然好像写的又臭又长，len和判断逻辑应该写在dfs里面的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited,  <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == word.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> output = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> xNext = x + dir[i][<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> yNext = y + dir[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (xNext &lt; <span class="number">0</span> || yNext &lt; <span class="number">0</span> || xNext &gt;= board.size() || yNext &gt;= board[<span class="number">0</span>].size() || board[xNext][yNext] != word[len] || visited[xNext][yNext] == <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[xNext][yNext] = <span class="literal">true</span>;</span><br><span class="line">                    output = output || dfs(board, word, visited, xNext, yNext, len+<span class="number">1</span>);</span><br><span class="line">                    visited[xNext][yNext] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> output;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// bool output = false;</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visited</span><span class="params">(board.size(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(board[<span class="number">0</span>].size(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(board, word, visited, i, j, <span class="number">1</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="35-搜索插入位置"><a class="markdownIt-Anchor" href="#35-搜索插入位置"></a> <a href="https://leetcode.cn/problems/search-insert-position/" target="_blank" rel="noopener">35. 搜索插入位置</a></h3>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p>
</blockquote>
<p>注意开闭区间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> output = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                output = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="74-搜索二维矩阵"><a class="markdownIt-Anchor" href="#74-搜索二维矩阵"></a> <a href="https://leetcode.cn/problems/search-a-2d-matrix/" target="_blank" rel="noopener">74. 搜索二维矩阵</a></h3>
<blockquote>
<p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p>
<ul>
<li>每行中的整数从左到右按非严格递增顺序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<p>非严格递增</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = row * column - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> midX = mid / column; <span class="comment">// 看看清啊，这里要除和模的是谁</span></span><br><span class="line">            <span class="keyword">int</span> midY = mid % column;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[midX][midY] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; matrix[midX][midY]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="34-在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#34-在排序数组中查找元素的第一个和最后一个位置"></a> <a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3>
<blockquote>
<p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> leftBound = mid;</span><br><span class="line">                <span class="keyword">while</span> (leftBound &gt;= <span class="number">0</span> &amp;&amp; nums[leftBound] == target) &#123;</span><br><span class="line">                    leftBound--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> rightBound = mid;</span><br><span class="line">                <span class="keyword">while</span> (rightBound &lt; nums.size() &amp;&amp; nums[rightBound] == target) &#123;</span><br><span class="line">                    rightBound++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;leftBound+<span class="number">1</span>, rightBound<span class="number">-1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解在二分查找上做文章，加入了一个选项，确定是不是最小的/最大的范围。</p>
<h3 id="33-搜索旋转排序数组"><a class="markdownIt-Anchor" href="#33-搜索旋转排序数组"></a> <a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">33. 搜索旋转排序数组</a></h3>
<blockquote>
<p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
</blockquote>
<p>先找分界点，再二分查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先找分界点</span></span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; nums[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                min = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = min;</span><br><span class="line">        right = left + nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mid % nums.size();</span><br><span class="line">            <span class="keyword">if</span> (target &lt; nums[i]) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[i]) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="153-寻找旋转排序数组中的最小值"><a class="markdownIt-Anchor" href="#153-寻找旋转排序数组中的最小值"></a> <a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">153. 寻找旋转排序数组中的最小值</a></h3>
<blockquote>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                min = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[min];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#4-寻找两个正序数组的中位数"></a> <a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. 寻找两个正序数组的中位数</a></h3>
<blockquote>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
</blockquote>
<h4 id="解法一不满足时间复杂度要求"><a class="markdownIt-Anchor" href="#解法一不满足时间复杂度要求"></a> 解法一——不满足时间复杂度要求</h4>
<p>直接找中间的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> output;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (nums1.size() + nums2.size()) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            prev = curr;</span><br><span class="line">            <span class="keyword">if</span> (p1 &lt; nums1.size() &amp;&amp; (p2 &gt;= nums2.size() || nums1[p1] &lt; nums2[p2])) &#123;</span><br><span class="line">                curr = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                curr = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.size() + nums2.size()) % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">//偶数</span></span><br><span class="line">            <span class="keyword">return</span> (prev + curr) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  &#123;</span><br><span class="line">            <span class="keyword">return</span> curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二第k小数"><a class="markdownIt-Anchor" href="#解法二第k小数"></a> 解法二——第k小数</h4>
<p>要求<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(m+n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的复杂度</p>
<p>题目是求中位数，其实就是求第 <code>k</code> 小数的一种特殊情况</p>
<p>更一般的情况 A[1] ，A[2] ，A[3]，A[k/2] … ，B[1]，B[2]，B[3]，B[k/2] … ，如果 A[k/2]&lt;B[k/2] ，那么A[1]，A[2]，A[3]，A[k/2]都不可能是第 k 小的数字。</p>
<p>不断地去找第k小的数字，排除的去掉。</p>
<p>作者：windliang</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> nums1Size = nums1.size();</span><br><span class="line">            <span class="keyword">int</span> nums2Size = nums2.size();</span><br><span class="line">            <span class="keyword">if</span> (p1 == nums1Size) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[p2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p2 == nums2Size) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[p1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> min(nums1[p1], nums2[p2]) ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> p1Next = min(p1 + k/<span class="number">2</span> - <span class="number">1</span>, nums1Size - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> p2Next = min(p2 + k/<span class="number">2</span> - <span class="number">1</span>, nums2Size - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1Next] &lt;= nums2[p2Next]) &#123;</span><br><span class="line">                k -= p1Next - p1 + <span class="number">1</span>;</span><br><span class="line">                p1 = p1Next + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= p2Next - p2 + <span class="number">1</span>;</span><br><span class="line">                p2 = p2Next + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((nums1.size() + nums2.size()) % <span class="number">2</span>) &#123; <span class="comment">// 奇数</span></span><br><span class="line">            <span class="keyword">return</span> getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / <span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / <span class="number">2</span>)) + getKthElement(nums1, nums2, ((nums1.size() + nums2.size()) / <span class="number">2</span>) + <span class="number">1</span>)) /<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="155-最小栈"><a class="markdownIt-Anchor" href="#155-最小栈"></a> <a href="https://leetcode.cn/problems/min-stack/" target="_blank" rel="noopener">155. 最小栈</a></h3>
<blockquote>
<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>
<p>实现 <code>MinStack</code> 类:</p>
<ul>
<li><code>MinStack()</code> 初始化堆栈对象。</li>
<li><code>void push(int val)</code> 将元素val推入堆栈。</li>
<li><code>void pop()</code> 删除堆栈顶部的元素。</li>
<li><code>int top()</code> 获取堆栈顶部的元素。</li>
<li><code>int getMin()</code> 获取堆栈中的最小元素。</li>
</ul>
</blockquote>
<p>再找一个辅助栈，专门存最小值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; minS;</span><br><span class="line"></span><br><span class="line">    MinStack() &#123;</span><br><span class="line">        minS.push(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        S.push(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; minS.top()) &#123;</span><br><span class="line">            minS.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            minS.push(minS.top());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        S.pop();</span><br><span class="line">        minS.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> S.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minS.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="394-字符串解码"><a class="markdownIt-Anchor" href="#394-字符串解码"></a> <a href="https://leetcode.cn/problems/decode-string/" target="_blank" rel="noopener">394. 字符串解码</a>（▲）</h3>
<blockquote>
<p>给定一个经过编码的字符串，返回它解码后的字符串。</p>
<p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p>
<p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p>
<p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p>
</blockquote>
<p>GPT的修改结果，思路更加清晰，我原来想得太乱了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">decodeString</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; times;             <span class="comment">// 栈存储重复次数</span></span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; strings;        <span class="comment">// 栈存储中间结果</span></span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">string</span> output;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;      <span class="comment">// 判断是否为数字</span></span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + (s[i] - <span class="string">'0'</span>);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                times.push(num);</span><br><span class="line">                i--; <span class="comment">// 回退一个位置，以便后续的 '[' 可以正确处理</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                strings.push(output); <span class="comment">// 将当前的 output 保存</span></span><br><span class="line">                output = <span class="string">""</span>;          <span class="comment">// 清空 output，准备存储新的子字符串</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="built_in">string</span> tempTimes = output;</span><br><span class="line">                output = strings.top(); <span class="comment">// 取出上一次的字符串</span></span><br><span class="line">                strings.pop();</span><br><span class="line">                <span class="keyword">int</span> repeat = times.top();</span><br><span class="line">                times.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; repeat; j++) &#123;</span><br><span class="line">                    output += tempTimes; <span class="comment">// 拼接重复的字符串</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字母</span></span><br><span class="line">                output.push_back(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="215-数组中的第k个最大元素"><a class="markdownIt-Anchor" href="#215-数组中的第k个最大元素"></a> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h3>
<blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>
</blockquote>
<h4 id="解法一基于快排和快速选择"><a class="markdownIt-Anchor" href="#解法一基于快排和快速选择"></a> 解法一——基于快排和快速选择</h4>
<p>首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l⋯r] 做快速排序的过程是（参考《算法导论》）：</p>
<p>分解： 将数组 a[l⋯r] 「划分」成两个子数组 a[l⋯q−1]、a[q+1⋯r]，使得 a[l⋯q−1] 中的每个元素小于等于 a[q]，且 a[q] 小于等于 a[q+1⋯r] 中的每个元素。其中，计算下标 q 也是「划分」过程的一部分。<br>
解决： 通过递归调用快速排序，对子数组 a[l⋯q−1] 和 a[q+1⋯r] 进行排序。<br>
合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l⋯r] 已经有序。<br>
上文中提到的 「划分」 过程是：从子数组 a[l⋯r] 中选择任意一个元素 x 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， x 的最终位置就是 q。</p>
<p><strong>所以只要某次划分的 q为倒数第k个下标的时候，我们就已经找到了答案。</strong></p>
<p>作者：力扣官方题解</p>
<p>还是没完全看懂，为啥要do while啊，防止多加吗—— 帮助程序在有大量重复数字时快速收敛边界。 快速收敛就是让<code>j</code>尽可能接近当前区间中间位置。</p>
<p><strong>在特别用例中，存在大量在<code>x</code>和<code>nums[i]</code>和<code>nums[j]</code>都相等的情况。</strong></p>
<p><strong>所以会有许多次<code>i++,j--</code>，这让j`更进一步地接近中间位置。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> partition = nums[l];</span><br><span class="line">        <span class="keyword">int</span> low = l <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">int</span> high = r +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// while(nums[low] &lt; partition) &#123;</span></span><br><span class="line">            <span class="comment">//     low++;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// while(nums[high] &gt; partition) &#123;</span></span><br><span class="line">            <span class="comment">//     high--;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="keyword">do</span> &#123;low++;&#125; <span class="keyword">while</span> (nums[low] &lt; partition);</span><br><span class="line">            <span class="keyword">do</span> &#123;high--;&#125; <span class="keyword">while</span> (nums[high] &gt; partition);</span><br><span class="line">            <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">                swap(nums[low], nums[high]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, l, high, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> quickSelect(nums, high + <span class="number">1</span>, r, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>, nums.size() - k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二堆"><a class="markdownIt-Anchor" href="#解法二堆"></a> 解法二——堆</h4>
<p>小根堆</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; pq;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            pq.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.top() &lt; nums[i]) &#123;</span><br><span class="line">                pq.pop();</span><br><span class="line">                pq.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="295-数据流的中位数"><a class="markdownIt-Anchor" href="#295-数据流的中位数"></a> <a href="https://leetcode.cn/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. 数据流的中位数</a></h3>
<blockquote>
<p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p>
<ul>
<li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li>
<li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li>
</ul>
<p>实现 MedianFinder 类:</p>
<ul>
<li><code>MedianFinder()</code>初始化 <code>MedianFinder</code> 对象。</li>
<li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li>
<li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li>
</ul>
</blockquote>
<p>用两个优先队列，分别存最大和最小？</p>
<p>当我们尝试添加一个数 num 到数据结构中，我们需要分情况讨论：</p>
<p>num≤max{queMin}</p>
<p>此时 num 小于等于中位数，我们需要将该数添加到 queMin 中。新的中位数将小于等于原来的中位数，因此我们可能需要将 queMin 中最大的数移动到 queMax 中。</p>
<p>num&gt;max{queMin}</p>
<p>此时 num 大于中位数，我们需要将该数添加到 queMin 中。新的中位数将大于等于原来的中位数，因此我们可能需要将 queMax 中最小的数移动到 queMin 中。</p>
<p>作者：力扣官方题解</p>
<p>奇数，qMin比qMax多存一个。偶数相同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;&gt;&gt; Qmin;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;&gt;&gt; Qmax; </span><br><span class="line"></span><br><span class="line">    MedianFinder() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Qmin.empty() || num &lt;= Qmin.top()) &#123;</span><br><span class="line">            Qmin.push(num);</span><br><span class="line">            <span class="keyword">if</span> (Qmax.size() + <span class="number">1</span> &lt; Qmin.size()) &#123;</span><br><span class="line">                Qmax.push(Qmin.top());</span><br><span class="line">                Qmin.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Qmax.push(num);</span><br><span class="line">            <span class="keyword">if</span> (Qmax.size() &gt; Qmin.size()) &#123;</span><br><span class="line">                Qmin.push(Qmax.top());</span><br><span class="line">                Qmax.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Qmin.size() &gt; Qmax.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Qmin.top();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Qmax.top() + Qmin.top()) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MedianFinder* obj = new MedianFinder();</span></span><br><span class="line"><span class="comment"> * obj-&gt;addNum(num);</span></span><br><span class="line"><span class="comment"> * double param_2 = obj-&gt;findMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="118-杨辉三角"><a class="markdownIt-Anchor" href="#118-杨辉三角"></a> <a href="https://leetcode.cn/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></h3>
<blockquote>
<p>给定一个非负整数 *<code>numRows</code>，*生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p>
<p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">generate</span><span class="params">(<span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">output</span><span class="params">(numRows)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            output[i].resize(i + <span class="number">1</span>);</span><br><span class="line">            output[i][<span class="number">0</span>] = output[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                output[i][j] = output[i - <span class="number">1</span>][j - <span class="number">1</span>] + output[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="152-乘积最大子数组"><a class="markdownIt-Anchor" href="#152-乘积最大子数组"></a> <a href="https://leetcode.cn/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. 乘积最大子数组</a></h3>
<blockquote>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<p><strong>子数组</strong> 是数组中<u>连续</u>的 <strong>非空</strong> 元素序列。</p>
<p>测试用例的答案是一个 <strong>32-位</strong> 整数。</p>
</blockquote>
<p>考虑和300题类似的思路，每次回退计算。但是超时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size())</span></span>; <span class="comment">// 包含该数的最长子数组乘积</span></span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> output = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;  i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                temp *= nums[j];</span><br><span class="line">                dp[i] = max(dp[i], temp);</span><br><span class="line">                <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] &gt; output) &#123;</span><br><span class="line">                output = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用两个正负两个数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpPlus</span><span class="params">(nums.size())</span></span>; <span class="comment">// 正序列（绝对值最大）</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dpMinus</span><span class="params">(nums.size())</span></span>; <span class="comment">// 负序列（绝对值最大）</span></span><br><span class="line">        dpPlus[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dpMinus[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> output = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            dpPlus[i] = max(nums[i], max(dpPlus[i - <span class="number">1</span>] * nums[i], dpMinus[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">            dpMinus[i] = min(nums[i], min(dpPlus[i - <span class="number">1</span>] * nums[i], dpMinus[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">            <span class="keyword">if</span> (dpPlus[i] &gt; output) &#123;</span><br><span class="line">                output = dpPlus[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="32-最长有效括号"><a class="markdownIt-Anchor" href="#32-最长有效括号"></a> <a href="https://leetcode.cn/problems/longest-valid-parentheses/" target="_blank" rel="noopener">32. 最长有效括号</a></h3>
<blockquote>
<p>给你一个只包含 <code>'('</code> 和 <code>')'</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p>
</blockquote>
<p>考虑有<code>&quot;()(()&quot;</code>的情况，所以单纯的记数左括号作为dp是不对的</p>
<p>所以考虑以下的思路：</p>
<ul>
<li><code>(</code>均为0</li>
<li><code>)</code>分上一个是<code>(</code>（增加2）还是<code>)</code>（还得继续往前找）
<ul>
<li><code>(</code>（增加2），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[i] = dp[i-2]+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
<li><code>)</code>（继续往前找），要把上一个元素序列扣掉（它的长度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>），去看<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i-dp[i-1]-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>是不是<code>(</code>，是的话<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>+</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">dp[i] = dp[i-1]+ dp[i-dp[i-1]-2]+2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span>) &#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i<span class="number">-2</span>] + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= <span class="number">1</span> &amp;&amp; s[i - <span class="number">1</span>] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i - dp[i<span class="number">-1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (s[i - dp[i<span class="number">-1</span>] - <span class="number">1</span>] == <span class="string">'('</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - dp[i<span class="number">-1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + dp[i - dp[i<span class="number">-1</span>] - <span class="number">2</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i] = dp[i<span class="number">-1</span>] + <span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            output = max(output, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>官方题解更加简洁</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxans = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s[i - dp[i - <span class="number">1</span>] - <span class="number">1</span>] == <span class="string">'('</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxans = max(maxans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="64-最小路径和"><a class="markdownIt-Anchor" href="#64-最小路径和"></a> <a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener">64. 最小路径和</a></h3>
<blockquote>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>**说明：**每次只能向下或者向右移动一步。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.size();</span><br><span class="line">        <span class="keyword">int</span> column = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(column, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">            temp += grid[<span class="number">0</span>][j];</span><br><span class="line">            dp[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; row; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; column; j++) &#123;</span><br><span class="line">                dp[j] = min(dp[j] , dp[j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[column - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="5-最长回文子串"><a class="markdownIt-Anchor" href="#5-最长回文子串"></a> <a href="https://leetcode.cn/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h3>
<blockquote>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文子串。</p>
</blockquote>
<p>和32挺像的。但是区别就是不光两个元素啊！所以会有其他的问题，比如一个滚动数组好像是不够的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (s.size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> output;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &gt;= len) &#123;</span><br><span class="line">                        len = j - i;</span><br><span class="line">                        output = s.substr(i, j - i + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="136-只出现一次的数字"><a class="markdownIt-Anchor" href="#136-只出现一次的数字"></a> <a href="https://leetcode.cn/problems/single-number/" target="_blank" rel="noopener">136. 只出现一次的数字</a></h3>
<blockquote>
<p>给你一个 <strong>非空</strong> 整数数组 <code>nums</code> ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>
<p>你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。</p>
</blockquote>
<h4 id="解法一不考虑线性复杂度"><a class="markdownIt-Anchor" href="#解法一不考虑线性复杂度"></a> 解法一——不考虑线性复杂度</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="comment">// int output = nums[0];</span></span><br><span class="line">        <span class="keyword">if</span> (nums.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i<span class="number">-1</span>] != nums[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二位运算"><a class="markdownIt-Anchor" href="#解法二位运算"></a> 解法二——位运算</h4>
<p>真的想不到啊。。。</p>
<p>对于这道题，可使用异或运算 ⊕。异或运算有以下三个性质。</p>
<ul>
<li>任何数和 0 做异或运算，结果仍然是原来的数，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">a⊕0=a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>。</li>
<li>任何数和其自身做异或运算，结果是 0，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a⊕a=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</li>
<li>异或运算满足交换律和结合律，即 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>⊕</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo>=</mo><mi>b</mi><mo>⊕</mo><mo stretchy="false">(</mo><mi>a</mi><mo>⊕</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>b</mi><mo>⊕</mo><mn>0</mn><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⊕</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>。</li>
</ul>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="169-多数元素"><a class="markdownIt-Anchor" href="#169-多数元素"></a> <a href="https://leetcode.cn/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h3>
<blockquote>
<p>给定一个大小为 <code>n</code> 的数组 <code>nums</code> ，返回其中的多数元素。多数元素是指在数组中出现次数 <strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
</blockquote>
<h4 id="解法一不考虑复杂度"><a class="markdownIt-Anchor" href="#解法一不考虑复杂度"></a> 解法一——不考虑复杂度</h4>
<p>① 先排序再找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; (nums.size() / <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>更简单的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>② 哈希表</p>
<h4 id="解法二boyer-moore-投票算法"><a class="markdownIt-Anchor" href="#解法二boyer-moore-投票算法"></a> 解法二——Boyer-Moore 投票算法</h4>
<p>如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 <code>0</code>，从结果本身我们可以看出众数比其他数多。</p>
<p>太形象了——“同归于尽消杀法” ：</p>
<p>由于多数超过50%, 比如100个数，那么多数至少51个，剩下少数是49个。</p>
<ol>
<li>第一个到来的士兵，直接插上自己阵营的旗帜占领这块高地，此时领主 winner 就是这个阵营的人，现存兵力 count = 1。</li>
<li>如果新来的士兵和前一个士兵是同一阵营，则集合起来占领高地，领主不变，winner 依然是当前这个士兵所属阵营，现存兵力 count++；</li>
<li>如果新来到的士兵不是同一阵营，则前方阵营派一个士兵和它同归于尽。 此时前方阵营兵力count --。（即使双方都死光，这块高地的旗帜 winner 依然不变，因为已经没有活着的士兵可以去换上自己的新旗帜）</li>
<li>当下一个士兵到来，发现前方阵营已经没有兵力，新士兵就成了领主，winner 变成这个士兵所属阵营的旗帜，现存兵力 count ++。</li>
</ol>
<p>就这样各路军阀一直以这种以一敌一同归于尽的方式厮杀下去，直到少数阵营都死光，那么最后剩下的几个必然属于多数阵营，winner 就是多数阵营。（多数阵营 51个，少数阵营只有49个，死剩下的2个就是多数阵营的人）</p>
<p><a href="https://leetcode.cn/problems/majority-element/solution/javashi-pin-jiang-jie-xi-lie-majority-element-by-s/" target="_blank" rel="noopener">https://leetcode.cn/problems/majority-element/solution/javashi-pin-jiang-jie-xi-lie-majority-element-by-s/</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> curr = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr == nums[i]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                curr = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="75-颜色分类"><a class="markdownIt-Anchor" href="#75-颜色分类"></a> <a href="https://leetcode.cn/problems/sort-colors/" target="_blank" rel="noopener">75. 颜色分类</a></h3>
<blockquote>
<p>给定一个包含红色、白色和蓝色、共 <code>n</code> 个元素的数组 <code>nums</code> ，<strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">原地</a></strong> 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>我们使用整数 <code>0</code>、 <code>1</code> 和 <code>2</code> 分别表示红色、白色和蓝色。</p>
<p>必须在不使用库内置的 sort 函数的情况下解决这个问题。</p>
</blockquote>
<h4 id="解法一排序冒泡"><a class="markdownIt-Anchor" href="#解法一排序冒泡"></a> 解法一——排序（冒泡）</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; nums.size() - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j - <span class="number">1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                    swap(nums[j - <span class="number">1</span>], nums[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法二直接统计反正就三个颜色"><a class="markdownIt-Anchor" href="#解法二直接统计反正就三个颜色"></a> 解法二——直接统计，反正就三个颜色</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> color[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            color[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; color[<span class="number">0</span>]; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = color[<span class="number">0</span>]; i &lt; color[<span class="number">0</span>] + color[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = color[<span class="number">0</span>] + color[<span class="number">1</span>]; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法三单指针"><a class="markdownIt-Anchor" href="#解法三单指针"></a> 解法三——单指针</h4>
<p>遍历两边</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p]);</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p]);</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="解法四双指针"><a class="markdownIt-Anchor" href="#解法四双指针"></a> 解法四——双指针(▲)</h4>
<p>两个指针一个指向0，一个指向1</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0 = <span class="number">0</span>, p1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums[i], nums[p0]);</span><br><span class="line">                <span class="keyword">if</span> (p0 &lt; p1) &#123;</span><br><span class="line">                    swap(nums[i], nums[p1]);</span><br><span class="line">                &#125;</span><br><span class="line">                p0++;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="31-下一个排列"><a class="markdownIt-Anchor" href="#31-下一个排列"></a> <a href="https://leetcode.cn/problems/next-permutation/" target="_blank" rel="noopener">31. 下一个排列</a>（▲）</h3>
<blockquote>
<p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 <code>arr</code> 的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code> 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code> 。</li>
<li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code> 。</li>
<li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code> 的下一个排列。</p>
<p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95" target="_blank" rel="noopener"> 原地 </a>**修改，只允许使用额外常数空间。</p>
</blockquote>
<img alt="image-20241010160245605" style="zoom:50%;" class="post-img b-lazy" data-img="/2024/03/30/LeetCode-problems/image-20241010160245605.png" data-index="67" data-src="/2024/03/30/LeetCode-problems/image-20241010160245605.png">
<p>如何得到这样的排列顺序？这是本文的重点。我们可以这样来分析：</p>
<ol>
<li>我们希望下一个数 <strong>比当前数大</strong>，这样才满足 “下一个排列” 的定义。因此只需要 <strong>将后面的「大数」与前面的「小数」交换</strong>，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465。</li>
<li>我们还希望下一个数 <strong>增加的幅度尽可能的小</strong>，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：
<ol>
<li>在 <strong>尽可能靠右的低位</strong> 进行交换，需要 <strong>从后向前</strong> 查找</li>
<li>将一个 <strong>尽可能小的「大数」</strong> 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换</li>
<li>将「大数」换到前面后，需要将「大数」后面的所有数 <strong>重置为升序，升序排列就是最小的排列</strong>。以 123465 为例：首先按照上一步，交换 5 和 4，得到 123564；然后需要将 5 之后的数重置为升序，得到 123546。显然 123546 比 123564 更小，123546 就是 123465 的下一个排列</li>
</ol>
</li>
</ol>
<p>作者：Imageslr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = nums.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 找到从后往前的第一个相邻升序对</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;=<span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="number">1</span>])  &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;<span class="comment">// 非最后一个排列</span></span><br><span class="line">            <span class="comment">//找到尽可能小的「大数」</span></span><br><span class="line">            <span class="keyword">int</span> k = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[k]) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums[i], nums[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin() + i + <span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="287-寻找重复数"><a class="markdownIt-Anchor" href="#287-寻找重复数"></a> <a href="https://leetcode.cn/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a>（▲）</h3>
<blockquote>
<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>[1, n]</code> 范围内（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>
<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，返回 <strong>这个重复的数</strong> 。</p>
<p>你设计的解决方案必须 <strong>不修改</strong> 数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>
</blockquote>
<p>二分法：</p>
<p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>是数组中小于i的数的个数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span>随数字增大有单调性（<em>target</em> 前 <em>cnt</em>[<em>i</em>]≤<em>i</em>，<em>target</em> 后 <em>cnt</em>[<em>i</em>]&gt;<em>i</em>）</p>
<ol>
<li>
<p>如果测试用例的数组中 target 出现了两次，其余的数各出现了一次，这个时候肯定满足上文提及的性质，因为小于 target 的数 i 满足 cnt[i]=i，大于等于 target 的数 j 满足 cnt[j]=j+1。</p>
</li>
<li>
<p>如果测试用例的数组中 target 出现了三次及以上，那么必然有一些数不在 nums 数组中了，这个时候相当于我们用 target 去替换了这些数，我们考虑替换的时候对 cnt[] 数组的影响。如果替换的数 i 小于 target ，那么 [i,target−1] 的 cnt 值均减一，其他不变，满足条件。如果替换的数 j 大于等于 target，那么 [target,j−1] 的 cnt 值均加一，其他不变，亦满足条件。</p>
</li>
</ol>
<p>作者：力扣官方题解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                cnt += (nums[i] &lt;= mid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt;= mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                output = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="华为手撕准备"><a class="markdownIt-Anchor" href="#华为手撕准备"></a> 华为手撕准备</h2>
<h3 id="54-螺旋矩阵-2"><a class="markdownIt-Anchor" href="#54-螺旋矩阵-2"></a> 54. 螺旋矩阵</h3>
<ol>
<li>visited矩阵</li>
<li>模拟</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> upBound = <span class="number">0</span>, downBound = row - <span class="number">1</span>, leftBound = <span class="number">0</span>, rightBound = column - <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = leftBound; j &lt;= rightBound; j++) &#123;</span><br><span class="line">                output.push_back(matrix[upBound][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            upBound++;</span><br><span class="line">            <span class="keyword">if</span> (upBound &gt; downBound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = upBound; i &lt;= downBound; i++) &#123;</span><br><span class="line">                output.push_back(matrix[i][rightBound]);</span><br><span class="line">            &#125;</span><br><span class="line">            rightBound--;</span><br><span class="line">            <span class="keyword">if</span> (rightBound &lt; leftBound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rightBound; j &gt;= leftBound; j--) &#123;</span><br><span class="line">                output.push_back(matrix[downBound][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            downBound--;</span><br><span class="line">            <span class="keyword">if</span> (downBound &lt; upBound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = downBound; i &gt;= upBound; i--) &#123;</span><br><span class="line">                output.push_back(matrix[i][leftBound]);</span><br><span class="line">            &#125;</span><br><span class="line">            leftBound++;</span><br><span class="line">            <span class="keyword">if</span> (rightBound &lt; leftBound) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; output;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> length = m * n;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;; <span class="comment">// 01右；10下；0-1左；-10上</span></span><br><span class="line">        <span class="keyword">int</span> countDir = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            output.emplace_back(matrix[x][y]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; count &lt;&lt; " || ";</span></span><br><span class="line">            <span class="keyword">if</span>(count &lt;= <span class="number">1</span>) &#123; <span class="comment">// count = 1 换方向</span></span><br><span class="line">                countDir = (countDir + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                m -= <span class="built_in">abs</span>(dir[countDir][<span class="number">0</span>]);</span><br><span class="line">                n -= <span class="built_in">abs</span>(dir[countDir][<span class="number">1</span>]);</span><br><span class="line">                count = <span class="built_in">abs</span>(dir[countDir][<span class="number">0</span>]) * m + <span class="built_in">abs</span>(dir[countDir][<span class="number">1</span>]) * n + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; i &lt;&lt;" "  &lt;&lt;count &lt;&lt; " || " &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; " || " &lt;&lt; countDir &lt;&lt; " " &lt;&lt; dir[countDir][0] &lt;&lt; " " &lt;&lt; dir[countDir][1] &lt;&lt; endl;</span></span><br><span class="line">            x += dir[countDir][<span class="number">0</span>];</span><br><span class="line">            y += dir[countDir][<span class="number">1</span>];</span><br><span class="line">            count --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="买卖股票"><a class="markdownIt-Anchor" href="#买卖股票"></a> 买卖股票</h3>
<ol>
<li>
<p>只能买卖一次</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>))</span></span>; <span class="comment">// 注意这里只开辟了一个2 * 2大小的二维数组</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = max(dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>], prices[i] + dp[(i - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(len - <span class="number">1</span>) % <span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>可以买卖无数次：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dp[i][0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>不止和上次也没持有比较，还和上次持有但是卖了有关。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">0</span>] = max(dp[(i<span class="number">-1</span>) % <span class="number">2</span>][<span class="number">0</span>], dp[(i<span class="number">-1</span>) % <span class="number">2</span>][<span class="number">1</span>]-prices[i]); <span class="comment">// 持有股票</span></span><br><span class="line">            dp[i % <span class="number">2</span>][<span class="number">1</span>] = max(dp[(i<span class="number">-1</span>) % <span class="number">2</span>][<span class="number">1</span>], dp[(i<span class="number">-1</span>) % <span class="number">2</span>][<span class="number">0</span>]+prices[i]); <span class="comment">// 不持有股票</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[(prices.size() - <span class="number">1</span>)%<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最多可以完成 <strong>两笔</strong> 交易。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = prices.size();</span><br><span class="line">        <span class="keyword">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = max(buy1, -prices[i]);</span><br><span class="line">            sell1 = max(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = max(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = max(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最多可以完成k笔交易的通解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector buy(k+1, INT_MIN), sel(k+1, 0);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : prices) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; k+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                buy[j] = max(buy[j], sel[j - <span class="number">1</span>] - i);</span><br><span class="line">                sel[j] = max(sel[j], buy[j] + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sel[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>无限次交易，但带冷静期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = - prices[<span class="number">0</span>]; <span class="comment">// 持有</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 不持有且不在不在冷冻期</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 冷冻期</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]); <span class="comment">// 持有只有两种：上一期持有，上次不持有-price[i]</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]); <span class="comment">// 上一次在冷冻期，或者上一次不持有</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i]; <span class="comment">// 上一期持有，本期抛售</span></span><br><span class="line">            <span class="comment">// cout &lt;&lt; dp[i][0] &lt;&lt; " " &lt;&lt; dp[i][1] &lt;&lt; " " &lt;&lt; dp[i][2] &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>], dp[prices.size() - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>无限次交易，但含手续费</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(prices.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; (<span class="number">2</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.size(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.size() - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="公共子串"><a class="markdownIt-Anchor" href="#公共子串"></a> 公共子串</h3>
<h3 id="回文子串"><a class="markdownIt-Anchor" href="#回文子串"></a> 回文子串</h3>
<p>动态规划</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(s.length(), <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(s.length(), <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="number">1</span> || dp[i+<span class="number">1</span>][j<span class="number">-1</span>])) &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>双指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left, right;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">1</span>; <span class="comment">// 0位置的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> center = <span class="number">1</span>; center &lt; s.length(); center++)  &#123;</span><br><span class="line">            output ++; <span class="comment">// 独自的</span></span><br><span class="line">            <span class="comment">// 区分奇偶，偶数往左找</span></span><br><span class="line">            <span class="keyword">if</span> (s[center] == s[center - <span class="number">1</span>]) &#123; <span class="comment">// 偶</span></span><br><span class="line">                left = center - <span class="number">1</span>;</span><br><span class="line">                right = center;</span><br><span class="line">                <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">                    output++;</span><br><span class="line">                    left--;</span><br><span class="line">                    right++;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 奇数是必然有的情况，不需要else</span></span><br><span class="line">            left = center - <span class="number">1</span>;</span><br><span class="line">            right = center + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">                output++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="括号匹配"><a class="markdownIt-Anchor" href="#括号匹配"></a> 括号匹配</h3>
<h3 id="链表成环"><a class="markdownIt-Anchor" href="#链表成环"></a> 链表成环</h3>
<hr>
<center>持续更新中</center>
<hr>

                </article>
                <ul class="tags-postTags">
                    
                    <li>
                        <a href="/tags/%E7%BC%96%E7%A8%8B/" rel="tag"># 编程</a>
                    </li>
                    
                </ul>
            </div>
        </div>
    </div>
    
    
    <div>
        <div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>
  
  <!-- JS库 sweetalert 可修改路径 -->
  <script type="text/javascript" src="http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js"></script>
  <script src="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js"></script>
  <link rel="stylesheet" type="text/css" href="http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css">

  <p><span>本文标题:</span>【更新中】LeetCode自用刷题记录</p>
  <p><span>文章作者:</span>Levitate_</p>
  <p><span>发布时间:</span>2024年03月29日 - 21:38:44</p>
  <p><span>原始链接:</span><a href="/2024/03/30/LeetCode-problems/" title="【更新中】LeetCode自用刷题记录">https://levitate-qian.github.io/2024/03/30/LeetCode-problems/</a>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://levitate-qian.github.io/2024/03/30/LeetCode-problems/" aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
    clipboard.on('success', $(function(){
      $(".fa-clipboard").click(function(){
        swal({   
          title: "",   
          text: '复制成功',   
          html: false,
          timer: 500,   
          showConfirmButton: false
        });
      });
    }));  
</script>

    </div>
    
    

    
    <nav id="gobottom" class="pagination">
        
        <span class="prev-next-post">·</span>
        
        <a class="next-post" title="LaTeX札记（六）：MATLAB与TikZ绘图" href="/2024/01/01/latex-note-06/">
            LaTeX札记（六）：MATLAB与TikZ绘图 →
        </a>
        
    </nav>

    
    <div class="inner">
        <div id="comment"></div>
    </div>
    
</div>

<div class="toc-bar">
    <div class="toc-btn-bar">
        <a href="#site-main" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M793.024 710.272a32 32 0 1 0 45.952-44.544l-310.304-320a32 32 0 0 0-46.4 0.48l-297.696 320a32 32 0 0 0 46.848 43.584l274.752-295.328 286.848 295.808z"/></svg>
        </a>
        <div class="toc-btn toc-switch">
            <svg class="toc-open" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M779.776 480h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M779.776 672h-387.2a32 32 0 0 0 0 64h387.2a32 32 0 0 0 0-64M256 288a32 32 0 1 0 0 64 32 32 0 0 0 0-64M392.576 352h387.2a32 32 0 0 0 0-64h-387.2a32 32 0 0 0 0 64M256 480a32 32 0 1 0 0 64 32 32 0 0 0 0-64M256 672a32 32 0 1 0 0 64 32 32 0 0 0 0-64"/></svg>
            <svg class="toc-close hide" viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M512 960c-247.039484 0-448-200.960516-448-448S264.960516 64 512 64 960 264.960516 960 512 759.039484 960 512 960zM512 128.287273c-211.584464 0-383.712727 172.128262-383.712727 383.712727 0 211.551781 172.128262 383.712727 383.712727 383.712727 211.551781 0 383.712727-172.159226 383.712727-383.712727C895.712727 300.415536 723.551781 128.287273 512 128.287273z"/><path d="M557.05545 513.376159l138.367639-136.864185c12.576374-12.416396 12.672705-32.671738 0.25631-45.248112s-32.704421-12.672705-45.248112-0.25631l-138.560301 137.024163-136.447897-136.864185c-12.512727-12.512727-32.735385-12.576374-45.248112-0.063647-12.512727 12.480043-12.54369 32.735385-0.063647 45.248112l136.255235 136.671523-137.376804 135.904314c-12.576374 12.447359-12.672705 32.671738-0.25631 45.248112 6.271845 6.335493 14.496116 9.504099 22.751351 9.504099 8.12794 0 16.25588-3.103239 22.496761-9.247789l137.567746-136.064292 138.687596 139.136568c6.240882 6.271845 14.432469 9.407768 22.65674 9.407768 8.191587 0 16.352211-3.135923 22.591372-9.34412 12.512727-12.480043 12.54369-32.704421 0.063647-45.248112L557.05545 513.376159z"/></svg>
        </div>
        <a href="#gobottom" class="toc-btn">
            <svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M231.424 346.208a32 32 0 0 0-46.848 43.584l297.696 320a32 32 0 0 0 46.4 0.48l310.304-320a32 32 0 1 0-45.952-44.544l-286.848 295.808-274.752-295.36z"/></svg>
        </a>
    </div>
    <div class="toc-main">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode自用刷题思路"><span class="toc-text"> LeetCode自用刷题思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-text"> 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#704-二分查找"><span class="toc-text"> 704. 二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-移除元素"><span class="toc-text"> 27. 移除元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#977-有序数组的平方"><span class="toc-text"> 977. 有序数组的平方</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#209-长度最小的子数组"><span class="toc-text"> 209. 长度最小的子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59-螺旋矩阵-ii"><span class="toc-text"> 59. 螺旋矩阵 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-text"> 链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#203-移除链表元素"><span class="toc-text"> 203. 移除链表元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#707-设计链表"><span class="toc-text"> 707. 设计链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-反转链表"><span class="toc-text"> 206. 反转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-两两交换链表中的节点"><span class="toc-text"> 24. 两两交换链表中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-删除链表的倒数第-n-个结点"><span class="toc-text"> 19. 删除链表的倒数第 N 个结点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力解法两次遍历"><span class="toc-text"> 解法一——暴力解法，两次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二双指针让快慢指针间隔n位"><span class="toc-text"> 解法二——双指针，让快慢指针间隔n位</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160-相交链表"><span class="toc-text"> 160. 相交链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-环形链表-ii"><span class="toc-text"> 142. 环形链表 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希表"><span class="toc-text"> 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#242-有效的字母异位词"><span class="toc-text"> 242. 有效的字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#349-两个数组的交集"><span class="toc-text"> 349. 两个数组的交集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一建立数组hash表"><span class="toc-text"> 解法一——建立数组hash表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二用无序set做"><span class="toc-text"> 解法二——用无序set做</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202-快乐数"><span class="toc-text"> 202. 快乐数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-两数之和"><span class="toc-text"> 1. 两数之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力解法"><span class="toc-text"> 解法一——暴力解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二利用哈希表的思路"><span class="toc-text"> 解法二——利用哈希表的思路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#454-四数相加-ii"><span class="toc-text"> 454. 四数相加 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#383-赎金信"><span class="toc-text"> 383. 赎金信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-三数之和"><span class="toc-text"> 15. 三数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-四数之和"><span class="toc-text"> 18. 四数之和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#204-计数质数"><span class="toc-text"> 204. 计数质数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-text"> 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#344-反转字符串"><span class="toc-text"> 344. 反转字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#541-反转字符串-ii"><span class="toc-text"> 541. 反转字符串 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-替换数字kamacoder"><span class="toc-text"> 54. 替换数字(kamacoder)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151-反转字符串中的单词"><span class="toc-text"> 151. 反转字符串中的单词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-右旋字符串-kamacoder"><span class="toc-text"> 55. 右旋字符串 (kamacoder)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一直接字符串提取拼接"><span class="toc-text"> 解法一——直接字符串提取拼接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二整体反转字符串两个反转单词"><span class="toc-text"> 解法二——“整体反转字符串”+“两个反转单词”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-找出字符串中第一个匹配项的下标"><span class="toc-text"> 28. 找出字符串中第一个匹配项的下标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一-暴力解法也能解取所有的n长字串即可"><span class="toc-text"> 解法一—— 暴力解法也能解，取所有的n长字串即可。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二kmp算法"><span class="toc-text"> 解法二——KMP算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#459-重复的子字符串"><span class="toc-text"> 459. 重复的子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一移动匹配"><span class="toc-text"> 解法一——移动匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二优化的kmp算法"><span class="toc-text"> 解法二——优化的KMP算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#双指针"><span class="toc-text"> 双指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈-队列"><span class="toc-text"> 栈、队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#232-用栈实现队列"><span class="toc-text"> 232. 用栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#双栈操作均集中在push"><span class="toc-text"> 双栈——操作均集中在push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双栈的官方题解输入栈-输出栈"><span class="toc-text"> 双栈的官方题解——输入栈、输出栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#225-用队列实现栈"><span class="toc-text"> 225. 用队列实现栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#两个队列"><span class="toc-text"> 两个队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个队列"><span class="toc-text"> 一个队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-有效的括号"><span class="toc-text"> 20. 有效的括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1047-删除字符串中的所有相邻重复项"><span class="toc-text"> 1047. 删除字符串中的所有相邻重复项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一stack"><span class="toc-text"> 解法一——stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二以字符串为栈"><span class="toc-text"> 解法二——以字符串为栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150-逆波兰表达式求值"><span class="toc-text"> 150. 逆波兰表达式求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#239-滑动窗口最大值"><span class="toc-text"> 239. 滑动窗口最大值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一对map的值进行排序"><span class="toc-text"> 解法一——对map的值进行排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二优先级序列"><span class="toc-text"> 解法二——优先级序列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-text"> 二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的深度优先dfs遍历144前序145后序94中序"><span class="toc-text"> 二叉树的深度优先DFS遍历（144前序&#x2F;145后序&#x2F;94中序）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#方法一递归"><span class="toc-text"> 方法一——递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法二非递归迭代"><span class="toc-text"> 方法二——非递归迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法三二叉树的统一迭代法"><span class="toc-text"> 方法三——二叉树的统一迭代法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二叉树的层序广度优先bfs遍历102107199637429515116117"><span class="toc-text"> 二叉树的层序（广度优先）BFS遍历（102&#x2F;107&#x2F;199&#x2F;637&#x2F;429&#x2F;515&#x2F;116&#x2F;117）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#102二叉树的层序遍历"><span class="toc-text"> 102.二叉树的层序遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#解法一非递归迭代"><span class="toc-text"> 解法一——非递归迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#解法二递归"><span class="toc-text"> 解法二——递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#107二叉树的层次遍历ii"><span class="toc-text"> 107.二叉树的层次遍历II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#199二叉树的右视图"><span class="toc-text"> 199.二叉树的右视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#637二叉树的层平均值"><span class="toc-text"> 637.二叉树的层平均值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#429n叉树的层序遍历"><span class="toc-text"> 429.N叉树的层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#515在每个树行中找最大值"><span class="toc-text"> 515.在每个树行中找最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#116填充每个节点的下一个右侧节点指针"><span class="toc-text"> 116.填充每个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#117填充每个节点的下一个右侧节点指针ii"><span class="toc-text"> 117.填充每个节点的下一个右侧节点指针II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#226-翻转二叉树"><span class="toc-text"> 226. 翻转二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一递归"><span class="toc-text"> 解法一——递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二迭代深度优先"><span class="toc-text"> 解法二——迭代（深度优先）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法三迭代广度优先"><span class="toc-text"> 解法三——迭代（广度优先）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101-对称二叉树"><span class="toc-text"> 101. 对称二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一递归法"><span class="toc-text"> 解法一——递归法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二迭代法"><span class="toc-text"> 解法二——迭代法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#100相同的树"><span class="toc-text"> 100.相同的树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#572另一个树的子树"><span class="toc-text"> 572.另一个树的子树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104二叉树的最大深度"><span class="toc-text"> 104.二叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归求解深度优先遍历"><span class="toc-text"> 递归求解——深度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#非递归迭代广度优先遍历"><span class="toc-text"> 非递归迭代——广度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#559-n-叉树的最大深度"><span class="toc-text"> 559. N 叉树的最大深度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#递归"><span class="toc-text"> 递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#迭代"><span class="toc-text"> 迭代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111二叉树的最小深度"><span class="toc-text"> 111.二叉树的最小深度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非递归迭代广度优先遍历-2"><span class="toc-text"> 非递归迭代——广度优先遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归深度优先遍历"><span class="toc-text"> 递归——深度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#222-完全二叉树的节点个数"><span class="toc-text"> 222. 完全二叉树的节点个数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一层次遍历"><span class="toc-text"> 解法一——层次遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二完全二叉树二分法"><span class="toc-text"> 解法二——完全二叉树+二分法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完全二叉树的性质"><span class="toc-text"> 完全二叉树的性质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110-平衡二叉树"><span class="toc-text"> 110. 平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自顶向下的递归"><span class="toc-text"> 自顶向下的递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自底向上的递归"><span class="toc-text"> 自底向上的递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257-二叉树的所有路径"><span class="toc-text"> 257. 二叉树的所有路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一递归使用栈"><span class="toc-text"> 解法一——递归+使用栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二递归使用字符串隐式回溯"><span class="toc-text"> 解法二——递归+使用字符串+隐式回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法三迭代"><span class="toc-text"> 解法三——迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404-左叶子之和"><span class="toc-text"> 404. 左叶子之和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一层次遍历bfs"><span class="toc-text"> 解法一——层次遍历BFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二深度优先dfs"><span class="toc-text"> 解法二——深度优先DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#513-找树左下角的值"><span class="toc-text"> 513. 找树左下角的值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一bfsflag"><span class="toc-text"> 解法一——BFS+flag</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二bfs左右节点相反"><span class="toc-text"> 解法二——BFS，左右节点相反</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs"><span class="toc-text"> DFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#路径总和112113"><span class="toc-text"> 路径总和（112&#x2F;113）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#112-路径总和"><span class="toc-text"> 112. 路径总和</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#迭代-2"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#递归-2"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#113-路径总和-ii"><span class="toc-text"> 113. 路径总和 II</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#迭代-3"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#递归-3"><span class="toc-text"> 递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#从遍历序列恢复二叉树"><span class="toc-text"> 从遍历序列恢复二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#106-从中序与后序遍历序列构造二叉树"><span class="toc-text"> 106. 从中序与后序遍历序列构造二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#105-从前序与中序遍历序列构造二叉树"><span class="toc-text"> 105. 从前序与中序遍历序列构造二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#654-最大二叉树"><span class="toc-text"> 654. 最大二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#617-合并二叉树"><span class="toc-text"> 617. 合并二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一迭代层次遍历列举所有情况"><span class="toc-text"> 解法一——迭代+层次遍历+列举所有情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二递归深度优先"><span class="toc-text"> 解法二——递归+深度优先</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#700-二叉搜索树中的搜索"><span class="toc-text"> 700. 二叉搜索树中的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-4"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-4"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-验证二叉搜索树"><span class="toc-text"> 98. 验证二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代中序遍历"><span class="toc-text"> 迭代——中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-5"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#530-二叉搜索树的最小绝对差"><span class="toc-text"> 530. 二叉搜索树的最小绝对差</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#501-二叉搜索树中的众数"><span class="toc-text"> 501. 二叉搜索树中的众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236-二叉树的最近公共祖先"><span class="toc-text"> 236. 二叉树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#235-二叉搜索树的最近公共祖先"><span class="toc-text"> 235. 二叉搜索树的最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-6"><span class="toc-text"> 递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-5"><span class="toc-text"> 迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#701-二叉搜索树中的插入操作"><span class="toc-text"> 701. 二叉搜索树中的插入操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-6"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-7"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#450-删除二叉搜索树中的节点"><span class="toc-text"> 450. 删除二叉搜索树中的节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-7"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-8"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#669-修剪二叉搜索树"><span class="toc-text"> 669. 修剪二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-8"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-9"><span class="toc-text"> 递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108-将有序数组转换为二叉搜索树"><span class="toc-text"> 108. 将有序数组转换为二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#538-把二叉搜索树转换为累加树"><span class="toc-text"> 538. 把二叉搜索树转换为累加树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代-9"><span class="toc-text"> 迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归-10"><span class="toc-text"> 递归</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#回溯"><span class="toc-text"> 回溯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#77-组合"><span class="toc-text"> 77. 组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力回溯"><span class="toc-text"> 解法一——暴力回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二回溯剪枝"><span class="toc-text"> 解法二——回溯+剪枝</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216-组合总和-iii"><span class="toc-text"> 216. 组合总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-电话号码的字母组合"><span class="toc-text"> 17. 电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-组合总和"><span class="toc-text"> 39. 组合总和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-组合总和-ii"><span class="toc-text"> 40. 组合总和 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#131-分割回文串"><span class="toc-text"> 131. 分割回文串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力回溯-2"><span class="toc-text"> 解法一——暴力回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二回溯优化回文串的识别"><span class="toc-text"> 解法二——回溯+优化回文串的识别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-复原-ip-地址"><span class="toc-text"> 93. 复原 IP 地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力回溯temp是字符串数组"><span class="toc-text"> 解法一——暴力回溯，temp是字符串数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二temp就是对源字符串加点"><span class="toc-text"> 解法二——temp就是对源字符串加点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78-子集"><span class="toc-text"> 78. 子集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一递归-2"><span class="toc-text"> 解法一——递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#思路一每个元素有选和不选两个情况"><span class="toc-text"> 思路一——每个元素有选和不选两个情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#思路二遍历整个树的所有节点"><span class="toc-text"> 思路二——遍历整个树的所有节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二枚举迭代"><span class="toc-text"> 解法二——枚举迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#90-子集-ii"><span class="toc-text"> 90. 子集 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一递归-3"><span class="toc-text"> 解法一——递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二枚举迭代-2"><span class="toc-text"> 解法二——枚举迭代</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#491-非递减子序列"><span class="toc-text"> 491. 非递减子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一深搜"><span class="toc-text"> 解法一——深搜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二回溯set去重"><span class="toc-text"> 解法二——回溯+set去重</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-全排列"><span class="toc-text"> 46. 全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-全排列-ii"><span class="toc-text"> 47. 全排列 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一利用unordered_map"><span class="toc-text"> 解法一——利用unordered_map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二利用used数组并对其限制条件"><span class="toc-text"> 解法二——利用used数组，并对其限制条件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#332-重新安排行程"><span class="toc-text"> 332. 重新安排行程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-n-皇后"><span class="toc-text"> 51. N 皇后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-解数独"><span class="toc-text"> 37. 解数独</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#贪心算法"><span class="toc-text"> 贪心算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#455-分发饼干"><span class="toc-text"> 455. 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一两重for循环"><span class="toc-text"> 解法一——两重for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二一层for循环"><span class="toc-text"> 解法二——一层for循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#376-摆动序列"><span class="toc-text"> 376. 摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一贪心"><span class="toc-text"> 解法一——贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-最大子数组和"><span class="toc-text"> 53. 最大子数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一贪心-2"><span class="toc-text"> 解法一——贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-2"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-买卖股票的最佳时机-ii"><span class="toc-text"> 122. 买卖股票的最佳时机 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一贪心-3"><span class="toc-text"> 解法一——贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-3"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-跳跃游戏"><span class="toc-text"> 55. 跳跃游戏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-跳跃游戏-ii"><span class="toc-text"> 45. 跳跃游戏 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1005-k-次取反后最大化的数组和"><span class="toc-text"> 1005. K 次取反后最大化的数组和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一逻辑复杂的分类讨论"><span class="toc-text"> 解法一——逻辑复杂的分类讨论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二贪心"><span class="toc-text"> 解法二——贪心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-加油站"><span class="toc-text"> 134. 加油站</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力解法一点点优化"><span class="toc-text"> 解法一——暴力解法+一点点优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二贪心-2"><span class="toc-text"> 解法二——贪心</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135-分发糖果"><span class="toc-text"> 135. 分发糖果</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一两次贪心"><span class="toc-text"> 解法一——两次贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二常数空间遍历"><span class="toc-text"> 解法二——常数空间遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#860-柠檬水找零"><span class="toc-text"> 860. 柠檬水找零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#406-根据身高重建队列"><span class="toc-text"> 406. 根据身高重建队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一插入用数组"><span class="toc-text"> 解法一——插入用数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二插入用链表"><span class="toc-text"> 解法二——插入用链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#452-用最少数量的箭引爆气球"><span class="toc-text"> 452. 用最少数量的箭引爆气球</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#435-无重叠区间"><span class="toc-text"> 435. 无重叠区间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一贪心左边缘"><span class="toc-text"> 解法一——贪心+左边缘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二贪心右边缘"><span class="toc-text"> 解法二——贪心+右边缘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#763-划分字母区间"><span class="toc-text"> 763. 划分字母区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56-合并区间"><span class="toc-text"> 56. 合并区间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#738-单调递增的数字"><span class="toc-text"> 738. 单调递增的数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#968-监控二叉树"><span class="toc-text"> 968. 监控二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划"><span class="toc-text"> 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#509-斐波那契数"><span class="toc-text"> 509. 斐波那契数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一直接递推"><span class="toc-text"> 解法一——直接递推</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-4"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-爬楼梯"><span class="toc-text"> 70. 爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-使用最小花费爬楼梯"><span class="toc-text"> 746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-不同路径"><span class="toc-text"> 62. 不同路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一动态规划硬解"><span class="toc-text"> 解法一——动态规划硬解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二数论方法"><span class="toc-text"> 解法二——数论方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-不同路径-ii"><span class="toc-text"> 63. 不同路径 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一动态规划"><span class="toc-text"> 解法一——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-整数拆分"><span class="toc-text"> 343. 整数拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一数论技巧"><span class="toc-text"> 解法一——数论？技巧？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-5"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96-不同的二叉搜索树"><span class="toc-text"> 96. 不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-1背包问题"><span class="toc-text"> 0-1背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1背包问题二维数组"><span class="toc-text"> 0-1背包问题——二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#0-1背包问题滚动数组"><span class="toc-text"> 0-1背包问题——滚动数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46-携带研究材料-kamacoder"><span class="toc-text"> 46. 携带研究材料 (kamacoder)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二维数组"><span class="toc-text"> 二维数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#滚动数组"><span class="toc-text"> 滚动数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#416-分割等和子集"><span class="toc-text"> 416. 分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-最后一块石头的重量-ii"><span class="toc-text"> 1049. 最后一块石头的重量 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-目标和"><span class="toc-text"> 494. 目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#474-一和零"><span class="toc-text"> 474. 一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全背包问题"><span class="toc-text"> 完全背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#完全背包问题-2"><span class="toc-text"> 完全背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-携带研究材料kamacoder"><span class="toc-text"> 52. 携带研究材料(kamacoder)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#518-零钱兑换-ii"><span class="toc-text"> 518. 零钱兑换 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#377-组合总和-iv"><span class="toc-text"> 377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57-爬楼梯-kamacoder"><span class="toc-text"> 57. 爬楼梯 (kamacoder)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#322-零钱兑换"><span class="toc-text"> 322. 零钱兑换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-完全平方数"><span class="toc-text"> 279. 完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-单词拆分"><span class="toc-text"> 139. 单词拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一遍历物品时候直接遍历字典列表"><span class="toc-text"> 解法一——遍历物品时候直接遍历字典列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二遍历物品时候遍历截取的字符串长度"><span class="toc-text"> 解法二——遍历物品时候，遍历截取的字符串长度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重背包问题"><span class="toc-text"> 多重背包问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多重背包问题-2"><span class="toc-text"> 多重背包问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#56-携带矿石资源-kamacoder"><span class="toc-text"> 56. 携带矿石资源 (kamacoder)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198-打家劫舍"><span class="toc-text"> 198. 打家劫舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213-打家劫舍-ii"><span class="toc-text"> 213. 打家劫舍 II</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一建立二维数组"><span class="toc-text"> 解法一——建立二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二利用上一题的代码分两个子函数"><span class="toc-text"> 解法二——利用上一题的代码，分两个子函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#337-打家劫舍-iii"><span class="toc-text"> 337. 打家劫舍 III</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一二维数组记录"><span class="toc-text"> 解法一——二维数组记录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二一个数组即可"><span class="toc-text"> 解法二——一个数组即可</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121-买卖股票的最佳时机"><span class="toc-text"> 121. 买卖股票的最佳时机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一贪心-4"><span class="toc-text"> 解法一——贪心</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-6"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-买卖股票的最佳时机-ii-2"><span class="toc-text"> 122. 买卖股票的最佳时机 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-买卖股票的最佳时机-iii"><span class="toc-text"> 123. 买卖股票的最佳时机 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#188-买卖股票的最佳时机-iv"><span class="toc-text"> 188. 买卖股票的最佳时机 IV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#309-买卖股票的最佳时机含冷冻期"><span class="toc-text"> 309. 买卖股票的最佳时机含冷冻期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#714-买卖股票的最佳时机含手续费"><span class="toc-text"> 714. 买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#300-最长递增子序列"><span class="toc-text"> 300. 最长递增子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#674-最长连续递增序列"><span class="toc-text"> 674. 最长连续递增序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#718-最长重复子数组"><span class="toc-text"> 718. 最长重复子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一二维数组"><span class="toc-text"> 解法一——二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二滚动数组"><span class="toc-text"> 解法二——滚动数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1143-最长公共子序列"><span class="toc-text"> 1143. 最长公共子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一二维数组-2"><span class="toc-text"> 解法一——二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二滚动数组-2"><span class="toc-text"> 解法二——滚动数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1035-不相交的线"><span class="toc-text"> 1035. 不相交的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-最大子数组和-2"><span class="toc-text"> 53. 最大子数组和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#392-判断子序列"><span class="toc-text"> 392. 判断子序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一双指针"><span class="toc-text"> 解法一——双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-7"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115-不同的子序列"><span class="toc-text"> 115. 不同的子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#583-两个字符串的删除操作"><span class="toc-text"> 583. 两个字符串的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-编辑距离"><span class="toc-text"> 72. 编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#647-回文子串"><span class="toc-text"> 647. 回文子串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一双指针-2"><span class="toc-text"> 解法一——双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二动态规划-8"><span class="toc-text"> 解法二——动态规划</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#516-最长回文子序列"><span class="toc-text"> 516. 最长回文子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单调栈"><span class="toc-text"> 单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#739-每日温度"><span class="toc-text"> 739. 每日温度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#496-下一个更大元素-i"><span class="toc-text"> 496. 下一个更大元素 I</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#503-下一个更大元素-ii"><span class="toc-text"> 503. 下一个更大元素 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-接雨水"><span class="toc-text"> 42. 接雨水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84-柱状图中最大的矩形"><span class="toc-text"> 84. 柱状图中最大的矩形</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#图论"><span class="toc-text"> 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#797-所有可能的路径"><span class="toc-text"> 797. 所有可能的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200-岛屿数量"><span class="toc-text"> 200. 岛屿数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一dfs"><span class="toc-text"> 解法一——DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二bfs"><span class="toc-text"> 解法二——BFS</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#695-岛屿的最大面积"><span class="toc-text"> 695. 岛屿的最大面积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1020-飞地的数量"><span class="toc-text"> 1020. 飞地的数量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一深搜visited数组"><span class="toc-text"> 解法一——深搜+visited数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二深搜优化空间"><span class="toc-text"> 解法二——深搜+优化空间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130-被围绕的区域"><span class="toc-text"> 130. 被围绕的区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一广搜"><span class="toc-text"> 解法一——广搜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二深搜"><span class="toc-text"> 解法二——深搜</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#417-太平洋大西洋水流问题"><span class="toc-text"> 417. 太平洋大西洋水流问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#827-最大人工岛"><span class="toc-text"> 827. 最大人工岛</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#127-单词接龙"><span class="toc-text"> 127. 单词接龙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#841-钥匙和房间"><span class="toc-text"> 841. 钥匙和房间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#463-岛屿的周长"><span class="toc-text"> 463. 岛屿的周长</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一深搜-2"><span class="toc-text"> 解法一——深搜</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二遍历"><span class="toc-text"> 解法二——遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并查集"><span class="toc-text"> 并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模板"><span class="toc-text"> 模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2492-两个城市间路径的最小分数"><span class="toc-text"> 2492. 两个城市间路径的最小分数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1971-寻找图中是否存在路径"><span class="toc-text"> 1971. 寻找图中是否存在路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#684-冗余连接"><span class="toc-text"> 684. 冗余连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#685-冗余连接-ii"><span class="toc-text"> 685. 冗余连接 II</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#增补热题100"><span class="toc-text"> 增补——热题100</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#49-字母异位词分组"><span class="toc-text"> 49. 字母异位词分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128-最长连续序列"><span class="toc-text"> 128. 最长连续序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#283-移动零"><span class="toc-text"> 283. 移动零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-盛最多水的容器"><span class="toc-text"> 11. 盛最多水的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一单调栈"><span class="toc-text"> 解法一——单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二双指针"><span class="toc-text"> 解法二——双指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-无重复字符的最长子串"><span class="toc-text"> 3. 无重复字符的最长子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#438-找到字符串中所有字母异位词"><span class="toc-text"> 438. 找到字符串中所有字母异位词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#560-和为-k-的子数组"><span class="toc-text"> 560. 和为 K 的子数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一暴力解法但是超时"><span class="toc-text"> 解法一——暴力解法，但是超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二前缀和建表"><span class="toc-text"> 解法二——前缀和建表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76-最小覆盖子串"><span class="toc-text"> 76. 最小覆盖子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-轮转数组"><span class="toc-text"> 189. 轮转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一队列"><span class="toc-text"> 解法一——队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二两次反转"><span class="toc-text"> 解法二——两次反转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#238-除自身以外数组的乘积"><span class="toc-text"> 238. 除自身以外数组的乘积</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一左右乘积列表"><span class="toc-text"> 解法一——左右乘积列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二空间复杂度为mathcal-o1"><span class="toc-text"> 解法二——空间复杂度为O(1)\mathcal O(1)O(1)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-缺失的第一个正数"><span class="toc-text"> 41. 缺失的第一个正数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一原始数组作为hash表"><span class="toc-text"> 解法一——原始数组作为hash表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二类似排序直接交换到对应下标位置去"><span class="toc-text"> 解法二——类似排序？直接交换到对应下标位置去</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73-矩阵置零"><span class="toc-text"> 73. 矩阵置零</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一记录行列"><span class="toc-text"> 解法一——记录行列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二使用标记变量"><span class="toc-text"> 解法二——使用标记变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-螺旋矩阵"><span class="toc-text"> 54. 螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-旋转图像"><span class="toc-text"> 48. 旋转图像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一旋转矩阵的思路一圈一圈来"><span class="toc-text"> 解法一——旋转矩阵的思路，一圈一圈来</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二用翻转代替旋转"><span class="toc-text"> 解法二——用翻转代替旋转</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#240-搜索二维矩阵-ii"><span class="toc-text"> 240. 搜索二维矩阵 II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-回文链表"><span class="toc-text"> 234. 回文链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一栈保存数值"><span class="toc-text"> 解法一——栈保存数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二快慢指针反转后面的链表"><span class="toc-text"> 解法二——快慢指针反转后面的链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-环形链表"><span class="toc-text"> 141. 环形链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-合并两个有序链表"><span class="toc-text"> 21. 合并两个有序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-两数相加"><span class="toc-text"> 2. 两数相加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-k-个一组翻转链表"><span class="toc-text"> 25. K 个一组翻转链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#138-随机链表的复制"><span class="toc-text"> 138. 随机链表的复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一回溯"><span class="toc-text"> 解法一——回溯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二迭代-节点拆分"><span class="toc-text"> 解法二——迭代 + 节点拆分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148-排序链表"><span class="toc-text"> 148. 排序链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-合并-k-个升序链表"><span class="toc-text"> 23. 合并 K 个升序链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最naive的思想存起来呗"><span class="toc-text"> 最naive的思想——存起来呗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分治合并"><span class="toc-text"> 分治合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146-lru-缓存"><span class="toc-text"> 146. LRU 缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#543-二叉树的直径"><span class="toc-text"> 543. 二叉树的直径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#230-二叉搜索树中第-k-小的元素"><span class="toc-text"> 230. 二叉搜索树中第 K 小的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-二叉树展开为链表"><span class="toc-text"> 114. 二叉树展开为链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一遍历一个数组非原地"><span class="toc-text"> 解法一——遍历+一个数组（非原地）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二寻找前驱节点"><span class="toc-text"> 解法二——寻找前驱节点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#437-路径总和-iii"><span class="toc-text"> 437. 路径总和 III</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124-二叉树中的最大路径和"><span class="toc-text"> 124. 二叉树中的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#994-腐烂的橘子"><span class="toc-text"> 994. 腐烂的橘子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#207-课程表"><span class="toc-text"> 207. 课程表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#深度优先栈"><span class="toc-text"> 深度优先——栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#广度优先队列"><span class="toc-text"> 广度优先——队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#210-课程表-ii"><span class="toc-text"> 210. 课程表 II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#208-实现-trie-前缀树"><span class="toc-text"> 208. 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-括号生成"><span class="toc-text"> 22. 括号生成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79-单词搜索"><span class="toc-text"> 79. 单词搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-搜索插入位置"><span class="toc-text"> 35. 搜索插入位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74-搜索二维矩阵"><span class="toc-text"> 74. 搜索二维矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-在排序数组中查找元素的第一个和最后一个位置"><span class="toc-text"> 34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-搜索旋转排序数组"><span class="toc-text"> 33. 搜索旋转排序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153-寻找旋转排序数组中的最小值"><span class="toc-text"> 153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-寻找两个正序数组的中位数"><span class="toc-text"> 4. 寻找两个正序数组的中位数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一不满足时间复杂度要求"><span class="toc-text"> 解法一——不满足时间复杂度要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二第k小数"><span class="toc-text"> 解法二——第k小数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-最小栈"><span class="toc-text"> 155. 最小栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#394-字符串解码"><span class="toc-text"> 394. 字符串解码（▲）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#215-数组中的第k个最大元素"><span class="toc-text"> 215. 数组中的第K个最大元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一基于快排和快速选择"><span class="toc-text"> 解法一——基于快排和快速选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二堆"><span class="toc-text"> 解法二——堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#295-数据流的中位数"><span class="toc-text"> 295. 数据流的中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-杨辉三角"><span class="toc-text"> 118. 杨辉三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-乘积最大子数组"><span class="toc-text"> 152. 乘积最大子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-最长有效括号"><span class="toc-text"> 32. 最长有效括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-最小路径和"><span class="toc-text"> 64. 最小路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-最长回文子串"><span class="toc-text"> 5. 最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136-只出现一次的数字"><span class="toc-text"> 136. 只出现一次的数字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一不考虑线性复杂度"><span class="toc-text"> 解法一——不考虑线性复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二位运算"><span class="toc-text"> 解法二——位运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169-多数元素"><span class="toc-text"> 169. 多数元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一不考虑复杂度"><span class="toc-text"> 解法一——不考虑复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二boyer-moore-投票算法"><span class="toc-text"> 解法二——Boyer-Moore 投票算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75-颜色分类"><span class="toc-text"> 75. 颜色分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#解法一排序冒泡"><span class="toc-text"> 解法一——排序（冒泡）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法二直接统计反正就三个颜色"><span class="toc-text"> 解法二——直接统计，反正就三个颜色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法三单指针"><span class="toc-text"> 解法三——单指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解法四双指针"><span class="toc-text"> 解法四——双指针(▲)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-下一个排列"><span class="toc-text"> 31. 下一个排列（▲）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#287-寻找重复数"><span class="toc-text"> 287. 寻找重复数（▲）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#华为手撕准备"><span class="toc-text"> 华为手撕准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#54-螺旋矩阵-2"><span class="toc-text"> 54. 螺旋矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#买卖股票"><span class="toc-text"> 买卖股票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公共子串"><span class="toc-text"> 公共子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#回文子串"><span class="toc-text"> 回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#括号匹配"><span class="toc-text"> 括号匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#链表成环"><span class="toc-text"> 链表成环</span></a></li></ol></li></ol></li></ol>
    
    </div>
</div>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>




	</div>
	


<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
            

<article class="read-next-card" style="background-image: url(https://s1.ax1x.com/2020/08/09/a7ycNV.png)">
  <header class="read-next-card-header">
    <small class="read-next-card-header-sitetitle">&mdash; Levitate_ &mdash;</small>
    <h3 class="read-next-card-header-title">最新文章</h3>
  </header>
  <div class="read-next-divider">
    <svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24">
      <path d="M13 14.5s2 3 5 3 5.5-2.463 5.5-5.5S21 6.5 18 6.5c-5 0-7 11-12 11C2.962 17.5.5 15.037.5 12S3 6.5 6 6.5s4.5 3.5 4.5 3.5"/>
    </svg>
  </div>
  <div class="read-next-card-content">
    <ul>
      
      
      
      <li>
        <a href="/2024/03/30/LeetCode-problems/">【更新中】LeetCode自用刷题记录</a>
      </li>
      
      
      
      <li>
        <a href="/2024/01/01/latex-note-06/">LaTeX札记（六）：MATLAB与TikZ绘图</a>
      </li>
      
      
      
      <li>
        <a href="/2023/04/05/python-matlab/">【科研札记】Python和MATLAB的协同使用</a>
      </li>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </ul>
  </div>
  <footer class="read-next-card-footer">
    <a href="/archives">  MORE  → </a>
  </footer>
</article>

            
            
            

<article class="read-next-card" style="background-image: url(https://s1.ax1x.com/2020/08/09/a7ycNV.png)">
    <header class="read-next-card-header tagcloud-card">
        <h3 class="read-next-card-header-title">分类</h3>
    </header>
    <div class="read-next-card-content">
        <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/LaTeX/">LaTeX</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/">人工智能</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AE%9E%E9%AA%8C/">实验</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%80%BB%E7%BB%93/">总结</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li></ul>
    </div>
</article>


            
            
            

<article class="read-next-card" style="background-image: url(https://s1.ax1x.com/2020/08/09/a7ycNV.png)">
	<header class="read-next-card-header tagcloud-card">
		<h3 class="read-next-card-header-title">标签云</h3>
	</header>
	<div class="read-next-card-content-ext">
		<a href="/tags/MATLAB/" style="font-size: 18.29px;">MATLAB</a> <a href="/tags/MIMO/" style="font-size: 19.71px;">MIMO</a> <a href="/tags/Vscode/" style="font-size: 15.43px;">Vscode</a> <a href="/tags/git/" style="font-size: 14px;">git</a> <a href="/tags/iPad/" style="font-size: 14px;">iPad</a> <a href="/tags/ssh/" style="font-size: 14px;">ssh</a> <a href="/tags/%E4%BF%A1%E5%8F%B7/" style="font-size: 14px;">信号</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 14px;">博客</a> <a href="/tags/%E5%A4%A7%E5%AD%A6/" style="font-size: 14px;">大学</a> <a href="/tags/%E5%B0%84%E9%A2%91/" style="font-size: 15.43px;">射频</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/" style="font-size: 19.71px;">数学建模</a> <a href="/tags/%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/" style="font-size: 22.57px;">无线通信</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 19.71px;">机器学习</a> <a href="/tags/%E6%A8%A1%E6%8B%9F%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/" style="font-size: 15.43px;">模拟电子技术</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 21.14px;">深度学习</a> <a href="/tags/%E7%94%B5%E7%A3%81%E5%9C%BA%E4%B8%8E%E7%94%B5%E7%A3%81%E6%B3%A2/" style="font-size: 16.86px;">电磁场与电磁波</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 14px;">编程</a> <a href="/tags/%E8%AE%BA%E6%96%87/" style="font-size: 24px;">论文</a> <a href="/tags/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/" style="font-size: 15.43px;">通信原理</a> <a href="/tags/%E9%A2%84%E7%BC%96%E7%A0%81/" style="font-size: 16.86px;">预编码</a>
	</div>
</article>

            
        </div>
    </div>
</aside>

	




<div id="search" class="search-overlay">
    <div class="search-form">
        
        <div class="search-overlay-logo">
        	<img src="https://s1.ax1x.com/2022/05/18/Oo3OeI.png" alt="Levitate_">
        </div>
        
        <input id="local-search-input" class="search-input" type="text" name="search" placeholder="搜索 ...">
        <a class="search-overlay-close" href="#"></a>
    </div>
    <div id="local-search-result"></div>
</div>

<footer class="site-footer outer">
	<div class="site-footer-content inner">
		<div class="copyright">
			<a href="/" title="Levitate_">Levitate_ &copy; 2020-2024</a>
			
				
			        <span hidden="true" id="/2024/03/30/LeetCode-problems/" class="leancloud-visitors" data-flag-title="【更新中】LeetCode自用刷题记录">
			            <span>阅读量 </span>
			            <span class="leancloud-visitors-count">0</span>
			        </span>
	    		
    		
		</div>
		<nav class="site-footer-nav">
			
			<a href="/atom.xml" title="RSS" target="_blank" rel="noopener">RSS</a>
			
			<a href="https://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
			<a href="https://github.com/xzhih/hexo-theme-casper" title="Casper" target="_blank" rel="noopener">Casper</a>
		</nav>
	</div>
</footer>
	


<script>
    if(window.navigator && navigator.serviceWorker) {
        navigator.serviceWorker.getRegistrations().then(function(registrations) {
            for(let registration of registrations) {
                registration.unregister()
            }
        })
    }
</script>


<script id="scriptLoad" src="/js/allinone.min.js" async></script>



<div class="floating-header">
	<div class="floating-header-logo">
        <a href="/" title="Levitate_">
			
                <img src="https://s1.ax1x.com/2022/05/18/Oo3OeI.png" alt="Levitate_ icon">
			
            <span>Levitate_</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">【更新中】LeetCode自用刷题记录</div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>




<script>;(function() {var bLazy = new Blazy()})();</script>




<script>
    document.getElementById('scriptLoad').addEventListener('load', function () {
        
        
            var bLazy = new Blazy();
        

        
        

        
        
        
            searchFunc("/");
        
        
    })
</script>




<link rel="stylesheet" href="/photoswipe/photoswipe.css">


<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>


<script src="/photoswipe/photoswipe-ui-default.min.js"></script>





<script id="valineScript" src="//unpkg.com/valine/dist/Valine.min.js" async></script>
<script>
    document.getElementById('valineScript').addEventListener("load", function() {
        new Valine({
            el: '#comment' ,
            verify: false,
            notify: false,
            appId: 'lv1bzqDwJo9FTYdBip3QGP7t-gzGzoHsz',
            appKey: 'mK4QC79PTUYTSginf9BXEzlv',
            placeholder: '求轻喷(*/ω＼*)',
            pageSize: 10,
            avatar: 'retro',
            visitor: true,
            requiredFields: ['mail']
        })
    });
</script>






<script>
    document.addEventListener('DOMContentLoaded',function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    });
</script>


</body>
</html>
